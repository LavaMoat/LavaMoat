// @ts-check

/** @typedef {import("webpack").Compiler} Compiler */
/** @typedef {import("webpack").Compilation} Compilation */
/** @typedef {import("webpack").WebpackError} WebpackError */
/** @typedef {import("webpack").Asset} Asset */

const inspect = require("util").inspect;
const { ConcatSource } = require("webpack-sources");

const JavascriptGenerator = require('webpack/lib/JavascriptGenerator');

class CustomGenerator extends JavascriptGenerator {
  generate(module, dependencyTemplates, options) {
    const output = super.generate(module, dependencyTemplates, options);
    const comment = `// This code was generated by CustomGenerator`;
    return `${comment}\n${output}`;
  }
}


class BeginEndPlugin {
  /**
   * Apply the plugin
   * @param {Compiler} compiler the compiler instance
   * @returns {void}
   */
  apply(compiler) {
    compiler.hooks.normalModuleFactory.tap('BeginEndPlugin', (nmf) => {
      const generatorHooks = nmf.getGeneratorHooks();

      generatorHooks.for('javascript').tap('BeginEndPlugin', (generator) => {
        const customGenerator = new CustomGenerator();
        return customGenerator;
      });
    });

    return;

    compiler.hooks.compilation.tap("BeginEndPlugin", (compilation) => {
      return compilation.hooks.optimizeModules.tap('LogSourcesPlugin', (modules) => {
        modules.forEach((module) => {
          const source = module._source && module._source._value;
          if (source) {
            console.log(`Module: ${module.resource}\nSource:\n${source}\n`);
          }
        });
      });
      compilation.hooks.optimizeChunkAssets.tap("BeginEndPlugin", (chunks) => {
        chunks.forEach((chunk) => {
          chunk.modulesIterable.forEach((module) => {
            const originalSource = module._source;

            console.error({
              ts: typeof originalSource,
              originalSource,
            });
            if (originalSource) {
              const wrappedSource = new ConcatSource(
                `/* Begin ${module.rawRequest} */\n`,
                originalSource,
                `\n/* End ${module.rawRequest} */`
              );

              module._source = wrappedSource;
            }
          });
        });
      });
    });
    // compiler.hooks.compilation.tap('BeginEndPlugin', (compilation) => {
    //   compilation.hooks.optimizeChunkAssets.tapAsync('BeginEndPlugin', (chunks, callback) => {
    //     for (const chunk of chunks) {
    //       const modules = chunk.modulesIterable;
    //       for (const module of modules) {
    //         const { rawRequest } = module;
    //         const source = module.originalSource().source();
    //         const beginComment = `/* BEGIN ${rawRequest} */\n`;
    //         const endComment = `\n/* END ${rawRequest} */`;

    //         console.error({
    //           ts: typeof source,
    //           rawRequest,
    //           module,
    //           mg: module.generator.__proto__
    //         })

    //         // Use initFragments to wrap the module's source with "BEGIN" and "END" comments
    //         // module._source._value = module._source._value.initFragments([
    //         //   new webpack.sources.RawSource(beginComment),
    //         //   module._source,
    //         //   new webpack.sources.RawSource(endComment),
    //         // ]);
    //       }
    //     }

    //     callback();
    //   });
    // });
  }
}

module.exports = BeginEndPlugin;
