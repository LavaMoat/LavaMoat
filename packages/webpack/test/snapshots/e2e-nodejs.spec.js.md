# Snapshot report for `test/e2e-nodejs.spec.js`

The actual snapshot is saved in `e2e-nodejs.spec.js.snap`.

Generated by [AVA](https://avajs.dev).

## webpack/node.js - policy shape

> Snapshot 1

    `{␊
      "resources": {␊
        "nodejs-package": {␊
          "packages": {␊
            "external:../../../node:fs": true␊
          }␊
        }␊
      }␊
    }`

> Snapshot 2

    `/******/ (() => { // webpackBootstrap␊
    /******/ 	var __webpack_modules__ = ({␊
    ␊
    /***/ "./node_modules/nodejs-package/index.js":␊
    /*!**********************************************!*\\␊
      !*** ./node_modules/nodejs-package/index.js ***!␊
      \\**********************************************/␊
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {␊
    ␊
    (function(){␊
         if (!this.ST) return ()=>{};␊
         with (this.ST) {␊
          with (this.RH) {␊
          with (this.G) {␊
            return function() { 'use strict';␊
    const { readdirSync } =__webpack_require__(/*! node:fs */ "node:fs")␊
    ␊
    module.exports = readdirSync('./')␊
            };␊
          }␊
        }␊
        }␊
    }).call(__webpack_require__._LM_("nodejs-package", { module,__webpack_require__}))()␊
    ␊
    /***/ }),␊
    ␊
    /***/ "node:fs":␊
    /*!**************************!*\\␊
      !*** external "node:fs" ***!␊
      \\**************************/␊
    /***/ ((module) => {␊
    ␊
    "use strict";␊
    module.exports = require("node:fs");␊
    ␊
    /***/ })␊
    ␊
    /******/ 	});␊
    /************************************************************************/␊
    /******/ 	// The module cache␊
    /******/ 	var __webpack_module_cache__ = {};␊
    /******/ 	␊
    /******/ 	// The require function␊
    /******/ 	function __webpack_require__(moduleId) {␊
    /******/ 		// Check if module is in cache␊
    /******/ 		var cachedModule = __webpack_module_cache__[moduleId];␊
    /******/ 		if (cachedModule !== undefined) {␊
    /******/ 			return cachedModule.exports;␊
    /******/ 		}␊
    /******/ 		// Create a new module (and put it into the cache)␊
    /******/ 		var module = __webpack_module_cache__[moduleId] = {␊
    /******/ 			// no module.id needed␊
    /******/ 			// no module.loaded needed␊
    /******/ 			exports: {}␊
    /******/ 		};␊
    /******/ 	␊
    /******/ 		// Execute the module function␊
    /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);␊
    /******/ 	␊
    /******/ 		// Return the exports of the module␊
    /******/ 		return module.exports;␊
    /******/ 	}␊
    /******/ 	␊
    /************************************************************************/␊
    /******/ 	/* webpack/runtime/LavaMoat/runtime */␊
    /******/ 	(() => {␊
    /******/ 		const LAVAMOAT = Object.create(null);␊
    /******/ 		;/*root*/;␊
    /******/ 		LAVAMOAT['root'] = ("$root$");␊
    /******/ 		;/*idmap*/;␊
    /******/ 		LAVAMOAT['idmap'] = ([["$root$",["./node.js"]],["nodejs-package",["./node_modules/nodejs-package/index.js"]]]);␊
    /******/ 		;/*unenforceable*/;␊
    /******/ 		LAVAMOAT['unenforceable'] = (["node:fs"]);␊
    /******/ 		;/*options*/;␊
    /******/ 		LAVAMOAT['options'] = ({"lockdown":{"errorTaming":"unsafe","mathTaming":"unsafe","dateTaming":"unsafe","consoleTaming":"unsafe"}});␊
    /******/ 		;/*policy*/;␊
    /******/ 		LAVAMOAT['policy'] = ({"resources":{"nodejs-package":{"packages":{"external:../../../node:fs":true}}}});␊
    /******/ 		;/*ENUM*/;␊
    /******/ 		LAVAMOAT['ENUM'] = ({␊
    /******/ 		  "NAME_globalThis": "G",␊
    /******/ 		  "NAME_scopeTerminator": "ST",␊
    /******/ 		  "NAME_runtimeHandler": "RH",␊
    /******/ 		  "RUNTIME_KEY": "_LM_"␊
    /******/ 		␊
    /******/ 		});␊
    /******/ 		;/*endowmentsToolkit*/;␊
    /******/ 		;(()=>{␊
    /******/ 		        const module = {exports: {}};␊
    /******/ 		        const exports = module.exports;␊
    /******/ 		          // @ts-check␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		module.exports = endowmentsToolkit␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		function endowmentsToolkit({␊
    /******/ 		  createFunctionWrapper = defaultCreateFunctionWrapper,␊
    /******/ 		} = {}) {␊
    /******/ 		  return {␊
    /******/ 		    getEndowmentsForConfig,␊
    /******/ 		    makeMinimalViewOfRef,␊
    /******/ 		    copyValueAtPath,␊
    /******/ 		    applyGetSetPropDescTransforms,␊
    /******/ 		    applyEndowmentPropDescTransforms,␊
    /******/ 		    copyWrappedGlobals,␊
    /******/ 		    createFunctionWrapper,␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function getEndowmentsForConfig(␊
    /******/ 		    sourceRef,␊
    /******/ 		    packagePolicy,␊
    /******/ 		    unwrapTo,␊
    /******/ 		    unwrapFrom␊
    /******/ 		  ) {␊
    /******/ 		    if (!packagePolicy.globals) {␊
    /******/ 		      return {}␊
    /******/ 		    }␊
    /******/ 		    // validate read access from packagePolicy␊
    /******/ 		    ␊
    /******/ 		    const whitelistedReads = []␊
    /******/ 		    ␊
    /******/ 		    const explicitlyBanned = []␊
    /******/ 		    Object.entries(packagePolicy.globals).forEach(␊
    /******/ 		      ([path, packagePolicyValue]) => {␊
    /******/ 		        const pathParts = path.split('.')␊
    /******/ 		        // disallow dunder proto in path␊
    /******/ 		        const pathContainsDunderProto = pathParts.some(␊
    /******/ 		          (pathPart) => pathPart === '__proto__'␊
    /******/ 		        )␊
    /******/ 		        if (pathContainsDunderProto) {␊
    /******/ 		          throw new Error(␊
    /******/ 		            \`Lavamoat - "__proto__" disallowed when creating minimal view. saw "${path}"\`␊
    /******/ 		          )␊
    /******/ 		        }␊
    /******/ 		        // false means no access. It's necessary so that overrides can also be used to tighten the policy␊
    /******/ 		        if (packagePolicyValue === false) {␊
    /******/ 		          explicitlyBanned.push(path)␊
    /******/ 		          return␊
    /******/ 		        }␊
    /******/ 		        // write access handled elsewhere␊
    /******/ 		        if (packagePolicyValue === 'write') {␊
    /******/ 		          return␊
    /******/ 		        }␊
    /******/ 		        if (packagePolicyValue !== true) {␊
    /******/ 		          throw new Error(␊
    /******/ 		            \`LavaMoat - unrecognizable policy value (${typeof packagePolicyValue}) for path "${path}"\`␊
    /******/ 		          )␊
    /******/ 		        }␊
    /******/ 		        whitelistedReads.push(path)␊
    /******/ 		      }␊
    /******/ 		    )␊
    /******/ 		    return makeMinimalViewOfRef(␊
    /******/ 		      sourceRef,␊
    /******/ 		      whitelistedReads,␊
    /******/ 		      unwrapTo,␊
    /******/ 		      unwrapFrom,␊
    /******/ 		      explicitlyBanned␊
    /******/ 		    )␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function makeMinimalViewOfRef(␊
    /******/ 		    sourceRef,␊
    /******/ 		    paths,␊
    /******/ 		    unwrapTo,␊
    /******/ 		    unwrapFrom,␊
    /******/ 		    explicitlyBanned = []␊
    /******/ 		  ) {␊
    /******/ 		    ␊
    /******/ 		    const targetRef = {}␊
    /******/ 		    paths.forEach((path) => {␊
    /******/ 		      copyValueAtPath(␊
    /******/ 		        '',␊
    /******/ 		        path.split('.'),␊
    /******/ 		        explicitlyBanned,␊
    /******/ 		        sourceRef,␊
    /******/ 		        targetRef,␊
    /******/ 		        unwrapTo,␊
    /******/ 		        unwrapFrom␊
    /******/ 		      )␊
    /******/ 		    })␊
    /******/ 		    return targetRef␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function extendPath(visited, next) {␊
    /******/ 		    // FIXME: second part of this conditional should be unnecessary␊
    /******/ 		    if (!visited || visited.length === 0) {␊
    /******/ 		      return next␊
    /******/ 		    }␊
    /******/ 		    return \`${visited}.${next}\`␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function isEmpty(value) {␊
    /******/ 		    return !value␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function copyValueAtPath(␊
    /******/ 		    visitedPath,␊
    /******/ 		    pathParts,␊
    /******/ 		    explicitlyBanned,␊
    /******/ 		    sourceRef,␊
    /******/ 		    targetRef,␊
    /******/ 		    unwrapTo = sourceRef,␊
    /******/ 		    unwrapFrom = targetRef␊
    /******/ 		  ) {␊
    /******/ 		    if (pathParts.length === 0) {␊
    /******/ 		      throw new Error('unable to copy, must have pathParts, was empty')␊
    /******/ 		    }␊
    /******/ 		    const [nextPart, ...remainingParts] = pathParts␊
    /******/ 		    const currentPath = extendPath(visitedPath, nextPart)␊
    /******/ 		    // get the property from any depth in the property chain␊
    /******/ 		    const { prop: sourcePropDesc } = getPropertyDescriptorDeep(␊
    /******/ 		      sourceRef,␊
    /******/ 		      nextPart␊
    /******/ 		    )␊
    /******/ 		␊
    /******/ 		    // if source missing the value to copy, just skip it␊
    /******/ 		    if (isEmpty(sourcePropDesc)) {␊
    /******/ 		      return␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    // if target already has a value, it must be extensible␊
    /******/ 		    const targetPropDesc = Reflect.getOwnPropertyDescriptor(targetRef, nextPart)␊
    /******/ 		    if (targetPropDesc) {␊
    /******/ 		      // dont attempt to extend a getter or trigger a setter␊
    /******/ 		      if (!('value' in targetPropDesc)) {␊
    /******/ 		        throw new Error(␊
    /******/ 		          \`unable to copy on to targetRef, targetRef has a getter at "${nextPart}"\`␊
    /******/ 		        )␊
    /******/ 		      }␊
    /******/ 		      // value must be extensible (cant write properties onto it)␊
    /******/ 		      const targetValue = targetPropDesc.value␊
    /******/ 		      const valueType = typeof targetValue␊
    /******/ 		      if (valueType !== 'object' && valueType !== 'function') {␊
    /******/ 		        throw new Error(␊
    /******/ 		          \`unable to copy on to targetRef, targetRef value is not an obj or func "${nextPart}"\`␊
    /******/ 		        )␊
    /******/ 		      }␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    // if this is not the last path in the assignment, walk into the containing reference␊
    /******/ 		    if (remainingParts.length > 0) {␊
    /******/ 		      const { sourceValue, sourceWritable } = getSourceValue(sourcePropDesc)␊
    /******/ 		      const nextSourceRef = sourceValue␊
    /******/ 		      let nextTargetRef␊
    /******/ 		      // check if value exists on target and does not need selective treatment␊
    /******/ 		      if (targetPropDesc && !explicitlyBanned.includes(currentPath)) {␊
    /******/ 		        // a value already exists, we should walk into it␊
    /******/ 		        nextTargetRef = targetPropDesc.value␊
    /******/ 		      } else {␊
    /******/ 		        // its not populated so lets write to it␊
    /******/ 		        // put an object to serve as a container␊
    /******/ 		        const containerRef = {}␊
    /******/ 		        const newPropDesc = {␊
    /******/ 		          value: containerRef,␊
    /******/ 		          writable: sourceWritable,␊
    /******/ 		          enumerable: sourcePropDesc.enumerable,␊
    /******/ 		          configurable: sourcePropDesc.configurable,␊
    /******/ 		        }␊
    /******/ 		        Reflect.defineProperty(targetRef, nextPart, newPropDesc)␊
    /******/ 		        // the newly created container will be the next target␊
    /******/ 		        nextTargetRef = containerRef␊
    /******/ 		      }␊
    /******/ 		      copyValueAtPath(␊
    /******/ 		        currentPath,␊
    /******/ 		        remainingParts,␊
    /******/ 		        explicitlyBanned,␊
    /******/ 		        nextSourceRef,␊
    /******/ 		        nextTargetRef␊
    /******/ 		      )␊
    /******/ 		      return␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    // If conflicting rules exist, opt for the negative one. This should never happen␊
    /******/ 		    if (explicitlyBanned.includes(currentPath)) {␊
    /******/ 		      console.warn(\`LavaMoat - conflicting rules exist for "${currentPath}"\`)␊
    /******/ 		      return␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    // this is the last part of the path, the value we're trying to actually copy␊
    /******/ 		    // if has getter/setter - apply this-value unwrapping␊
    /******/ 		    if (!('value' in sourcePropDesc)) {␊
    /******/ 		      // wrapper setter/getter with correct receiver␊
    /******/ 		      const wrapperPropDesc = applyGetSetPropDescTransforms(␊
    /******/ 		        sourcePropDesc,␊
    /******/ 		        unwrapFrom,␊
    /******/ 		        unwrapTo␊
    /******/ 		      )␊
    /******/ 		      Reflect.defineProperty(targetRef, nextPart, wrapperPropDesc)␊
    /******/ 		      return␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    // need to determine the value type in order to copy it with␊
    /******/ 		    // this-value unwrapping support␊
    /******/ 		    const { sourceValue, sourceWritable } = getSourceValue(sourcePropDesc)␊
    /******/ 		␊
    /******/ 		    // not a function - copy as is␊
    /******/ 		    if (typeof sourceValue !== 'function') {␊
    /******/ 		      Reflect.defineProperty(targetRef, nextPart, sourcePropDesc)␊
    /******/ 		      return␊
    /******/ 		    }␊
    /******/ 		    // otherwise add workaround for functions to swap back to the sourceal "this" reference␊
    /******/ 		    ␊
    /******/ 		    const unwrapTest = (thisValue) => thisValue === unwrapFrom␊
    /******/ 		    const newValue = createFunctionWrapper(sourceValue, unwrapTest, unwrapTo)␊
    /******/ 		    const newPropDesc = {␊
    /******/ 		      value: newValue,␊
    /******/ 		      writable: sourceWritable,␊
    /******/ 		      enumerable: sourcePropDesc.enumerable,␊
    /******/ 		      configurable: sourcePropDesc.configurable,␊
    /******/ 		    }␊
    /******/ 		    Reflect.defineProperty(targetRef, nextPart, newPropDesc)␊
    /******/ 		␊
    /******/ 		    ␊
    /******/ 		    function getSourceValue(sourcePropDesc) {␊
    /******/ 		      // determine the source value, this coerces getters to values␊
    /******/ 		      // im deeply sorry, respecting getters was complicated and␊
    /******/ 		      // my brain is not very good␊
    /******/ 		      let sourceValue, sourceWritable␊
    /******/ 		      if ('value' in sourcePropDesc) {␊
    /******/ 		        sourceValue = sourcePropDesc.value␊
    /******/ 		        sourceWritable = sourcePropDesc.writable␊
    /******/ 		      } else if ('get' in sourcePropDesc && sourcePropDesc.get) {␊
    /******/ 		        sourceValue = sourcePropDesc.get.call(unwrapTo)␊
    /******/ 		        sourceWritable = 'set' in sourcePropDesc␊
    /******/ 		      } else {␊
    /******/ 		        throw new Error(␊
    /******/ 		          'getEndowmentsForConfig - property descriptor missing a getter'␊
    /******/ 		        )␊
    /******/ 		      }␊
    /******/ 		      return { sourceValue, sourceWritable }␊
    /******/ 		    }␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function applyEndowmentPropDescTransforms(␊
    /******/ 		    propDesc,␊
    /******/ 		    unwrapFromCompartmentGlobalThis,␊
    /******/ 		    unwrapToGlobalThis␊
    /******/ 		  ) {␊
    /******/ 		    let newPropDesc = propDesc␊
    /******/ 		    newPropDesc = applyFunctionPropDescTransform(␊
    /******/ 		      newPropDesc,␊
    /******/ 		      unwrapFromCompartmentGlobalThis,␊
    /******/ 		      unwrapToGlobalThis␊
    /******/ 		    )␊
    /******/ 		    newPropDesc = applyGetSetPropDescTransforms(␊
    /******/ 		      newPropDesc,␊
    /******/ 		      unwrapFromCompartmentGlobalThis,␊
    /******/ 		      unwrapToGlobalThis␊
    /******/ 		    )␊
    /******/ 		    return newPropDesc␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function applyGetSetPropDescTransforms(␊
    /******/ 		    sourcePropDesc,␊
    /******/ 		    unwrapFromGlobalThis,␊
    /******/ 		    unwrapToGlobalThis␊
    /******/ 		  ) {␊
    /******/ 		    const wrappedPropDesc = { ...sourcePropDesc }␊
    /******/ 		    if (sourcePropDesc.get) {␊
    /******/ 		      wrappedPropDesc.get = function () {␊
    /******/ 		        // eslint-disable-next-line @typescript-eslint/no-this-alias␊
    /******/ 		        const receiver = this␊
    /******/ 		        // replace the "receiver" value if it points to fake parent␊
    /******/ 		        const receiverRef =␊
    /******/ 		          receiver === unwrapFromGlobalThis ? unwrapToGlobalThis : receiver␊
    /******/ 		        // sometimes getters replace themselves with static properties, as seen wih the FireFox runtime␊
    /******/ 		        const result = Reflect.apply(␊
    /******/ 		           (␊
    /******/ 		            sourcePropDesc.get␊
    /******/ 		          ),␊
    /******/ 		          receiverRef,␊
    /******/ 		          []␊
    /******/ 		        )␊
    /******/ 		        if (typeof result === 'function') {␊
    /******/ 		          // functions must be wrapped to ensure a good this-value.␊
    /******/ 		          // lockdown causes some propDescs to go to value -> getter,␊
    /******/ 		          // eg "Function.prototype.bind". we need to wrap getter results␊
    /******/ 		          // as well in order to ensure they have their this-value wrapped correctly␊
    /******/ 		          // if this ends up being problematic we can maybe take advantage of lockdown's␊
    /******/ 		          // "getter.originalValue" property being available␊
    /******/ 		          return createFunctionWrapper(␊
    /******/ 		            result,␊
    /******/ 		            ␊
    /******/ 		            (thisValue) => thisValue === unwrapFromGlobalThis,␊
    /******/ 		            unwrapToGlobalThis␊
    /******/ 		          )␊
    /******/ 		        } else {␊
    /******/ 		          return result␊
    /******/ 		        }␊
    /******/ 		      }␊
    /******/ 		    }␊
    /******/ 		    if (sourcePropDesc.set) {␊
    /******/ 		      wrappedPropDesc.set = function (value) {␊
    /******/ 		        // replace the "receiver" value if it points to fake parent␊
    /******/ 		        // eslint-disable-next-line @typescript-eslint/no-this-alias␊
    /******/ 		        const receiver = this␊
    /******/ 		        const receiverRef =␊
    /******/ 		          receiver === unwrapFromGlobalThis ? unwrapToGlobalThis : receiver␊
    /******/ 		        return Reflect.apply(␊
    /******/ 		           (sourcePropDesc.set),␊
    /******/ 		          receiverRef,␊
    /******/ 		          [value]␊
    /******/ 		        )␊
    /******/ 		      }␊
    /******/ 		    }␊
    /******/ 		    return wrappedPropDesc␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function applyFunctionPropDescTransform(␊
    /******/ 		    propDesc,␊
    /******/ 		    unwrapFromCompartmentGlobalThis,␊
    /******/ 		    unwrapToGlobalThis␊
    /******/ 		  ) {␊
    /******/ 		    if (!('value' in propDesc && typeof propDesc.value === 'function')) {␊
    /******/ 		      return propDesc␊
    /******/ 		    }␊
    /******/ 		    ␊
    /******/ 		    const unwrapTest = (thisValue) => {␊
    /******/ 		      // unwrap function calls this-value to unwrapToGlobalThis when:␊
    /******/ 		      // this value is globalThis ex. globalThis.abc()␊
    /******/ 		      // scope proxy leak workaround ex. abc()␊
    /******/ 		      return thisValue === unwrapFromCompartmentGlobalThis␊
    /******/ 		    }␊
    /******/ 		    const newFn = createFunctionWrapper(␊
    /******/ 		      propDesc.value,␊
    /******/ 		      unwrapTest,␊
    /******/ 		      unwrapToGlobalThis␊
    /******/ 		    )␊
    /******/ 		    return { ...propDesc, value: newFn }␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function getPropertyDescriptorDeep(target, key) {␊
    /******/ 		    ␊
    /******/ 		    let receiver = target␊
    /******/ 		    // eslint-disable-next-line no-constant-condition␊
    /******/ 		    while (true) {␊
    /******/ 		      // abort if this is the end of the prototype chain.␊
    /******/ 		      if (!receiver) {␊
    /******/ 		        return { prop: null, receiver: null }␊
    /******/ 		      }␊
    /******/ 		      // support lookup on objects and primitives␊
    /******/ 		      const typeofReceiver = typeof receiver␊
    /******/ 		      if (typeofReceiver === 'object' || typeofReceiver === 'function') {␊
    /******/ 		        const prop = Reflect.getOwnPropertyDescriptor(receiver, key)␊
    /******/ 		        if (prop) {␊
    /******/ 		          return { receiver, prop }␊
    /******/ 		        }␊
    /******/ 		        // try next in the prototype chain␊
    /******/ 		        receiver = Reflect.getPrototypeOf(receiver)␊
    /******/ 		      } else {␊
    /******/ 		        // prototype lookup for primitives␊
    /******/ 		        // eslint-disable-next-line no-proto␊
    /******/ 		        receiver =  (receiver).__proto__␊
    /******/ 		      }␊
    /******/ 		    }␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function copyWrappedGlobals(␊
    /******/ 		    globalRef,␊
    /******/ 		    target,␊
    /******/ 		    globalThisRefs = ['globalThis']␊
    /******/ 		  ) {␊
    /******/ 		    // find the relevant endowment sources␊
    /******/ 		    const globalProtoChain = getPrototypeChain(globalRef)␊
    /******/ 		    // the index for the common prototypal ancestor, Object.prototype␊
    /******/ 		    // this should always be the last index, but we check just in case␊
    /******/ 		    const commonPrototypeIndex = globalProtoChain.findIndex(␊
    /******/ 		      (globalProtoChainEntry) => globalProtoChainEntry === Object.prototype␊
    /******/ 		    )␊
    /******/ 		    if (commonPrototypeIndex === -1) {␊
    /******/ 		      // TODO: fix this error message␊
    /******/ 		      throw new Error(␊
    /******/ 		        'Lavamoat - unable to find common prototype between Compartment and globalRef'␊
    /******/ 		      )␊
    /******/ 		    }␊
    /******/ 		    // we will copy endowments from all entries in the prototype chain, excluding Object.prototype␊
    /******/ 		    const endowmentSources = globalProtoChain.slice(0, commonPrototypeIndex)␊
    /******/ 		␊
    /******/ 		    // call all getters, in case of behavior change (such as with FireFox lazy getters)␊
    /******/ 		    // call on contents of endowmentsSources directly instead of in new array instances. If there is a lazy getter it only changes the original prop desc.␊
    /******/ 		    endowmentSources.forEach((source) => {␊
    /******/ 		      const descriptors = Object.getOwnPropertyDescriptors(source)␊
    /******/ 		      Object.values(descriptors).forEach((desc) => {␊
    /******/ 		        if ('get' in desc && desc.get) {␊
    /******/ 		          try {␊
    /******/ 		            // calling getters can potentially throw (e.g. localStorage inside a sandboxed iframe)␊
    /******/ 		            Reflect.apply(desc.get, globalRef, [])␊
    /******/ 		          } catch {}␊
    /******/ 		        }␊
    /******/ 		      })␊
    /******/ 		    })␊
    /******/ 		␊
    /******/ 		    const endowmentSourceDescriptors = endowmentSources.map(␊
    /******/ 		      (globalProtoChainEntry) =>␊
    /******/ 		        Object.getOwnPropertyDescriptors(globalProtoChainEntry)␊
    /******/ 		    )␊
    /******/ 		    // flatten propDesc collections with precedence for globalThis-end of the prototype chain␊
    /******/ 		    const endowmentDescriptorsFlat = Object.assign(␊
    /******/ 		      Object.create(null),␊
    /******/ 		      ...endowmentSourceDescriptors.reverse()␊
    /******/ 		    )␊
    /******/ 		    // expose all own properties of globalRef, including non-enumerable␊
    /******/ 		    Object.entries(endowmentDescriptorsFlat)␊
    /******/ 		      // ignore properties already defined on compartment global␊
    /******/ 		      .filter(([key]) => !(key in target))␊
    /******/ 		      // ignore circular globalThis refs␊
    /******/ 		      .filter(([key]) => !globalThisRefs.includes(key))␊
    /******/ 		      // define property on compartment global␊
    /******/ 		      .forEach(([key, desc]) => {␊
    /******/ 		        // unwrap functions, setters/getters & apply scope proxy workaround␊
    /******/ 		        const wrappedPropDesc = applyEndowmentPropDescTransforms(␊
    /******/ 		          desc,␊
    /******/ 		          target,␊
    /******/ 		          globalRef␊
    /******/ 		        )␊
    /******/ 		        Reflect.defineProperty(target, key, wrappedPropDesc)␊
    /******/ 		      })␊
    /******/ 		    // global circular references otherwise added by prepareCompartmentGlobalFromConfig␊
    /******/ 		    // Add all circular refs to root package compartment globalThis␊
    /******/ 		    for (const ref of globalThisRefs) {␊
    /******/ 		      if (ref in target) {␊
    /******/ 		        continue␊
    /******/ 		      }␊
    /******/ 		      target[ref] = target␊
    /******/ 		    }␊
    /******/ 		    return target␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  ␊
    /******/ 		  function getPrototypeChain(value) {␊
    /******/ 		    const protoChain = []␊
    /******/ 		    let current = value␊
    /******/ 		    while (␊
    /******/ 		      current &&␊
    /******/ 		      (typeof current === 'object' || typeof current === 'function')␊
    /******/ 		    ) {␊
    /******/ 		      protoChain.push(current)␊
    /******/ 		      current = Reflect.getPrototypeOf(current)␊
    /******/ 		    }␊
    /******/ 		    return protoChain␊
    /******/ 		  }␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		function defaultCreateFunctionWrapper(sourceValue, unwrapTest, unwrapTo) {␊
    /******/ 		  ␊
    /******/ 		  const newValue = function (...args) {␊
    /******/ 		    if (new.target) {␊
    /******/ 		      // handle constructor calls␊
    /******/ 		      return Reflect.construct(sourceValue, args, new.target)␊
    /******/ 		    } else {␊
    /******/ 		      // handle function calls␊
    /******/ 		      // unwrap to target value if this value is the source package compartment's globalThis␊
    /******/ 		      const thisRef = unwrapTest(this) ? unwrapTo : this␊
    /******/ 		      return Reflect.apply(sourceValue, thisRef, args)␊
    /******/ 		    }␊
    /******/ 		  }␊
    /******/ 		  Object.defineProperties(␊
    /******/ 		    newValue,␊
    /******/ 		    Object.getOwnPropertyDescriptors(sourceValue)␊
    /******/ 		  )␊
    /******/ 		  return newValue␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		        ;␊
    /******/ 		        LAVAMOAT['endowmentsToolkit'] = module.exports;␊
    /******/ 		      })();␊
    /******/ 		;/*runtime*/;␊
    /******/ 		/// <reference path="./runtime.d.ts" />␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		const {␊
    /******/ 		  create,␊
    /******/ 		  freeze,␊
    /******/ 		  assign,␊
    /******/ 		  defineProperty,␊
    /******/ 		  defineProperties,␊
    /******/ 		  getOwnPropertyDescriptors,␊
    /******/ 		  fromEntries,␊
    /******/ 		} = Object␊
    /******/ 		const warn = typeof console === 'object' ? console.warn : () => {}␊
    /******/ 		// Avoid running any wrapped code or using compartment if lockdown was not called.␊
    /******/ 		// This is for when the bundle ends up running despite SES being missing.␊
    /******/ 		// It was previously useful for sub-compilations running an incomplete bundle as part of the build, but currently that is being skipped. We might go back to it for the sake of build time security if it's deemed worthwihile in absence of lockdown.␊
    /******/ 		const LOCKDOWN_ON = typeof lockdown !== 'undefined'␊
    /******/ 		if (LOCKDOWN_ON) {␊
    /******/ 		  lockdown(LAVAMOAT.options.lockdown)␊
    /******/ 		} else {␊
    /******/ 		  warn(␊
    /******/ 		    'LavaMoat: runtime execution started without SES present, switching to no-op.'␊
    /******/ 		  )␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		const { getEndowmentsForConfig, copyWrappedGlobals } =␊
    /******/ 		  LAVAMOAT.endowmentsToolkit()␊
    /******/ 		␊
    /******/ 		// These must match assumptions in the wrapper.js␊
    /******/ 		// sharedKeys are included in the runtime␊
    /******/ 		␊
    /******/ 		const { NAME_globalThis, NAME_scopeTerminator, NAME_runtimeHandler } =␊
    /******/ 		  LAVAMOAT.ENUM␊
    /******/ 		␊
    /******/ 		// strictScopeTerminator from SES is not strict enough - \`has\` would only return true for globals␊
    /******/ 		// and here we want to prevent reaching into the scope where local variables from bundle runtime are available.␊
    /******/ 		const stricterScopeTerminator = freeze(␊
    /******/ 		  new Proxy(␊
    /******/ 		    freeze(create(null)),␊
    /******/ 		    freeze({␊
    /******/ 		      // TODO: emulate a reference error in a getter.␊
    /******/ 		      has: freeze(() => true),␊
    /******/ 		    })␊
    /******/ 		  )␊
    /******/ 		)␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		const enforcePolicy = (requestedResourceId, referrerResourceId) => {␊
    /******/ 		  if (typeof requestedResourceId === 'undefined') {␊
    /******/ 		    throw Error(\`Requested resource ID is undefined\`)␊
    /******/ 		  }␊
    /******/ 		  requestedResourceId = '' + requestedResourceId␊
    /******/ 		  referrerResourceId = '' + referrerResourceId␊
    /******/ 		  // implicitly allow all for root and modules from the same package␊
    /******/ 		  if (␊
    /******/ 		    referrerResourceId === LAVAMOAT.root ||␊
    /******/ 		    requestedResourceId === referrerResourceId␊
    /******/ 		  ) {␊
    /******/ 		    return␊
    /******/ 		  }␊
    /******/ 		  const myPolicy = LAVAMOAT.policy.resources[referrerResourceId] || {}␊
    /******/ 		  // @ts-expect-error - missing details in policy type, see TODO in types.js␊
    /******/ 		  if (myPolicy.packages && myPolicy.packages[requestedResourceId]) {␊
    /******/ 		    return␊
    /******/ 		  }␊
    /******/ 		  throw Error(␊
    /******/ 		    \`Policy does not allow importing ${requestedResourceId} from ${referrerResourceId}\`␊
    /******/ 		  )␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		const theRealGlobalThis = globalThis␊
    /******/ 		␊
    /******/ 		let rootCompartmentGlobalThis␊
    /******/ 		const globalAliases = ['globalThis', 'window', 'self']␊
    /******/ 		␊
    /******/ 		const installGlobalsForPolicy = (resourceId, packageCompartmentGlobal) => {␊
    /******/ 		  if (resourceId === LAVAMOAT.root) {␊
    /******/ 		    rootCompartmentGlobalThis = packageCompartmentGlobal␊
    /******/ 		    copyWrappedGlobals(␊
    /******/ 		      theRealGlobalThis,␊
    /******/ 		      rootCompartmentGlobalThis,␊
    /******/ 		      globalAliases␊
    /******/ 		    )␊
    /******/ 		  } else {␊
    /******/ 		    // TODO: getEndowmentsForConfig doesn't implement support for "write"␊
    /******/ 		    const endowments = getEndowmentsForConfig(␊
    /******/ 		      rootCompartmentGlobalThis,␊
    /******/ 		      LAVAMOAT.policy.resources[resourceId] || {},␊
    /******/ 		      globalThis,␊
    /******/ 		      packageCompartmentGlobal␊
    /******/ 		    )␊
    /******/ 		␊
    /******/ 		    defineProperties(␊
    /******/ 		      packageCompartmentGlobal,␊
    /******/ 		      fromEntries(␊
    /******/ 		        globalAliases.map((alias) => [␊
    /******/ 		          alias,␊
    /******/ 		          { value: packageCompartmentGlobal },␊
    /******/ 		        ])␊
    /******/ 		      )␊
    /******/ 		    )␊
    /******/ 		    defineProperties(␊
    /******/ 		      packageCompartmentGlobal,␊
    /******/ 		      getOwnPropertyDescriptors(endowments)␊
    /******/ 		    )␊
    /******/ 		  }␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		const compartmentMap = new Map()␊
    /******/ 		␊
    /******/ 		const findResourceId = (moduleId) => {␊
    /******/ 		  const found = LAVAMOAT.idmap.find(([, moduleIds]) =>␊
    /******/ 		    moduleIds.includes(moduleId)␊
    /******/ 		  )␊
    /******/ 		  if (found) {␊
    /******/ 		    return found[0]␊
    /******/ 		  }␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		const wrapRequireWithPolicy = (__webpack_require__, referrerResourceId) =>␊
    /******/ 		  function (specifier) {␊
    /******/ 		    console.log(\`[${referrerResourceId}] require(${specifier})\`, LAVAMOAT.unenforceable.includes(specifier))␊
    /******/ 		    if (!LAVAMOAT.unenforceable.includes(specifier)) {␊
    /******/ 		      const requestedResourceId = findResourceId(specifier)␊
    /******/ 		      enforcePolicy(requestedResourceId, referrerResourceId)␊
    /******/ 		    }␊
    /******/ 		    // @ts-ignore - unknown this is the point here␊
    /******/ 		    return __webpack_require__.apply(this, arguments)␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		␊
    /******/ 		const lavamoatRuntimeWrapper = (resourceId, runtimeKit) => {␊
    /******/ 		  if (!LOCKDOWN_ON) {␊
    /******/ 		    // Scope Terminator not being present in the output causes the wrapper closure to run a no-op instaed of the module body␊
    /******/ 		    return create(null)␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  if (!compartmentMap.has(resourceId)) {␊
    /******/ 		    // Endow original Math and Date, because SES tames them and we don't need that␊
    /******/ 		    const c = new Compartment({ Math, Date })␊
    /******/ 		    installGlobalsForPolicy(resourceId, c.globalThis)␊
    /******/ 		    compartmentMap.set(resourceId, c)␊
    /******/ 		  }␊
    /******/ 		␊
    /******/ 		  let overrides = create(null)␊
    /******/ 		␊
    /******/ 		  // modules may reference \`require\` dynamically, but that's something we don't want to allow␊
    /******/ 		  const { __webpack_require__ } = runtimeKit␊
    /******/ 		  let { module } = runtimeKit␊
    /******/ 		␊
    /******/ 		  if (__webpack_require__) {␊
    /******/ 		    // wrap webpack runtime for policy check and hardening␊
    /******/ 		    const policyRequire = wrapRequireWithPolicy(__webpack_require__, resourceId)␊
    /******/ 		␊
    /******/ 		    // TODO: figure out what to wrap and what to copy␊
    /******/ 		    // TODO: most of the work here could be done once instead of for each wrapping␊
    /******/ 		␊
    /******/ 		    // Webpack has built-in plugins that add more runtime functions. We might need to support them eventually.␊
    /******/ 		    // It's a case-by-case basis decision.␊
    /******/ 		    // TODO: print a warning for other functions on the __webpack_require__ namespace that we're not supporting.␊
    /******/ 		    //   It's probably best served at build time though - with runtimeRequirements or looking at the items in webpack runtime when adding lavamoat runtime.␊
    /******/ 		␊
    /******/ 		    // The following seem harmless and are used by default: ['O', 'n', 'd', 'o', 'r', 's']␊
    /******/ 		    const supportedRuntimeItems = ['O', 'n', 'd', 'o', 'r', 's']␊
    /******/ 		    for (const item of supportedRuntimeItems) {␊
    /******/ 		      // @ts-expect-error - I'm not gonna do webppack's minified runtime typing␊
    /******/ 		      policyRequire[item] = harden(__webpack_require__[item])␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    // TODO: check if this is not breaking anything␊
    /******/ 		    // @ts-expect-error - webpack runtime is not typed␊
    /******/ 		    policyRequire.m = new Proxy(␊
    /******/ 		      {},␊
    /******/ 		      {␊
    /******/ 		        has: (target, prop) => {␊
    /******/ 		          warn(␊
    /******/ 		            \`A module attempted to read ${String(␊
    /******/ 		              prop␊
    /******/ 		            )} directly from webpack's module cache\`␊
    /******/ 		          )␊
    /******/ 		          return false␊
    /******/ 		        },␊
    /******/ 		      }␊
    /******/ 		    )␊
    /******/ 		␊
    /******/ 		    // webpack rewrites regerences to \`global\` to \`__webpack_require__.g\` in the bundle␊
    /******/ 		    policyRequire.g = compartmentMap.get(resourceId).globalThis␊
    /******/ 		␊
    /******/ 		    // override nmd to limit what it can mutate␊
    /******/ 		    // @ts-expect-error - webpack runtime is not typed␊
    /******/ 		    policyRequire.nmd = (moduleReference) => {␊
    /******/ 		      if (moduleReference === module) {␊
    /******/ 		        module = __webpack_require__.nmd(module)␊
    /******/ 		      }␊
    /******/ 		    }␊
    /******/ 		␊
    /******/ 		    overrides.__webpack_require__ = policyRequire␊
    /******/ 		  }␊
    /******/ 		  const runtimeHandler = assign(create(null), runtimeKit, overrides)␊
    /******/ 		␊
    /******/ 		  // allow setting, but ignore value for  module = __webpack_require__.nmd(module)␊
    /******/ 		  defineProperty(runtimeHandler, 'module', {␊
    /******/ 		    get: () => module,␊
    /******/ 		    set: () => {},␊
    /******/ 		  })␊
    /******/ 		  // Make it possible to overwrite \`exports\` locally despite runtimeHandler being frozen␊
    /******/ 		  let exportsReference = runtimeHandler.exports␊
    /******/ 		  defineProperty(runtimeHandler, 'exports', {␊
    /******/ 		    get: () => exportsReference,␊
    /******/ 		    set: (value) => {␊
    /******/ 		      exportsReference = value␊
    /******/ 		    },␊
    /******/ 		  })␊
    /******/ 		  freeze(runtimeHandler)␊
    /******/ 		␊
    /******/ 		  return {␊
    /******/ 		    [NAME_scopeTerminator]: stricterScopeTerminator,␊
    /******/ 		    [NAME_runtimeHandler]: runtimeHandler,␊
    /******/ 		    [NAME_globalThis]: compartmentMap.get(resourceId).globalThis,␊
    /******/ 		  }␊
    /******/ 		}␊
    /******/ 		␊
    /******/ 		// defaultExport is getting assigned to __webpack_require__._LM_␊
    /******/ 		LAVAMOAT.defaultExport = freeze(lavamoatRuntimeWrapper)␊
    /******/ 		;␊
    /******/ 		  __webpack_require__._LM_ = LAVAMOAT.defaultExport;␊
    /******/ 		  (typeof harden !== 'undefined') && harden(__webpack_require__._LM_);␊
    /******/ 	})();␊
    /******/ 	␊
    /******/ 	/* webpack/runtime/compat get default export */␊
    /******/ 	(() => {␊
    /******/ 		// getDefaultExport function for compatibility with non-harmony modules␊
    /******/ 		__webpack_require__.n = (module) => {␊
    /******/ 			var getter = module && module.__esModule ?␊
    /******/ 				() => (module['default']) :␊
    /******/ 				() => (module);␊
    /******/ 			__webpack_require__.d(getter, { a: getter });␊
    /******/ 			return getter;␊
    /******/ 		};␊
    /******/ 	})();␊
    /******/ 	␊
    /******/ 	/* webpack/runtime/define property getters */␊
    /******/ 	(() => {␊
    /******/ 		// define getter functions for harmony exports␊
    /******/ 		__webpack_require__.d = (exports, definition) => {␊
    /******/ 			for(var key in definition) {␊
    /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {␊
    /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });␊
    /******/ 				}␊
    /******/ 			}␊
    /******/ 		};␊
    /******/ 	})();␊
    /******/ 	␊
    /******/ 	/* webpack/runtime/hasOwnProperty shorthand */␊
    /******/ 	(() => {␊
    /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))␊
    /******/ 	})();␊
    /******/ 	␊
    /******/ 	/* webpack/runtime/make namespace object */␊
    /******/ 	(() => {␊
    /******/ 		// define __esModule on exports␊
    /******/ 		__webpack_require__.r = (exports) => {␊
    /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {␊
    /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });␊
    /******/ 			}␊
    /******/ 			Object.defineProperty(exports, '__esModule', { value: true });␊
    /******/ 		};␊
    /******/ 	})();␊
    /******/ 	␊
    /************************************************************************/␊
    var __webpack_exports__ = {};␊
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.␊
    (() => {␊
    /*!*****************!*\\␊
      !*** ./node.js ***!␊
      \\*****************/␊
    (function(){␊
         if (!this.ST) return ()=>{};␊
         with (this.ST) {␊
          with (this.RH) {␊
          with (this.G) {␊
            return function() { 'use strict';␊
    __webpack_require__.r(__webpack_exports__);␊
    /* harmony import */ var nodejs_package__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nodejs-package */ "./node_modules/nodejs-package/index.js");␊
    /* harmony import */ var nodejs_package__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nodejs_package__WEBPACK_IMPORTED_MODULE_0__);␊
    ␊
    ␊
    console.log((nodejs_package__WEBPACK_IMPORTED_MODULE_0___default()))␊
            };␊
          }␊
        }␊
        }␊
    }).call(__webpack_require__._LM_("$root$", { __webpack_require__,__webpack_exports__}))()␊
    })();␊
    ␊
    /******/ })()␊
    ;`
