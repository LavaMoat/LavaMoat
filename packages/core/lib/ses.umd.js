(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  /**
   * commons.js
   * Declare shorthand functions. Sharing these declarations across modules
   * improves on consistency and minification. Unused declarations are
   * dropped by the tree shaking process.
   *
   * We capture these, not just for brevity, but for security. If any code
   * modifies Object to change what 'assign' points to, the Compartment shim
   * would be corrupted.
   */

  const {
    assign,
    create,
    defineProperties,
    entries,
    freeze,
    getOwnPropertyDescriptor,
    getOwnPropertyDescriptors,
    getOwnPropertyNames,
    getPrototypeOf,
    is,
    isExtensible,
    keys,
    prototype: objectPrototype,
    seal,
    setPrototypeOf,
    values,
  } = Object;

  // At time of this writing, we still support Node 10 which doesn't have
  // `Object.fromEntries`. If it is absent, this should be an adequate
  // replacement.
  // By the terminology of https://ponyfoo.com/articles/polyfills-or-ponyfills
  // it is a ponyfill rather than a polyfill or shim because we do not
  // install it on `Object`.
  const objectFromEntries = entryPairs => {
    const result = {};
    for (const [prop, val] of entryPairs) {
      result[prop] = val;
    }
    return result;
  };

  const fromEntries = Object.fromEntries || objectFromEntries;

  const defineProperty = (object, prop, descriptor) => {
    // Object.defineProperty is allowed to fail silently so we use
    // Object.defineProperties instead.
    return defineProperties(object, { [prop]: descriptor });
  };

  const { apply, construct, get: reflectGet, set: reflectSet } = Reflect;

  const { isArray, prototype: arrayPrototype } = Array;
  const { revocable: proxyRevocable } = Proxy;
  const { prototype: regexpPrototype } = RegExp;
  const { prototype: stringPrototype } = String;
  const { prototype: weakmapPrototype } = WeakMap;

  /**
   * uncurryThis()
   * This form of uncurry uses Reflect.apply()
   *
   * The original uncurry uses:
   * const bind = Function.prototype.bind;
   * const uncurryThis = bind.bind(bind.call);
   *
   * See those reference for a complete explanation:
   * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
   * which only lives at
   * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
   *
   * @param {(thisArg: Object, ...args: any[]) => any} fn
   */
  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);

  const objectHasOwnProperty = uncurryThis(objectPrototype.hasOwnProperty);
  //
  const arrayFilter = uncurryThis(arrayPrototype.filter);
  const arrayJoin = uncurryThis(arrayPrototype.join);
  const arrayPush = uncurryThis(arrayPrototype.push);
  const arrayPop = uncurryThis(arrayPrototype.pop);
  const arrayIncludes = uncurryThis(arrayPrototype.includes);
  //
  const regexpTest = uncurryThis(regexpPrototype.test);
  //
  const stringMatch = uncurryThis(stringPrototype.match);
  const stringSearch = uncurryThis(stringPrototype.search);
  const stringSlice = uncurryThis(stringPrototype.slice);
  const stringSplit = uncurryThis(stringPrototype.split);
  //
  const weakmapGet = uncurryThis(weakmapPrototype.get);
  const weakmapSet = uncurryThis(weakmapPrototype.set);
  const weakmapHas = uncurryThis(weakmapPrototype.has);

  /**
   * immutableObject
   * An immutable (frozen) exotic object and is safe to share.
   */
  const immutableObject = freeze({ __proto__: null });

  const nativeSuffix = ') { [native code] }';

  // Note: Top level mutable state. Does not make anything worse, since the
  // patching of `Function.prototype.toString` is also globally stateful. We
  // use this top level state so that multiple calls to `tameFunctionToString` are
  // idempotent, rather than creating redundant indirections.
  let nativeBrander;

  /**
   * Replace `Function.prototype.toString` with one that recognizes
   * shimmed functions as honorary native functions.
   */
  function tameFunctionToString() {
    if (nativeBrander === undefined) {
      const nativeBrand = new WeakSet();

      const originalFunctionToString = Function.prototype.toString;

      const tamingMethods = {
        toString() {
          const str = apply(originalFunctionToString, this, []);
          if (str.endsWith(nativeSuffix) || !nativeBrand.has(this)) {
            return str;
          }
          return `function ${this.name}() { [native code] }`;
        },
      };

      defineProperty(Function.prototype, 'toString', {
        value: tamingMethods.toString,
      });

      nativeBrander = freeze(func => nativeBrand.add(func));
    }
    return nativeBrander;
  }

  /**
   * @file Exports {@code whitelist}, a recursively defined
   * JSON record enumerating all intrinsics and their properties
   * according to ECMA specs.
   *
   * @author JF Paradis
   * @author Mark S. Miller
   */

  /* eslint max-lines: 0 */

  /**
   * constantProperties
   * non-configurable, non-writable data properties of all global objects.
   * Must be powerless.
   * Maps from property name to the actual value
   */
  const constantProperties = {
    // *** Value Properties of the Global Object

    Infinity,
    NaN,
    undefined,
  };

  /**
   * universalPropertyNames
   * Properties of all global objects.
   * Must be powerless.
   * Maps from property name to the intrinsic name in the whitelist.
   */
  const universalPropertyNames = {
    // *** Function Properties of the Global Object

    isFinite: 'isFinite',
    isNaN: 'isNaN',
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',

    decodeURI: 'decodeURI',
    decodeURIComponent: 'decodeURIComponent',
    encodeURI: 'encodeURI',
    encodeURIComponent: 'encodeURIComponent',

    // *** Constructor Properties of the Global Object

    Array: 'Array',
    ArrayBuffer: 'ArrayBuffer',
    BigInt: 'BigInt',
    BigInt64Array: 'BigInt64Array',
    BigUint64Array: 'BigUint64Array',
    Boolean: 'Boolean',
    DataView: 'DataView',
    EvalError: 'EvalError',
    Float32Array: 'Float32Array',
    Float64Array: 'Float64Array',
    Int8Array: 'Int8Array',
    Int16Array: 'Int16Array',
    Int32Array: 'Int32Array',
    Map: 'Map',
    Number: 'Number',
    Object: 'Object',
    Promise: 'Promise',
    Proxy: 'Proxy',
    RangeError: 'RangeError',
    ReferenceError: 'ReferenceError',
    Set: 'Set',
    String: 'String',
    Symbol: 'Symbol',
    SyntaxError: 'SyntaxError',
    TypeError: 'TypeError',
    Uint8Array: 'Uint8Array',
    Uint8ClampedArray: 'Uint8ClampedArray',
    Uint16Array: 'Uint16Array',
    Uint32Array: 'Uint32Array',
    URIError: 'URIError',
    WeakMap: 'WeakMap',
    WeakSet: 'WeakSet',

    // *** Other Properties of the Global Object

    JSON: 'JSON',
    Reflect: 'Reflect',

    // *** Annex B

    escape: 'escape',
    unescape: 'unescape',

    // ESNext

    lockdown: 'lockdown',
    harden: 'harden',
    HandledPromise: 'HandledPromise', // TODO: Until Promise.delegate (see below).
    StaticModuleRecord: 'StaticModuleRecord',
  };

  /**
   * initialGlobalPropertyNames
   * Those found only on the initial global, i.e., the global of the
   * start compartment, as well as any compartments created before lockdown.
   * These may provide much of the power provided by the original.
   * Maps from property name to the intrinsic name in the whitelist.
   */
  const initialGlobalPropertyNames = {
    // *** Constructor Properties of the Global Object

    Date: '%InitialDate%',
    Error: '%InitialError%',
    RegExp: '%InitialRegExp%',

    // *** Other Properties of the Global Object

    Math: '%InitialMath%',

    // ESNext

    // From Error-stack proposal
    // Only on initial global. No corresponding
    // powerless form for other globals.
    getStackString: '%InitialGetStackString%',

    // TODO https://github.com/Agoric/SES-shim/issues/551
    // Need initial WeakRef and FinalizationGroup in
    // start compartment only.
  };

  /**
   * sharedGlobalPropertyNames
   * Those found only on the globals of new compartments created after lockdown,
   * which must therefore be powerless.
   * Maps from property name to the intrinsic name in the whitelist.
   */
  const sharedGlobalPropertyNames = {
    // *** Constructor Properties of the Global Object

    Date: '%SharedDate%',
    Error: '%SharedError%',
    RegExp: '%SharedRegExp%',

    // *** Other Properties of the Global Object

    Math: '%SharedMath%',
  };

  // All the "subclasses" of Error. These are collectively represented in the
  // EcmaScript spec by the meta variable NativeError.
  // TODO Add AggregateError https://github.com/Agoric/SES-shim/issues/550
  const NativeErrors = [
    EvalError,
    RangeError,
    ReferenceError,
    SyntaxError,
    TypeError,
    URIError,
  ];

  /**
   * <p>Each JSON record enumerates the disposition of the properties on
   *    some corresponding intrinsic object.
   *
   * <p>All records are made of key-value pairs where the key
   *    is the property to process, and the value is the associated
   *    dispositions a.k.a. the "permit". Those permits can be:
   * <ul>
   * <li>The boolean value "false", in which case this property is
   *     blacklisted and simply removed. Properties not mentioned
   *     are also considered blacklisted and are removed.
   * <li>A string value equal to a primitive ("number", "string", etc),
   *     in which case the property is whitelisted if its value property
   *     is typeof the given type. For example, {@code "Infinity"} leads to
   *     "number" and property values that fail {@code typeof "number"}.
   *     are removed.
   * <li>A string value equal to an intinsic name ("ObjectPrototype",
   *     "Array", etc), in which case the property whitelisted if its
   *     value property is equal to the value of the corresponfing
   *     intrinsics. For example, {@code Map.prototype} leads to
   *     "MapPrototype" and the property is removed if its value is
   *     not equal to %MapPrototype%
   * <li>Another record, in which case this property is simply
   *     whitelisted and that next record represents the disposition of
   *     the object which is its value. For example, {@code "Object"}
   *     leads to another record explaining what properties {@code
   *     "Object"} may have and how each such property should be treated.
   *
   * <p>Notes:
   * <li>"[[Proto]]" is used to refer to the "[[Prototype]]" internal
   *     slot, which says which object this object inherits from.
   * <li>"--proto--" is used to refer to the "__proto__" property name,
   *     which is the name of an accessor property on Object.prototype.
   *     In practice, it is used to access the [[Proto]] internal slot,
   *     but is distinct from the internal slot itself. We use
   *     "--proto--" rather than "__proto__" below because "__proto__"
   *     in an object literal is special syntax rather than a normal
   *     property definition.
   * <li>"ObjectPrototype" is the default "[[Proto]]" (when not specified).
   * <li>Constants "fn" and "getter" are used to keep the structure DRY.
   * <li>Symbol properties are listed using the "@@name" form.
   */

  // Function Instances
  const FunctionInstance = {
    '[[Proto]]': '%FunctionPrototype%',
    length: 'number',
    name: 'string',
    // Do not specify "prototype" here, since only Function instances that can
    // be used as a constructor have a prototype property. For constructors,
    // since prototype properties are instance-specific, we define it there.
  };

  // AsyncFunction Instances
  const AsyncFunctionInstance = {
    // This property is not mentioned in ECMA 262, but is present in V8 and
    // necessary for lockdown to succeed.
    '[[Proto]]': '%AsyncFunctionPrototype%',
  };

  // Aliases
  const fn = FunctionInstance;
  const asyncFn = AsyncFunctionInstance;

  const getter = {
    get: fn,
    set: 'undefined',
  };

  // Possible but not encountered in the specs
  // export const setter = {
  //   get: 'undefined',
  //   set: fn,
  // };

  const accessor = {
    get: fn,
    set: fn,
  };

  function isAccessorPermit(permit) {
    return permit === getter || permit === accessor;
  }

  // NativeError Object Structure
  function NativeError(prototype) {
    return {
      // Properties of the NativeError Constructors
      '[[Proto]]': '%SharedError%',

      // NativeError.prototype
      prototype,
    };
  }

  function NativeErrorPrototype(constructor) {
    return {
      // Properties of the NativeError Prototype Objects
      '[[Proto]]': '%ErrorPrototype%',
      constructor,
      message: 'string',
      name: 'string',
      // Redundantly present only on v8. Safe to remove.
      toString: false,
    };
  }

  // The TypedArray Constructors
  function TypedArray(prototype) {
    return {
      // Properties of the TypedArray Constructors
      '[[Proto]]': '%TypedArray%',
      BYTES_PER_ELEMENT: 'number',
      prototype,
    };
  }

  function TypedArrayPrototype(constructor) {
    return {
      // Properties of the TypedArray Prototype Objects
      '[[Proto]]': '%TypedArrayPrototype%',
      BYTES_PER_ELEMENT: 'number',
      constructor,
    };
  }

  // Without Math.random
  const SharedMath = {
    E: 'number',
    LN10: 'number',
    LN2: 'number',
    LOG10E: 'number',
    LOG2E: 'number',
    PI: 'number',
    SQRT1_2: 'number',
    SQRT2: 'number',
    '@@toStringTag': 'string',
    abs: fn,
    acos: fn,
    acosh: fn,
    asin: fn,
    asinh: fn,
    atan: fn,
    atanh: fn,
    atan2: fn,
    cbrt: fn,
    ceil: fn,
    clz32: fn,
    cos: fn,
    cosh: fn,
    exp: fn,
    expm1: fn,
    floor: fn,
    fround: fn,
    hypot: fn,
    imul: fn,
    log: fn,
    log1p: fn,
    log10: fn,
    log2: fn,
    max: fn,
    min: fn,
    pow: fn,
    round: fn,
    sign: fn,
    sin: fn,
    sinh: fn,
    sqrt: fn,
    tan: fn,
    tanh: fn,
    trunc: fn,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    idiv: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    idivmod: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    imod: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    imuldiv: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    irem: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    mod: false,
  };

  const whitelist = {
    // ECMA https://tc39.es/ecma262

    // The intrinsics object has no prototype to avoid conflicts.
    '[[Proto]]': null,

    // %ThrowTypeError%
    '%ThrowTypeError%': fn,

    // *** The Global Object

    // *** Value Properties of the Global Object
    Infinity: 'number',
    NaN: 'number',
    undefined: 'undefined',

    // *** Function Properties of the Global Object

    // eval
    '%UniqueEval%': fn,
    isFinite: fn,
    isNaN: fn,
    parseFloat: fn,
    parseInt: fn,
    decodeURI: fn,
    decodeURIComponent: fn,
    encodeURI: fn,
    encodeURIComponent: fn,

    // *** Fundamental Objects

    Object: {
      // Properties of the Object Constructor
      '[[Proto]]': '%FunctionPrototype%',
      assign: fn,
      create: fn,
      defineProperties: fn,
      defineProperty: fn,
      entries: fn,
      freeze: fn,
      fromEntries: fn,
      getOwnPropertyDescriptor: fn,
      getOwnPropertyDescriptors: fn,
      getOwnPropertyNames: fn,
      getOwnPropertySymbols: fn,
      getPrototypeOf: fn,
      is: fn,
      isExtensible: fn,
      isFrozen: fn,
      isSealed: fn,
      keys: fn,
      preventExtensions: fn,
      prototype: '%ObjectPrototype%',
      seal: fn,
      setPrototypeOf: fn,
      values: fn,
    },

    '%ObjectPrototype%': {
      // Properties of the Object Prototype Object
      '[[Proto]]': null,
      constructor: 'Object',
      hasOwnProperty: fn,
      isPrototypeOf: fn,
      propertyIsEnumerable: fn,
      toLocaleString: fn,
      toString: fn,
      valueOf: fn,

      // Annex B: Additional Properties of the Object.prototype Object

      '--proto--': accessor,
      __defineGetter__: fn,
      __defineSetter__: fn,
      __lookupGetter__: fn,
      __lookupSetter__: fn,
    },

    '%UniqueFunction%': {
      // Properties of the Function Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%FunctionPrototype%',
    },

    '%InertFunction%': {
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%FunctionPrototype%',
    },

    '%FunctionPrototype%': {
      apply: fn,
      bind: fn,
      call: fn,
      constructor: '%InertFunction%', // TODO test
      toString: fn,
      '@@hasInstance': fn,
      // proposed but not yet std yet. To be removed if there
      caller: false,
      // proposed but not yet std yet. To be removed if there
      arguments: false,
    },

    Boolean: {
      // Properties of the Boolean Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%BooleanPrototype%',
    },

    '%BooleanPrototype%': {
      constructor: 'Boolean',
      toString: fn,
      valueOf: fn,
    },

    Symbol: {
      // Properties of the Symbol Constructor
      '[[Proto]]': '%FunctionPrototype%',
      asyncIterator: 'symbol',
      for: fn,
      hasInstance: 'symbol',
      isConcatSpreadable: 'symbol',
      iterator: 'symbol',
      keyFor: fn,
      match: 'symbol',
      matchAll: 'symbol',
      prototype: '%SymbolPrototype%',
      replace: 'symbol',
      search: 'symbol',
      species: 'symbol',
      split: 'symbol',
      toPrimitive: 'symbol',
      toStringTag: 'symbol',
      unscopables: 'symbol',
    },

    '%SymbolPrototype%': {
      // Properties of the Symbol Prototype Object
      constructor: 'Symbol',
      description: getter,
      toString: fn,
      valueOf: fn,
      '@@toPrimitive': fn,
      '@@toStringTag': 'string',
    },

    '%InitialError%': {
      // Properties of the Error Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%ErrorPrototype%',
      // Non standard, v8 only, used by tap
      captureStackTrace: fn,
      // Non standard, v8 only, used by tap, tamed to accessor
      stackTraceLimit: accessor,
      // Non standard, v8 only, used by several, tamed to accessor
      prepareStackTrace: accessor,
    },

    '%SharedError%': {
      // Properties of the Error Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%ErrorPrototype%',
      // Non standard, v8 only, used by tap
      captureStackTrace: fn,
      // Non standard, v8 only, used by tap, tamed to accessor
      stackTraceLimit: accessor,
      // Non standard, v8 only, used by several, tamed to accessor
      prepareStackTrace: accessor,
    },

    '%ErrorPrototype%': {
      constructor: '%SharedError%',
      message: 'string',
      name: 'string',
      toString: fn,
      // proposed de-facto, assumed TODO
      // stack: accessor,
    },

    // NativeError

    EvalError: NativeError('%EvalErrorPrototype%'),
    RangeError: NativeError('%RangeErrorPrototype%'),
    ReferenceError: NativeError('%ReferenceErrorPrototype%'),
    SyntaxError: NativeError('%SyntaxErrorPrototype%'),
    TypeError: NativeError('%TypeErrorPrototype%'),
    URIError: NativeError('%URIErrorPrototype%'),

    '%EvalErrorPrototype%': NativeErrorPrototype('EvalError'),
    '%RangeErrorPrototype%': NativeErrorPrototype('RangeError'),
    '%ReferenceErrorPrototype%': NativeErrorPrototype('ReferenceError'),
    '%SyntaxErrorPrototype%': NativeErrorPrototype('SyntaxError'),
    '%TypeErrorPrototype%': NativeErrorPrototype('TypeError'),
    '%URIErrorPrototype%': NativeErrorPrototype('URIError'),

    // *** Numbers and Dates

    Number: {
      // Properties of the Number Constructor
      '[[Proto]]': '%FunctionPrototype%',
      EPSILON: 'number',
      isFinite: fn,
      isInteger: fn,
      isNaN: fn,
      isSafeInteger: fn,
      MAX_SAFE_INTEGER: 'number',
      MAX_VALUE: 'number',
      MIN_SAFE_INTEGER: 'number',
      MIN_VALUE: 'number',
      NaN: 'number',
      NEGATIVE_INFINITY: 'number',
      parseFloat: fn,
      parseInt: fn,
      POSITIVE_INFINITY: 'number',
      prototype: '%NumberPrototype%',
    },

    '%NumberPrototype%': {
      // Properties of the Number Prototype Object
      constructor: 'Number',
      toExponential: fn,
      toFixed: fn,
      toLocaleString: fn,
      toPrecision: fn,
      toString: fn,
      valueOf: fn,
    },

    BigInt: {
      // Properties of the BigInt Constructor
      '[[Proto]]': '%FunctionPrototype%',
      asIntN: fn,
      asUintN: fn,
      prototype: '%BigIntPrototype%',
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      bitLength: false,
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      fromArrayBuffer: false,
    },

    '%BigIntPrototype%': {
      constructor: 'BigInt',
      toLocaleString: fn,
      toString: fn,
      valueOf: fn,
      '@@toStringTag': 'string',
    },

    '%InitialMath%': {
      ...SharedMath,
      // random is standard but omitted from SharedMath
      random: fn,
    },

    '%SharedMath%': SharedMath,

    '%InitialDate%': {
      // Properties of the Date Constructor
      '[[Proto]]': '%FunctionPrototype%',
      now: fn,
      parse: fn,
      prototype: '%DatePrototype%',
      UTC: fn,
    },

    '%SharedDate%': {
      // Properties of the Date Constructor
      '[[Proto]]': '%FunctionPrototype%',
      now: fn,
      parse: fn,
      prototype: '%DatePrototype%',
      UTC: fn,
    },

    '%DatePrototype%': {
      constructor: '%SharedDate%',
      getDate: fn,
      getDay: fn,
      getFullYear: fn,
      getHours: fn,
      getMilliseconds: fn,
      getMinutes: fn,
      getMonth: fn,
      getSeconds: fn,
      getTime: fn,
      getTimezoneOffset: fn,
      getUTCDate: fn,
      getUTCDay: fn,
      getUTCFullYear: fn,
      getUTCHours: fn,
      getUTCMilliseconds: fn,
      getUTCMinutes: fn,
      getUTCMonth: fn,
      getUTCSeconds: fn,
      setDate: fn,
      setFullYear: fn,
      setHours: fn,
      setMilliseconds: fn,
      setMinutes: fn,
      setMonth: fn,
      setSeconds: fn,
      setTime: fn,
      setUTCDate: fn,
      setUTCFullYear: fn,
      setUTCHours: fn,
      setUTCMilliseconds: fn,
      setUTCMinutes: fn,
      setUTCMonth: fn,
      setUTCSeconds: fn,
      toDateString: fn,
      toISOString: fn,
      toJSON: fn,
      toLocaleDateString: fn,
      toLocaleString: fn,
      toLocaleTimeString: fn,
      toString: fn,
      toTimeString: fn,
      toUTCString: fn,
      valueOf: fn,
      '@@toPrimitive': fn,

      // Annex B: Additional Properties of the Date.prototype Object
      getYear: fn,
      setYear: fn,
      toGMTString: fn,
    },

    // Text Processing

    String: {
      // Properties of the String Constructor
      '[[Proto]]': '%FunctionPrototype%',
      fromCharCode: fn,
      fromCodePoint: fn,
      prototype: '%StringPrototype%',
      raw: fn,
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      fromArrayBuffer: false,
    },

    '%StringPrototype%': {
      // Properties of the String Prototype Object
      length: 'number',
      charAt: fn,
      charCodeAt: fn,
      codePointAt: fn,
      concat: fn,
      constructor: 'String',
      endsWith: fn,
      includes: fn,
      indexOf: fn,
      lastIndexOf: fn,
      localeCompare: fn,
      match: fn,
      matchAll: fn,
      normalize: fn,
      padEnd: fn,
      padStart: fn,
      repeat: fn,
      replace: fn,
      replaceAll: fn, // ES2021
      search: fn,
      slice: fn,
      split: fn,
      startsWith: fn,
      substring: fn,
      toLocaleLowerCase: fn,
      toLocaleUpperCase: fn,
      toLowerCase: fn,
      toString: fn,
      toUpperCase: fn,
      trim: fn,
      trimEnd: fn,
      trimStart: fn,
      valueOf: fn,
      '@@iterator': fn,

      // Annex B: Additional Properties of the String.prototype Object
      substr: fn,
      anchor: fn,
      big: fn,
      blink: fn,
      bold: fn,
      fixed: fn,
      fontcolor: fn,
      fontsize: fn,
      italics: fn,
      link: fn,
      small: fn,
      strike: fn,
      sub: fn,
      sup: fn,
      trimLeft: fn,
      trimRight: fn,
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      compare: false,
    },

    '%StringIteratorPrototype%': {
      '[[Proto]]': '%IteratorPrototype%',
      next: fn,
      '@@toStringTag': 'string',
    },

    '%InitialRegExp%': {
      // Properties of the RegExp Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%RegExpPrototype%',
      '@@species': getter,

      // The https://github.com/tc39/proposal-regexp-legacy-features
      // are all optional, unsafe, and omitted
      input: false,
      $_: false,
      lastMatch: false,
      '$&': false,
      lastParen: false,
      '$+': false,
      leftContext: false,
      '$`': false,
      rightContext: false,
      "$'": false,
      $1: false,
      $2: false,
      $3: false,
      $4: false,
      $5: false,
      $6: false,
      $7: false,
      $8: false,
      $9: false,
    },

    '%SharedRegExp%': {
      // Properties of the RegExp Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%RegExpPrototype%',
      '@@species': getter,
    },

    '%RegExpPrototype%': {
      // Properties of the RegExp Prototype Object
      constructor: '%SharedRegExp%',
      exec: fn,
      dotAll: getter,
      flags: getter,
      global: getter,
      ignoreCase: getter,
      '@@match': fn,
      '@@matchAll': fn,
      multiline: getter,
      '@@replace': fn,
      '@@search': fn,
      source: getter,
      '@@split': fn,
      sticky: getter,
      test: fn,
      toString: fn,
      unicode: getter,

      // Annex B: Additional Properties of the RegExp.prototype Object
      compile: false, // UNSAFE and suppressed.
    },

    '%RegExpStringIteratorPrototype%': {
      // The %RegExpStringIteratorPrototype% Object
      '[[Proto]]': '%IteratorPrototype%',
      next: fn,
      '@@toStringTag': 'string',
    },

    // Indexed Collections

    Array: {
      // Properties of the Array Constructor
      '[[Proto]]': '%FunctionPrototype%',
      from: fn,
      isArray: fn,
      of: fn,
      prototype: '%ArrayPrototype%',
      '@@species': getter,
    },

    '%ArrayPrototype%': {
      // Properties of the Array Prototype Object
      length: 'number',
      concat: fn,
      constructor: 'Array',
      copyWithin: fn,
      entries: fn,
      every: fn,
      fill: fn,
      filter: fn,
      find: fn,
      findIndex: fn,
      flat: fn,
      flatMap: fn,
      forEach: fn,
      includes: fn,
      indexOf: fn,
      join: fn,
      keys: fn,
      lastIndexOf: fn,
      map: fn,
      pop: fn,
      push: fn,
      reduce: fn,
      reduceRight: fn,
      reverse: fn,
      shift: fn,
      slice: fn,
      some: fn,
      sort: fn,
      splice: fn,
      toLocaleString: fn,
      toString: fn,
      unshift: fn,
      values: fn,
      '@@iterator': fn,
      '@@unscopables': {
        '[[Proto]]': null,
        copyWithin: 'boolean',
        entries: 'boolean',
        fill: 'boolean',
        find: 'boolean',
        findIndex: 'boolean',
        flat: 'boolean',
        flatMap: 'boolean',
        includes: 'boolean',
        keys: 'boolean',
        values: 'boolean',
      },
    },

    '%ArrayIteratorPrototype%': {
      // The %ArrayIteratorPrototype% Object
      '[[Proto]]': '%IteratorPrototype%',
      next: fn,
      '@@toStringTag': 'string',
    },

    // *** TypedArray Objects

    '%TypedArray%': {
      // Properties of the %TypedArray% Intrinsic Object
      '[[Proto]]': '%FunctionPrototype%',
      from: fn,
      of: fn,
      prototype: '%TypedArrayPrototype%',
      '@@species': getter,
    },

    '%TypedArrayPrototype%': {
      buffer: getter,
      byteLength: getter,
      byteOffset: getter,
      constructor: '%TypedArray%',
      copyWithin: fn,
      entries: fn,
      every: fn,
      fill: fn,
      filter: fn,
      find: fn,
      findIndex: fn,
      forEach: fn,
      includes: fn,
      indexOf: fn,
      join: fn,
      keys: fn,
      lastIndexOf: fn,
      length: getter,
      map: fn,
      reduce: fn,
      reduceRight: fn,
      reverse: fn,
      set: fn,
      slice: fn,
      some: fn,
      sort: fn,
      subarray: fn,
      toLocaleString: fn,
      toString: fn,
      values: fn,
      '@@iterator': fn,
      '@@toStringTag': getter,
    },

    // The TypedArray Constructors

    BigInt64Array: TypedArray('%BigInt64ArrayPrototype%'),
    BigUint64Array: TypedArray('%BigUint64ArrayPrototype%'),
    Float32Array: TypedArray('%Float32ArrayPrototype%'),
    Float64Array: TypedArray('%Float64ArrayPrototype%'),
    Int16Array: TypedArray('%Int16ArrayPrototype%'),
    Int32Array: TypedArray('%Int32ArrayPrototype%'),
    Int8Array: TypedArray('%Int8ArrayPrototype%'),
    Uint16Array: TypedArray('%Uint16ArrayPrototype%'),
    Uint32Array: TypedArray('%Uint32ArrayPrototype%'),
    Uint8Array: TypedArray('%Uint8ArrayPrototype%'),
    Uint8ClampedArray: TypedArray('%Uint8ClampedArrayPrototype%'),

    '%BigInt64ArrayPrototype%': TypedArrayPrototype('BigInt64Array'),
    '%BigUint64ArrayPrototype%': TypedArrayPrototype('BigUint64Array'),
    '%Float32ArrayPrototype%': TypedArrayPrototype('Float32Array'),
    '%Float64ArrayPrototype%': TypedArrayPrototype('Float64Array'),
    '%Int16ArrayPrototype%': TypedArrayPrototype('Int16Array'),
    '%Int32ArrayPrototype%': TypedArrayPrototype('Int32Array'),
    '%Int8ArrayPrototype%': TypedArrayPrototype('Int8Array'),
    '%Uint16ArrayPrototype%': TypedArrayPrototype('Uint16Array'),
    '%Uint32ArrayPrototype%': TypedArrayPrototype('Uint32Array'),
    '%Uint8ArrayPrototype%': TypedArrayPrototype('Uint8Array'),
    '%Uint8ClampedArrayPrototype%': TypedArrayPrototype('Uint8ClampedArray'),

    // *** Keyed Collections

    Map: {
      // Properties of the Map Constructor
      '[[Proto]]': '%FunctionPrototype%',
      '@@species': getter,
      prototype: '%MapPrototype%',
    },

    '%MapPrototype%': {
      clear: fn,
      constructor: 'Map',
      delete: fn,
      entries: fn,
      forEach: fn,
      get: fn,
      has: fn,
      keys: fn,
      set: fn,
      size: getter,
      values: fn,
      '@@iterator': fn,
      '@@toStringTag': 'string',
    },

    '%MapIteratorPrototype%': {
      // The %MapIteratorPrototype% Object
      '[[Proto]]': '%IteratorPrototype%',
      next: fn,
      '@@toStringTag': 'string',
    },

    Set: {
      // Properties of the Set Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%SetPrototype%',
      '@@species': getter,
    },

    '%SetPrototype%': {
      add: fn,
      clear: fn,
      constructor: 'Set',
      delete: fn,
      entries: fn,
      forEach: fn,
      has: fn,
      keys: fn,
      size: getter,
      values: fn,
      '@@iterator': fn,
      '@@toStringTag': 'string',
    },

    '%SetIteratorPrototype%': {
      // The %SetIteratorPrototype% Object
      '[[Proto]]': '%IteratorPrototype%',
      next: fn,
      '@@toStringTag': 'string',
    },

    WeakMap: {
      // Properties of the WeakMap Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%WeakMapPrototype%',
    },

    '%WeakMapPrototype%': {
      constructor: 'WeakMap',
      delete: fn,
      get: fn,
      has: fn,
      set: fn,
      '@@toStringTag': 'string',
    },

    WeakSet: {
      // Properties of the WeakSet Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%WeakSetPrototype%',
    },

    '%WeakSetPrototype%': {
      add: fn,
      constructor: 'WeakSet',
      delete: fn,
      has: fn,
      '@@toStringTag': 'string',
    },

    // *** Structured Data

    ArrayBuffer: {
      // Properties of the ArrayBuffer Constructor
      '[[Proto]]': '%FunctionPrototype%',
      isView: fn,
      prototype: '%ArrayBufferPrototype%',
      '@@species': getter,
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      fromString: false,
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      fromBigInt: false,
    },

    '%ArrayBufferPrototype%': {
      byteLength: getter,
      constructor: 'ArrayBuffer',
      slice: fn,
      '@@toStringTag': 'string',
      // See https://github.com/Moddable-OpenSource/moddable/issues/523
      concat: false,
    },

    // SharedArrayBuffer Objects
    SharedArrayBuffer: false, // UNSAFE and purposely suppressed.
    '%SharedArrayBufferPrototype%': false, // UNSAFE and purposely suppressed.

    DataView: {
      // Properties of the DataView Constructor
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%DataViewPrototype%',
    },

    '%DataViewPrototype%': {
      buffer: getter,
      byteLength: getter,
      byteOffset: getter,
      constructor: 'DataView',
      getBigInt64: fn,
      getBigUint64: fn,
      getFloat32: fn,
      getFloat64: fn,
      getInt8: fn,
      getInt16: fn,
      getInt32: fn,
      getUint8: fn,
      getUint16: fn,
      getUint32: fn,
      setBigInt64: fn,
      setBigUint64: fn,
      setFloat32: fn,
      setFloat64: fn,
      setInt8: fn,
      setInt16: fn,
      setInt32: fn,
      setUint8: fn,
      setUint16: fn,
      setUint32: fn,
      '@@toStringTag': 'string',
    },

    // Atomics
    Atomics: false, // UNSAFE and suppressed.

    JSON: {
      parse: fn,
      stringify: fn,
      '@@toStringTag': 'string',
    },

    // *** Control Abstraction Objects

    '%IteratorPrototype%': {
      // The %IteratorPrototype% Object
      '@@iterator': fn,
    },

    '%AsyncIteratorPrototype%': {
      // The %AsyncIteratorPrototype% Object
      '@@asyncIterator': fn,
    },

    '%InertGeneratorFunction%': {
      // Properties of the GeneratorFunction Constructor
      '[[Proto]]': '%InertFunction%',
      prototype: '%Generator%',
    },

    '%Generator%': {
      // Properties of the GeneratorFunction Prototype Object
      '[[Proto]]': '%FunctionPrototype%',
      constructor: '%InertGeneratorFunction%',
      prototype: '%GeneratorPrototype%',
      '@@toStringTag': 'string',
    },

    '%InertAsyncGeneratorFunction%': {
      // Properties of the AsyncGeneratorFunction Constructor
      '[[Proto]]': '%InertFunction%',
      prototype: '%AsyncGenerator%',
    },

    '%AsyncGenerator%': {
      // Properties of the AsyncGeneratorFunction Prototype Object
      '[[Proto]]': '%FunctionPrototype%',
      constructor: '%InertAsyncGeneratorFunction%',
      prototype: '%AsyncGeneratorPrototype%',
      '@@toStringTag': 'string',
    },

    '%GeneratorPrototype%': {
      // Properties of the Generator Prototype Object
      '[[Proto]]': '%IteratorPrototype%',
      constructor: '%Generator%',
      next: fn,
      return: fn,
      throw: fn,
      '@@toStringTag': 'string',
    },

    '%AsyncGeneratorPrototype%': {
      // Properties of the AsyncGenerator Prototype Object
      '[[Proto]]': '%AsyncIteratorPrototype%',
      constructor: '%AsyncGenerator%',
      next: fn,
      return: fn,
      throw: fn,
      '@@toStringTag': 'string',
    },

    // TODO: To be replaced with Promise.delegate
    //
    // The HandledPromise global variable shimmed by `@agoric/eventual-send/shim`
    // implements an initial version of the eventual send specification at:
    // https://github.com/tc39/proposal-eventual-send
    //
    // We will likely change this to add a property to Promise called
    // Promise.delegate and put static methods on it, which will necessitate
    // another whitelist change to update to the current proposed standard.
    HandledPromise: {
      '[[Proto]]': 'Promise',
      applyFunction: fn,
      applyFunctionSendOnly: fn,
      applyMethod: fn,
      applyMethodSendOnly: fn,
      get: fn,
      getSendOnly: fn,
      prototype: '%PromisePrototype%',
      resolve: fn,
    },

    Promise: {
      // Properties of the Promise Constructor
      '[[Proto]]': '%FunctionPrototype%',
      all: fn,
      allSettled: fn,
      // To transition from `false` to `fn` once we also have `AggregateError`
      // TODO https://github.com/Agoric/SES-shim/issues/550
      any: false, // ES2021
      prototype: '%PromisePrototype%',
      race: fn,
      reject: fn,
      resolve: fn,
      '@@species': getter,
    },

    '%PromisePrototype%': {
      // Properties of the Promise Prototype Object
      catch: fn,
      constructor: 'Promise',
      finally: fn,
      then: fn,
      '@@toStringTag': 'string',
    },

    '%InertAsyncFunction%': {
      // Properties of the AsyncFunction Constructor
      '[[Proto]]': '%InertFunction%',
      prototype: '%AsyncFunctionPrototype%',
    },

    '%AsyncFunctionPrototype%': {
      // Properties of the AsyncFunction Prototype Object
      '[[Proto]]': '%FunctionPrototype%',
      constructor: '%InertAsyncFunction%',
      '@@toStringTag': 'string',
    },

    // Reflection

    Reflect: {
      // The Reflect Object
      // Not a function object.
      apply: fn,
      construct: fn,
      defineProperty: fn,
      deleteProperty: fn,
      get: fn,
      getOwnPropertyDescriptor: fn,
      getPrototypeOf: fn,
      has: fn,
      isExtensible: fn,
      ownKeys: fn,
      preventExtensions: fn,
      set: fn,
      setPrototypeOf: fn,
      '@@toStringTag': 'string',
    },

    Proxy: {
      // Properties of the Proxy Constructor
      '[[Proto]]': '%FunctionPrototype%',
      revocable: fn,
    },

    // Appendix B

    // Annex B: Additional Properties of the Global Object

    escape: fn,
    unescape: fn,

    // Proposed

    '%UniqueCompartment%': {
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%CompartmentPrototype%',
      toString: fn,
    },

    '%InertCompartment%': {
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%CompartmentPrototype%',
      toString: fn,
    },

    '%CompartmentPrototype%': {
      constructor: '%InertCompartment%',
      evaluate: fn,
      globalThis: getter,
      name: getter,
      // Should this be proposed?
      toString: fn,
    },

    lockdown: fn,
    harden: fn,

    '%InitialGetStackString%': fn,
  };

  const modulesWhitelist = {
    '%CompartmentPrototype%': {
      ...whitelist['%CompartmentPrototype%'],
      import: asyncFn,
      load: asyncFn,
      importNow: fn,
      module: fn,
    },

    StaticModuleRecord: {
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%StaticModuleRecordPrototype%',
      toString: fn,
    },

    '%InertStaticModuleRecord%': {
      '[[Proto]]': '%FunctionPrototype%',
      prototype: '%StaticModuleRecordPrototype%',
      toString: fn,
    },

    '%StaticModuleRecordPrototype%': {
      constructor: '%InertStaticModuleRecord%',
      // Should this be proposed?
      toString: fn,
    },
  };

  // Like defineProperty, but throws if it would modify an existing property.
  // We use this to ensure that two conflicting attempts to define the same
  // property throws, causing SES initialization to fail. Otherwise, a
  // conflict between, for example, two of SES's internal whitelists might
  // get masked as one overwrites the other. Accordingly, the thrown error
  // complains of a "Conflicting definition".
  function initProperty(obj, name, desc) {
    if (objectHasOwnProperty(obj, name)) {
      const preDesc = getOwnPropertyDescriptor(obj, name);
      if (
        !Object.is(preDesc.value, desc.value) ||
        preDesc.get !== desc.get ||
        preDesc.set !== desc.set ||
        preDesc.writable !== desc.writable ||
        preDesc.enumerable !== desc.enumerable ||
        preDesc.configurable !== desc.configurable
      ) {
        throw new Error(`Conflicting definitions of ${name}`);
      }
    }
    defineProperty(obj, name, desc);
  }

  // Like defineProperties, but throws if it would modify an existing property.
  // This ensures that the intrinsics added to the intrinsics collector object
  // graph do not overlap.
  function initProperties(obj, descs) {
    for (const [name, desc] of entries(descs)) {
      initProperty(obj, name, desc);
    }
  }

  // sampleGlobals creates an intrinsics object, suitable for
  // interinsicsCollector.addIntrinsics, from the named properties of a global
  // object.
  function sampleGlobals(globalObject, newPropertyNames) {
    const newIntrinsics = { __proto__: null };
    for (const [globalName, intrinsicName] of entries(newPropertyNames)) {
      if (objectHasOwnProperty(globalObject, globalName)) {
        newIntrinsics[intrinsicName] = globalObject[globalName];
      }
    }
    return newIntrinsics;
  }

  function makeIntrinsicsCollector() {
    const intrinsics = { __proto__: null };
    let pseudoNatives;

    const intrinsicsCollector = {
      addIntrinsics(newIntrinsics) {
        initProperties(intrinsics, getOwnPropertyDescriptors(newIntrinsics));
      },

      // For each intrinsic, if it has a `.prototype` property, use the
      // whitelist to find out the intrinsic name for that prototype and add it
      // to the intrinsics.
      completePrototypes() {
        for (const [name, intrinsic] of entries(intrinsics)) {
          if (intrinsic !== Object(intrinsic)) {
            // eslint-disable-next-line no-continue
            continue;
          }
          if (!objectHasOwnProperty(intrinsic, 'prototype')) {
            // eslint-disable-next-line no-continue
            continue;
          }
          const permit = whitelist[name];
          if (typeof permit !== 'object') {
            throw new Error(`Expected permit object at whitelist.${name}`);
          }
          const namePrototype = permit.prototype;
          if (!namePrototype) {
            throw new Error(`${name}.prototype property not whitelisted`);
          }
          if (
            typeof namePrototype !== 'string' ||
            !objectHasOwnProperty(whitelist, namePrototype)
          ) {
            throw new Error(`Unrecognized ${name}.prototype whitelist entry`);
          }
          const intrinsicPrototype = intrinsic.prototype;
          if (objectHasOwnProperty(intrinsics, namePrototype)) {
            if (intrinsics[namePrototype] !== intrinsicPrototype) {
              throw new Error(`Conflicting bindings of ${namePrototype}`);
            }
            // eslint-disable-next-line no-continue
            continue;
          }
          intrinsics[namePrototype] = intrinsicPrototype;
        }
      },
      finalIntrinsics() {
        freeze(intrinsics);
        pseudoNatives = new WeakSet(
          values(intrinsics).filter(obj => typeof obj === 'function'),
        );
        return intrinsics;
      },
      isPseudoNative(obj) {
        if (!pseudoNatives) {
          throw new Error(
            'isPseudoNative can only be called after finalIntrinsics',
          );
        }
        return pseudoNatives.has(obj);
      },
    };

    intrinsicsCollector.addIntrinsics(constantProperties);
    intrinsicsCollector.addIntrinsics(
      sampleGlobals(globalThis, universalPropertyNames),
    );

    return intrinsicsCollector;
  }

  /**
   * getGlobalIntrinsics()
   * Doesn't tame, delete, or modify anything. Samples globalObject to create an
   * intrinsics record containing only the whitelisted global variables, listed
   * by the intrinsic names appropriate for new globals, i.e., the globals of
   * newly constructed compartments.
   *
   * WARNING:
   * If run before lockdown, the returned intrinsics record will carry the
   * *original* unsafe (feral, untamed) bindings of these global variables.
   *
   * @param {Object} globalObject
   */
  function getGlobalIntrinsics(globalObject) {
    const intrinsicsCollector = makeIntrinsicsCollector();

    intrinsicsCollector.addIntrinsics(
      sampleGlobals(globalObject, sharedGlobalPropertyNames),
    );

    return intrinsicsCollector.finalIntrinsics();
  }

  const InertCompartment = function Compartment(
    _endowments = {},
    _modules = {},
    _options = {},
  ) {
    throw new TypeError('Not available');
  };

  // It is not clear that
  // `StaticModuleRecord.prototype.constructor` needs to be the
  // useless `InertStaticModuleRecord` rather than
  // `StaticModuleRecord` itself. The reason we're starting off
  // extra caution is that `StaticModuleRecord` would be the only
  // remaining universally shared primordial reachable by navigation
  // that can turn strings of code into a representation closer to
  // code execution. The others, `eval`, `Function`, and `Compartment`
  // are already protected, and only `Compartment` can turn a
  // `StaticModuleRecord` into execution, which is why it would
  // probably be safe. However, since this extra caution has a tiny
  // cost, I'd rather start out more restrictive, maintaining the option
  // to loosen the rule over time.
  //
  const InertStaticModuleRecord = function StaticModuleRecord(
    _string,
    _url,
  ) {
    throw new TypeError('Not available');
  };

  /**
   * Object.getConstructorOf()
   * Helper function to improve readability, similar to Object.getPrototypeOf().
   *
   * @param {Object} obj
   */
  function getConstructorOf(obj) {
    return getPrototypeOf(obj).constructor;
  }

  /**
   * getAnonymousIntrinsics()
   * Get the intrinsics not otherwise reachable by named own property
   * traversal from the global object.
   *
   * @returns {Object}
   */
  function getAnonymousIntrinsics() {
    const InertFunction = Function.prototype.constructor;

    const SymbolIterator = (typeof Symbol && Symbol.iterator) || '@@iterator';
    const SymbolMatchAll = (typeof Symbol && Symbol.matchAll) || '@@matchAll';

    // 9.2.4.1 %ThrowTypeError%

    // eslint-disable-next-line prefer-rest-params
    const ThrowTypeError = getOwnPropertyDescriptor(arguments, 'callee').get;

    // 21.1.5.2 The %StringIteratorPrototype% Object

    // eslint-disable-next-line no-new-wrappers
    const StringIteratorObject = new String()[SymbolIterator]();
    const StringIteratorPrototype = getPrototypeOf(StringIteratorObject);

    // 21.2.7.1 The %RegExpStringIteratorPrototype% Object
    const RegExpStringIterator =
      RegExp.prototype[SymbolMatchAll] && new RegExp()[SymbolMatchAll]();
    const RegExpStringIteratorPrototype =
      RegExpStringIterator && getPrototypeOf(RegExpStringIterator);

    // 22.1.5.2 The %ArrayIteratorPrototype% Object

    // eslint-disable-next-line no-array-constructor
    const ArrayIteratorObject = new Array()[SymbolIterator]();
    const ArrayIteratorPrototype = getPrototypeOf(ArrayIteratorObject);

    // 22.2.1 The %TypedArray% Intrinsic Object

    const TypedArray = getPrototypeOf(Float32Array);

    // 23.1.5.2 The %MapIteratorPrototype% Object

    const MapIteratorObject = new Map()[SymbolIterator]();
    const MapIteratorPrototype = getPrototypeOf(MapIteratorObject);

    // 23.2.5.2 The %SetIteratorPrototype% Object

    const SetIteratorObject = new Set()[SymbolIterator]();
    const SetIteratorPrototype = getPrototypeOf(SetIteratorObject);

    // 25.1.2 The %IteratorPrototype% Object

    const IteratorPrototype = getPrototypeOf(ArrayIteratorPrototype);

    // 25.2.1 The GeneratorFunction Constructor

    // eslint-disable-next-line no-empty-function
    function* GeneratorFunctionInstance() {}
    const GeneratorFunction = getConstructorOf(GeneratorFunctionInstance);

    // 25.2.3 Properties of the GeneratorFunction Prototype Object

    const Generator = GeneratorFunction.prototype;

    // 25.3.1 The AsyncGeneratorFunction Constructor

    // eslint-disable-next-line no-empty-function
    async function* AsyncGeneratorFunctionInstance() {}
    const AsyncGeneratorFunction = getConstructorOf(
      AsyncGeneratorFunctionInstance,
    );

    // 25.3.2.2 AsyncGeneratorFunction.prototype
    const AsyncGenerator = AsyncGeneratorFunction.prototype;
    // 25.5.1 Properties of the AsyncGenerator Prototype Object
    const AsyncGeneratorPrototype = AsyncGenerator.prototype;
    const AsyncIteratorPrototype = getPrototypeOf(AsyncGeneratorPrototype);

    // 25.7.1 The AsyncFunction Constructor

    // eslint-disable-next-line no-empty-function
    async function AsyncFunctionInstance() {}
    const AsyncFunction = getConstructorOf(AsyncFunctionInstance);

    const intrinsics = {
      '%InertFunction%': InertFunction,
      '%ArrayIteratorPrototype%': ArrayIteratorPrototype,
      '%InertAsyncFunction%': AsyncFunction,
      '%AsyncGenerator%': AsyncGenerator,
      '%InertAsyncGeneratorFunction%': AsyncGeneratorFunction,
      '%AsyncGeneratorPrototype%': AsyncGeneratorPrototype,
      '%AsyncIteratorPrototype%': AsyncIteratorPrototype,
      '%Generator%': Generator,
      '%InertGeneratorFunction%': GeneratorFunction,
      '%IteratorPrototype%': IteratorPrototype,
      '%MapIteratorPrototype%': MapIteratorPrototype,
      '%RegExpStringIteratorPrototype%': RegExpStringIteratorPrototype,
      '%SetIteratorPrototype%': SetIteratorPrototype,
      '%StringIteratorPrototype%': StringIteratorPrototype,
      '%ThrowTypeError%': ThrowTypeError,
      '%TypedArray%': TypedArray,
      '%InertCompartment%': InertCompartment,
    };

    return intrinsics;
  }

  function getModularAnonymousIntrinsics() {
    return {
      ...getAnonymousIntrinsics(),
      '%InertStaticModuleRecord%': InertStaticModuleRecord,
    };
  }

  // Adapted from SES/Caja - Copyright (C) 2011 Google Inc.
  // Copyright (C) 2018 Agoric

  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  // http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  // based upon:
  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js
  // then copied from proposal-frozen-realms deep-freeze.js
  // then copied from SES/src/bundle/deepFreeze.js

  const { freeze: freeze$1, getOwnPropertyDescriptors: getOwnPropertyDescriptors$1, getPrototypeOf: getPrototypeOf$1 } = Object;
  const { ownKeys } = Reflect;

  /**
   * Create a `harden` function.
   */
  function makeHardener() {
    const hardened = new WeakSet();

    const { harden } = {
      harden(root) {
        const toFreeze = new Set();
        const paths = new WeakMap();

        // If val is something we should be freezing but aren't yet,
        // add it to toFreeze.
        function enqueue(val, path) {
          if (Object(val) !== val) {
            // ignore primitives
            return;
          }
          const type = typeof val;
          if (type !== 'object' && type !== 'function') {
            // future proof: break until someone figures out what it should do
            throw new TypeError(`Unexpected typeof: ${type}`);
          }
          if (hardened.has(val) || toFreeze.has(val)) {
            // Ignore if this is an exit, or we've already visited it
            return;
          }
          // console.log(`adding ${val} to toFreeze`, val);
          toFreeze.add(val);
          paths.set(val, path);
        }

        function freezeAndTraverse(obj) {
          // Now freeze the object to ensure reactive
          // objects such as proxies won't add properties
          // during traversal, before they get frozen.

          // Object are verified before being enqueued,
          // therefore this is a valid candidate.
          // Throws if this fails (strict mode).
          freeze$1(obj);

          // we rely upon certain commitments of Object.freeze and proxies here

          // get stable/immutable outbound links before a Proxy has a chance to do
          // something sneaky.
          const path = paths.get(obj) || 'unknown';
          const descs = getOwnPropertyDescriptors$1(obj);
          const proto = getPrototypeOf$1(obj);
          enqueue(proto, `${path}.__proto__`);

          ownKeys(descs).forEach(name => {
            const pathname = `${path}.${String(name)}`;
            // todo uncurried form
            // todo: getOwnPropertyDescriptors is guaranteed to return well-formed
            // descriptors, but they still inherit from Object.prototype. If
            // someone has poisoned Object.prototype to add 'value' or 'get'
            // properties, then a simple 'if ("value" in desc)' or 'desc.value'
            // test could be confused. We use hasOwnProperty to be sure about
            // whether 'value' is present or not, which tells us for sure that
            // this is a data property.
            const desc = descs[name];
            if ('value' in desc) {
              // todo uncurried form
              enqueue(desc.value, `${pathname}`);
            } else {
              enqueue(desc.get, `${pathname}(get)`);
              enqueue(desc.set, `${pathname}(set)`);
            }
          });
        }

        function dequeue() {
          // New values added before forEach() has finished will be visited.
          toFreeze.forEach(freezeAndTraverse); // todo curried forEach
        }

        function commit() {
          // todo curried forEach
          // we capture the real WeakSet.prototype.add above, in case someone
          // changes it. The two-argument form of forEach passes the second
          // argument as the 'this' binding, so we add to the correct set.
          toFreeze.forEach(hardened.add, hardened);
        }

        enqueue(root);
        dequeue();
        // console.log("toFreeze set:", toFreeze);
        commit();

        return root;
      },
    };

    return harden;
  }

  // Copyright (C) 2011 Google Inc.

  const { apply: apply$1, ownKeys: ownKeys$1 } = Reflect;
  const uncurryThis$1 = fn => (thisArg, ...args) => apply$1(fn, thisArg, args);
  const hasOwnProperty = uncurryThis$1(Object.prototype.hasOwnProperty);

  /**
   * asStringPropertyName()
   *
   * @param {string} path
   * @param {string | symbol} prop
   */
  function asStringPropertyName(path, prop) {
    if (typeof prop === 'string') {
      return prop;
    }

    if (typeof prop === 'symbol') {
      return `@@${prop.toString().slice(14, -1)}`;
    }

    throw new TypeError(`Unexpected property name type ${path} ${prop}`);
  }

  /**
   * whitelistIntrinsics()
   * Removes all non-whitelisted properties found by recursively and
   * reflectively walking own property chains.
   *
   * @param {Object} intrinsics
   * @param {(Object) => void} nativeBrander
   */
  function whitelistIntrinsics(intrinsics, nativeBrander) {
    // These primities are allowed allowed for permits.
    const primitives = ['undefined', 'boolean', 'number', 'string', 'symbol'];

    /*
     * whitelistPrototype()
     * Validate the object's [[prototype]] against a permit.
     */
    function whitelistPrototype(path, obj, protoName) {
      if (obj !== Object(obj)) {
        throw new TypeError(`Object expected: ${path}, ${obj}, ${protoName}`);
      }
      const proto = getPrototypeOf(obj);

      // Null prototype.
      if (proto === null && protoName === null) {
        return;
      }

      // Assert: protoName, if provided, is a string.
      if (protoName !== undefined && typeof protoName !== 'string') {
        throw new TypeError(`Malformed whitelist permit ${path}.__proto__`);
      }

      // If permit not specified, default to Object.prototype.
      if (proto === intrinsics[protoName || '%ObjectPrototype%']) {
        return;
      }

      // We can't clean [[prototype]], therefore abort.
      throw new Error(`Unexpected intrinsic ${path}.__proto__ at ${protoName}`);
    }

    /*
     * isWhitelistPropertyValue()
     * Whitelist a single property value against a permit.
     */
    function isWhitelistPropertyValue(path, value, prop, permit) {
      if (typeof permit === 'object') {
        // eslint-disable-next-line no-use-before-define
        whitelistProperties(path, value, permit);
        // The property is whitelisted.
        return true;
      }

      if (permit === false) {
        // A boolan 'false' permit specifies the removal of a property.
        // We require a more specific permit instead of allowing 'true'.
        return false;
      }

      if (typeof permit === 'string') {
        // A string permit can have one of two meanings:

        if (prop === 'prototype' || prop === 'constructor') {
          // For prototype and constructor value properties, the permit
          // is the name of an intrinsic.
          // Assumption: prototype and constructor cannot be primitives.
          // Assert: the permit is the name of an intrinsic.
          // Assert: the property value is equal to that intrinsic.

          if (hasOwnProperty(intrinsics, permit)) {
            if (value !== intrinsics[permit]) {
              throw new TypeError(`Does not match whitelist ${path}`);
            }
            return true;
          }
        } else {
          // For all other properties, the permit is the name of a primitive.
          // Assert: the permit is the name of a primitive.
          // Assert: the property value type is equal to that primitive.

          // eslint-disable-next-line no-lonely-if
          if (primitives.includes(permit)) {
            // eslint-disable-next-line valid-typeof
            if (typeof value !== permit) {
              throw new TypeError(
                `At ${path} expected ${permit} not ${typeof value}`,
              );
            }
            return true;
          }
        }
      }

      throw new TypeError(`Unexpected whitelist permit ${permit} at ${path}`);
    }

    /*
     * isWhitelistProperty()
     * Whitelist a single property against a permit.
     */
    function isWhitelistProperty(path, obj, prop, permit) {
      const desc = getOwnPropertyDescriptor(obj, prop);

      // Is this a value property?
      if (hasOwnProperty(desc, 'value')) {
        if (isAccessorPermit(permit)) {
          throw new TypeError(`Accessor expected at ${path}`);
        }
        return isWhitelistPropertyValue(path, desc.value, prop, permit);
      }
      if (!isAccessorPermit(permit)) {
        throw new TypeError(`Accessor not expected at ${path}`);
      }
      return (
        isWhitelistPropertyValue(`${path}<get>`, desc.get, prop, permit.get) &&
        isWhitelistPropertyValue(`${path}<set>`, desc.set, prop, permit.set)
      );
    }

    /*
     * getSubPermit()
     */
    function getSubPermit(obj, permit, prop) {
      const permitProp = prop === '__proto__' ? '--proto--' : prop;
      if (hasOwnProperty(permit, permitProp)) {
        return permit[permitProp];
      }

      if (typeof obj === 'function') {
        nativeBrander(obj);
        if (hasOwnProperty(FunctionInstance, permitProp)) {
          return FunctionInstance[permitProp];
        }
      }

      return undefined;
    }

    /*
     * whitelistProperties()
     * Whitelist all properties against a permit.
     */
    function whitelistProperties(path, obj, permit) {
      if (obj === undefined) {
        return;
      }

      const protoName = permit['[[Proto]]'];
      whitelistPrototype(path, obj, protoName);

      for (const prop of ownKeys$1(obj)) {
        const propString = asStringPropertyName(path, prop);
        const subPath = `${path}.${propString}`;
        const subPermit = getSubPermit(obj, permit, propString);

        if (subPermit) {
          // Property has a permit.
          if (isWhitelistProperty(subPath, obj, prop, subPermit)) {
            // Property is whitelisted.
            // eslint-disable-next-line no-continue
            continue;
          }
        }

        if (subPermit !== false) {
          // This call to `console.log` is intensional. It is not a vestige
          // of a debugging attempt. See the comment at top of file for an
          // explanation.
          console.log(`Removing ${subPath}`);
        }
        delete obj[prop];
      }
    }

    // Start path with 'intrinsics' to clarify that properties are not
    // removed from the global object by the whitelisting operation.
    whitelistProperties('intrinsics', intrinsics, whitelist);
  }

  // Adapted from SES/Caja - Copyright (C) 2011 Google Inc.

  /**
   * Replace the legacy accessors of Object to comply with strict mode
   * and ES2016 semantics, we do this by redefining them while in 'use strict'.
   *
   * todo: list the issues resolved
   *
   * This function can be used in two ways: (1) invoked directly to fix the primal
   * realm's Object.prototype, and (2) converted to a string to be executed
   * inside each new RootRealm to fix their Object.prototypes. Evaluation requires
   * the function to have no dependencies, so don't import anything from
   * the outside.
   */

  function repairLegacyAccessors() {
    try {
      // Verify that the method is not callable.
      // eslint-disable-next-line no-underscore-dangle
      (0, Object.prototype.__lookupGetter__)('x');
    } catch (ignore) {
      // Throws, no need to patch.
      return;
    }

    // On some platforms, the implementation of these functions act as
    // if they are in sloppy mode: if they're invoked badly, they will
    // expose the global object, so we need to repair these for
    // security. Thus it is our responsibility to fix this, and we need
    // to include repairAccessors. E.g. Chrome in 2016.

    function toObject(obj) {
      if (obj === undefined || obj === null) {
        throw new TypeError("can't convert undefined or null to object");
      }
      return Object(obj);
    }

    function asPropertyName(obj) {
      if (typeof obj === 'symbol') {
        return obj;
      }
      return `${obj}`;
    }

    function aFunction(obj, accessor) {
      if (typeof obj !== 'function') {
        throw TypeError(`invalid ${accessor} usage`);
      }
      return obj;
    }

    defineProperties(objectPrototype, {
      __defineGetter__: {
        value: function __defineGetter__(prop, func) {
          const O = toObject(this);
          defineProperty(O, prop, {
            get: aFunction(func, 'getter'),
            enumerable: true,
            configurable: true,
          });
        },
      },
      __defineSetter__: {
        value: function __defineSetter__(prop, func) {
          const O = toObject(this);
          defineProperty(O, prop, {
            set: aFunction(func, 'setter'),
            enumerable: true,
            configurable: true,
          });
        },
      },
      __lookupGetter__: {
        value: function __lookupGetter__(prop) {
          let O = toObject(this);
          prop = asPropertyName(prop);
          let desc;
          // eslint-disable-next-line no-cond-assign
          while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {
            O = getPrototypeOf(O);
          }
          return desc && desc.get;
        },
      },
      __lookupSetter__: {
        value: function __lookupSetter__(prop) {
          let O = toObject(this);
          prop = asPropertyName(prop);
          let desc;
          // eslint-disable-next-line no-cond-assign
          while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {
            O = getPrototypeOf(O);
          }
          return desc && desc.set;
        },
      },
    });
  }

  // This module replaces the original `Function` constructor, and the original
  // `%GeneratorFunction%`, `%AsyncFunction%` and `%AsyncGeneratorFunction%`,
  // with safe replacements that throw if invoked.
  //
  // These are all reachable via syntax, so it isn't sufficient to just
  // replace global properties with safe versions. Our main goal is to prevent
  // access to the `Function` constructor through these starting points.
  //
  // After modules block is done, the originals must no longer be reachable,
  // unless a copy has been made, and functions can only be created by syntax
  // (using eval) or by invoking a previously saved reference to the originals.
  //
  // Typically, this module will not be used directly, but via the
  // [lockdown - shim] which handles all necessary repairs and taming in SES.
  //
  // Relation to ECMA specifications
  //
  // The taming of constructors really wants to be part of the standard, because
  // new constructors may be added in the future, reachable from syntax, and this
  // list must be updated to match.
  //
  // In addition, the standard needs to define four new intrinsics for the safe
  // replacement functions. See [./whitelist intrinsics].
  //
  // Adapted from SES/Caja
  // Copyright (C) 2011 Google Inc.
  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js

  /**
   * tameFunctionConstructors()
   * This block replaces the original Function constructor, and the original
   * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with
   * safe replacements that throw if invoked.
   */
  function tameFunctionConstructors() {
    try {
      // Verify that the method is not callable.
      (0, Function.prototype.constructor)('return 1');
    } catch (ignore) {
      // Throws, no need to patch.
      return {};
    }

    const newIntrinsics = {};

    /*
     * The process to repair constructors:
     * 1. Create an instance of the function by evaluating syntax
     * 2. Obtain the prototype from the instance
     * 3. Create a substitute tamed constructor
     * 4. Replace the original constructor with the tamed constructor
     * 5. Replace tamed constructor prototype property with the original one
     * 6. Replace its [[Prototype]] slot with the tamed constructor of Function
     */
    function repairFunction(name, intrinsicName, declaration) {
      let FunctionInstance;
      try {
        // eslint-disable-next-line no-eval
        FunctionInstance = (0, eval)(declaration);
      } catch (e) {
        if (e instanceof SyntaxError) {
          // Prevent failure on platforms where async and/or generators
          // are not supported.
          return;
        }
        // Re-throw
        throw e;
      }
      const FunctionPrototype = getPrototypeOf(FunctionInstance);

      // Prevents the evaluation of source when calling constructor on the
      // prototype of functions.
      // eslint-disable-next-line func-names
      const InertConstructor = function() {
        throw new TypeError('Not available');
      };
      defineProperties(InertConstructor, {
        prototype: { value: FunctionPrototype },
        name: {
          value: name,
          writable: false,
          enumerable: false,
          configurable: true,
        },
      });

      defineProperties(FunctionPrototype, {
        constructor: { value: InertConstructor },
      });

      // Reconstructs the inheritance among the new tamed constructors
      // to mirror the original specified in normal JS.
      if (InertConstructor !== Function.prototype.constructor) {
        setPrototypeOf(InertConstructor, Function.prototype.constructor);
      }

      newIntrinsics[intrinsicName] = InertConstructor;
    }

    // Here, the order of operation is important: Function needs to be repaired
    // first since the other repaired constructors need to inherit from the
    // tamed Function function constructor.

    repairFunction('Function', '%InertFunction%', '(function(){})');
    repairFunction(
      'GeneratorFunction',
      '%InertGeneratorFunction%',
      '(function*(){})',
    );
    repairFunction(
      'AsyncFunction',
      '%InertAsyncFunction%',
      '(async function(){})',
    );
    repairFunction(
      'AsyncGeneratorFunction',
      '%InertAsyncGeneratorFunction%',
      '(async function*(){})',
    );

    return newIntrinsics;
  }

  function tameDateConstructor(dateTaming = 'safe') {
    if (dateTaming !== 'safe' && dateTaming !== 'unsafe') {
      throw new Error(`unrecognized dateTaming ${dateTaming}`);
    }
    const OriginalDate = Date;
    const DatePrototype = OriginalDate.prototype;

    // Use concise methods to obtain named functions without constructors.
    const tamedMethods = {
      now() {
        return NaN;
      },
    };

    // Tame the Date constructor.
    // Common behavior
    //   * new Date(x) coerces x into a number and then returns a Date
    //     for that number of millis since the epoch
    //   * new Date(NaN) returns a Date object which stringifies to
    //     'Invalid Date'
    //   * new Date(undefined) returns a Date object which stringifies to
    //     'Invalid Date'
    // OriginalDate (normal standard) behavior
    //   * Date(anything) gives a string with the current time
    //   * new Date() returns the current time, as a Date object
    // SharedDate behavior
    //   * Date(anything) returned 'Invalid Date'
    //   * new Date() returns a Date object which stringifies to
    //     'Invalid Date'
    const makeDateConstructor = ({ powers = 'none' } = {}) => {
      let ResultDate;
      if (powers === 'original') {
        ResultDate = function Date(...rest) {
          if (new.target === undefined) {
            return Reflect.apply(OriginalDate, undefined, rest);
          }
          return Reflect.construct(OriginalDate, rest, new.target);
        };
      } else {
        ResultDate = function Date(...rest) {
          if (new.target === undefined) {
            return 'Invalid Date';
          }
          if (rest.length === 0) {
            rest = [NaN];
          }
          return Reflect.construct(OriginalDate, rest, new.target);
        };
      }

      defineProperties(ResultDate, {
        length: { value: 7 },
        prototype: {
          value: DatePrototype,
          writable: false,
          enumerable: false,
          configurable: false,
        },
        parse: {
          value: Date.parse,
          writable: true,
          enumerable: false,
          configurable: true,
        },
        UTC: {
          value: Date.UTC,
          writable: true,
          enumerable: false,
          configurable: true,
        },
      });
      return ResultDate;
    };
    const InitialDate = makeDateConstructor({ powers: 'original' });
    const SharedDate = makeDateConstructor({ power: 'none' });

    defineProperties(InitialDate, {
      now: {
        value: Date.now,
        writable: true,
        enumerable: false,
        configurable: true,
      },
    });
    defineProperties(SharedDate, {
      now: {
        value: tamedMethods.now,
        writable: true,
        enumerable: false,
        configurable: true,
      },
    });

    defineProperties(DatePrototype, {
      constructor: { value: SharedDate },
    });

    return {
      '%InitialDate%': InitialDate,
      '%SharedDate%': SharedDate,
    };
  }

  function tameMathObject(mathTaming = 'safe') {
    if (mathTaming !== 'safe' && mathTaming !== 'unsafe') {
      throw new Error(`unrecognized mathTaming ${mathTaming}`);
    }
    const originalMath = Math;
    const initialMath = originalMath; // to follow the naming pattern

    const { random: _, ...otherDescriptors } = getOwnPropertyDescriptors(
      originalMath,
    );

    const sharedMath = create(Object.prototype, otherDescriptors);

    return {
      '%InitialMath%': initialMath,
      '%SharedMath%': sharedMath,
    };
  }

  function tameRegExpConstructor(regExpTaming = 'safe') {
    if (regExpTaming !== 'safe' && regExpTaming !== 'unsafe') {
      throw new Error(`unrecognized regExpTaming ${regExpTaming}`);
    }
    const OriginalRegExp = RegExp;
    const RegExpPrototype = OriginalRegExp.prototype;

    const makeRegExpConstructor = (_ = {}) => {
      // RegExp has non-writable static properties we need to omit.
      const ResultRegExp = function RegExp(...rest) {
        if (new.target === undefined) {
          return OriginalRegExp(...rest);
        }
        return Reflect.construct(OriginalRegExp, rest, new.target);
      };

      defineProperties(ResultRegExp, {
        length: { value: 2 },
        prototype: {
          value: RegExpPrototype,
          writable: false,
          enumerable: false,
          configurable: false,
        },
        [Symbol.species]: getOwnPropertyDescriptor(
          OriginalRegExp,
          Symbol.species,
        ),
      });
      return ResultRegExp;
    };

    const InitialRegExp = makeRegExpConstructor();
    const SharedRegExp = makeRegExpConstructor();

    if (regExpTaming !== 'unsafe') {
      delete RegExpPrototype.compile;
    }
    defineProperties(RegExpPrototype, {
      constructor: { value: SharedRegExp },
    });

    return {
      '%InitialRegExp%': InitialRegExp,
      '%SharedRegExp%': SharedRegExp,
    };
  }

  /**
   * @file Exports {@code enablements}, a recursively defined
   * JSON record defining the optimum set of intrinsics properties
   * that need to be "repaired" before hardening is applied on
   * enviromments subject to the override mistake.
   *
   * @author JF Paradis
   */

  /**
   * <p>Because "repairing" replaces data properties with accessors, every
   * time a repaired property is accessed, the associated getter is invoked,
   * which degrades the runtime performance of all code executing in the
   * repaired enviromment, compared to the non-repaired case. In order
   * to maintain performance, we only repair the properties of objects
   * for which hardening causes a breakage of their normal intended usage.
   *
   * There are three unwanted cases:
   * <ul>
   * <li>Overriding properties on objects typically used as records,
   *     namely {@code "Object"} and {@code "Array"}. In the case of arrays,
   *     the situation is unintentional, a given program might not be aware
   *     that non-numerical properties are stored on the underlying object
   *     instance, not on the array. When an object is typically used as a
   *     map, we repair all of its prototype properties.
   * <li>Overriding properties on objects that provide defaults on their
   *     prototype and that programs typically set using an assignment, such as
   *     {@code "Error.prototype.message"} and {@code "Function.prototype.name"}
   *     (both default to "").
   * <li>Setting-up a prototype chain, where a constructor is set to extend
   *     another one. This is typically set by assignment, for example
   *     {@code "Child.prototype.constructor = Child"}, instead of invoking
   *     Object.defineProperty();
   *
   * <p>Each JSON record enumerates the disposition of the properties on
   * some corresponding intrinsic object.
   *
   * <p>For each such record, the values associated with its property
   * names can be:
   * <ul>
   * <li>true, in which case this property is simply repaired. The
   *     value associated with that property is not traversed. For
   * 	   example, {@code "Function.prototype.name"} leads to true,
   *     meaning that the {@code "name"} property of {@code
   *     "Function.prototype"} should be repaired (which is needed
   *     when inheriting from @code{Function} and setting the subclass's
   *     {@code "prototype.name"} property). If the property is
   *     already an accessor property, it is not repaired (because
   *     accessors are not subject to the override mistake).
   * <li>"*", in which case this property is not repaired but the
   *     value associated with that property are traversed and repaired.
   * <li>Another record, in which case this property is not repaired
   *     and that next record represents the disposition of the object
   *     which is its value. For example,{@code "FunctionPrototype"}
   *     leads to another record explaining which properties {@code
   *     Function.prototype} need to be repaired.
   */

  var enablements = {
    '%ObjectPrototype%': '*',

    '%ArrayPrototype%': '*',

    '%FunctionPrototype%': {
      constructor: true, // set by "regenerator-runtime"
      bind: true, // set by "underscore"
      name: true,
      toString: true,
    },

    '%ErrorPrototype%': {
      constructor: true, // set by "fast-json-patch"
      message: true,
      name: true, // set by "precond"
      toString: true, // set by "bluebird"
    },

    '%TypeErrorPrototype%': {
      constructor: true, // set by "readable-stream"
      message: true, // set by "tape"
      name: true, // set by "readable-stream"
    },

    '%SyntaxErrorPrototype%': {
      message: true, // to match TypeErrorPrototype.message
    },

    '%RangeErrorPrototype%': {
      message: true, // to match TypeErrorPrototype.message
    },

    '%URIErrorPrototype%': {
      message: true, // to match TypeErrorPrototype.message
    },

    '%EvalErrorPrototype%': {
      message: true, // to match TypeErrorPrototype.message
    },

    '%ReferenceErrorPrototype%': {
      message: true, // to match TypeErrorPrototype.message
    },

    '%PromisePrototype%': {
      constructor: true, // set by "core-js"
    },

    '%TypedArrayPrototype%': '*',

    '%Generator%': {
      constructor: true,
      name: true,
      toString: true,
    },

    '%IteratorPrototype%': '*',
  };

  // Adapted from SES/Caja

  const { ownKeys: ownKeys$2 } = Reflect;

  function isObject(obj) {
    return obj !== null && typeof obj === 'object';
  }

  /**
   * For a special set of properties defined in the `enablement` whitelist,
   * `enablePropertyOverrides` ensures that the effect of freezing does not
   * suppress the ability to override these properties on derived objects by
   * simple assignment.
   *
   * Because of lack of sufficient foresight at the time, ES5 unfortunately
   * specified that a simple assignment to a non-existent property must fail if
   * it would override an non-writable data property of the same name in the
   * shadow of the prototype chain. In retrospect, this was a mistake, the
   * so-called "override mistake". But it is now too late and we must live with
   * the consequences.
   *
   * As a result, simply freezing an object to make it tamper proof has the
   * unfortunate side effect of breaking previously correct code that is
   * considered to have followed JS best practices, if this previous code used
   * assignment to override.
   *
   * For the enabled properties, `enablePropertyOverrides` effectively shims what
   * the assignment behavior would have been in the absence of the override
   * mistake. However, the shim produces an imperfect emulation. It shims the
   * behavior by turning these data properties into accessor properties, where
   * the accessor's getter and setter provide the desired behavior. For
   * non-reflective operations, the illusion is perfect. However, reflective
   * operations like `getOwnPropertyDescriptor` see the descriptor of an accessor
   * property rather than the descriptor of a data property. At the time of this
   * writing, this is the best we know how to do.
   *
   * To the getter of the accessor we add a property named
   * `'originalValue'` whose value is, as it says, the value that the
   * data property had before being converted to an accessor property. We add
   * this extra property to the getter for two reason:
   *
   * The harden algorithm walks the own properties reflectively, i.e., with
   * `getOwnPropertyDescriptor` semantics, rather than `[[Get]]` semantics. When
   * it sees an accessor property, it does not invoke the getter. Rather, it
   * proceeds to walk both the getter and setter as part of its transitive
   * traversal. Without this extra property, `enablePropertyOverrides` would have
   * hidden the original data property value from `harden`, which would be bad.
   * Instead, by exposing that value in an own data property on the getter,
   * `harden` finds and walks it anyway.
   *
   * We enable a form of cooperative emulation, giving reflective code an
   * opportunity to cooperate in upholding the illusion. When such cooperative
   * reflective code sees an accessor property, where the accessor's getter
   * has an `originalValue` property, it knows that the getter is
   * alleging that it is the result of the `enablePropertyOverrides` conversion
   * pattern, so it can decide to cooperatively "pretend" that it sees a data
   * property with that value.
   *
   * @param {Record<string, any>} intrinsics
   */
  function enablePropertyOverrides(intrinsics) {
    function enable(path, obj, prop, desc) {
      if ('value' in desc && desc.configurable) {
        const { value } = desc;

        function getter() {
          return value;
        }
        defineProperty(getter, 'originalValue', {
          value,
          writable: false,
          enumerable: false,
          configurable: false,
        });

        function setter(newValue) {
          if (obj === this) {
            throw new TypeError(
              `Cannot assign to read only property '${String(
              prop,
            )}' of '${path}'`,
            );
          }
          if (objectHasOwnProperty(this, prop)) {
            this[prop] = newValue;
          } else {
            defineProperty(this, prop, {
              value: newValue,
              writable: true,
              enumerable: true,
              configurable: true,
            });
          }
        }

        defineProperty(obj, prop, {
          get: getter,
          set: setter,
          enumerable: desc.enumerable,
          configurable: desc.configurable,
        });
      }
    }

    function enableProperty(path, obj, prop) {
      const desc = getOwnPropertyDescriptor(obj, prop);
      if (!desc) {
        return;
      }
      enable(path, obj, prop, desc);
    }

    function enableAllProperties(path, obj) {
      const descs = getOwnPropertyDescriptors(obj);
      if (!descs) {
        return;
      }
      // TypeScript does not allow symbols to be used as indexes because it
      // cannot recokon types of symbolized properties.
      // @ts-ignore
      ownKeys$2(descs).forEach(prop => enable(path, obj, prop, descs[prop]));
    }

    function enableProperties(path, obj, plan) {
      for (const prop of getOwnPropertyNames(plan)) {
        const desc = getOwnPropertyDescriptor(obj, prop);
        if (!desc || desc.get || desc.set) {
          // No not a value property, nothing to do.
          // eslint-disable-next-line no-continue
          continue;
        }

        // Plan has no symbol keys and we use getOwnPropertyNames()
        // so `prop` cannot only be a string, not a symbol. We coerce it in place
        // with `String(..)` anyway just as good hygiene, since these paths are just
        // for diagnostic purposes.
        const subPath = `${path}.${String(prop)}`;
        const subPlan = plan[prop];

        if (subPlan === true) {
          enableProperty(subPath, obj, prop);
        } else if (subPlan === '*') {
          enableAllProperties(subPath, desc.value);
        } else if (isObject(subPlan)) {
          enableProperties(subPath, desc.value, subPlan);
        } else {
          throw new TypeError(`Unexpected override enablement plan ${subPath}`);
        }
      }
    }

    // Do the repair.
    enableProperties('root', intrinsics, enablements);
  }

  // @ts-check

  /**
   * Prepend the correct indefinite article onto a noun, typically a typeof
   * result, e.g., "an object" vs. "a number"
   *
   * @param {string} str The noun to prepend
   * @returns {string} The noun prepended with a/an
   */
  const an = str => {
    str = `${str}`;
    if (str.length >= 1 && 'aeiouAEIOU'.includes(str[0])) {
      return `an ${str}`;
    }
    return `a ${str}`;
  };
  freeze(an);

  /**
   * Like `JSON.stringify` but does not blow up if given a cycle. This is not
   * intended to be a serialization to support any useful unserialization,
   * or any programmatic use of the resulting string. The string is intended
   * only for showing a human, in order to be informative enough for some
   * logging purposes. As such, this `cycleTolerantStringify` has an
   * imprecise specification and may change over time.
   *
   * The current `cycleTolerantStringify` possibly emits too many "seen"
   * markings: Not only for cycles, but also for repeated subtrees by
   * object identity.
   *
   * @param {any} payload
   * @returns {string}
   */
  const cycleTolerantStringify = payload => {
    const seenSet = new Set();
    const replacer = (_, val) => {
      if (typeof val === 'object' && val !== null) {
        if (seenSet.has(val)) {
          return '<**seen**>';
        }
        seenSet.add(val);
      }
      return val;
    };
    return JSON.stringify(payload, replacer);
  };
  freeze(cycleTolerantStringify);

  // Copyright (C) 2019 Agoric, under Apache License 2.0

  // For our internal debugging purposes, uncomment
  // const internalDebugConsole = console;

  // /////////////////////////////////////////////////////////////////////////////

  /** @type {WeakMap<StringablePayload, any>} */
  const declassifiers = new WeakMap();

  /** @type {AssertQuote} */
  const quote = payload => {
    const result = freeze({
      toString: freeze(() => cycleTolerantStringify(payload)),
    });
    declassifiers.set(result, payload);
    return result;
  };
  freeze(quote);

  // /////////////////////////////////////////////////////////////////////////////

  /**
   * @typedef {Object} HiddenDetails
   *
   * Captures the arguments passed to the `details` template string tag.
   *
   * @property {TemplateStringsArray | string[]} template
   * @property {any[]} args
   */

  /**
   * @type {WeakMap<DetailsToken, HiddenDetails>}
   *
   * Maps from a details token which a `details` template literal returned
   * to a record of the contents of that template literal expression.
   */
  const hiddenDetailsMap = new WeakMap();

  // TODO Move this type declaration to types.js as a separate @callback type,
  // without breaking the meaning of the type. As currently written, if it is
  // moved into a separate @callback type, it no longer understands that `args`
  // is a rest parameter. I have not yet figured out how to declare that it is,
  // except by having it here directly annotating the `details` function.
  /**
   * Use the `details` function as a template literal tag to create
   * informative error messages. The assertion functions take such messages
   * as optional arguments:
   * ```js
   * assert(sky.isBlue(), details`${sky.color} should be "blue"`);
   * ```
   * The details template tag returns an object that can print itself with the
   * formatted message in two ways. It will report the real details to
   * the console but include only the typeof information in the thrown error
   * to prevent revealing secrets up the exceptional path. In the example
   * above, the thrown error may reveal only that `sky.color` is a string,
   * whereas the same diagnostic printed to the console reveals that the
   * sky was green.
   *
   * @param {TemplateStringsArray | string[]} template The template to format.
   * The `raw` member of a `TemplateStringsArray` is ignored, so a simple
   * `string[]` can also be used as a template.
   * @param {any[]} args Arguments to the template
   * @returns {DetailsToken} The token associated with for these details
   */
  const details = (template, ...args) => {
    // Keep in mind that the vast majority of calls to `details` creates
    // a details token that is never used, so this path must remain as fast as
    // possible. Hence we store what we've got with little processing, postponing
    // all the work to happen only if needed, for example, if an assertion fails.
    const detailsToken = freeze({ __proto__: null });
    hiddenDetailsMap.set(detailsToken, { template, args });
    return detailsToken;
  };
  freeze(details);

  /**
   * @param {HiddenDetails} hiddenDetails
   * @returns {string}
   */
  const getMessageString = ({ template, args }) => {
    const parts = [template[0]];
    for (let i = 0; i < args.length; i += 1) {
      const arg = args[i];
      let argStr;
      if (declassifiers.has(arg)) {
        argStr = `${arg}`;
      } else if (arg instanceof Error) {
        argStr = `(${an(arg.name)})`;
      } else {
        argStr = `(${an(typeof arg)})`;
      }
      parts.push(argStr, template[i + 1]);
    }
    return parts.join('');
  };

  /**
   * @param {HiddenDetails} hiddenDetails
   * @returns {LogArgs}
   */
  const getLogArgs = ({ template, args }) => {
    const logArgs = [template[0]];
    for (let i = 0; i < args.length; i += 1) {
      let arg = args[i];
      if (declassifiers.has(arg)) {
        arg = declassifiers.get(arg);
      }
      // Remove the extra spaces (since console.error puts them
      // between each cause).
      const priorWithoutSpace = (logArgs.pop() || '').replace(/ $/, '');
      if (priorWithoutSpace !== '') {
        logArgs.push(priorWithoutSpace);
      }
      const nextWithoutSpace = template[i + 1].replace(/^ /, '');
      logArgs.push(arg, nextWithoutSpace);
    }
    if (logArgs[logArgs.length - 1] === '') {
      logArgs.pop();
    }
    return logArgs;
  };

  /**
   * @type {WeakMap<Error, LogArgs>}
   *
   * Maps from an error object to the log args that are a more informative
   * alternative message for that error. When logging the error, these
   * log args should be preferred to `error.message`.
   */
  const hiddenMessageLogArgs = new WeakMap();

  /**
   * @type {AssertMakeError}
   */
  const makeError = (
    optDetails = details`Assert failed`,
    ErrorConstructor = Error,
  ) => {
    if (typeof optDetails === 'string') {
      // If it is a string, use it as the literal part of the template so
      // it doesn't get quoted.
      optDetails = details([optDetails]);
    }
    const hiddenDetails = hiddenDetailsMap.get(optDetails);
    if (hiddenDetails === undefined) {
      throw new Error(`unrecognized details ${optDetails}`);
    }
    const messageString = getMessageString(hiddenDetails);
    const error = new ErrorConstructor(messageString);
    hiddenMessageLogArgs.set(error, getLogArgs(hiddenDetails));
    // TODO Having a `debugger` statement in production code is
    // controversial
    // eslint-disable-next-line no-debugger
    debugger;
    // If we get rid of the `debugger` statement above, the next line is a
    // particularly fruitful place to put a breakpoint.
    return error;
  };
  freeze(makeError);

  // /////////////////////////////////////////////////////////////////////////////

  /**
   * @type {WeakMap<Error, LogArgs[]>}
   *
   * Maps from an error to an array of log args, where each log args is
   * remembered as an annotation on that error. This can be used, for example,
   * to keep track of additional causes of the error. The elements of any
   * log args may include errors which are associated with further annotations.
   * An augmented console, like the causal console of `console.js`, could
   * then retrieve the graph of such annotations.
   */
  const hiddenNoteLogArgsArrays = new WeakMap();

  /**
   * @type {WeakMap<Error, NoteCallback[]>}
   *
   * An augmented console will normally only take the hidden noteArgs array once,
   * when it logs the error being annotated. Once that happens, further
   * annotations of that error should go to the console immediately. We arrange
   * that by accepting a note-callback function from the console as an optional
   * part of that taking operation. Normally there will only be at most one
   * callback per error, but that depends on console behavior which we should not
   * assume. We make this an array of callbacks so multiple registrations
   * are independent.
   */
  const hiddenNoteCallbackArrays = new WeakMap();

  /** @type {AssertNote} */
  const note = (error, detailsNote) => {
    if (typeof detailsNote === 'string') {
      // If it is a string, use it as the literal part of the template so
      // it doesn't get quoted.
      detailsNote = details([detailsNote]);
    }
    const hiddenDetails = hiddenDetailsMap.get(detailsNote);
    if (hiddenDetails === undefined) {
      throw new Error(`unrecognized details ${detailsNote}`);
    }
    const logArgs = getLogArgs(hiddenDetails);
    const callbacks = hiddenNoteCallbackArrays.get(error);
    if (callbacks !== undefined) {
      for (const callback of callbacks) {
        callback(error, logArgs);
      }
    } else {
      const logArgsArray = hiddenNoteLogArgsArrays.get(error);
      if (logArgsArray !== undefined) {
        logArgsArray.push(logArgs);
      } else {
        hiddenNoteLogArgsArrays.set(error, [logArgs]);
      }
    }
  };
  freeze(note);

  /**
   * The unprivileged form that just uses the de facto `error.stack` property.
   * The start compartment normally has a privileged `globalThis.getStackString`
   * which should be preferred if present.
   *
   * @param {Error} error
   * @returns {string}
   */
  const defaultGetStackString = error => {
    if (!('stack' in error)) {
      return '';
    }
    const stackString = `${error.stack}`;
    const pos = stackString.indexOf('\n');
    if (stackString.startsWith(' ') || pos === -1) {
      return stackString;
    }
    return stackString.slice(pos + 1); // exclude the initial newline
  };

  /** @type {LoggedErrorHandler} */
  const loggedErrorHandler = {
    getStackString: globalThis.getStackString || defaultGetStackString,
    takeMessageLogArgs: error => {
      const result = hiddenMessageLogArgs.get(error);
      hiddenMessageLogArgs.delete(error);
      return result;
    },
    takeNoteLogArgsArray: (error, callback) => {
      const result = hiddenNoteLogArgsArrays.get(error);
      hiddenNoteLogArgsArrays.delete(error);
      if (callback !== undefined) {
        const callbacks = hiddenNoteCallbackArrays.get(error);
        if (callbacks) {
          callbacks.push(callback);
        } else {
          hiddenNoteCallbackArrays.set(error, [callback]);
        }
      }
      return result || [];
    },
  };
  freeze(loggedErrorHandler);

  // /////////////////////////////////////////////////////////////////////////////

  /**
   * Makes and returns an `assert` function object that shares the bookkeeping
   * state defined by this module with other `assert` function objects make by
   * `makeAssert`. This state is per-module-instance and is exposed by the
   * `loggedErrorHandler` above. We refer to `assert` as a "function object"
   * because it can be called directly as a function, but also has methods that
   * can be called.
   *
   * If `optRaise` is provided, the returned `assert` function object will call
   * `optRaise(error)` before throwing the error. This enables `optRaise` to
   * engage in even more violent termination behavior, like terminating the vat,
   * that prevents execution from reaching the following throw. However, if
   * `optRaise` returns normally, which would be unusual, the throw following
   * `optRaise(error)` would still happen.
   *
   * @param {((error: Error) => void)=} optRaise
   * @returns {Assert}
   */
  const makeAssert = (optRaise = undefined) => {
    /** @type {AssertFail} */
    const fail = (
      optDetails = details`Assert failed`,
      ErrorConstructor = Error,
    ) => {
      const error = makeError(optDetails, ErrorConstructor);
      if (optRaise !== undefined) {
        optRaise(error);
      }
      throw error;
    };
    freeze(fail);

    // Don't freeze or export `baseAssert` until we add methods.
    // TODO If I change this from a `function` function to an arrow
    // function, I seem to get type errors from TypeScript. Why?
    /** @type {BaseAssert} */
    function baseAssert(
      flag,
      optDetails = details`Check failed`,
      ErrorConstructor = Error,
    ) {
      if (!flag) {
        throw fail(optDetails, ErrorConstructor);
      }
    }

    /** @type {AssertEqual} */
    const equal = (
      actual,
      expected,
      optDetails = details`Expected ${actual} is same as ${expected}`,
      ErrorConstructor = RangeError,
    ) => {
      baseAssert(is(actual, expected), optDetails, ErrorConstructor);
    };
    freeze(equal);

    /** @type {AssertTypeof} */
    const assertTypeof = (specimen, typename, optDetails) => {
      baseAssert(
        typeof typename === 'string',
        details`${quote(typename)} must be a string`,
      );
      if (optDetails === undefined) {
        // Like
        // ```js
        // optDetails = details`${specimen} must be ${quote(an(typename))}`;
        // ```
        // except it puts the typename into the literal part of the template
        // so it doesn't get quoted.
        optDetails = details(['', ` must be ${an(typename)}`], specimen);
      }
      equal(typeof specimen, typename, optDetails, TypeError);
    };
    freeze(assertTypeof);

    /** @type {AssertString} */
    const assertString = (specimen, optDetails) =>
      assertTypeof(specimen, 'string', optDetails);

    // Note that "assert === baseAssert"
    /** @type {Assert} */
    const assert = assign(baseAssert, {
      error: makeError,
      fail,
      equal,
      typeof: assertTypeof,
      string: assertString,
      note,
      details,
      quote,
    });
    return freeze(assert);
  };
  freeze(makeAssert);

  /** @type {Assert} */
  const assert = makeAssert();

  const { details: d, quote: q } = assert;

  const localePattern = /^(\w*[a-z])Locale([A-Z]\w*)$/;

  // Use concise methods to obtain named functions without constructor
  // behavior or `.prototype` property.
  const tamedMethods = {
    // See https://tc39.es/ecma262/#sec-string.prototype.localecompare
    localeCompare(that) {
      if (this === null || this === undefined) {
        throw new TypeError(
          'Cannot localeCompare with null or undefined "this" value',
        );
      }
      const s = `${this}`;
      that = `${that}`;
      if (s < that) {
        return -1;
      }
      if (s > that) {
        return 1;
      }
      assert(s === that, d`expected ${q(s)} and ${q(that)} to compare`);
      return 0;
    },
  };

  const nonLocaleCompare = tamedMethods.localeCompare;

  function tameLocaleMethods(intrinsics, localeTaming = 'safe') {
    if (localeTaming !== 'safe' && localeTaming !== 'unsafe') {
      throw new Error(`unrecognized dateTaming ${localeTaming}`);
    }
    if (localeTaming === 'unsafe') {
      return;
    }

    defineProperty(String.prototype, 'localeCompare', {
      value: nonLocaleCompare,
    });

    for (const intrinsicName of getOwnPropertyNames(intrinsics)) {
      const intrinsic = intrinsics[intrinsicName];
      if (intrinsic === Object(intrinsic)) {
        for (const methodName of getOwnPropertyNames(intrinsic)) {
          const match = localePattern.exec(methodName);
          if (match) {
            assert(
              typeof intrinsic[methodName] === 'function',
              d`expected ${q(methodName)} to be a function`,
            );
            const nonLocaleMethodName = `${match[1]}${match[2]}`;
            const method = intrinsic[nonLocaleMethodName];
            assert(
              typeof method === 'function',
              d`function ${q(nonLocaleMethodName)} not found`,
            );
            defineProperty(intrinsic, methodName, { value: method });
          }
        }
      }
    }
  }

  /**
   * keywords
   * In JavaScript you cannot use these reserved words as variables.
   * See 11.6.1 Identifier Names
   */
  const keywords = [
    // 11.6.2.1 Keywords
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'export',
    'extends',
    'finally',
    'for',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'new',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'yield',

    // Also reserved when parsing strict mode code
    'let',
    'static',

    // 11.6.2.2 Future Reserved Words
    'enum',

    // Also reserved when parsing strict mode code
    'implements',
    'package',
    'protected',
    'interface',
    'private',
    'public',

    // Reserved but not mentioned in specs
    'await',

    'null',
    'true',
    'false',

    'this',
    'arguments',
  ];

  /**
   * identifierPattern
   * Simplified validation of indentifier names: may only contain alphanumeric
   * characters (or "$" or "_"), and may not start with a digit. This is safe
   * and does not reduces the compatibility of the shim. The motivation for
   * this limitation was to decrease the complexity of the implementation,
   * and to maintain a resonable level of performance.
   * Note: \w is equivalent [a-zA-Z_0-9]
   * See 11.6.1 Identifier Names
   */
  const identifierPattern = new RegExp('^[a-zA-Z_$][\\w$]*$');

  /**
   * isValidIdentifierName()
   * What variable names might it bring into scope? These include all
   * property names which can be variable names, including the names
   * of inherited properties. It excludes symbols and names which are
   * keywords. We drop symbols safely. Currently, this shim refuses
   * service if any of the names are keywords or keyword-like. This is
   * safe and only prevent performance optimization.
   *
   * @param {string} name
   */
  function isValidIdentifierName(name) {
    // Ensure we have a valid identifier. We use regexpTest rather than
    // /../.test() to guard against the case where RegExp has been poisoned.
    return (
      name !== 'eval' &&
      !arrayIncludes(keywords, name) &&
      regexpTest(identifierPattern, name)
    );
  }

  /*
   * isImmutableDataProperty
   */

  function isImmutableDataProperty(obj, name) {
    const desc = getOwnPropertyDescriptor(obj, name);
    return (
      //
      // The getters will not have .writable, don't let the falsyness of
      // 'undefined' trick us: test with === false, not ! . However descriptors
      // inherit from the (potentially poisoned) global object, so we might see
      // extra properties which weren't really there. Accessor properties have
      // 'get/set/enumerable/configurable', while data properties have
      // 'value/writable/enumerable/configurable'.
      desc.configurable === false &&
      desc.writable === false &&
      //
      // Checks for data properties because they're the only ones we can
      // optimize (accessors are most likely non-constant). Descriptors can't
      // can't have accessors and value properties at the same time, therefore
      // this check is sufficient. Using explicit own property deal with the
      // case where Object.prototype has been poisoned.
      objectHasOwnProperty(desc, 'value')
    );
  }

  /**
   * getScopeConstants()
   * What variable names might it bring into scope? These include all
   * property names which can be variable names, including the names
   * of inherited properties. It excludes symbols and names which are
   * keywords. We drop symbols safely. Currently, this shim refuses
   * service if any of the names are keywords or keyword-like. This is
   * safe and only prevent performance optimization.
   *
   * @param {Object} globalObject
   * @param {Object} localObject
   */
  function getScopeConstants(globalObject, localObject = {}) {
    // getOwnPropertyNames() does ignore Symbols so we don't need to
    // filter them out.
    const globalNames = getOwnPropertyNames(globalObject);
    const localNames = getOwnPropertyNames(localObject);

    // Collect all valid & immutable identifiers from the endowments.
    const localConstants = localNames.filter(
      name =>
        isValidIdentifierName(name) && isImmutableDataProperty(localObject, name),
    );

    // Collect all valid & immutable identifiers from the global that
    // are also not present in the endwoments (immutable or not).
    const globalConstants = globalNames.filter(
      name =>
        // Can't define a constant: it would prevent a
        // lookup on the endowments.
        !localNames.includes(name) &&
        isValidIdentifierName(name) &&
        isImmutableDataProperty(globalObject, name),
    );

    return [...globalConstants, ...localConstants];
  }

  const { details: d$1, quote: q$1 } = assert;

  // The original unsafe untamed eval function, which must not escape.
  // Sample at module initialization time, which is before lockdown can
  // repair it.  Use it only to build powerless abstractions.
  // eslint-disable-next-line no-eval
  const FERAL_EVAL = eval;

  /**
   * alwaysThrowHandler
   * This is an object that throws if any propery is called. It's used as
   * a proxy handler which throws on any trap called.
   * It's made from a proxy with a get trap that throws. It's safe to
   * create one and share it between all scopeHandlers.
   */
  const alwaysThrowHandler = new Proxy(immutableObject, {
    get(_shadow, prop) {
      assert.fail(
        d$1`Please report unexpected scope handler trap: ${q$1(String(prop))}`,
      );
    },
  });

  /*
   * createScopeHandler()
   * ScopeHandler manages a Proxy which serves as the global scope for the
   * performEval operation (the Proxy is the argument of a 'with' binding).
   * As described in createSafeEvaluator(), it has several functions:
   * - allow the very first (and only the very first) use of 'eval' to map to
   * the real (unsafe) eval function, so it acts as a 'direct eval' and can
   * access its lexical scope (which maps to the 'with' binding, which the
   * ScopeHandler also controls).
   * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,
   * which lives as the 'eval' property of the safeGlobal.
   * - route all other property lookups at the safeGlobal.
   * - hide the unsafeGlobal which lives on the scope chain above the 'with'.
   * - ensure the Proxy invariants despite some global properties being frozen.
   */
  function createScopeHandler(
    globalObject,
    localObject = {},
    { sloppyGlobalsMode = false } = {},
  ) {
    return {
      // The scope handler throws if any trap other than get/set/has are run
      // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).
      __proto__: alwaysThrowHandler,

      // This flag allow us to determine if the eval() call is an done by the
      // realm's code or if it is user-land invocation, so we can react differently.
      useUnsafeEvaluator: false,

      get(_shadow, prop) {
        if (typeof prop === 'symbol') {
          return undefined;
        }

        // Special treatment for eval. The very first lookup of 'eval' gets the
        // unsafe (real direct) eval, so it will get the lexical scope that uses
        // the 'with' context.
        if (prop === 'eval') {
          // test that it is true rather than merely truthy
          if (this.useUnsafeEvaluator === true) {
            // revoke before use
            this.useUnsafeEvaluator = false;
            return FERAL_EVAL;
          }
          // fall through
        }

        // Properties of the localObject.
        if (prop in localObject) {
          // Use reflect to defeat accessors that could be present on the
          // localObject object itself as `this`.
          // This is done out of an overabundance of caution, as the SES shim
          // only use the localObject carry globalLexicals and live binding
          // traps.
          // The globalLexicals are captured as a snapshot of what's passed to
          // the Compartment constructor, wherein all accessors and setters are
          // eliminated and the result frozen.
          // The live binding traps do use accessors, and none of those accessors
          // make use of their receiver.
          // Live binding traps provide no avenue for user code to observe the
          // receiver.
          return reflectGet(localObject, prop, globalObject);
        }

        // Properties of the global.
        return reflectGet(globalObject, prop);
      },

      set(_shadow, prop, value) {
        // Properties of the localObject.
        if (prop in localObject) {
          const desc = getOwnPropertyDescriptor(localObject, prop);
          if ('value' in desc) {
            // Work around a peculiar behavior in the specs, where
            // value properties are defined on the receiver.
            return reflectSet(localObject, prop, value);
          }
          // Ensure that the 'this' value on setters resolves
          // to the safeGlobal, not to the localObject object.
          return reflectSet(localObject, prop, value, globalObject);
        }

        // Properties of the global.
        return reflectSet(globalObject, prop, value);
      },

      // we need has() to return false for some names to prevent the lookup from
      // climbing the scope chain and eventually reaching the unsafeGlobal
      // object (globalThis), which is bad.

      // todo: we'd like to just have has() return true for everything, and then
      // use get() to raise a ReferenceError for anything not on the safe global.
      // But we want to be compatible with ReferenceError in the normal case and
      // the lack of ReferenceError in the 'typeof' case. Must either reliably
      // distinguish these two cases (the trap behavior might be different), or
      // we rely on a mandatory source-to-source transform to change 'typeof abc'
      // to XXX. We already need a mandatory parse to prevent the 'import',
      // since it's a special form instead of merely being a global variable/

      // note: if we make has() return true always, then we must implement a
      // set() trap to avoid subverting the protection of strict mode (it would
      // accept assignments to undefined globals, when it ought to throw
      // ReferenceError for such assignments)

      has(_shadow, prop) {
        // unsafeGlobal: hide all properties of the current global
        // at the expense of 'typeof' being wrong for those properties. For
        // example, in the browser, evaluating 'document = 3', will add
        // a property to globalObject instead of throwing a ReferenceError.
        if (
          sloppyGlobalsMode ||
          prop === 'eval' ||
          prop in localObject ||
          prop in globalObject ||
          prop in globalThis
        ) {
          return true;
        }

        return false;
      },

      // note: this is likely a bug of safari
      // https://bugs.webkit.org/show_bug.cgi?id=195534

      getPrototypeOf() {
        return null;
      },

      // Chip has seen this happen single stepping under the Chrome/v8 debugger.
      // TODO record how to reliably reproduce, and to test if this fix helps.
      // TODO report as bug to v8 or Chrome, and record issue link here.

      getOwnPropertyDescriptor(_target, prop) {
        // Coerce with `String` in case prop is a symbol.
        const quotedProp = JSON.stringify(String(prop));
        console.warn(
          `getOwnPropertyDescriptor trap on scopeHandler for ${quotedProp}`,
          new Error().stack,
        );
        return undefined;
      },
    };
  }

  // Captures a key and value of the form #key=value or @key=value
  const sourceMetaEntryRegExp =
    '\\s*[@#]\\s*([a-zA-Z][a-zA-Z0-9]*)\\s*=\\s*([^\\s\\*]*)';
  // Captures either a one-line or multi-line comment containing
  // one #key=value or @key=value.
  // Produces two pairs of capture groups, but the initial two may be undefined.
  // On account of the mechanics of regular expressions, scanning from the end
  // does not allow us to capture every pair, so getSourceURL must capture and
  // trim until there are no matching comments.
  const sourceMetaEntriesRegExp = new RegExp(
    `(?:\\s*//${sourceMetaEntryRegExp}|/\\*${sourceMetaEntryRegExp}\\s*\\*/)\\s*$`,
  );

  function getSourceURL(src) {
    let sourceURL = '<unknown>';

    // Our regular expression matches the last one or two comments with key value
    // pairs at the end of the source, avoiding a scan over the entire length of
    // the string, but at the expense of being able to capture all the (key,
    // value) pair meta comments at the end of the source, which may include
    // sourceMapURL in addition to sourceURL.
    // So, we sublimate the comments out of the source until no source or no
    // comments remain.
    while (src.length > 0) {
      const match = sourceMetaEntriesRegExp.exec(src);
      if (match === null) {
        break;
      }
      src = src.slice(0, src.length - match[0].length);

      // We skip $0 since it contains the entire match.
      // The match contains four capture groups,
      // two (key, value) pairs, the first of which
      // may be undefined.
      // On the off-chance someone put two sourceURL comments in their code with
      // different commenting conventions, the latter has precedence.
      if (match[3] === 'sourceURL') {
        sourceURL = match[4];
      } else if (match[1] === 'sourceURL') {
        sourceURL = match[2];
      }
    }

    return sourceURL;
  }

  // @ts-check

  /**
   * Find the first occurence of the given pattern and return
   * the location as the approximate line number.
   *
   * @param {string} src
   * @param {RegExp} pattern
   * @returns {number}
   */
  function getLineNumber(src, pattern) {
    const index = stringSearch(src, pattern);
    if (index < 0) {
      return -1;
    }
    return stringSplit(stringSlice(src, 0, index), '\n').length;
  }

  // /////////////////////////////////////////////////////////////////////////////

  const htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`, 'g');

  /**
   * Conservatively reject the source text if it may contain text that some
   * JavaScript parsers may treat as an html-like comment. To reject without
   * parsing, `rejectHtmlComments` will also reject some other text as well.
   *
   * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments
   * explains that JavaScript parsers may or may not recognize html
   * comment tokens "<" immediately followed by "!--" and "--"
   * immediately followed by ">" in non-module source text, and treat
   * them as a kind of line comment. Since otherwise both of these can
   * appear in normal JavaScript source code as a sequence of operators,
   * we have the terrifying possibility of the same source code parsing
   * one way on one correct JavaScript implementation, and another way
   * on another.
   *
   * This shim takes the conservative strategy of just rejecting source
   * text that contains these strings anywhere. Note that this very
   * source file is written strangely to avoid mentioning these
   * character strings explicitly.
   *
   * We do not write the regexp in a straightforward way, so that an
   * apparennt html comment does not appear in this file. Thus, we avoid
   * rejection by the overly eager rejectDangerousSources.
   *
   * @param {string} src
   * @returns {string}
   */
  function rejectHtmlComments(src) {
    const lineNumber = getLineNumber(src, htmlCommentPattern);
    if (lineNumber < 0) {
      return src;
    }
    const name = getSourceURL(src);
    throw new SyntaxError(
      `Possible HTML comment rejected at ${name}:${lineNumber}. (SES_HTML_COMMENT_REJECTED)`,
    );
  }

  /**
   * An optional transform to place ahead of `rejectHtmlComments` to evade *that*
   * rejection. However, it may change the meaning of the program.
   *
   * This evasion replaces each alleged html comment with the space-separated
   * JavaScript operator sequence that it may mean, assuming that it appears
   * outside of a comment or literal string, in source code where the JS
   * parser makes no special case for html comments (like module source code).
   * In that case, this evasion preserves the meaning of the program, though it
   * does change the souce column numbers on each effected line.
   *
   * If the html comment appeared in a literal (a string literal, regexp literal,
   * or a template literal), then this evasion will change the meaning of the
   * program by changing the text of that literal.
   *
   * If the html comment appeared in a JavaScript comment, then this evasion does
   * not change the meaning of the program because it only changes the contents of
   * those comments.
   *
   * @param { string } src
   * @returns { string }
   */
  function evadeHtmlCommentTest(src) {
    const replaceFn = match => (match[0] === '<' ? '< ! --' : '-- >');
    return src.replace(htmlCommentPattern, replaceFn);
  }

  // /////////////////////////////////////////////////////////////////////////////

  const importPattern = new RegExp('\\bimport(\\s*(?:\\(|/[/*]))', 'g');

  /**
   * Conservatively reject the source text if it may contain a dynamic
   * import expression. To reject without parsing, `rejectImportExpressions` will
   * also reject some other text as well.
   *
   * The proposed dynamic import expression is the only syntax currently
   * proposed, that can appear in non-module JavaScript code, that
   * enables direct access to the outside world that cannot be
   * surpressed or intercepted without parsing and rewriting. Instead,
   * this shim conservatively rejects any source text that seems to
   * contain such an expression. To do this safely without parsing, we
   * must also reject some valid programs, i.e., those containing
   * apparent import expressions in literal strings or comments.
   *
   * The current conservative rule looks for the identifier "import"
   * followed by either an open paren or something that looks like the
   * beginning of a comment. We assume that we do not need to worry
   * about html comment syntax because that was already rejected by
   * rejectHtmlComments.
   *
   * this \s *must* match all kinds of syntax-defined whitespace. If e.g.
   * U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as
   * whitespace by the parser, but not matched by /\s/, then this would admit
   * an attack like: import\u2028('power.js') . We're trying to distinguish
   * something like that from something like importnotreally('power.js') which
   * is perfectly safe.
   *
   * @param { string } src
   * @returns { string }
   */
  function rejectImportExpressions(src) {
    const lineNumber = getLineNumber(src, importPattern);
    if (lineNumber < 0) {
      return src;
    }
    const name = getSourceURL(src);
    throw new SyntaxError(
      `Possible import expression rejected at ${name}:${lineNumber}. (SES_IMPORT_REJECTED)`,
    );
  }

  /**
   * An optional transform to place ahead of `rejectImportExpressions` to evade
   * *that* rejection. However, it may change the meaning of the program.
   *
   * This evasion replaces each suspicious `import` identifier with `__import__`.
   * If the alleged import expression appears in a JavaScript comment, this
   * evasion will not change the meaning of the program. If it appears in a
   * literal (string literal, regexp literal, or a template literal), then this
   * evasion will change the contents of that literal. If it appears as code
   * where it would be parsed as an expression, then it might or might not change
   * the meaning of the program, depending on the binding, if any, of the lexical
   * variable `__import__`.
   *
   * Finally, if the original appears in code where it is not parsed as an
   * expression, for example `foo.import(path)`, then this evasion would rewrite
   * to `foo.__import__(path)` which has a surprisingly different meaning.
   *
   * @param { string } src
   * @returns { string }
   */
  function evadeImportExpressionTest(src) {
    const replaceFn = (_, p1) => `__import__${p1}`;
    return src.replace(importPattern, replaceFn);
  }

  // /////////////////////////////////////////////////////////////////////////////

  const someDirectEvalPattern = new RegExp('\\beval(\\s*\\()', 'g');

  /**
   * Heuristically reject some text that seems to contain a direct eval
   * expression, with both false positives and false negavives. To reject without
   * parsing, `rejectSomeDirectEvalExpressions` may will also reject some other
   * text as well. It may also accept source text that contains a direct eval
   * written oddly, such as `(eval)(src)`. This false negative is not a security
   * vulnerability. Rather it is a compat hazard because it will execute as
   * an indirect eval under the SES-shim but as a direct eval on platforms that
   * support SES directly (like XS).
   *
   * The shim cannot correctly emulate a direct eval as explained at
   * https://github.com/Agoric/realms-shim/issues/12
   * If we did not reject direct eval syntax, we would
   * accidentally evaluate these with an emulation of indirect eval. To
   * prevent future compatibility problems, in shifting from use of the
   * shim to genuine platform support for the proposal, we should
   * instead statically reject code that seems to contain a direct eval
   * expression.
   *
   * As with the dynamic import expression, to avoid a full parse, we do
   * this approximately with a regexp, that will also reject strings
   * that appear safely in comments or strings. Unlike dynamic import,
   * if we miss some, this only creates future compat problems, not
   * security problems. Thus, we are only trying to catch innocent
   * occurrences, not malicious one. In particular, `(eval)(...)` is
   * direct eval syntax that would not be caught by the following regexp.
   *
   * Exported for unit tests.
   *
   * @param { string } src
   * @returns { string }
   */
  function rejectSomeDirectEvalExpressions(src) {
    const lineNumber = getLineNumber(src, someDirectEvalPattern);
    if (lineNumber < 0) {
      return src;
    }
    const name = getSourceURL(src);
    throw new SyntaxError(
      `Possible direct eval expression rejected at ${name}:${lineNumber}. (SES_EVAL_REJECTED)`,
    );
  }

  // /////////////////////////////////////////////////////////////////////////////

  /**
   * A transform that bundles together the transforms that must unconditionally
   * happen last in order to ensure safe evaluation without parsing.
   *
   * @param {string} source
   * @returns {string}
   */
  function mandatoryTransforms(source) {
    source = rejectHtmlComments(source);
    source = rejectImportExpressions(source);
    return source;
  }

  /**
   * Starting with `source`, apply each transform to the result of the
   * previous one, returning the result of the last transformation.
   *
   * @param {string} source
   * @param {((str: string) => string)[]} transforms
   * @returns {string}
   */
  function applyTransforms(source, transforms) {
    for (const transform of transforms) {
      source = transform(source);
    }
    return source;
  }

  // The original unsafe untamed Function constructor, which must not escape.
  // Sample at module initialization time, which is before lockdown can
  // repair it. Use it only to build powerless abstractions.
  const FERAL_FUNCTION = Function;

  /**
   * buildOptimizer()
   * Given an array of indentifier, the optimizer return a `const` declaration
   * destructring `this`.
   *
   * @param {Array<string>} constants
   */
  function buildOptimizer(constants) {
    // No need to build an oprimizer when there are no constants.
    if (constants.length === 0) return '';
    // Use 'this' to avoid going through the scope proxy, which is unecessary
    // since the optimizer only needs references to the safe global.
    return `const {${arrayJoin(constants, ',')}} = this;`;
  }

  /**
   * makeEvaluateFactory()
   * The factory create 'evaluate' functions with the correct optimizer
   * inserted.
   *
   * @param {Array<string>} [constants]
   */
  function makeEvaluateFactory(constants = []) {
    const optimizer = buildOptimizer(constants);

    // Create a function in sloppy mode, so that we can use 'with'. It returns
    // a function in strict mode that evaluates the provided code using direct
    // eval, and thus in strict mode in the same scope. We must be very careful
    // to not create new names in this scope

    // 1: we use 'with' (around a Proxy) to catch all free variable names. The
    // `this` value holds the Proxy which safely wraps the safeGlobal
    // 2: 'optimizer' catches constant variable names for speed.
    // 3: The inner strict function is effectively passed two parameters:
    //    a) its arguments[0] is the source to be directly evaluated.
    //    b) its 'this' is the this binding seen by the code being
    //       directly evaluated (the globalObject).
    // 4: The outer sloppy function is passed one parameter, the scope proxy.
    //    as the `this` parameter.

    // Notes:
    // - everything in the 'optimizer' string is looked up in the proxy
    //   (including an 'arguments[0]', which points at the Proxy).
    // - keywords like 'function' which are reserved keywords, and cannot be
    //   used as a variables, so they is not part to the optimizer.
    // - when 'eval' is looked up in the proxy, and it's the first time it is
    //   looked up after useUnsafeEvaluator is turned on, the proxy returns the
    //   eval intrinsic, and flips useUnsafeEvaluator back to false. Any reference
    //   to 'eval' in that string will get the tamed evaluator.

    return FERAL_FUNCTION(`
    with (this) {
      ${optimizer}
      return function() {
        'use strict';
        return eval(arguments[0]);
      };
    }
  `);
  }

  // Portions adapted from V8 - Copyright 2016 the V8 project authors.

  const { details: d$2 } = assert;

  /**
   * performEval()
   * The low-level operation used by all evaluators:
   * eval(), Function(), Evalutator.prototype.evaluate().
   *
   * @param {string} source
   * @param {Object} globalObject
   * @param {Objeect} localObject
   * @param {Object} [options]
   * @param {Array<Transform>} [options.localTransforms]
   * @param {Array<Transform>} [options.globalTransforms]
   * @param {bool} [options.sloppyGlobalsMode]
   */
  function performEval(
    source,
    globalObject,
    localObject = {},
    {
      localTransforms = [],
      globalTransforms = [],
      sloppyGlobalsMode = false,
    } = {},
  ) {
    // Execute the mandatory transforms last to ensure that any rewritten code
    // meets those mandatory requirements.
    source = applyTransforms(source, [
      ...localTransforms,
      ...globalTransforms,
      mandatoryTransforms,
    ]);

    const scopeHandler = createScopeHandler(globalObject, localObject, {
      sloppyGlobalsMode,
    });
    const scopeProxyRevocable = proxyRevocable(immutableObject, scopeHandler);
    // Ensure that "this" resolves to the scope proxy.

    const constants = getScopeConstants(globalObject, localObject);
    const evaluateFactory = makeEvaluateFactory(constants);
    const evaluate = apply(evaluateFactory, scopeProxyRevocable.proxy, []);

    scopeHandler.useUnsafeEvaluator = true;
    let err;
    try {
      // Ensure that "this" resolves to the safe global.
      return apply(evaluate, globalObject, [source]);
    } catch (e) {
      // stash the child-code error in hopes of debugging the internal failure
      err = e;
      throw e;
    } finally {
      if (scopeHandler.useUnsafeEvaluator === true) {
        // The proxy switches off useUnsafeEvaluator immediately after
        // the first access, but if that's not the case we should abort.
        // This condition is one where this vat is now hopelessly confused,
        // and the vat as a whole should be aborted. All immediately reachable
        // state should be abandoned. However, that is not yet possible,
        // so we at least prevent further variable resolution via the
        // scopeHandler, and throw an error with diagnostic info including
        // the thrown error if any from evaluating the source code.
        scopeProxyRevocable.revoke();
        // TODO A GOOD PLACE TO PANIC(), i.e., kill the vat incarnation.
        // See https://github.com/Agoric/SES-shim/issues/490
        assert.fail(d$2`handler did not revoke useUnsafeEvaluator ${err}`);
      }
    }
  }

  /*
   * makeEvalFunction()
   * A safe version of the native eval function which relies on
   * the safety of performEval for confinement.
   */
  const makeEvalFunction = (globalObject, options = {}) => {
    // We use the the concise method syntax to create an eval without a
    // [[Construct]] behavior (such that the invocation "new eval()" throws
    // TypeError: eval is not a constructor"), but which still accepts a
    // 'this' binding.
    const newEval = {
      eval(source) {
        if (typeof source !== 'string') {
          // As per the runtime semantic of PerformEval [ECMAScript 18.2.1.1]:
          // If Type(source) is not String, return source.
          // TODO Recent proposals from Mike Samuel may change this non-string
          // rule. Track.
          return source;
        }
        return performEval(source, globalObject, {}, options);
      },
    }.eval;

    return newEval;
  };

  // The original unsafe untamed Function constructor, which must not escape.
  // Sample at module initialization time, which is before lockdown can
  // repair it.  Use it only to build powerless abstractions.
  const FERAL_FUNCTION$1 = Function;

  /*
   * makeFunctionConstructor()
   * A safe version of the native Function which relies on
   * the safety of performEval for confinement.
   */
  function makeFunctionConstructor(globaObject, options = {}) {
    // Define an unused parameter to ensure Function.length === 1
    const newFunction = function Function(_body) {
      // Sanitize all parameters at the entry point.
      // eslint-disable-next-line prefer-rest-params
      const bodyText = `${arrayPop(arguments) || ''}`;
      // eslint-disable-next-line prefer-rest-params
      const parameters = `${arrayJoin(arguments, ',')}`;

      // Are parameters and bodyText valid code, or is someone
      // attempting an injection attack? This will throw a SyntaxError if:
      // - parameters doesn't parse as parameters
      // - bodyText doesn't parse as a function body
      // - either contain a call to super() or references a super property.
      // eslint-disable-next-line no-new
      new FERAL_FUNCTION$1(parameters, bodyText);

      // Safe to be combined. Defeat potential trailing comments.
      // TODO: since we create an anonymous function, the 'this' value
      // isn't bound to the global object as per specs, but set as undefined.
      const src = `(function anonymous(${parameters}\n) {\n${bodyText}\n})`;
      return performEval(src, globaObject, {}, options);
    };

    defineProperties(newFunction, {
      // Ensure that any function created in any evaluator in a realm is an
      // instance of Function in any evaluator of the same realm.
      prototype: {
        value: Function.prototype,
        writable: false,
        enumerable: false,
        configurable: false,
      },
    });

    // Assert identity of Function.__proto__ accross all compartments
    assert(
      getPrototypeOf(Function) === Function.prototype,
      'Function prototype is the same accross compartments',
    );
    assert(
      getPrototypeOf(newFunction) === Function.prototype,
      'Function constructor prototype is the same accross compartments',
    );

    return newFunction;
  }

  /**
   * initGlobalObject()
   * Create new global object using a process similar to ECMA specifications
   * (portions of SetRealmGlobalObject and SetDefaultGlobalBindings).
   * `newGlobalPropertyNames` should be either `initialGlobalPropertyNames` or
   * `sharedGlobalPropertyNames`.
   *
   * @param {Object} globalObject
   * @param {Object} intrinsics
   * @param {Object} newGlobalPropertyNames
   * @param {Function} makeCompartmentConstructor
   * @param {Object} compartmentPrototype
   * @param {Object} [options]
   * @param {Array<Transform>} [options.globalTransforms]
   * @param {(Object) => void} [options.nativeBrander]
   */
  function initGlobalObject(
    globalObject,
    intrinsics,
    newGlobalPropertyNames,
    makeCompartmentConstructor,
    compartmentPrototype,
    { globalTransforms, nativeBrander },
  ) {
    for (const [name, constant] of entries(constantProperties)) {
      defineProperty(globalObject, name, {
        value: constant,
        writable: false,
        enumerable: false,
        configurable: false,
      });
    }

    for (const [name, intrinsicName] of entries(universalPropertyNames)) {
      if (objectHasOwnProperty(intrinsics, intrinsicName)) {
        defineProperty(globalObject, name, {
          value: intrinsics[intrinsicName],
          writable: true,
          enumerable: false,
          configurable: true,
        });
      }
    }

    for (const [name, intrinsicName] of entries(newGlobalPropertyNames)) {
      if (objectHasOwnProperty(intrinsics, intrinsicName)) {
        defineProperty(globalObject, name, {
          value: intrinsics[intrinsicName],
          writable: true,
          enumerable: false,
          configurable: true,
        });
      }
    }

    const perCompartmentGlobals = {
      globalThis: globalObject,
      eval: makeEvalFunction(globalObject, {
        globalTransforms,
      }),
      Function: makeFunctionConstructor(globalObject, {
        globalTransforms,
      }),
    };

    perCompartmentGlobals.Compartment = makeCompartmentConstructor(
      makeCompartmentConstructor,
      intrinsics,
      nativeBrander,
    );

    // TODO These should still be tamed according to the whitelist before
    // being made available.
    for (const [name, value] of entries(perCompartmentGlobals)) {
      defineProperty(globalObject, name, {
        value,
        writable: true,
        enumerable: false,
        configurable: true,
      });
      if (typeof value === 'function') {
        nativeBrander(value);
      }
    }
  }

  // @ts-check

  // For our internal debugging purposes, uncomment
  // const internalDebugConsole = console;

  // The whitelists of console methods, from:
  // Whatwg "living standard" https://console.spec.whatwg.org/
  // Node https://nodejs.org/dist/latest-v14.x/docs/api/console.html
  // MDN https://developer.mozilla.org/en-US/docs/Web/API/Console_API
  // TypeScript https://openstapps.gitlab.io/projectmanagement/interfaces/_node_modules__types_node_globals_d_.console.html
  // Chrome https://developers.google.com/web/tools/chrome-devtools/console/api

  // All console level methods have parameters (fmt?, ...args)
  // where the argument sequence `fmt?, ...args` formats args according to
  // fmt if fmt is a format string. Otherwise, it just renders them all as values
  // separated by spaces.
  // https://console.spec.whatwg.org/#formatter
  // https://nodejs.org/docs/latest/api/util.html#util_util_format_format_args

  // For the causal console, all occurrences of `fmt, ...args` or `...args` by
  // itself must check for the presence of an error to ask the
  // `loggedErrorHandler` to handle.
  // In theory we should do a deep inspection to detect for example an array
  // containing an error. We currently do not detect these and may never.

  /** @type {readonly [keyof VirtualConsole, LogSeverity | undefined][]} */
  const consoleLevelMethods = freeze([
    ['debug', 'debug'], // (fmt?, ...args) verbose level on Chrome
    ['log', 'log'], // (fmt?, ...args) info level on Chrome
    ['info', 'info'], // (fmt?, ...args)
    ['warn', 'warn'], // (fmt?, ...args)
    ['error', 'error'], // (fmt?, ...args)

    ['trace', 'log'], // (fmt?, ...args)
    ['dirxml', 'log'], // (fmt?, ...args)
    ['group', 'log'], // (fmt?, ...args)
    ['groupCollapsed', 'log'], // (fmt?, ...args)
  ]);

  /** @type {readonly [keyof VirtualConsole, LogSeverity | undefined][]} */
  const consoleOtherMethods = freeze([
    ['assert', 'error'], // (value, fmt?, ...args)
    ['timeLog', 'log'], // (label?, ...args) no fmt string

    // Insensitive to whether any argument is an error. All arguments can pass
    // thru to baseConsole as is.
    ['clear', undefined], // ()
    ['count', 'info'], // (label?)
    ['countReset', undefined], // (label?)
    ['dir', 'log'], // (item, options?)
    ['groupEnd', 'log'], // ()
    // In theory tabular data may be or contain an error. However, we currently
    // do not detect these and may never.
    ['table', 'log'], // (tabularData, properties?)
    ['time', 'info'], // (label?)
    ['timeEnd', 'info'], // (label?)

    // Node Inspector only, MDN, and TypeScript, but not whatwg
    ['profile', undefined], // (label?)
    ['profileEnd', undefined], // (label?)
    ['timeStamp', undefined], // (label?)
  ]);

  /** @type {readonly [keyof VirtualConsole, LogSeverity | undefined][]} */
  const consoleWhitelist = freeze([
    ...consoleLevelMethods,
    ...consoleOtherMethods,
  ]);

  /**
   * consoleOmittedProperties is currently unused. I record and maintain it here
   * with the intention that it be treated like the `false` entries in the main
   * SES whitelist: that seeing these on the original console is expected, but
   * seeing anything else that's outside the whitelist is surprising and should
   * provide a diagnostic.
   *
   * const consoleOmittedProperties = freeze([
   *   'memory', // Chrome
   *   'exception', // FF, MDN
   *   '_ignoreErrors', // Node
   *   '_stderr', // Node
   *   '_stderrErrorHandler', // Node
   *   '_stdout', // Node
   *   '_stdoutErrorHandler', // Node
   *   '_times', // Node
   *   'context', // Chrome, Node
   *   'record', // Safari
   *   'recordEnd', // Safari
   *
   *   'screenshot', // Safari
   *   // Symbols
   *   '@@toStringTag', // Chrome: "Object", Safari: "Console"
   *   // A variety of other symbols also seen on Node
   * ]);
   */

  // /////////////////////////////////////////////////////////////////////////////

  /** @type {MakeLoggingConsoleKit} */
  const makeLoggingConsoleKit = () => {
    // Not frozen!
    let logArray = [];

    const loggingConsole = fromEntries(
      consoleWhitelist.map(([name, _]) => {
        // Use an arrow function so that it doesn't come with its own name in
        // its printed form. Instead, we're hoping that tooling uses only
        // the `.name` property set below.
        const method = (...args) => {
          logArray.push([name, ...args]);
        };
        defineProperty(method, 'name', { value: name });
        return [name, freeze(method)];
      }),
    );
    freeze(loggingConsole);

    const takeLog = () => {
      const result = freeze(logArray);
      logArray = [];
      return result;
    };
    freeze(takeLog);

    const typedLoggingConsole = /** @type {VirtualConsole} */ (loggingConsole);

    return freeze({ loggingConsole: typedLoggingConsole, takeLog });
  };
  freeze(makeLoggingConsoleKit);

  // /////////////////////////////////////////////////////////////////////////////

  /** @type {ErrorInfo} */
  const ErrorInfo = {
    NOTE: 'ERROR_NOTE:',
    MESSAGE: 'ERROR_MESSAGE:',
  };
  freeze(ErrorInfo);

  /**
   * The error annotations are sent to the baseConsole by calling some level
   * method. The 'debug' level seems best, because the Chrome console classifies
   * `debug` as verbose and does not show it by default. But we keep it symbolic
   * so we can change our mind. (On Node, `debug`, `log`, and `info` are aliases
   * for the same function and so will behave the same there.)
   */
  const BASE_CONSOLE_LEVEL = 'debug';

  /** @type {MakeCausalConsole} */
  const makeCausalConsole = (baseConsole, loggedErrorHandler) => {
    const {
      getStackString,
      takeMessageLogArgs,
      takeNoteLogArgsArray,
    } = loggedErrorHandler;

    // by "tagged", we mean first sent to the baseConsole as an argument in a
    // console level method call, in which it is shown with an identifying tag
    // number. We number the errors according to the order in
    // which they were first logged to the baseConsole, starting at 1.
    let numErrorsTagged = 0;
    /** @type WeakMap<Error, number> */
    const errorTagOrder = new WeakMap();

    /**
     * @param {Error} err
     * @returns {string}
     */
    const tagError = err => {
      let errNum;
      if (errorTagOrder.has(err)) {
        errNum = errorTagOrder.get(err);
      } else {
        numErrorsTagged += 1;
        errorTagOrder.set(err, numErrorsTagged);
        errNum = numErrorsTagged;
      }
      return `${err.name}#${errNum}`;
    };

    const extractErrorArgs = (logArgs, subErrorsSink) => {
      const argTags = logArgs.map(arg => {
        if (arg instanceof Error) {
          subErrorsSink.push(arg);
          return `(${tagError(arg)})`;
        }
        return arg;
      });
      return argTags;
    };

    /**
     * @param {Error} error
     * @param {ErrorInfoKind} kind
     * @param {readonly any[]} logArgs
     * @param {Array<Error>} subErrorsSink
     */
    const logErrorInfo = (error, kind, logArgs, subErrorsSink) => {
      const errorTag = tagError(error);
      const errorName =
        kind === ErrorInfo.MESSAGE ? `${errorTag}:` : `${errorTag} ${kind}`;
      const argTags = extractErrorArgs(logArgs, subErrorsSink);
      baseConsole[BASE_CONSOLE_LEVEL](errorName, ...argTags);
    };

    /**
     * Logs the `subErrors` within a group named `label`.
     *
     * @param {string} label
     * @param {Error[]} subErrors
     * @returns {void}
     */
    const logSubErrors = (label, subErrors) => {
      if (subErrors.length >= 1) {
        baseConsole.groupCollapsed(label);
        try {
          for (const subError of subErrors) {
            // eslint-disable-next-line no-use-before-define
            logError(subError);
          }
        } finally {
          baseConsole.groupEnd();
        }
      }
    };

    const errorsLogged = new WeakSet();

    /** @type {NoteCallback} */
    const noteCallback = (error, noteLogArgs) => {
      const subErrors = [];
      // Annotation arrived after the error has already been logged,
      // so just log the annotation immediately, rather than remembering it.
      logErrorInfo(error, ErrorInfo.NOTE, noteLogArgs, subErrors);
      logSubErrors(tagError(error), subErrors);
    };

    const logError = error => {
      if (errorsLogged.has(error)) {
        return;
      }
      const errorTag = tagError(error);
      errorsLogged.add(error);
      const subErrors = [];
      const messageLogArgs = takeMessageLogArgs(error);
      const noteLogArgsArray = takeNoteLogArgsArray(error, noteCallback);
      // Show the error's most informative error message
      if (messageLogArgs === undefined) {
        // If there is no message log args, then just show the message that
        // the error itself carries.
        baseConsole[BASE_CONSOLE_LEVEL](`${errorTag}:`, error.message);
      } else {
        // If there is one, we take it to be strictly more informative than the
        // message string carried by the error, so show it *instead*.
        logErrorInfo(error, ErrorInfo.MESSAGE, messageLogArgs, subErrors);
      }
      // After the message but before any other annotations, show the stack.
      let stackString = getStackString(error);
      if (
        typeof stackString === 'string' &&
        stackString.length >= 1 &&
        !stackString.endsWith('\n')
      ) {
        stackString += '\n';
      }
      baseConsole[BASE_CONSOLE_LEVEL]('', stackString);
      // Show the other annotations on error
      for (const noteLogArgs of noteLogArgsArray) {
        logErrorInfo(error, ErrorInfo.NOTE, noteLogArgs, subErrors);
      }
      // explain all the errors seen in the messages already emitted.
      logSubErrors(errorTag, subErrors);
    };

    const levelMethods = consoleLevelMethods.map(([level, _]) => {
      const levelMethod = (...logArgs) => {
        const subErrors = [];
        const argTags = extractErrorArgs(logArgs, subErrors);
        // @ts-ignore
        baseConsole[level](...argTags);
        logSubErrors('', subErrors);
      };
      defineProperty(levelMethod, 'name', { value: level });
      return [level, freeze(levelMethod)];
    });
    const otherMethodNames = consoleOtherMethods.filter(
      ([name, _]) => name in baseConsole,
    );
    const otherMethods = otherMethodNames.map(([name, _]) => {
      const otherMethod = (...args) => {
        // @ts-ignore
        baseConsole[name](...args);
        return undefined;
      };
      defineProperty(otherMethod, 'name', { value: name });
      return [name, freeze(otherMethod)];
    });

    const causalConsole = fromEntries([...levelMethods, ...otherMethods]);
    return freeze(causalConsole);
  };
  freeze(makeCausalConsole);

  // /////////////////////////////////////////////////////////////////////////////

  /** @type {FilterConsole} */
  const filterConsole = (baseConsole, filter, _topic = undefined) => {
    // TODO do something with optional topic string
    const whilelist = consoleWhitelist.filter(([name, _]) => name in baseConsole);
    const methods = whilelist.map(([name, severity]) => {
      const method = (...args) => {
        if (severity === undefined || filter.canLog(severity)) {
          // @ts-ignore
          baseConsole[name](...args);
        }
      };
      return [name, freeze(method)];
    });
    const filteringConsole = fromEntries(methods);
    return freeze(filteringConsole);
  };
  freeze(filterConsole);

  // @ts-check

  const originalConsole = console;

  /**
   * Wrap console unless suppressed.
   * At the moment, the console is considered a host power in the start
   * compartment, and not a primordial. Hence it is absent from the whilelist
   * and bypasses the intrinsicsCollector.
   *
   * @param {"safe" | "unsafe"} consoleTaming
   * @param {GetStackString=} optGetStackString
   */
  const tameConsole = (
    consoleTaming = 'safe',
    optGetStackString = undefined,
  ) => {
    if (consoleTaming !== 'safe' && consoleTaming !== 'unsafe') {
      throw new Error(`unrecognized consoleTaming ${consoleTaming}`);
    }

    if (consoleTaming === 'unsafe') {
      return { console: originalConsole };
    }
    let loggedErrorHandler$1;
    if (optGetStackString === undefined) {
      loggedErrorHandler$1 = loggedErrorHandler;
    } else {
      loggedErrorHandler$1 = {
        ...loggedErrorHandler,
        getStackString: optGetStackString,
      };
    }
    const causalConsole = makeCausalConsole(originalConsole, loggedErrorHandler$1);
    return { console: causalConsole };
  };

  // Whitelist names from https://v8.dev/docs/stack-trace-api
  // Whitelisting only the names used by error-stack-shim/src/v8StackFrames
  // callSiteToFrame to shim the error stack proposal.
  const safeV8CallSiteMethodNames = [
    // suppress 'getThis' definitely
    'getTypeName',
    // suppress 'getFunction' definitely
    'getFunctionName',
    'getMethodName',
    'getFileName',
    'getLineNumber',
    'getColumnNumber',
    'getEvalOrigin',
    'isToplevel',
    'isEval',
    'isNative',
    'isConstructor',
    'isAsync',
    // suppress 'isPromiseAll' for now
    // suppress 'getPromiseIndex' for now

    // Additional names found by experiment, absent from
    // https://v8.dev/docs/stack-trace-api
    'getPosition',
    'getScriptNameOrSourceURL',

    'toString', // TODO replace to use only whitelisted info
  ];

  // TODO this is a ridiculously expensive way to attenuate callsites.
  // Before that matters, we should switch to a reasonable representation.
  const safeV8CallSiteFacet = callSite => {
    const methodEntry = name => [name, () => callSite[name]()];
    const o = fromEntries(safeV8CallSiteMethodNames.map(methodEntry));
    return Object.create(o, {});
  };

  const safeV8SST = sst => sst.map(safeV8CallSiteFacet);

  const callSiteFilter = _callSite => true;
  // const callSiteFilter = callSite =>
  //   !callSite.getFileName().includes('/node_modules/');

  const callSiteStringifier = callSite => `\n  at ${callSite}`;

  const stackStringFromSST = (error, sst) =>
    [...sst.filter(callSiteFilter).map(callSiteStringifier)].join('');

  function tameV8ErrorConstructor(
    OriginalError,
    InitialError,
    errorTaming,
  ) {
    // Mapping from error instance to the structured stack trace capturing the
    // stack for that instance.
    const ssts = new WeakMap();

    // Use concise methods to obtain named functions without constructors.
    const tamedMethods = {
      // The optional `optFn` argument is for cutting off the bottom of
      // the stack --- for capturing the stack only above the topmost
      // call to that function. Since this isn't the "real" captureStackTrace
      // but instead calls the real one, if no other cutoff is provided,
      // we cut this one off.
      captureStackTrace(error, optFn = tamedMethods.captureStackTrace) {
        if (typeof OriginalError.captureStackTrace === 'function') {
          // OriginalError.captureStackTrace is only on v8
          OriginalError.captureStackTrace(error, optFn);
          return;
        }
        Reflect.set(error, 'stack', '');
      },
      // Shim of proposed special power, to reside by default only
      // in the start compartment, for getting the stack traceback
      // string associated with an error.
      // See https://tc39.es/proposal-error-stacks/
      getStackString(error) {
        if (!ssts.has(error)) {
          // eslint-disable-next-line no-void
          void error.stack;
        }
        const sst = ssts.get(error);
        if (!sst) {
          return '';
        }
        return stackStringFromSST(error, sst);
      },
      prepareStackTrace(error, sst) {
        ssts.set(error, sst);
        if (errorTaming === 'unsafe') {
          const stackString = stackStringFromSST(error, sst);
          return `${error}${stackString}`;
        }
        return '';
      },
    };

    // A prepareFn is a prepareStackTrace function.
    // An sst is a `structuredStackTrace`, which is an array of
    // callsites.
    // A user prepareFn is a prepareFn defined by a client of this API,
    // and provided by assigning to `Error.prepareStackTrace`.
    // A user prepareFn should only receive an attenuated sst, which
    // is an array of attenuated callsites.
    // A system prepareFn is the prepareFn created by this module to
    // be installed on the real `Error` constructor, to receive
    // an original sst, i.e., an array of unattenuated callsites.
    // An input prepareFn is a function the user assigns to
    // `Error.prepareStackTrace`, which might be a user prepareFn or
    // a system prepareFn previously obtained by reading
    // `Error.prepareStackTrace`.

    const defaultPrepareFn = tamedMethods.prepareStackTrace;

    OriginalError.prepareStackTrace = defaultPrepareFn;

    // A weakset branding some functions as system prepareFns, all of which
    // must be defined by this module, since they can receive an
    // unattenuated sst.
    const systemPrepareFnSet = new WeakSet([defaultPrepareFn]);

    const systemPrepareFnFor = inputPrepareFn => {
      if (systemPrepareFnSet.has(inputPrepareFn)) {
        return inputPrepareFn;
      }
      // Use concise methods to obtain named functions without constructors.
      const systemMethods = {
        prepareStackTrace(error, sst) {
          ssts.set(error, sst);
          return inputPrepareFn(error, safeV8SST(sst));
        },
      };
      systemPrepareFnSet.add(systemMethods.prepareStackTrace);
      return systemMethods.prepareStackTrace;
    };

    defineProperties(InitialError, {
      captureStackTrace: {
        value: tamedMethods.captureStackTrace,
        writable: true,
        enumerable: false,
        configurable: true,
      },
      stackTraceLimit: {
        get() {
          if (typeof OriginalError.stackTraceLimit === 'number') {
            // OriginalError.stackTraceLimit is only on v8
            return OriginalError.stackTraceLimit;
          }
          return undefined;
        },
        // https://v8.dev/docs/stack-trace-api#compatibility advises that
        // programmers can "always" set `Error.stackTraceLimit` and
        // `Error.prepareStackTrace` even on non-v8 platforms. On non-v8
        // it will have no effect, but this advise only makes sense
        // if the assignment itself does not fail, which it would
        // if `Error` were naively frozen. Hence, we add setters that
        // accept but ignore the assignment on non-v8 platforms.
        set(newLimit) {
          if (typeof OriginalError.stackTraceLimit === 'number') {
            // OriginalError.stackTraceLimit is only on v8
            OriginalError.stackTraceLimit = newLimit;
            // We place the useless return on the next line to ensure
            // that anything we place after the if in the future only
            // happens if the then-case does not.
            // eslint-disable-next-line no-useless-return
            return;
          }
        },
        // WTF on v8 stackTraceLimit is enumerable
        enumerable: false,
        configurable: true,
      },
      prepareStackTrace: {
        get() {
          return OriginalError.prepareStackTrace;
        },
        set(inputPrepareStackTraceFn) {
          if (typeof inputPrepareStackTraceFn === 'function') {
            const systemPrepareFn = systemPrepareFnFor(inputPrepareStackTraceFn);
            OriginalError.prepareStackTrace = systemPrepareFn;
          } else {
            OriginalError.prepareStackTrace = defaultPrepareFn;
          }
        },
        enumerable: false,
        configurable: true,
      },
    });

    return tamedMethods.getStackString;
  }

  // Use concise methods to obtain named functions without constructors.
  const tamedMethods$1 = {
    getStackString(_error) {
      return '';
    },
  };

  function tameErrorConstructor(errorTaming = 'safe') {
    if (errorTaming !== 'safe' && errorTaming !== 'unsafe') {
      throw new Error(`unrecognized errorTaming ${errorTaming}`);
    }
    const OriginalError = Error;
    const ErrorPrototype = OriginalError.prototype;

    const platform =
      typeof OriginalError.captureStackTrace === 'function' ? 'v8' : 'unknown';

    const makeErrorConstructor = (_ = {}) => {
      const ResultError = function Error(...rest) {
        let error;
        if (new.target === undefined) {
          error = apply(OriginalError, this, rest);
        } else {
          error = construct(OriginalError, rest, new.target);
        }
        if (platform === 'v8') {
          OriginalError.captureStackTrace(error, ResultError);
        }
        return error;
      };
      defineProperties(ResultError, {
        length: { value: 1 },
        prototype: {
          value: ErrorPrototype,
          writable: false,
          enumerable: false,
          configurable: false,
        },
      });
      return ResultError;
    };
    const InitialError = makeErrorConstructor({ powers: 'original' });
    const SharedError = makeErrorConstructor({ powers: 'none' });
    defineProperties(ErrorPrototype, {
      constructor: { value: SharedError },
      /* TODO
      stack: {
        get() {
          return '';
        },
        set(_) {
          // ignore
        },
      },
      */
    });

    for (const NativeError of NativeErrors) {
      setPrototypeOf(NativeError, SharedError);
    }

    let initialGetStackString = tamedMethods$1.getStackString;
    if (platform === 'v8') {
      initialGetStackString = tameV8ErrorConstructor(
        OriginalError,
        InitialError,
        errorTaming,
      );
    }
    return {
      '%InitialGetStackString%': initialGetStackString,
      '%InitialError%': InitialError,
      '%SharedError%': SharedError,
    };
  }

  // Copyright (C) 2018 Agoric

  const { details: d$3, quote: q$2 } = assert;

  let firstOptions;

  // A successful lockdown call indicates that `harden` can be called and
  // guarantee that the hardened object graph is frozen out to the fringe.
  let lockedDown = false;

  // Build a harden() with an empty fringe.
  // Gate it on lockdown.
  const lockdownHarden = makeHardener();

  const harden = ref => {
    assert(lockedDown, 'Cannot harden before lockdown');
    return lockdownHarden(ref);
  };

  const alreadyHardenedIntrinsics = () => false;

  function repairIntrinsics(
    makeCompartmentConstructor,
    compartmentPrototype,
    getAnonymousIntrinsics,
    options = {},
  ) {
    // First time, absent options default to 'safe'.
    // Subsequent times, absent options default to first options.
    // Thus, all present options must agree with first options.
    // Reconstructing `option` here also ensures that it is a well
    // behaved record, with only own data properties.
    options = { ...firstOptions, ...options };
    const {
      dateTaming = 'safe',
      errorTaming = 'safe',
      mathTaming = 'safe',
      regExpTaming = 'safe',
      localeTaming = 'safe',
      consoleTaming = 'safe',

      ...extraOptions
    } = options;

    // Assert that only supported options were passed.
    // Use Reflect.ownKeys to reject symbol-named properties as well.
    const extraOptionsNames = Reflect.ownKeys(extraOptions);
    assert(
      extraOptionsNames.length === 0,
      d$3`lockdown(): non supported option ${q$2(extraOptionsNames)}`,
    );

    // Asserts for multiple invocation of lockdown().
    if (firstOptions) {
      for (const name of keys(firstOptions)) {
        assert(
          options[name] === firstOptions[name],
          d$3`lockdown(): cannot re-invoke with different option ${q$2(name)}`,
        );
      }
      return alreadyHardenedIntrinsics;
    }

    firstOptions = {
      dateTaming,
      errorTaming,
      mathTaming,
      regExpTaming,
      localeTaming,
      consoleTaming,
    };

    /**
     * 1. TAME powers & gather intrinsics first.
     */
    const intrinsicsCollector = makeIntrinsicsCollector();

    intrinsicsCollector.addIntrinsics(tameFunctionConstructors());

    intrinsicsCollector.addIntrinsics(tameDateConstructor(dateTaming));
    intrinsicsCollector.addIntrinsics(tameErrorConstructor(errorTaming));
    intrinsicsCollector.addIntrinsics(tameMathObject(mathTaming));
    intrinsicsCollector.addIntrinsics(tameRegExpConstructor(regExpTaming));

    intrinsicsCollector.addIntrinsics(getAnonymousIntrinsics());

    intrinsicsCollector.completePrototypes();

    const intrinsics = intrinsicsCollector.finalIntrinsics();

    // Wrap console unless suppressed.
    // At the moment, the console is considered a host power in the start
    // compartment, and not a primordial. Hence it is absent from the whilelist
    // and bypasses the intrinsicsCollector.
    let optGetStackString;
    if (errorTaming !== 'unsafe') {
      optGetStackString = intrinsics['%InitialGetStackString%'];
    }
    const consoleRecord = tameConsole(consoleTaming, optGetStackString);
    globalThis.console = consoleRecord.console;

    // Replace *Locale* methods with their non-locale equivalents
    tameLocaleMethods(intrinsics, localeTaming);

    // Replace Function.prototype.toString with one that recognizes
    // shimmed functions as honorary native functions.
    const nativeBrander = tameFunctionToString();

    /**
     * 2. WHITELIST to standardize the environment.
     */

    // Remove non-standard properties.
    // All remaining function encountered during whitelisting are
    // branded as honorary native functions.
    whitelistIntrinsics(intrinsics, nativeBrander);

    // Repair problems with legacy accessors if necessary.
    repairLegacyAccessors();

    // Initialize the powerful initial global, i.e., the global of the
    // start compartment, from the intrinsics.
    initGlobalObject(
      globalThis,
      intrinsics,
      initialGlobalPropertyNames,
      makeCompartmentConstructor,
      compartmentPrototype,
      {
        nativeBrander,
      },
    );

    /**
     * 3. HARDEN to share the intrinsics.
     */

    function hardenIntrinsics() {
      // Circumvent the override mistake.
      enablePropertyOverrides(intrinsics);

      // Finally register and optionally freeze all the intrinsics. This
      // must be the operation that modifies the intrinsics.
      lockdownHarden(intrinsics);

      // Having completed lockdown without failing, the user may now
      // call `harden` and expect the object's transitively accessible properties
      // to be frozen out to the fringe.
      // Raise the `harden` gate.
      lockedDown = true;

      // Returning `true` indicates that this is a JS to SES transition.
      return true;
    }

    return hardenIntrinsics;
  }

  const makeLockdown = (
    makeCompartmentConstructor,
    compartmentPrototype,
    getAnonymousIntrinsics,
  ) => {
    const lockdown = (options = {}) => {
      const maybeHardenIntrinsics = repairIntrinsics(
        makeCompartmentConstructor,
        compartmentPrototype,
        getAnonymousIntrinsics,
        options,
      );
      return maybeHardenIntrinsics();
    };
    return lockdown;
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var babel = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
     factory(exports) ;
  }(commonjsGlobal, (function (exports) {
    var context = /*#__PURE__*/Object.freeze({
      __proto__: null,
      get types () { return t; },
      get DEFAULT_EXTENSIONS () { return DEFAULT_EXTENSIONS; },
      get OptionManager () { return OptionManager; },
      get Plugin () { return Plugin$1; },
      get File () { return File$2; },
      get buildExternalHelpers () { return babelBuildExternalHelpers; },
      get resolvePlugin () { return resolvePlugin; },
      get resolvePreset () { return resolvePreset; },
      get version () { return version$1; },
      get getEnv () { return getEnv; },
      get tokTypes () { return types; },
      get traverse () { return traverse$1; },
      get template () { return template; },
      get createConfigItem () { return createConfigItem; },
      get loadPartialConfig () { return loadPartialConfig$1; },
      get loadPartialConfigSync () { return loadPartialConfigSync; },
      get loadPartialConfigAsync () { return loadPartialConfigAsync; },
      get loadOptions () { return loadOptions; },
      get loadOptionsSync () { return loadOptionsSync; },
      get loadOptionsAsync () { return loadOptionsAsync; },
      get transform () { return transform; },
      get transformSync () { return transformSync; },
      get transformAsync () { return transformAsync; },
      get transformFile () { return transformFile$1; },
      get transformFileSync () { return transformFileSync; },
      get transformFileAsync () { return transformFileAsync; },
      get transformFromAst () { return transformFromAst; },
      get transformFromAstSync () { return transformFromAstSync; },
      get transformFromAstAsync () { return transformFromAstAsync; },
      get parse () { return parse$3; },
      get parseSync () { return parseSync; },
      get parseAsync () { return parseAsync; }
    });

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    var REACT_ELEMENT_TYPE;

    function _jsx(type, props, key, children) {
      if (!REACT_ELEMENT_TYPE) {
        REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 0xeac7;
      }

      var defaultProps = type && type.defaultProps;
      var childrenLength = arguments.length - 3;

      if (!props && childrenLength !== 0) {
        props = {
          children: void 0
        };
      }

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = new Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 3];
        }

        props.children = childArray;
      }

      if (props && defaultProps) {
        for (var propName in defaultProps) {
          if (props[propName] === void 0) {
            props[propName] = defaultProps[propName];
          }
        }
      } else if (!props) {
        props = defaultProps || {};
      }

      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key === undefined ? null : '' + key,
        ref: null,
        props: props,
        _owner: null
      };
    }

    function _asyncIterator(iterable) {
      var method;

      if (typeof Symbol !== "undefined") {
        if (Symbol.asyncIterator) {
          method = iterable[Symbol.asyncIterator];
          if (method != null) return method.call(iterable);
        }

        if (Symbol.iterator) {
          method = iterable[Symbol.iterator];
          if (method != null) return method.call(iterable);
        }
      }

      throw new TypeError("Object is not async iterable");
    }

    function _AwaitValue(value) {
      this.wrapped = value;
    }

    function _AsyncGenerator(gen) {
      var front, back;

      function send(key, arg) {
        return new Promise(function (resolve, reject) {
          var request = {
            key: key,
            arg: arg,
            resolve: resolve,
            reject: reject,
            next: null
          };

          if (back) {
            back = back.next = request;
          } else {
            front = back = request;
            resume(key, arg);
          }
        });
      }

      function resume(key, arg) {
        try {
          var result = gen[key](arg);
          var value = result.value;
          var wrappedAwait = value instanceof _AwaitValue;
          Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
            if (wrappedAwait) {
              resume(key === "return" ? "return" : "next", arg);
              return;
            }

            settle(result.done ? "return" : "normal", arg);
          }, function (err) {
            resume("throw", err);
          });
        } catch (err) {
          settle("throw", err);
        }
      }

      function settle(type, value) {
        switch (type) {
          case "return":
            front.resolve({
              value: value,
              done: true
            });
            break;

          case "throw":
            front.reject(value);
            break;

          default:
            front.resolve({
              value: value,
              done: false
            });
            break;
        }

        front = front.next;

        if (front) {
          resume(front.key, front.arg);
        } else {
          back = null;
        }
      }

      this._invoke = send;

      if (typeof gen.return !== "function") {
        this.return = undefined;
      }
    }

    if (typeof Symbol === "function" && Symbol.asyncIterator) {
      _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
        return this;
      };
    }

    _AsyncGenerator.prototype.next = function (arg) {
      return this._invoke("next", arg);
    };

    _AsyncGenerator.prototype.throw = function (arg) {
      return this._invoke("throw", arg);
    };

    _AsyncGenerator.prototype.return = function (arg) {
      return this._invoke("return", arg);
    };

    function _wrapAsyncGenerator(fn) {
      return function () {
        return new _AsyncGenerator(fn.apply(this, arguments));
      };
    }

    function _awaitAsyncGenerator(value) {
      return new _AwaitValue(value);
    }

    function _asyncGeneratorDelegate(inner, awaitWrap) {
      var iter = {},
          waiting = false;

      function pump(key, value) {
        waiting = true;
        value = new Promise(function (resolve) {
          resolve(inner[key](value));
        });
        return {
          done: false,
          value: awaitWrap(value)
        };
      }

      if (typeof Symbol === "function" && Symbol.iterator) {
        iter[Symbol.iterator] = function () {
          return this;
        };
      }

      iter.next = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }

        return pump("next", value);
      };

      if (typeof inner.throw === "function") {
        iter.throw = function (value) {
          if (waiting) {
            waiting = false;
            throw value;
          }

          return pump("throw", value);
        };
      }

      if (typeof inner.return === "function") {
        iter.return = function (value) {
          if (waiting) {
            waiting = false;
            return value;
          }

          return pump("return", value);
        };
      }

      return iter;
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineEnumerableProperties(obj, descs) {
      for (var key in descs) {
        var desc = descs[key];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, key, desc);
      }

      if (Object.getOwnPropertySymbols) {
        var objectSymbols = Object.getOwnPropertySymbols(descs);

        for (var i = 0; i < objectSymbols.length; i++) {
          var sym = objectSymbols[i];
          var desc = descs[sym];
          desc.configurable = desc.enumerable = true;
          if ("value" in desc) desc.writable = true;
          Object.defineProperty(obj, sym, desc);
        }
      }

      return obj;
    }

    function _defaults(obj, defaults) {
      var keys = Object.getOwnPropertyNames(defaults);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = Object.getOwnPropertyDescriptor(defaults, key);

        if (value && value.configurable && obj[key] === undefined) {
          Object.defineProperty(obj, key, value);
        }
      }

      return obj;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }

        ownKeys.forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      }

      return target;
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _newArrowCheck(innerThis, boundThis) {
      if (innerThis !== boundThis) {
        throw new TypeError("Cannot instantiate an arrow function");
      }
    }

    function _objectDestructuringEmpty(obj) {
      if (obj == null) throw new TypeError("Cannot destructure undefined");
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      return function () {
        var Super = _getPrototypeOf(Derived),
            result;

        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
      };
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get(target, property, receiver || target);
    }

    function set(target, property, value, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.set) {
        set = Reflect.set;
      } else {
        set = function set(target, property, value, receiver) {
          var base = _superPropBase(target, property);

          var desc;

          if (base) {
            desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.set) {
              desc.set.call(receiver, value);
              return true;
            } else if (!desc.writable) {
              return false;
            }
          }

          desc = Object.getOwnPropertyDescriptor(receiver, property);

          if (desc) {
            if (!desc.writable) {
              return false;
            }

            desc.value = value;
            Object.defineProperty(receiver, property, desc);
          } else {
            _defineProperty(receiver, property, value);
          }

          return true;
        };
      }

      return set(target, property, value, receiver);
    }

    function _set(target, property, value, receiver, isStrict) {
      var s = set(target, property, value, receiver || target);

      if (!s && isStrict) {
        throw new Error('failed to set property');
      }

      return value;
    }

    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }

      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }

    function _taggedTemplateLiteralLoose(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }

      strings.raw = raw;
      return strings;
    }

    function _readOnlyError(name) {
      throw new Error("\"" + name + "\" is read-only");
    }

    function _classNameTDZError(name) {
      throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
    }

    function _temporalUndefined() {}

    function _tdz(name) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    }

    function _temporalRef(val, name) {
      return val === _temporalUndefined ? _tdz(name) : val;
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _slicedToArrayLoose(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _iterableToArrayLimitLoose(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];

      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        _arr.push(_step.value);

        if (i && _arr.length === i) break;
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;

          var F = function () {};

          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var it,
          normalCompletion = true,
          didErr = false,
          err;
      return {
        s: function () {
          it = o[Symbol.iterator]();
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    function _createForOfIteratorHelperLoose(o) {
      var i = 0;

      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      i = o[Symbol.iterator]();
      return i.next.bind(i);
    }

    function _skipFirstGeneratorNext(fn) {
      return function () {
        var it = fn.apply(this, arguments);
        it.next();
        return it;
      };
    }

    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];

      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }

      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");

      return typeof key === "symbol" ? key : String(key);
    }

    function _initializerWarningHelper(descriptor, context) {
      throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
    }

    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }

    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
      });
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;

      if ('value' in desc || desc.initializer) {
        desc.writable = true;
      }

      desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
      }, desc);

      if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
      }

      if (desc.initializer === void 0) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }

      return desc;
    }

    var id = 0;

    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }

    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }

      return receiver;
    }

    function _classPrivateFieldGet(receiver, privateMap) {
      var descriptor = privateMap.get(receiver);

      if (!descriptor) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      if (descriptor.get) {
        return descriptor.get.call(receiver);
      }

      return descriptor.value;
    }

    function _classPrivateFieldSet(receiver, privateMap, value) {
      var descriptor = privateMap.get(receiver);

      if (!descriptor) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      if (descriptor.set) {
        descriptor.set.call(receiver, value);
      } else {
        if (!descriptor.writable) {
          throw new TypeError("attempted to set read only private field");
        }

        descriptor.value = value;
      }

      return value;
    }

    function _classPrivateFieldDestructureSet(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      var descriptor = privateMap.get(receiver);

      if (descriptor.set) {
        if (!("__destrObj" in descriptor)) {
          descriptor.__destrObj = {
            set value(v) {
              descriptor.set.call(receiver, v);
            }

          };
        }

        return descriptor.__destrObj;
      } else {
        if (!descriptor.writable) {
          throw new TypeError("attempted to set read only private field");
        }

        return descriptor;
      }
    }

    function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
      if (receiver !== classConstructor) {
        throw new TypeError("Private static access of wrong provenance");
      }

      if (descriptor.get) {
        return descriptor.get.call(receiver);
      }

      return descriptor.value;
    }

    function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
      if (receiver !== classConstructor) {
        throw new TypeError("Private static access of wrong provenance");
      }

      if (descriptor.set) {
        descriptor.set.call(receiver, value);
      } else {
        if (!descriptor.writable) {
          throw new TypeError("attempted to set read only private field");
        }

        descriptor.value = value;
      }

      return value;
    }

    function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
      if (receiver !== classConstructor) {
        throw new TypeError("Private static access of wrong provenance");
      }

      return method;
    }

    function _classStaticPrivateMethodSet() {
      throw new TypeError("attempted to set read only static private field");
    }

    function _decorate(decorators, factory, superClass, mixins) {
      var api = _getDecoratorsApi();

      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          api = mixins[i](api);
        }
      }

      var r = factory(function initialize(O) {
        api.initializeInstanceElements(O, decorated.elements);
      }, superClass);
      var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);
      api.initializeClassElements(r.F, decorated.elements);
      return api.runClassFinishers(r.F, decorated.finishers);
    }

    function _getDecoratorsApi() {
      _getDecoratorsApi = function () {
        return api;
      };

      var api = {
        elementsDefinitionOrder: [["method"], ["field"]],
        initializeInstanceElements: function (O, elements) {
          ["method", "field"].forEach(function (kind) {
            elements.forEach(function (element) {
              if (element.kind === kind && element.placement === "own") {
                this.defineClassElement(O, element);
              }
            }, this);
          }, this);
        },
        initializeClassElements: function (F, elements) {
          var proto = F.prototype;
          ["method", "field"].forEach(function (kind) {
            elements.forEach(function (element) {
              var placement = element.placement;

              if (element.kind === kind && (placement === "static" || placement === "prototype")) {
                var receiver = placement === "static" ? F : proto;
                this.defineClassElement(receiver, element);
              }
            }, this);
          }, this);
        },
        defineClassElement: function (receiver, element) {
          var descriptor = element.descriptor;

          if (element.kind === "field") {
            var initializer = element.initializer;
            descriptor = {
              enumerable: descriptor.enumerable,
              writable: descriptor.writable,
              configurable: descriptor.configurable,
              value: initializer === void 0 ? void 0 : initializer.call(receiver)
            };
          }

          Object.defineProperty(receiver, element.key, descriptor);
        },
        decorateClass: function (elements, decorators) {
          var newElements = [];
          var finishers = [];
          var placements = {
            static: [],
            prototype: [],
            own: []
          };
          elements.forEach(function (element) {
            this.addElementPlacement(element, placements);
          }, this);
          elements.forEach(function (element) {
            if (!_hasDecorators(element)) return newElements.push(element);
            var elementFinishersExtras = this.decorateElement(element, placements);
            newElements.push(elementFinishersExtras.element);
            newElements.push.apply(newElements, elementFinishersExtras.extras);
            finishers.push.apply(finishers, elementFinishersExtras.finishers);
          }, this);

          if (!decorators) {
            return {
              elements: newElements,
              finishers: finishers
            };
          }

          var result = this.decorateConstructor(newElements, decorators);
          finishers.push.apply(finishers, result.finishers);
          result.finishers = finishers;
          return result;
        },
        addElementPlacement: function (element, placements, silent) {
          var keys = placements[element.placement];

          if (!silent && keys.indexOf(element.key) !== -1) {
            throw new TypeError("Duplicated element (" + element.key + ")");
          }

          keys.push(element.key);
        },
        decorateElement: function (element, placements) {
          var extras = [];
          var finishers = [];

          for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
            var keys = placements[element.placement];
            keys.splice(keys.indexOf(element.key), 1);
            var elementObject = this.fromElementDescriptor(element);
            var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);
            element = elementFinisherExtras.element;
            this.addElementPlacement(element, placements);

            if (elementFinisherExtras.finisher) {
              finishers.push(elementFinisherExtras.finisher);
            }

            var newExtras = elementFinisherExtras.extras;

            if (newExtras) {
              for (var j = 0; j < newExtras.length; j++) {
                this.addElementPlacement(newExtras[j], placements);
              }

              extras.push.apply(extras, newExtras);
            }
          }

          return {
            element: element,
            finishers: finishers,
            extras: extras
          };
        },
        decorateConstructor: function (elements, decorators) {
          var finishers = [];

          for (var i = decorators.length - 1; i >= 0; i--) {
            var obj = this.fromClassDescriptor(elements);
            var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);

            if (elementsAndFinisher.finisher !== undefined) {
              finishers.push(elementsAndFinisher.finisher);
            }

            if (elementsAndFinisher.elements !== undefined) {
              elements = elementsAndFinisher.elements;

              for (var j = 0; j < elements.length - 1; j++) {
                for (var k = j + 1; k < elements.length; k++) {
                  if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {
                    throw new TypeError("Duplicated element (" + elements[j].key + ")");
                  }
                }
              }
            }
          }

          return {
            elements: elements,
            finishers: finishers
          };
        },
        fromElementDescriptor: function (element) {
          var obj = {
            kind: element.kind,
            key: element.key,
            placement: element.placement,
            descriptor: element.descriptor
          };
          var desc = {
            value: "Descriptor",
            configurable: true
          };
          Object.defineProperty(obj, Symbol.toStringTag, desc);
          if (element.kind === "field") obj.initializer = element.initializer;
          return obj;
        },
        toElementDescriptors: function (elementObjects) {
          if (elementObjects === undefined) return;
          return _toArray(elementObjects).map(function (elementObject) {
            var element = this.toElementDescriptor(elementObject);
            this.disallowProperty(elementObject, "finisher", "An element descriptor");
            this.disallowProperty(elementObject, "extras", "An element descriptor");
            return element;
          }, this);
        },
        toElementDescriptor: function (elementObject) {
          var kind = String(elementObject.kind);

          if (kind !== "method" && kind !== "field") {
            throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"');
          }

          var key = _toPropertyKey(elementObject.key);

          var placement = String(elementObject.placement);

          if (placement !== "static" && placement !== "prototype" && placement !== "own") {
            throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"');
          }

          var descriptor = elementObject.descriptor;
          this.disallowProperty(elementObject, "elements", "An element descriptor");
          var element = {
            kind: kind,
            key: key,
            placement: placement,
            descriptor: Object.assign({}, descriptor)
          };

          if (kind !== "field") {
            this.disallowProperty(elementObject, "initializer", "A method descriptor");
          } else {
            this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
            this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
            this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");
            element.initializer = elementObject.initializer;
          }

          return element;
        },
        toElementFinisherExtras: function (elementObject) {
          var element = this.toElementDescriptor(elementObject);

          var finisher = _optionalCallableProperty(elementObject, "finisher");

          var extras = this.toElementDescriptors(elementObject.extras);
          return {
            element: element,
            finisher: finisher,
            extras: extras
          };
        },
        fromClassDescriptor: function (elements) {
          var obj = {
            kind: "class",
            elements: elements.map(this.fromElementDescriptor, this)
          };
          var desc = {
            value: "Descriptor",
            configurable: true
          };
          Object.defineProperty(obj, Symbol.toStringTag, desc);
          return obj;
        },
        toClassDescriptor: function (obj) {
          var kind = String(obj.kind);

          if (kind !== "class") {
            throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"');
          }

          this.disallowProperty(obj, "key", "A class descriptor");
          this.disallowProperty(obj, "placement", "A class descriptor");
          this.disallowProperty(obj, "descriptor", "A class descriptor");
          this.disallowProperty(obj, "initializer", "A class descriptor");
          this.disallowProperty(obj, "extras", "A class descriptor");

          var finisher = _optionalCallableProperty(obj, "finisher");

          var elements = this.toElementDescriptors(obj.elements);
          return {
            elements: elements,
            finisher: finisher
          };
        },
        runClassFinishers: function (constructor, finishers) {
          for (var i = 0; i < finishers.length; i++) {
            var newConstructor = (0, finishers[i])(constructor);

            if (newConstructor !== undefined) {
              if (typeof newConstructor !== "function") {
                throw new TypeError("Finishers must return a constructor.");
              }

              constructor = newConstructor;
            }
          }

          return constructor;
        },
        disallowProperty: function (obj, name, objectType) {
          if (obj[name] !== undefined) {
            throw new TypeError(objectType + " can't have a ." + name + " property.");
          }
        }
      };
      return api;
    }

    function _createElementDescriptor(def) {
      var key = _toPropertyKey(def.key);

      var descriptor;

      if (def.kind === "method") {
        descriptor = {
          value: def.value,
          writable: true,
          configurable: true,
          enumerable: false
        };
      } else if (def.kind === "get") {
        descriptor = {
          get: def.value,
          configurable: true,
          enumerable: false
        };
      } else if (def.kind === "set") {
        descriptor = {
          set: def.value,
          configurable: true,
          enumerable: false
        };
      } else if (def.kind === "field") {
        descriptor = {
          configurable: true,
          writable: true,
          enumerable: true
        };
      }

      var element = {
        kind: def.kind === "field" ? "field" : "method",
        key: key,
        placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
        descriptor: descriptor
      };
      if (def.decorators) element.decorators = def.decorators;
      if (def.kind === "field") element.initializer = def.value;
      return element;
    }

    function _coalesceGetterSetter(element, other) {
      if (element.descriptor.get !== undefined) {
        other.descriptor.get = element.descriptor.get;
      } else {
        other.descriptor.set = element.descriptor.set;
      }
    }

    function _coalesceClassElements(elements) {
      var newElements = [];

      var isSameElement = function (other) {
        return other.kind === "method" && other.key === element.key && other.placement === element.placement;
      };

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        var other;

        if (element.kind === "method" && (other = newElements.find(isSameElement))) {
          if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
            if (_hasDecorators(element) || _hasDecorators(other)) {
              throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");
            }

            other.descriptor = element.descriptor;
          } else {
            if (_hasDecorators(element)) {
              if (_hasDecorators(other)) {
                throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ").");
              }

              other.decorators = element.decorators;
            }

            _coalesceGetterSetter(element, other);
          }
        } else {
          newElements.push(element);
        }
      }

      return newElements;
    }

    function _hasDecorators(element) {
      return element.decorators && element.decorators.length;
    }

    function _isDataDescriptor(desc) {
      return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
    }

    function _optionalCallableProperty(obj, name) {
      var value = obj[name];

      if (value !== undefined && typeof value !== "function") {
        throw new TypeError("Expected '" + name + "' to be a function");
      }

      return value;
    }

    function _classPrivateMethodGet(receiver, privateSet, fn) {
      if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      return fn;
    }

    function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }

    function _wrapRegExp(re, groups) {
      _wrapRegExp = function (re, groups) {
        return new BabelRegExp(re, undefined, groups);
      };

      var _RegExp = _wrapNativeSuper(RegExp);

      var _super = RegExp.prototype;

      var _groups = new WeakMap();

      function BabelRegExp(re, flags, groups) {
        var _this = _RegExp.call(this, re, flags);

        _groups.set(_this, groups || _groups.get(re));

        return _this;
      }

      _inherits(BabelRegExp, _RegExp);

      BabelRegExp.prototype.exec = function (str) {
        var result = _super.exec.call(this, str);

        if (result) result.groups = buildGroups(result, this);
        return result;
      };

      BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
        if (typeof substitution === "string") {
          var groups = _groups.get(this);

          return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
            return "$" + groups[name];
          }));
        } else if (typeof substitution === "function") {
          var _this = this;

          return _super[Symbol.replace].call(this, str, function () {
            var args = [];
            args.push.apply(args, arguments);

            if (typeof args[args.length - 1] !== "object") {
              args.push(buildGroups(args, _this));
            }

            return substitution.apply(this, args);
          });
        } else {
          return _super[Symbol.replace].call(this, str, substitution);
        }
      };

      function buildGroups(result, re) {
        var g = _groups.get(re);

        return Object.keys(g).reduce(function (groups, name) {
          groups[name] = result[g[name]];
          return groups;
        }, Object.create(null));
      }

      return _wrapRegExp.apply(this, arguments);
    }

    var _rollupPluginBabelHelpers = /*#__PURE__*/Object.freeze({
      __proto__: null,
      get typeof () { return _typeof; },
      jsx: _jsx,
      asyncIterator: _asyncIterator,
      AwaitValue: _AwaitValue,
      AsyncGenerator: _AsyncGenerator,
      wrapAsyncGenerator: _wrapAsyncGenerator,
      awaitAsyncGenerator: _awaitAsyncGenerator,
      asyncGeneratorDelegate: _asyncGeneratorDelegate,
      asyncToGenerator: _asyncToGenerator,
      classCallCheck: _classCallCheck,
      createClass: _createClass,
      defineEnumerableProperties: _defineEnumerableProperties,
      defaults: _defaults,
      defineProperty: _defineProperty,
      get extends () { return _extends; },
      objectSpread: _objectSpread,
      objectSpread2: _objectSpread2,
      inherits: _inherits,
      inheritsLoose: _inheritsLoose,
      get getPrototypeOf () { return _getPrototypeOf; },
      get setPrototypeOf () { return _setPrototypeOf; },
      isNativeReflectConstruct: _isNativeReflectConstruct,
      get construct () { return _construct; },
      isNativeFunction: _isNativeFunction,
      get wrapNativeSuper () { return _wrapNativeSuper; },
      'instanceof': _instanceof,
      interopRequireDefault: _interopRequireDefault,
      interopRequireWildcard: _interopRequireWildcard,
      newArrowCheck: _newArrowCheck,
      objectDestructuringEmpty: _objectDestructuringEmpty,
      objectWithoutPropertiesLoose: _objectWithoutPropertiesLoose,
      objectWithoutProperties: _objectWithoutProperties,
      assertThisInitialized: _assertThisInitialized,
      possibleConstructorReturn: _possibleConstructorReturn,
      createSuper: _createSuper,
      superPropBase: _superPropBase,
      get get () { return _get; },
      set: _set,
      taggedTemplateLiteral: _taggedTemplateLiteral,
      taggedTemplateLiteralLoose: _taggedTemplateLiteralLoose,
      readOnlyError: _readOnlyError,
      classNameTDZError: _classNameTDZError,
      temporalUndefined: _temporalUndefined,
      tdz: _tdz,
      temporalRef: _temporalRef,
      slicedToArray: _slicedToArray,
      slicedToArrayLoose: _slicedToArrayLoose,
      toArray: _toArray,
      toConsumableArray: _toConsumableArray,
      arrayWithoutHoles: _arrayWithoutHoles,
      arrayWithHoles: _arrayWithHoles,
      iterableToArray: _iterableToArray,
      iterableToArrayLimit: _iterableToArrayLimit,
      iterableToArrayLimitLoose: _iterableToArrayLimitLoose,
      unsupportedIterableToArray: _unsupportedIterableToArray,
      arrayLikeToArray: _arrayLikeToArray,
      nonIterableSpread: _nonIterableSpread,
      nonIterableRest: _nonIterableRest,
      createForOfIteratorHelper: _createForOfIteratorHelper,
      createForOfIteratorHelperLoose: _createForOfIteratorHelperLoose,
      skipFirstGeneratorNext: _skipFirstGeneratorNext,
      toPrimitive: _toPrimitive,
      toPropertyKey: _toPropertyKey,
      initializerWarningHelper: _initializerWarningHelper,
      initializerDefineProperty: _initializerDefineProperty,
      applyDecoratedDescriptor: _applyDecoratedDescriptor,
      classPrivateFieldLooseKey: _classPrivateFieldLooseKey,
      classPrivateFieldLooseBase: _classPrivateFieldLooseBase,
      classPrivateFieldGet: _classPrivateFieldGet,
      classPrivateFieldSet: _classPrivateFieldSet,
      classPrivateFieldDestructureSet: _classPrivateFieldDestructureSet,
      classStaticPrivateFieldSpecGet: _classStaticPrivateFieldSpecGet,
      classStaticPrivateFieldSpecSet: _classStaticPrivateFieldSpecSet,
      classStaticPrivateMethodGet: _classStaticPrivateMethodGet,
      classStaticPrivateMethodSet: _classStaticPrivateMethodSet,
      decorate: _decorate,
      classPrivateMethodGet: _classPrivateMethodGet,
      classPrivateMethodSet: _classPrivateMethodSet,
      get wrapRegExp () { return _wrapRegExp; }
    });

    function shallowEqual(actual, expected) {
      var keys = Object.keys(expected);

      for (var _i = 0, _arr = keys; _i < _arr.length; _i++) {
        var key = _arr[_i];

        if (actual[key] !== expected[key]) {
          return false;
        }
      }

      return true;
    }

    function isArrayExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ArrayExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isAssignmentExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "AssignmentExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBinaryExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BinaryExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isInterpreterDirective(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "InterpreterDirective") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDirective(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Directive") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDirectiveLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DirectiveLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBlockStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BlockStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBreakStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BreakStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isCallExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "CallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isCatchClause(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "CatchClause") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isConditionalExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ConditionalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isContinueStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ContinueStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDebuggerStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DebuggerStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDoWhileStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DoWhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEmptyStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EmptyStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExpressionStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExpressionStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFile(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "File") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isForInStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ForInStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isForStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ForStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFunctionDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FunctionDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFunctionExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FunctionExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isIdentifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Identifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isIfStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "IfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isLabeledStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "LabeledStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isStringLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "StringLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNumericLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NumericLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNullLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NullLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBooleanLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BooleanLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isRegExpLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "RegExpLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isLogicalExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isMemberExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "MemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNewExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NewExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isProgram(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Program") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectMethod(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isRestElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "RestElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isReturnStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ReturnStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSequenceExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "SequenceExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isParenthesizedExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ParenthesizedExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSwitchCase(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "SwitchCase") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSwitchStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "SwitchStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isThisExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ThisExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isThrowStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTryStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TryStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isUnaryExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "UnaryExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isUpdateExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "UpdateExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isVariableDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "VariableDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isVariableDeclarator(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "VariableDeclarator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isWhileStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "WhileStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isWithStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "WithStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isAssignmentPattern(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "AssignmentPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isArrayPattern(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ArrayPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ArrowFunctionExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportAllDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportAllDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportDefaultDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isForOfStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isImportDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ImportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ImportNamespaceSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isImportSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ImportSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isMetaProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "MetaProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassMethod(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectPattern(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectPattern") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSpreadElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "SpreadElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSuper(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Super") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TaggedTemplateExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTemplateElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TemplateElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTemplateLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TemplateLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isYieldExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "YieldExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "AnyTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ArrayTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BooleanTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BooleanLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NullLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassImplements(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassImplements") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareClass(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareClass") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareFunction(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareInterface(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareInterface") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareModule(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareModule") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareModuleExports(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareModuleExports") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareTypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareOpaqueType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareVariable(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareVariable") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareExportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclareExportAllDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclaredPredicate(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DeclaredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExistsTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FunctionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFunctionTypeParam(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FunctionTypeParam") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "GenericTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isInferredPredicate(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isInterfaceExtends(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "InterfaceExtends") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "InterfaceDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "InterfaceTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "IntersectionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "MixedTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EmptyTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NullableTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NumberLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NumberTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectTypeInternalSlot") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectTypeCallProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectTypeIndexer") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectTypeProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectTypeProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isOpaqueType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "OpaqueType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "QualifiedTypeIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "StringLiteralTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "StringTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "SymbolTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ThisTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TupleTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeofTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeAlias(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeAlias") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeCastExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeParameter(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeParameter") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeParameterDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TypeParameterInstantiation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "UnionTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isVariance(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Variance") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumBooleanBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumBooleanBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumNumberBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumNumberBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumStringBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumStringBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumSymbolBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumBooleanMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumBooleanMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumNumberMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumNumberMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumStringMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumStringMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXAttribute(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXClosingElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXClosingElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXEmptyExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXExpressionContainer") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXSpreadChild(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXSpreadChild") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXIdentifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXMemberExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXNamespacedName(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXNamespacedName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXOpeningElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXOpeningElement") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXSpreadAttribute") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXText(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXText") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXFragment(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXOpeningFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSXClosingFragment(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNoop(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Noop") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPlaceholder(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Placeholder") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "V8IntrinsicIdentifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ArgumentPlaceholder") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isAwaitExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBindExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BindExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEventualMemberExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EventualMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEventualMemberCallExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EventualMemberCallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "OptionalMemberExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "PipelineTopicExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPipelineBareFunction(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "PipelineBareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "PipelinePrimaryTopicReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEventualCallExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EventualCallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isOptionalCallExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "OptionalCallExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassPrivateProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClassPrivateMethod(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isImport(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Import") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDecorator(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Decorator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDoExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "DoExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportNamespaceSpecifier") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPrivateName(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "PrivateName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBigIntLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BigIntLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isRecordExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "RecordExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTupleExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TupleExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSParameterProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSParameterProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSDeclareFunction(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSDeclareFunction") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSDeclareMethod(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSDeclareMethod") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSQualifiedName(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSQualifiedName") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSCallSignatureDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSConstructSignatureDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSPropertySignature(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSPropertySignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSMethodSignature(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSMethodSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSIndexSignature(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSAnyKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSAnyKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSBooleanKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSBigIntKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSNeverKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSNeverKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSNullKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSNullKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSNumberKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSNumberKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSObjectKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSObjectKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSStringKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSStringKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSSymbolKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSUndefinedKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSUnknownKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSVoidKeyword(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSVoidKeyword") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSThisType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSThisType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSFunctionType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSFunctionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSConstructorType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSConstructorType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeReference(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypePredicate(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypePredicate") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeQuery(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeQuery") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSArrayType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSArrayType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTupleType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTupleType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSOptionalType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSOptionalType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSRestType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSRestType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSUnionType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSUnionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSIntersectionType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSIntersectionType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSConditionalType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSConditionalType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSInferType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSInferType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSParenthesizedType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSParenthesizedType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeOperator(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeOperator") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSIndexedAccessType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSMappedType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSMappedType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSLiteralType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSExpressionWithTypeArguments") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSInterfaceDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSInterfaceBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSInterfaceBody") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeAliasDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSAsExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSAsExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeAssertion(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeAssertion") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSEnumDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSEnumMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSEnumMember") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSModuleDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSModuleBlock(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSModuleBlock") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSImportType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSImportType") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSImportEqualsDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSExternalModuleReference") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSNonNullExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSNonNullExpression") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSExportAssignment(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSExportAssignment") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSNamespaceExportDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeAnnotation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeParameterInstantiation") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeParameterDeclaration") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeParameter(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeParameter") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExpression(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "EventualMemberExpression" === nodeType || "EventualMemberCallExpression" === nodeType || "OptionalMemberExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "EventualCallExpression" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBinary(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isScopable(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBlockParent(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isBlock(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTerminatorless(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isCompletionStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isConditional(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isLoop(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isWhile(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExpressionWrapper(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFor(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isForXStatement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFunction(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFunctionParent(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPureish(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPatternLike(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isLVal(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSEntityName(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isLiteral(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isUserWhitespacable(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isMethod(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isObjectMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isProperty(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isUnaryLike(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPattern(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isClass(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Class" || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isModuleDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isExportDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isModuleSpecifier(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFlow(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFlowType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFlowDeclaration(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isFlowPredicate(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumBody(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumBody" || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isEnumMember(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "EnumMember" || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isJSX(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isPrivate(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSTypeElement(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isTSBaseType(node, opts) {
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "TSBaseType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isNumberLiteral(node, opts) {
      console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "NumberLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isRegexLiteral(node, opts) {
      console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "RegexLiteral") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isRestProperty(node, opts) {
      console.trace("The node type RestProperty has been renamed to RestElement");
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "RestProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }
    function isSpreadProperty(node, opts) {
      console.trace("The node type SpreadProperty has been renamed to SpreadElement");
      if (!node) return false;
      var nodeType = node.type;

      if (nodeType === "SpreadProperty") {
        if (typeof opts === "undefined") {
          return true;
        } else {
          return shallowEqual(node, opts);
        }
      }

      return false;
    }

    function matchesPattern(member, match, allowPartial) {
      if (!isMemberExpression(member)) return false;
      var parts = Array.isArray(match) ? match : match.split(".");
      var nodes = [];
      var node;

      for (node = member; isMemberExpression(node); node = node.object) {
        nodes.push(node.property);
      }

      nodes.push(node);
      if (nodes.length < parts.length) return false;
      if (!allowPartial && nodes.length > parts.length) return false;

      for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        var _node = nodes[j];
        var value = void 0;

        if (isIdentifier(_node)) {
          value = _node.name;
        } else if (isStringLiteral(_node)) {
          value = _node.value;
        } else {
          return false;
        }

        if (parts[i] !== value) return false;
      }

      return true;
    }

    function buildMatchMemberExpression(match, allowPartial) {
      var parts = match.split(".");
      return function (member) {
        return matchesPattern(member, parts, allowPartial);
      };
    }

    var isReactComponent = buildMatchMemberExpression("React.Component");

    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }

    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }

    var eq_1 = eq;

    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;

    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    }

    var _listCacheSet = listCacheSet;

    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;
    var _ListCache = ListCache;

    function stackClear() {
      this.__data__ = new _ListCache();
      this.size = 0;
    }

    var _stackClear = stackClear;

    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);
      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete;

    function stackGet(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet;

    function stackHas(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas;

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
    var _freeGlobal = freeGlobal;

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    var root = _freeGlobal || freeSelf || Function('return this')();
    var _root = root;

    var Symbol$1 = _root.Symbol;
    var _Symbol = Symbol$1;

    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }

      return result;
    }

    var _getRawTag = getRawTag;

    var objectProto$1 = Object.prototype;
    var nativeObjectToString$1 = objectProto$1.toString;

    function objectToString(value) {
      return nativeObjectToString$1.call(value);
    }

    var _objectToString = objectToString;

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject;

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    function isFunction$1(value) {
      if (!isObject_1(value)) {
        return false;
      }

      var tag = _baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction$1;

    var coreJsData = _root['__core-js_shared__'];
    var _coreJsData = coreJsData;

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();

    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }

    var _isMasked = isMasked;

    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;

    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }

    var _toSource = toSource;

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype,
        objectProto$2 = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

    function baseIsNative(value) {
      if (!isObject_1(value) || _isMasked(value)) {
        return false;
      }

      var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    var Map$1 = _getNative(_root, 'Map');
    var _Map = Map$1;

    var nativeCreate = _getNative(Object, 'create');
    var _nativeCreate = nativeCreate;

    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    function hashGet(key) {
      var data = this.__data__;

      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
    }

    var _hashHas = hashHas;

    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet;

    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;
    var _Hash = Hash;

    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash(),
        'map': new (_Map || _ListCache)(),
        'string': new _Hash()
      };
    }

    var _mapCacheClear = mapCacheClear;

    function isKeyable(value) {
      var type = typeof value;
      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }

    var _isKeyable = isKeyable;

    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }

    var _getMapData = getMapData;

    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;
    var _MapCache = MapCache;

    var LARGE_ARRAY_SIZE = 200;

    function stackSet(key, value) {
      var data = this.__data__;

      if (data instanceof _ListCache) {
        var pairs = data.__data__;

        if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }

        data = this.__data__ = new _MapCache(pairs);
      }

      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet;

    function Stack(entries) {
      var data = this.__data__ = new _ListCache(entries);
      this.size = data.size;
    }

    Stack.prototype.clear = _stackClear;
    Stack.prototype['delete'] = _stackDelete;
    Stack.prototype.get = _stackGet;
    Stack.prototype.has = _stackHas;
    Stack.prototype.set = _stackSet;
    var _Stack = Stack;

    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }

      return array;
    }

    var _arrayEach = arrayEach;

    var defineProperty = function () {
      try {
        var func = _getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }();

    var _defineProperty$1 = defineProperty;

    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && _defineProperty$1) {
        _defineProperty$1(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    var _baseAssignValue = baseAssignValue;

    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    function assignValue(object, key, value) {
      var objValue = object[key];

      if (!(hasOwnProperty$4.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
        _baseAssignValue(object, key, value);
      }
    }

    var _assignValue = assignValue;

    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }

        if (isNew) {
          _baseAssignValue(object, key, newValue);
        } else {
          _assignValue(object, key, newValue);
        }
      }

      return object;
    }

    var _copyObject = copyObject;

    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    var _baseTimes = baseTimes;

    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    var argsTag = '[object Arguments]';

    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
    }

    var _baseIsArguments = baseIsArguments;

    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
    var isArguments = _baseIsArguments(function () {
      return arguments;
    }()) ? _baseIsArguments : function (value) {
      return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };
    var isArguments_1 = isArguments;

    var isArray = Array.isArray;
    var isArray_1 = isArray;

    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    var isBuffer_1 = createCommonjsModule(function (module, exports) {
    var freeExports =  exports && !exports.nodeType && exports;
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? _root.Buffer : undefined;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    var isBuffer = nativeIsBuffer || stubFalse_1;
    module.exports = isBuffer;
    });

    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    var _isIndex = isIndex;

    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }

    var isLength_1 = isLength;

    var argsTag$1 = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

    function baseIsTypedArray(value) {
      return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray;

    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary;

    var _nodeUtil = createCommonjsModule(function (module, exports) {
    var freeExports =  exports && !exports.nodeType && exports;
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && _freeGlobal.process;

    var nodeUtil = function () {
      try {
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    module.exports = nodeUtil;
    });

    var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
    var isTypedArray_1 = isTypedArray;

    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray_1(value),
          isArg = !isArr && isArguments_1(value),
          isBuff = !isArr && !isArg && isBuffer_1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? _baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || _isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys;

    var objectProto$8 = Object.prototype;

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;
      return value === proto;
    }

    var _isPrototype = isPrototype;

    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg;

    var nativeKeys = _overArg(Object.keys, Object);
    var _nativeKeys = nativeKeys;

    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    function baseKeys(object) {
      if (!_isPrototype(object)) {
        return _nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    var _baseKeys = baseKeys;

    function isArrayLike(value) {
      return value != null && isLength_1(value.length) && !isFunction_1(value);
    }

    var isArrayLike_1 = isArrayLike;

    function keys(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
    }

    var keys_1 = keys;

    function baseAssign(object, source) {
      return object && _copyObject(source, keys_1(source), object);
    }

    var _baseAssign = baseAssign;

    function nativeKeysIn(object) {
      var result = [];

      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }

      return result;
    }

    var _nativeKeysIn = nativeKeysIn;

    var objectProto$a = Object.prototype;
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

    function baseKeysIn(object) {
      if (!isObject_1(object)) {
        return _nativeKeysIn(object);
      }

      var isProto = _isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
          result.push(key);
        }
      }

      return result;
    }

    var _baseKeysIn = baseKeysIn;

    function keysIn$1(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
    }

    var keysIn_1 = keysIn$1;

    function baseAssignIn(object, source) {
      return object && _copyObject(source, keysIn_1(source), object);
    }

    var _baseAssignIn = baseAssignIn;

    var _cloneBuffer = createCommonjsModule(function (module, exports) {
    var freeExports =  exports && !exports.nodeType && exports;
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? _root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }

      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
    });

    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    var _copyArray = copyArray;

    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }

      return result;
    }

    var _arrayFilter = arrayFilter;

    function stubArray() {
      return [];
    }

    var stubArray_1 = stubArray;

    var objectProto$b = Object.prototype;
    var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
      if (object == null) {
        return [];
      }

      object = Object(object);
      return _arrayFilter(nativeGetSymbols(object), function (symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };
    var _getSymbols = getSymbols;

    function copySymbols(source, object) {
      return _copyObject(source, _getSymbols(source), object);
    }

    var _copySymbols = copySymbols;

    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }

    var _arrayPush = arrayPush;

    var getPrototype = _overArg(Object.getPrototypeOf, Object);
    var _getPrototype = getPrototype;

    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function (object) {
      var result = [];

      while (object) {
        _arrayPush(result, _getSymbols(object));
        object = _getPrototype(object);
      }

      return result;
    };
    var _getSymbolsIn = getSymbolsIn;

    function copySymbolsIn(source, object) {
      return _copyObject(source, _getSymbolsIn(source), object);
    }

    var _copySymbolsIn = copySymbolsIn;

    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys;

    function getAllKeys(object) {
      return _baseGetAllKeys(object, keys_1, _getSymbols);
    }

    var _getAllKeys = getAllKeys;

    function getAllKeysIn(object) {
      return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
    }

    var _getAllKeysIn = getAllKeysIn;

    var DataView$1 = _getNative(_root, 'DataView');
    var _DataView = DataView$1;

    var Promise$1 = _getNative(_root, 'Promise');
    var _Promise = Promise$1;

    var Set$1 = _getNative(_root, 'Set');
    var _Set = Set$1;

    var WeakMap$1 = _getNative(_root, 'WeakMap');
    var _WeakMap = WeakMap$1;

    var mapTag$1 = '[object Map]',
        objectTag$1 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$1 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';
    var dataViewTag$1 = '[object DataView]';
    var dataViewCtorString = _toSource(_DataView),
        mapCtorString = _toSource(_Map),
        promiseCtorString = _toSource(_Promise),
        setCtorString = _toSource(_Set),
        weakMapCtorString = _toSource(_WeakMap);
    var getTag = _baseGetTag;

    if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
      getTag = function getTag(value) {
        var result = _baseGetTag(value),
            Ctor = result == objectTag$1 ? value.constructor : undefined,
            ctorString = Ctor ? _toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$1;

            case mapCtorString:
              return mapTag$1;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag$1;

            case weakMapCtorString:
              return weakMapTag$1;
          }
        }

        return result;
      };
    }

    var _getTag = getTag;

    var objectProto$c = Object.prototype;
    var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }

      return result;
    }

    var _initCloneArray = initCloneArray;

    var Uint8Array$1 = _root.Uint8Array;
    var _Uint8Array = Uint8Array$1;

    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
      return result;
    }

    var _cloneArrayBuffer = cloneArrayBuffer;

    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    var _cloneDataView = cloneDataView;

    var reFlags = /\w*$/;

    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    var _cloneRegExp = cloneRegExp;

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    var _cloneSymbol = cloneSymbol;

    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    var _cloneTypedArray = cloneTypedArray;

    var boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag = '[object Symbol]';
    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]',
        float32Tag$1 = '[object Float32Array]',
        float64Tag$1 = '[object Float64Array]',
        int8Tag$1 = '[object Int8Array]',
        int16Tag$1 = '[object Int16Array]',
        int32Tag$1 = '[object Int32Array]',
        uint8Tag$1 = '[object Uint8Array]',
        uint8ClampedTag$1 = '[object Uint8ClampedArray]',
        uint16Tag$1 = '[object Uint16Array]',
        uint32Tag$1 = '[object Uint32Array]';

    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;

      switch (tag) {
        case arrayBufferTag$1:
          return _cloneArrayBuffer(object);

        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object);

        case dataViewTag$2:
          return _cloneDataView(object, isDeep);

        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return _cloneTypedArray(object, isDeep);

        case mapTag$2:
          return new Ctor();

        case numberTag$1:
        case stringTag$1:
          return new Ctor(object);

        case regexpTag$1:
          return _cloneRegExp(object);

        case setTag$2:
          return new Ctor();

        case symbolTag:
          return _cloneSymbol(object);
      }
    }

    var _initCloneByTag = initCloneByTag;

    var objectCreate = Object.create;

    var baseCreate = function () {
      function object() {}

      return function (proto) {
        if (!isObject_1(proto)) {
          return {};
        }

        if (objectCreate) {
          return objectCreate(proto);
        }

        object.prototype = proto;
        var result = new object();
        object.prototype = undefined;
        return result;
      };
    }();

    var _baseCreate = baseCreate;

    function initCloneObject(object) {
      return typeof object.constructor == 'function' && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
    }

    var _initCloneObject = initCloneObject;

    var mapTag$3 = '[object Map]';

    function baseIsMap(value) {
      return isObjectLike_1(value) && _getTag(value) == mapTag$3;
    }

    var _baseIsMap = baseIsMap;

    var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
    var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
    var isMap_1 = isMap;

    var setTag$3 = '[object Set]';

    function baseIsSet(value) {
      return isObjectLike_1(value) && _getTag(value) == setTag$3;
    }

    var _baseIsSet = baseIsSet;

    var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
    var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
    var isSet_1 = isSet;

    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;
    var argsTag$2 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$2 = '[object Boolean]',
        dateTag$2 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag$2 = '[object Function]',
        genTag$1 = '[object GeneratorFunction]',
        mapTag$4 = '[object Map]',
        numberTag$2 = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag$2 = '[object RegExp]',
        setTag$4 = '[object Set]',
        stringTag$2 = '[object String]',
        symbolTag$1 = '[object Symbol]',
        weakMapTag$2 = '[object WeakMap]';
    var arrayBufferTag$2 = '[object ArrayBuffer]',
        dataViewTag$3 = '[object DataView]',
        float32Tag$2 = '[object Float32Array]',
        float64Tag$2 = '[object Float64Array]',
        int8Tag$2 = '[object Int8Array]',
        int16Tag$2 = '[object Int16Array]',
        int32Tag$2 = '[object Int32Array]',
        uint8Tag$2 = '[object Uint8Array]',
        uint8ClampedTag$2 = '[object Uint8ClampedArray]',
        uint16Tag$2 = '[object Uint16Array]',
        uint32Tag$2 = '[object Uint32Array]';
    var cloneableTags = {};
    cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$2] = cloneableTags[setTag$4] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }

      if (result !== undefined) {
        return result;
      }

      if (!isObject_1(value)) {
        return value;
      }

      var isArr = isArray_1(value);

      if (isArr) {
        result = _initCloneArray(value);

        if (!isDeep) {
          return _copyArray(value, result);
        }
      } else {
        var tag = _getTag(value),
            isFunc = tag == funcTag$2 || tag == genTag$1;

        if (isBuffer_1(value)) {
          return _cloneBuffer(value, isDeep);
        }

        if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
          result = isFlat || isFunc ? {} : _initCloneObject(value);

          if (!isDeep) {
            return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }

          result = _initCloneByTag(value, tag, isDeep);
        }
      }

      stack || (stack = new _Stack());
      var stacked = stack.get(value);

      if (stacked) {
        return stacked;
      }

      stack.set(value, result);

      if (isSet_1(value)) {
        value.forEach(function (subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap_1(value)) {
        value.forEach(function (subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn : keys_1;
      var props = isArr ? undefined : keysFunc(value);
      _arrayEach(props || value, function (subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }

        _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    var _baseClone = baseClone;

    var CLONE_SYMBOLS_FLAG$1 = 4;

    function clone(value) {
      return _baseClone(value, CLONE_SYMBOLS_FLAG$1);
    }

    var clone_1 = clone;

    var fastProto = null;

    function FastObject(o) {
      if (fastProto !== null && typeof fastProto.property) {
        var result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
      }

      fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
      return new FastObject();
    }

    FastObject();

    var toFastProperties = function toFastproperties(o) {
      return FastObject(o);
    };

    var global$1 = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }

    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }

    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;

    if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    }

    if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }

      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }

      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }

    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }

      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }

      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }

    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }

      draining = false;

      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }

      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }

      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;

      while (len) {
        currentQueue = queue;
        queue = [];

        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }

        queueIndex = -1;
        len = queue.length;
      }

      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }

    function nextTick(fun) {
      var args = new Array(arguments.length - 1);

      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }

      queue.push(new Item(fun, args));

      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    }

    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }

    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    };

    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = '';
    var versions = {};
    var release = {};
    var config = {};

    function noop() {}

    var on = noop;
    var addListener = noop;
    var once = noop;
    var off = noop;
    var removeListener = noop;
    var removeAllListeners = noop;
    var emit = noop;
    function binding(name) {
      throw new Error('process.binding is not supported');
    }
    function cwd() {
      return '/';
    }
    function chdir(dir) {
      throw new Error('process.chdir is not supported');
    }
    function umask() {
      return 0;
    }
    var performance = global$1.performance || {};

    var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
      return new Date().getTime();
    };

    function hrtime(previousTimestamp) {
      var clocktime = performanceNow.call(performance) * 1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor(clocktime % 1 * 1e9);

      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];

        if (nanoseconds < 0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }

      return [seconds, nanoseconds];
    }
    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }
    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    function isType(nodeType, targetType) {
      if (nodeType === targetType) return true;
      if (ALIAS_KEYS[targetType]) return false;
      var aliases = FLIPPED_ALIAS_KEYS[targetType];

      if (aliases) {
        if (aliases[0] === nodeType) return true;

        for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
          var alias = _step.value;
          if (nodeType === alias) return true;
        }
      }

      return false;
    }

    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType) return true;
      var aliases = PLACEHOLDERS_ALIAS[placeholderType];

      if (aliases) {
        for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
          var alias = _step.value;
          if (targetType === alias) return true;
        }
      }

      return false;
    }

    function is(type, node, opts) {
      if (!node) return false;
      var matches = isType(node.type, type);

      if (!matches) {
        if (!opts && node.type === "Placeholder" && type in FLIPPED_ALIAS_KEYS) {
          return isPlaceholderType(node.expectedNode, type);
        }

        return false;
      }

      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

    function isInAstralSet(code, set) {
      var pos = 0x10000;

      for (var i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
      }

      return false;
    }

    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;

      if (code <= 0xffff) {
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }

      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;

      if (code <= 0xffff) {
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
      }

      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      var isFirst = true;

      for (var _i2 = 0, _Array$from2 = Array.from(name); _i2 < _Array$from2.length; _i2++) {
        var _char = _Array$from2[_i2];

        var cp = _char.codePointAt(0);

        if (isFirst) {
          if (!isIdentifierStart(cp)) {
            return false;
          }

          isFirst = false;
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }

      return !isFirst;
    }

    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }

    function isValidIdentifier(name, reserved) {
      if (reserved === void 0) {
        reserved = true;
      }

      if (typeof name !== "string") return false;

      if (reserved) {
        if (isKeyword(name) || isStrictReservedWord(name)) {
          return false;
        } else if (name === "await") {
          return false;
        }
      }

      return isIdentifierName(name);
    }

    var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    var FLATTENABLE_KEYS = ["body", "expressions"];
    var FOR_INIT_KEYS = ["left", "init"];
    var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    var LOGICAL_OPERATORS = ["||", "&&", "??"];
    var UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
    var BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
    var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);
    var ASSIGNMENT_OPERATORS = ["=", "+="].concat(NUMBER_BINARY_OPERATORS.map(function (op) {
      return op + "=";
    }), LOGICAL_OPERATORS.map(function (op) {
      return op + "=";
    }));
    var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    var STRING_UNARY_OPERATORS = ["typeof"];
    var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
    var INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    var BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
    var NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");

    function validate(node, key, val) {
      if (!node) return;
      var fields = NODE_FIELDS[node.type];
      if (!fields) return;
      var field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateField(node, key, val, field) {
      if (!field || !field.validate) return;
      if (field.optional && val == null) return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      if (val == null) return;
      var validate = NODE_PARENT_VALIDATIONS[val.type];
      if (!validate) return;
      validate(node, key, val);
    }

    var VISITOR_KEYS = {};
    var ALIAS_KEYS = {};
    var FLIPPED_ALIAS_KEYS = {};
    var NODE_FIELDS = {};
    var BUILDER_KEYS = {};
    var DEPRECATED_KEYS = {};
    var NODE_PARENT_VALIDATIONS = {};

    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }

    function validate$1(validate) {
      return {
        validate: validate
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, typeName);
    }
    function validateType(typeName) {
      return validate$1(typeIs(typeName));
    }
    function validateOptional(validate) {
      return {
        validate: validate,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate$1(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val)) return;

        for (var i = 0; i < val.length; i++) {
          var subkey = key + "[" + i + "]";
          var v = val[i];
          callback(node, subkey, v);
          if (process.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);
        }
      }

      validator.each = callback;
      return validator;
    }
    function assertOneOf() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      function validate(node, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
        }
      }

      validate.oneOf = values;
      return validate;
    }
    function assertNodeType() {
      for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        types[_key2] = arguments[_key2];
      }

      function validate(node, key, val) {
        for (var _iterator = _createForOfIteratorHelperLoose(types), _step; !(_step = _iterator()).done;) {
          var type = _step.value;

          if (is(type, val)) {
            validateChild(node, key, val);
            return;
          }
        }

        throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val && val.type));
      }

      validate.oneOfNodeTypes = types;
      return validate;
    }
    function assertNodeOrValueType() {
      for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        types[_key3] = arguments[_key3];
      }

      function validate(node, key, val) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {
          var type = _step2.value;

          if (getType(val) === type || is(type, val)) {
            validateChild(node, key, val);
            return;
          }
        }

        throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val && val.type));
      }

      validate.oneOfNodeOrValueTypes = types;
      return validate;
    }
    function assertValueType(type) {
      function validate(node, key, val) {
        var valid = getType(val) === type;

        if (!valid) {
          throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
        }
      }

      validate.type = type;
      return validate;
    }
    function assertShape(shape) {
      function validate(node, key, val) {
        var errors = [];

        for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {
          var property = _Object$keys[_i];

          try {
            validateField(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }

            throw error;
          }
        }

        if (errors.length) {
          throw new TypeError("Property " + key + " of " + node.type + " expected to have the following:\n" + errors.join("\n"));
        }
      }

      validate.shapeOf = shape;
      return validate;
    }
    function assertOptionalChainStart() {
      function validate(node) {
        var _current2;

        var current = node;

        while (node) {
          var _current = current,
              type = _current.type;

          if (type === "OptionalCallExpression") {
            if (current.optional) return;
            current = current.callee;
            continue;
          }

          if (type === "OptionalMemberExpression") {
            if (current.optional) return;
            current = current.object;
            continue;
          }

          break;
        }

        throw new TypeError("Non-optional " + node.type + " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from " + ((_current2 = current) == null ? void 0 : _current2.type));
      }

      return validate;
    }
    function chain() {
      for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        fns[_key4] = arguments[_key4];
      }

      function validate() {
        for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
          var fn = _step3.value;
          fn.apply(void 0, arguments);
        }
      }

      validate.chainOf = fns;
      return validate;
    }
    var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    var validFieldKeys = ["default", "optional", "validate"];
    function defineType(type, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var inherits = opts.inherits && store[opts.inherits] || {};
      var fields = opts.fields;

      if (!fields) {
        fields = {};

        if (inherits.fields) {
          var keys = Object.getOwnPropertyNames(inherits.fields);

          for (var _i2 = 0, _arr = keys; _i2 < _arr.length; _i2++) {
            var key = _arr[_i2];
            var field = inherits.fields[key];
            fields[key] = {
              "default": field["default"],
              optional: field.optional,
              validate: field.validate
            };
          }
        }
      }

      var visitor = opts.visitor || inherits.visitor || [];
      var aliases = opts.aliases || inherits.aliases || [];
      var builder = opts.builder || inherits.builder || opts.visitor || [];

      for (var _i3 = 0, _arr2 = Object.keys(opts); _i3 < _arr2.length; _i3++) {
        var k = _arr2[_i3];

        if (validTypeOpts.indexOf(k) === -1) {
          throw new Error("Unknown type option \"" + k + "\" on " + type);
        }
      }

      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }

      for (var _i4 = 0, _arr3 = visitor.concat(builder); _i4 < _arr3.length; _i4++) {
        var _key5 = _arr3[_i4];
        fields[_key5] = fields[_key5] || {};
      }

      for (var _i5 = 0, _Object$keys2 = Object.keys(fields); _i5 < _Object$keys2.length; _i5++) {
        var _key6 = _Object$keys2[_i5];
        var _field = fields[_key6];

        if (_field["default"] !== undefined && builder.indexOf(_key6) === -1) {
          _field.optional = true;
        }

        if (_field["default"] === undefined) {
          _field["default"] = null;
        } else if (!_field.validate && _field["default"] != null) {
          _field.validate = assertValueType(getType(_field["default"]));
        }

        for (var _i6 = 0, _arr4 = Object.keys(_field); _i6 < _arr4.length; _i6++) {
          var _k = _arr4[_i6];

          if (validFieldKeys.indexOf(_k) === -1) {
            throw new Error("Unknown field key \"" + _k + "\" on " + type + "." + _key6);
          }
        }
      }

      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach(function (alias) {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });

      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }

      store[type] = opts;
    }
    var store = {};

    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
          "default": !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: function () {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return assertValueType("string");
            }

            var identifier = assertOneOf.apply(void 0, ASSIGNMENT_OPERATORS);
            var pattern = assertOneOf("=");
            return function (node, key, val) {
              var validator = is("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
        },
        right: {
          validate: assertNodeType("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: assertOneOf.apply(void 0, BINARY_OPERATORS)
        },
        left: {
          validate: assertNodeType("Expression")
        },
        right: {
          validate: assertNodeType("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: assertNodeType("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
          "default": []
        },
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: assertNodeType("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: assertNodeType("Expression", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: assertOneOf(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: assertNodeType("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        consequent: {
          validate: assertNodeType("Expression")
        },
        alternate: {
          validate: assertNodeType("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: assertNodeType("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: assertNodeType("Program")
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
        },
        right: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: assertNodeType("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        update: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    var functionCommon = {
      params: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
      },
      generator: {
        "default": false
      },
      async: {
        "default": false
      }
    };
    var functionTypeAnnotationCommon = {
      returnType: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
    var functionDeclarationCommon = Object.assign({}, functionCommon, {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    });
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, functionDeclarationCommon, {}, functionTypeAnnotationCommon, {
        body: {
          validate: assertNodeType("BlockStatement")
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) return function () {};
        var identifier = assertNodeType("Identifier");
        return function (parent, key, node) {
          if (!is("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
        id: {
          validate: assertNodeType("Identifier"),
          optional: true
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      })
    });
    var patternLikeCommon = {
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator")))
      }
    };
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon, {
        name: {
          validate: chain(assertValueType("string"), function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (!isValidIdentifier(val, false)) {
              throw new TypeError("\"" + val + "\" is not a valid identifier name");
            }
          })
        },
        optional: {
          validate: assertValueType("boolean"),
          optional: true
        }
      }),
      validate: function validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        var match = /\.(\w+)$/.exec(key);
        if (!match) return;
        var parentKey = match[1];
        var nonComp = {
          computed: false
        };

        if (parentKey === "property") {
          if (is("MemberExpression", parent, nonComp)) return;
          if (is("OptionalMemberExpression", parent, nonComp)) return;
        } else if (parentKey === "key") {
          if (is("Property", parent, nonComp)) return;
          if (is("Method", parent, nonComp)) return;
        } else if (parentKey === "exported") {
          if (is("ExportSpecifier", parent)) return;
        } else if (parentKey === "imported") {
          if (is("ImportSpecifier", parent, {
            imported: node
          })) return;
        } else if (parentKey === "meta") {
          if (is("MetaProperty", parent, {
            meta: node
          })) return;
        }

        if ((isKeyword(node.name) || isReservedWord(node.name)) && node.name !== "this") {
          throw new TypeError("\"" + node.name + "\" is not a valid identifier");
        }
      }
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        consequent: {
          validate: assertNodeType("Statement")
        },
        alternate: {
          optional: true,
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: assertNodeType("Identifier")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: assertValueType("number")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: assertValueType("string")
        },
        flags: {
          validate: chain(assertValueType("string"), function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            var invalid = /[^gimsuy]/.exec(val);

            if (invalid) {
              throw new TypeError("\"" + invalid[0] + "\" is not a valid RegExp flag");
            }
          }),
          "default": ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: assertOneOf.apply(void 0, LOGICAL_OPERATORS)
        },
        left: {
          validate: assertNodeType("Expression")
        },
        right: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: assertNodeType("Expression")
        },
        property: {
          validate: function () {
            var normal = assertNodeType("Identifier", "PrivateName");
            var computed = assertNodeType("Expression");
            return function (node, key, val) {
              var validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }()
        },
        computed: {
          "default": false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: assertOneOf(true, false),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: {
          validate: assertValueType("string")
        },
        sourceType: {
          validate: assertOneOf("script", "module"),
          "default": "script"
        },
        interpreter: {
          validate: assertNodeType("InterpreterDirective"),
          "default": null,
          optional: true
        },
        directives: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
          "default": []
        },
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
        kind: Object.assign({
          validate: assertOneOf("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          "default": "method"
        } : {}),
        computed: {
          "default": false
        },
        key: {
          validate: function () {
            var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
            var computed = assertNodeType("Expression");
            return function (node, key, val) {
              var validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }()
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      }),
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand"].concat(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []),
      fields: {
        computed: {
          "default": false
        },
        key: {
          validate: function () {
            var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
            var computed = assertNodeType("Expression");
            return function (node, key, val) {
              var validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }()
        },
        value: {
          validate: assertNodeType("Expression", "PatternLike")
        },
        shorthand: {
          validate: chain(assertValueType("boolean"), function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (val && node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (val && !is("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          "default": false
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: function () {
        var pattern = assertNodeType("Identifier", "Pattern");
        var expression = assertNodeType("Expression");
        return function (parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          var validator = is("ObjectPattern", parent) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon, {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "Pattern", "MemberExpression")
        }
      }),
      validate: function validate(parent, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        var match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match) throw new Error("Internal Babel error: malformed key.");
        var listKey = match[1],
            index = match[2];

        if (parent[listKey].length > index + 1) {
          throw new TypeError("RestElement must be last element of " + listKey);
        }
      }
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: assertNodeType("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        consequent: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
        }
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: assertNodeType("Expression")
        },
        cases: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("SwitchCase")))
        }
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: chain(assertNodeType("BlockStatement"), function (node) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          })
        },
        handler: {
          optional: true,
          validate: assertNodeType("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: assertNodeType("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          "default": true
        },
        argument: {
          validate: assertNodeType("Expression")
        },
        operator: {
          validate: assertOneOf.apply(void 0, UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          "default": false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
        },
        operator: {
          validate: assertOneOf.apply(void 0, UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        kind: {
          validate: assertOneOf("var", "let", "const")
        },
        declarations: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("VariableDeclarator")))
        }
      },
      validate: function validate(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (!is("ForXStatement", parent, {
          left: node
        })) return;

        if (node.declarations.length !== 1) {
          throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
        }
      }
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: function () {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return assertNodeType("LVal");
            }

            var normal = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern");
            var without = assertNodeType("Identifier");
            return function (node, key, val) {
              var validator = node.init ? normal : without;
              validator(node, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: assertValueType("boolean")
        },
        init: {
          optional: true,
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        }
      }
    });

    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon, {
        left: {
          validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
        },
        right: {
          validate: assertNodeType("Expression")
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon, {
        elements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike")))
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
        expression: {
          validate: assertValueType("boolean")
        },
        body: {
          validate: assertNodeType("BlockStatement", "Expression")
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
        }
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: assertNodeType("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: assertNodeType("ClassBody")
        },
        superClass: {
          optional: true,
          validate: assertNodeType("Expression")
        },
        superTypeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        "implements": {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        },
        "abstract": {
          validate: assertValueType("boolean"),
          optional: true
        }
      },
      validate: function () {
        var identifier = assertNodeType("Identifier");
        return function (parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (!is("ExportDefaultDeclaration", parent)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("ExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: assertNodeType("StringLiteral")
        }
      }
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: assertNodeType("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
        }
      }
    });
    defineType("ExportNamedDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          optional: true,
          validate: chain(assertNodeType("Declaration"), function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        specifiers: {
          "default": [],
          validate: chain(assertValueType("array"), assertEach(function () {
            var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            var sourceless = assertNodeType("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
            return function (node, key, val) {
              var validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            };
          }()))
        },
        source: {
          validate: assertNodeType("StringLiteral"),
          optional: true
        },
        exportKind: validateOptional(assertOneOf("type", "value"))
      }
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        },
        exported: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function () {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return assertNodeType("VariableDeclaration", "LVal");
            }

            var declaration = assertNodeType("VariableDeclaration");
            var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
            return function (node, key, val) {
              if (is("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            };
          }()
        },
        right: {
          validate: assertNodeType("Expression")
        },
        body: {
          validate: assertNodeType("Statement")
        },
        "await": {
          "default": false
        }
      }
    });
    defineType("ImportDeclaration", {
      visitor: ["specifiers", "source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration"],
      fields: {
        specifiers: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: assertNodeType("StringLiteral")
        },
        importKind: {
          validate: assertOneOf("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: assertNodeType("Identifier")
        },
        imported: {
          validate: assertNodeType("Identifier")
        },
        importKind: {
          validate: assertOneOf("type", "typeof"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: chain(assertNodeType("Identifier"), function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            var property;

            switch (val.name) {
              case "function":
                property = "sent";
                break;

              case "new":
                property = "target";
                break;

              case "import":
                property = "meta";
                break;
            }

            if (!is("Identifier", node.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          })
        },
        property: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = {
      "abstract": {
        validate: assertValueType("boolean"),
        optional: true
      },
      accessibility: {
        validate: assertOneOf("public", "private", "protected"),
        optional: true
      },
      "static": {
        "default": false
      },
      computed: {
        "default": false
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      },
      key: {
        validate: chain(function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
      }
    };
    var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, {}, classMethodOrPropertyCommon, {
      kind: {
        validate: assertOneOf("get", "set", "method", "constructor"),
        "default": "method"
      },
      access: {
        validate: chain(assertValueType("string"), assertOneOf("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    });
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, functionTypeAnnotationCommon, {
        body: {
          validate: assertNodeType("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon, {
        properties: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("RestElement", "ObjectProperty")))
        }
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: assertNodeType("Expression")
        },
        quasi: {
          validate: assertNodeType("TemplateLiteral")
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: assertShape({
            raw: {
              validate: assertValueType("string")
            },
            cooked: {
              validate: assertValueType("string"),
              optional: true
            }
          })
        },
        tail: {
          "default": false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TemplateElement")))
        },
        expressions: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression")), function (node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of expressions.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: chain(assertValueType("boolean"), function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;

            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }),
          "default": false
        },
        argument: {
          optional: true,
          validate: assertNodeType("Expression")
        }
      }
    });

    var defineInterfaceishType = function defineInterfaceishType(name, typeParameterType) {
      if (typeParameterType === void 0) {
        typeParameterType = "TypeParameterDeclaration";
      }

      defineType(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
        aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: validateType("Identifier"),
          typeParameters: validateOptionalType(typeParameterType),
          "extends": validateOptional(arrayOfType("InterfaceExtends")),
          mixins: validateOptional(arrayOfType("InterfaceExtends")),
          "implements": validateOptional(arrayOfType("ClassImplements")),
          body: validateType("ObjectTypeAnnotation")
        }
      });
    };

    defineType("AnyTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["Flow", "FlowType"],
      fields: {
        elementType: validateType("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["Flow", "FlowType"],
      fields: {
        value: validate$1(assertValueType("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      visitor: ["id"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        predicate: validateOptionalType("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType(["Identifier", "StringLiteral"]),
        body: validateType("BlockStatement"),
        kind: validateOptional(assertOneOf("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: validateType("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        right: validateType("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        supertype: validateOptionalType("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        declaration: validateOptionalType("Flow"),
        specifiers: validateOptional(arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"])),
        source: validateOptionalType("StringLiteral"),
        "default": validateOptional(assertValueType("boolean"))
      }
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        source: validateType("StringLiteral"),
        exportKind: validateOptional(assertOneOf("type", "value"))
      }
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["Flow", "FlowPredicate"],
      fields: {
        value: validateType("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["Flow", "FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["Flow", "FlowType"],
      fields: {
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        params: validate$1(arrayOfType("FunctionTypeParam")),
        rest: validateOptionalType("FunctionTypeParam"),
        returnType: validateType("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      aliases: ["Flow"],
      fields: {
        name: validateOptionalType("Identifier"),
        typeAnnotation: validateType("FlowType"),
        optional: validateOptional(assertValueType("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow", "FlowType"],
      fields: {
        id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: validateOptionalType("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["Flow", "FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {
        id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: validateOptionalType("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["Flow", "FlowType"],
      fields: {
        "extends": validateOptional(arrayOfType("InterfaceExtends")),
        body: validateType("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow", "FlowType"],
      fields: {
        types: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow", "FlowType"],
      fields: {
        typeAnnotation: validateType("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["Flow", "FlowType"],
      fields: {
        value: validate$1(assertValueType("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["Flow", "FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: validate$1(arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
        indexers: validateOptional(arrayOfType("ObjectTypeIndexer")),
        callProperties: validateOptional(arrayOfType("ObjectTypeCallProperty")),
        internalSlots: validateOptional(arrayOfType("ObjectTypeInternalSlot")),
        exact: {
          validate: assertValueType("boolean"),
          "default": false
        },
        inexact: validateOptional(assertValueType("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value", "optional", "static", "method"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        id: validateType("Identifier"),
        value: validateType("FlowType"),
        optional: validate$1(assertValueType("boolean")),
        "static": validate$1(assertValueType("boolean")),
        method: validate$1(assertValueType("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        value: validateType("FlowType"),
        "static": validate$1(assertValueType("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["id", "key", "value", "variance"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        id: validateOptionalType("Identifier"),
        key: validateType("FlowType"),
        value: validateType("FlowType"),
        "static": validate$1(assertValueType("boolean")),
        variance: validateOptionalType("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        key: validateType(["Identifier", "StringLiteral"]),
        value: validateType("FlowType"),
        kind: validate$1(assertOneOf("init", "get", "set")),
        "static": validate$1(assertValueType("boolean")),
        proto: validate$1(assertValueType("boolean")),
        optional: validate$1(assertValueType("boolean")),
        variance: validateOptionalType("Variance")
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {
        argument: validateType("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        supertype: validateOptionalType("FlowType"),
        impltype: validateType("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      aliases: ["Flow"],
      fields: {
        id: validateType("Identifier"),
        qualification: validateType(["Identifier", "QualifiedTypeIdentifier"])
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["Flow", "FlowType"],
      fields: {
        value: validate$1(assertValueType("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow", "FlowType"],
      fields: {
        types: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["Flow", "FlowType"],
      fields: {
        argument: validateType("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        right: validateType("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      aliases: ["Flow"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: validateType("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["Flow", "ExpressionWrapper", "Expression"],
      fields: {
        expression: validateType("Expression"),
        typeAnnotation: validateType("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      aliases: ["Flow"],
      visitor: ["bound", "default", "variance"],
      fields: {
        name: validate$1(assertValueType("string")),
        bound: validateOptionalType("TypeAnnotation"),
        "default": validateOptionalType("FlowType"),
        variance: validateOptionalType("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      aliases: ["Flow"],
      visitor: ["params"],
      fields: {
        params: validate$1(arrayOfType("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      aliases: ["Flow"],
      visitor: ["params"],
      fields: {
        params: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow", "FlowType"],
      fields: {
        types: validate$1(arrayOfType("FlowType"))
      }
    });
    defineType("Variance", {
      aliases: ["Flow"],
      builder: ["kind"],
      fields: {
        kind: validate$1(assertOneOf("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: validateType("Identifier"),
        body: validateType(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicit: validate$1(assertValueType("boolean")),
        members: validateArrayOfType("EnumBooleanMember")
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicit: validate$1(assertValueType("boolean")),
        members: validateArrayOfType("EnumNumberMember")
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicit: validate$1(assertValueType("boolean")),
        members: validateArrayOfType(["EnumStringMember", "EnumDefaultedMember"])
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: validateArrayOfType("EnumDefaultedMember")
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: validateType("Identifier"),
        init: validateType("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: validateType("Identifier"),
        init: validateType("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: validateType("Identifier"),
        init: validateType("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: validateType("Identifier")
      }
    });

    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["JSX", "Immutable", "Expression"],
      fields: {
        openingElement: {
          validate: assertNodeType("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: assertNodeType("JSXClosingElement")
        },
        children: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType("JSXEmptyExpression", {
      aliases: ["JSX"]
    });
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["JSX", "Immutable"],
      fields: {
        expression: {
          validate: assertNodeType("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["JSX", "Immutable"],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      aliases: ["JSX"],
      fields: {
        name: {
          validate: assertValueType("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      aliases: ["JSX"],
      fields: {
        object: {
          validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: assertNodeType("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      aliases: ["JSX"],
      fields: {
        namespace: {
          validate: assertNodeType("JSXIdentifier")
        },
        name: {
          validate: assertNodeType("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          "default": false
        },
        attributes: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      aliases: ["JSX"],
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["JSX", "Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["JSX", "Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: assertNodeType("JSXOpeningFragment")
        },
        closingFragment: {
          validate: assertNodeType("JSXClosingFragment")
        },
        children: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["JSX", "Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["JSX", "Immutable"]
    });

    var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    var PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };

    for (var _i = 0, _PLACEHOLDERS = PLACEHOLDERS; _i < _PLACEHOLDERS.length; _i++) {
      var type = _PLACEHOLDERS[_i];
      var alias = ALIAS_KEYS[type];
      if (alias && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
    }

    var PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
      PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }

        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });

    defineType("Noop", {
      visitor: []
    });
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: {
        name: {
          validate: assertNodeType("Identifier")
        },
        expectedNode: {
          validate: assertOneOf.apply(void 0, PLACEHOLDERS)
        }
      }
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: assertValueType("string")
        }
      }
    });

    defineType("ArgumentPlaceholder", {});
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {} : {
        object: {
          validate: assertNodeType("Expression")
        },
        callee: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon, {
        value: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        definite: {
          validate: assertValueType("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        },
        readonly: {
          validate: assertValueType("boolean"),
          optional: true
        },
        declare: {
          validate: assertValueType("boolean"),
          optional: true
        }
      })
    });
    defineType("EventualMemberExpression", {
      builder: ["object", "property", "computed"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: assertNodeType("Expression")
        },
        property: {
          validate: function () {
            var normal = assertNodeType("Identifier");
            var computed = assertNodeType("Expression");
            return function (node, key, val) {
              var validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }()
        },
        computed: {
          "default": false
        }
      }
    });
    defineType("EventualMemberCallExpression", {
      visitor: ["callee", "property", "arguments", "computed", "typeParameters", "typeArguments"],
      builder: ["callee", "property", "arguments"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: assertNodeType("Expression")
        },
        property: {
          validate: function () {
            var normal = assertNodeType("Identifier");
            var computed = assertNodeType("Expression");
            return function (node, key, val) {
              var validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }()
        },
        arguments: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName")))
        },
        computed: {
          "default": false
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: assertNodeType("Expression")
        },
        property: {
          validate: function () {
            var normal = assertNodeType("Identifier");
            var computed = assertNodeType("Expression");
            return function (node, key, val) {
              var validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }()
        },
        computed: {
          "default": false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
        }
      }
    });
    defineType("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
    defineType("EventualCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: assertNodeType("Expression")
        },
        arguments: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName")))
        },
        typeArguments: {
          validate: assertNodeType("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: assertNodeType("Expression")
        },
        arguments: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
        },
        typeArguments: {
          validate: assertNodeType("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: assertNodeType("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators"],
      builder: ["key", "value", "decorators"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: assertNodeType("PrivateName")
        },
        value: {
          validate: assertNodeType("Expression"),
          optional: true
        },
        decorators: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon, {
        key: {
          validate: assertNodeType("PrivateName")
        },
        body: {
          validate: assertNodeType("BlockStatement")
        }
      })
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: assertNodeType("Expression")
        }
      }
    });
    defineType("DoExpression", {
      visitor: ["body"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: assertNodeType("BlockStatement")
        }
      }
    });
    defineType("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: assertNodeType("Identifier")
        }
      }
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectProperty", "ObjectMethod", "SpreadElement")))
        }
      }
    });
    defineType("TupleExpression", {
      fields: {
        elements: {
          validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
          "default": []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });

    var bool = assertValueType("boolean");
    var tSFunctionTypeAnnotationCommon = {
      returnType: {
        validate: assertNodeType("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: assertOneOf("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: assertValueType("boolean"),
          optional: true
        },
        parameter: {
          validate: assertNodeType("Identifier", "AssignmentPattern")
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, functionDeclarationCommon, {}, tSFunctionTypeAnnotationCommon)
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, tSFunctionTypeAnnotationCommon)
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: validateType("TSEntityName"),
        right: validateType("Identifier")
      }
    });
    var signatureDeclarationCommon = {
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      parameters: validateArrayOfType(["Identifier", "RestElement"]),
      typeAnnotation: validateOptionalType("TSTypeAnnotation")
    };
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = {
      key: validateType("Expression"),
      computed: validate$1(bool),
      optional: validateOptional(bool)
    };
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation", "initializer"],
      fields: Object.assign({}, namedTypeElementCommon, {
        readonly: validateOptional(bool),
        typeAnnotation: validateOptionalType("TSTypeAnnotation"),
        initializer: validateOptionalType("Expression")
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon, {}, namedTypeElementCommon)
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: validateOptional(bool),
        parameters: validateArrayOfType("Identifier"),
        typeAnnotation: validateOptionalType("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

    for (var _i$1 = 0, _tsKeywordTypes = tsKeywordTypes; _i$1 < _tsKeywordTypes.length; _i$1++) {
      var type$1 = _tsKeywordTypes[_i$1];
      defineType(type$1, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }

    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtr = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon
    };
    defineType("TSFunctionType", fnOrCtr);
    defineType("TSConstructorType", fnOrCtr);
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: validateType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: validateType(["Identifier", "TSThisType"]),
        typeAnnotation: validateOptionalType("TSTypeAnnotation"),
        asserts: validateOptional(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName"],
      fields: {
        exprName: validateType(["TSEntityName", "TSImportType"])
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: validateArrayOfType("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: validateType("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: validateArrayOfType("TSType")
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: validateType("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: validateArrayOfType("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: validateType("TSType"),
        extendsType: validateType("TSType"),
        trueType: validateType("TSType"),
        falseType: validateType("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: validateType("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: validate$1(assertValueType("string")),
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: validateType("TSType"),
        indexType: validateType("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "typeAnnotation"],
      fields: {
        readonly: validateOptional(bool),
        typeParameter: validateType("TSTypeParameter"),
        optional: validateOptional(bool),
        typeAnnotation: validateOptionalType("TSType")
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: validateType(["NumericLiteral", "StringLiteral", "BooleanLiteral"])
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: validateType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: validateOptional(bool),
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
        "extends": validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
        body: validateType("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: validateArrayOfType("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: validateOptional(bool),
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSAsExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: validateType("Expression"),
        typeAnnotation: validateType("TSType")
      }
    });
    defineType("TSTypeAssertion", {
      aliases: ["Expression"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: validateType("TSType"),
        expression: validateType("Expression")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: validateOptional(bool),
        "const": validateOptional(bool),
        id: validateType("Identifier"),
        members: validateArrayOfType("TSEnumMember"),
        initializer: validateOptionalType("Expression")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: validateType(["Identifier", "StringLiteral"]),
        initializer: validateOptionalType("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        declare: validateOptional(bool),
        global: validateOptional(bool),
        id: validateType(["Identifier", "StringLiteral"]),
        body: validateType(["TSModuleBlock", "TSModuleDeclaration"])
      }
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent"],
      visitor: ["body"],
      fields: {
        body: validateArrayOfType("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      visitor: ["argument", "qualifier", "typeParameters"],
      fields: {
        argument: validateType("StringLiteral"),
        qualifier: validateOptionalType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement"],
      visitor: ["id", "moduleReference"],
      fields: {
        isExport: validate$1(bool),
        id: validateType("Identifier"),
        moduleReference: validateType(["TSEntityName", "TSExternalModuleReference"])
      }
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: validateType("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression"],
      visitor: ["expression"],
      fields: {
        expression: validateType("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: validateType("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: validateType("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: assertNodeType("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSType")))
        }
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: {
          validate: chain(assertValueType("array"), assertEach(assertNodeType("TSTypeParameter")))
        }
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: assertValueType("string")
        },
        constraint: {
          validate: assertNodeType("TSType"),
          optional: true
        },
        "default": {
          validate: assertNodeType("TSType"),
          optional: true
        }
      }
    });

    toFastProperties(VISITOR_KEYS);
    toFastProperties(ALIAS_KEYS);
    toFastProperties(FLIPPED_ALIAS_KEYS);
    toFastProperties(NODE_FIELDS);
    toFastProperties(BUILDER_KEYS);
    toFastProperties(DEPRECATED_KEYS);
    toFastProperties(PLACEHOLDERS_ALIAS);
    toFastProperties(PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = Object.keys(VISITOR_KEYS).concat(Object.keys(FLIPPED_ALIAS_KEYS)).concat(Object.keys(DEPRECATED_KEYS));

    function builder(type) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var keys = BUILDER_KEYS[type];
      var countArgs = args.length;

      if (countArgs > keys.length) {
        throw new Error(type + ": Too many arguments passed. Received " + countArgs + " but can receive no more than " + keys.length);
      }

      var node = {
        type: type
      };
      var i = 0;
      keys.forEach(function (key) {
        var field = NODE_FIELDS[type][key];
        var arg;
        if (i < countArgs) arg = args[i];
        if (arg === undefined) arg = clone_1(field["default"]);
        node[key] = arg;
        i++;
      });

      for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        validate(node, key, node[key]);
      }

      return node;
    }

    function ArrayExpression() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return builder.apply(void 0, ["ArrayExpression"].concat(args));
    }
    function AssignmentExpression() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return builder.apply(void 0, ["AssignmentExpression"].concat(args));
    }
    function BinaryExpression() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return builder.apply(void 0, ["BinaryExpression"].concat(args));
    }
    function InterpreterDirective() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return builder.apply(void 0, ["InterpreterDirective"].concat(args));
    }
    function Directive() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return builder.apply(void 0, ["Directive"].concat(args));
    }
    function DirectiveLiteral() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return builder.apply(void 0, ["DirectiveLiteral"].concat(args));
    }
    function BlockStatement() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return builder.apply(void 0, ["BlockStatement"].concat(args));
    }
    function BreakStatement() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      return builder.apply(void 0, ["BreakStatement"].concat(args));
    }
    function CallExpression() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      return builder.apply(void 0, ["CallExpression"].concat(args));
    }
    function CatchClause() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }

      return builder.apply(void 0, ["CatchClause"].concat(args));
    }
    function ConditionalExpression() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }

      return builder.apply(void 0, ["ConditionalExpression"].concat(args));
    }
    function ContinueStatement() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }

      return builder.apply(void 0, ["ContinueStatement"].concat(args));
    }
    function DebuggerStatement() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }

      return builder.apply(void 0, ["DebuggerStatement"].concat(args));
    }
    function DoWhileStatement() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }

      return builder.apply(void 0, ["DoWhileStatement"].concat(args));
    }
    function EmptyStatement() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }

      return builder.apply(void 0, ["EmptyStatement"].concat(args));
    }
    function ExpressionStatement() {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }

      return builder.apply(void 0, ["ExpressionStatement"].concat(args));
    }
    function File() {
      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }

      return builder.apply(void 0, ["File"].concat(args));
    }
    function ForInStatement() {
      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }

      return builder.apply(void 0, ["ForInStatement"].concat(args));
    }
    function ForStatement() {
      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }

      return builder.apply(void 0, ["ForStatement"].concat(args));
    }
    function FunctionDeclaration() {
      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }

      return builder.apply(void 0, ["FunctionDeclaration"].concat(args));
    }
    function FunctionExpression() {
      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }

      return builder.apply(void 0, ["FunctionExpression"].concat(args));
    }
    function Identifier() {
      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }

      return builder.apply(void 0, ["Identifier"].concat(args));
    }
    function IfStatement() {
      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }

      return builder.apply(void 0, ["IfStatement"].concat(args));
    }
    function LabeledStatement() {
      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
        args[_key24] = arguments[_key24];
      }

      return builder.apply(void 0, ["LabeledStatement"].concat(args));
    }
    function StringLiteral() {
      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
        args[_key25] = arguments[_key25];
      }

      return builder.apply(void 0, ["StringLiteral"].concat(args));
    }
    function NumericLiteral() {
      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
        args[_key26] = arguments[_key26];
      }

      return builder.apply(void 0, ["NumericLiteral"].concat(args));
    }
    function NullLiteral() {
      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
        args[_key27] = arguments[_key27];
      }

      return builder.apply(void 0, ["NullLiteral"].concat(args));
    }
    function BooleanLiteral() {
      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
        args[_key28] = arguments[_key28];
      }

      return builder.apply(void 0, ["BooleanLiteral"].concat(args));
    }
    function RegExpLiteral() {
      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
        args[_key29] = arguments[_key29];
      }

      return builder.apply(void 0, ["RegExpLiteral"].concat(args));
    }
    function LogicalExpression() {
      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
        args[_key30] = arguments[_key30];
      }

      return builder.apply(void 0, ["LogicalExpression"].concat(args));
    }
    function MemberExpression() {
      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
        args[_key31] = arguments[_key31];
      }

      return builder.apply(void 0, ["MemberExpression"].concat(args));
    }
    function NewExpression() {
      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
        args[_key32] = arguments[_key32];
      }

      return builder.apply(void 0, ["NewExpression"].concat(args));
    }
    function Program() {
      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
        args[_key33] = arguments[_key33];
      }

      return builder.apply(void 0, ["Program"].concat(args));
    }
    function ObjectExpression() {
      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
        args[_key34] = arguments[_key34];
      }

      return builder.apply(void 0, ["ObjectExpression"].concat(args));
    }
    function ObjectMethod() {
      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
        args[_key35] = arguments[_key35];
      }

      return builder.apply(void 0, ["ObjectMethod"].concat(args));
    }
    function ObjectProperty() {
      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
        args[_key36] = arguments[_key36];
      }

      return builder.apply(void 0, ["ObjectProperty"].concat(args));
    }
    function RestElement() {
      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
        args[_key37] = arguments[_key37];
      }

      return builder.apply(void 0, ["RestElement"].concat(args));
    }
    function ReturnStatement() {
      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
        args[_key38] = arguments[_key38];
      }

      return builder.apply(void 0, ["ReturnStatement"].concat(args));
    }
    function SequenceExpression() {
      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
        args[_key39] = arguments[_key39];
      }

      return builder.apply(void 0, ["SequenceExpression"].concat(args));
    }
    function ParenthesizedExpression() {
      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
        args[_key40] = arguments[_key40];
      }

      return builder.apply(void 0, ["ParenthesizedExpression"].concat(args));
    }
    function SwitchCase() {
      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
        args[_key41] = arguments[_key41];
      }

      return builder.apply(void 0, ["SwitchCase"].concat(args));
    }
    function SwitchStatement() {
      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
        args[_key42] = arguments[_key42];
      }

      return builder.apply(void 0, ["SwitchStatement"].concat(args));
    }
    function ThisExpression() {
      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
        args[_key43] = arguments[_key43];
      }

      return builder.apply(void 0, ["ThisExpression"].concat(args));
    }
    function ThrowStatement() {
      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
        args[_key44] = arguments[_key44];
      }

      return builder.apply(void 0, ["ThrowStatement"].concat(args));
    }
    function TryStatement() {
      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
        args[_key45] = arguments[_key45];
      }

      return builder.apply(void 0, ["TryStatement"].concat(args));
    }
    function UnaryExpression() {
      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
        args[_key46] = arguments[_key46];
      }

      return builder.apply(void 0, ["UnaryExpression"].concat(args));
    }
    function UpdateExpression() {
      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
        args[_key47] = arguments[_key47];
      }

      return builder.apply(void 0, ["UpdateExpression"].concat(args));
    }
    function VariableDeclaration() {
      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
        args[_key48] = arguments[_key48];
      }

      return builder.apply(void 0, ["VariableDeclaration"].concat(args));
    }
    function VariableDeclarator() {
      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
        args[_key49] = arguments[_key49];
      }

      return builder.apply(void 0, ["VariableDeclarator"].concat(args));
    }
    function WhileStatement() {
      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
        args[_key50] = arguments[_key50];
      }

      return builder.apply(void 0, ["WhileStatement"].concat(args));
    }
    function WithStatement() {
      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
        args[_key51] = arguments[_key51];
      }

      return builder.apply(void 0, ["WithStatement"].concat(args));
    }
    function AssignmentPattern() {
      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
        args[_key52] = arguments[_key52];
      }

      return builder.apply(void 0, ["AssignmentPattern"].concat(args));
    }
    function ArrayPattern() {
      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
        args[_key53] = arguments[_key53];
      }

      return builder.apply(void 0, ["ArrayPattern"].concat(args));
    }
    function ArrowFunctionExpression() {
      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
        args[_key54] = arguments[_key54];
      }

      return builder.apply(void 0, ["ArrowFunctionExpression"].concat(args));
    }
    function ClassBody() {
      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {
        args[_key55] = arguments[_key55];
      }

      return builder.apply(void 0, ["ClassBody"].concat(args));
    }
    function ClassExpression() {
      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {
        args[_key56] = arguments[_key56];
      }

      return builder.apply(void 0, ["ClassExpression"].concat(args));
    }
    function ClassDeclaration() {
      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {
        args[_key57] = arguments[_key57];
      }

      return builder.apply(void 0, ["ClassDeclaration"].concat(args));
    }
    function ExportAllDeclaration() {
      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {
        args[_key58] = arguments[_key58];
      }

      return builder.apply(void 0, ["ExportAllDeclaration"].concat(args));
    }
    function ExportDefaultDeclaration() {
      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {
        args[_key59] = arguments[_key59];
      }

      return builder.apply(void 0, ["ExportDefaultDeclaration"].concat(args));
    }
    function ExportNamedDeclaration() {
      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {
        args[_key60] = arguments[_key60];
      }

      return builder.apply(void 0, ["ExportNamedDeclaration"].concat(args));
    }
    function ExportSpecifier() {
      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {
        args[_key61] = arguments[_key61];
      }

      return builder.apply(void 0, ["ExportSpecifier"].concat(args));
    }
    function ForOfStatement() {
      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {
        args[_key62] = arguments[_key62];
      }

      return builder.apply(void 0, ["ForOfStatement"].concat(args));
    }
    function ImportDeclaration() {
      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {
        args[_key63] = arguments[_key63];
      }

      return builder.apply(void 0, ["ImportDeclaration"].concat(args));
    }
    function ImportDefaultSpecifier() {
      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {
        args[_key64] = arguments[_key64];
      }

      return builder.apply(void 0, ["ImportDefaultSpecifier"].concat(args));
    }
    function ImportNamespaceSpecifier() {
      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {
        args[_key65] = arguments[_key65];
      }

      return builder.apply(void 0, ["ImportNamespaceSpecifier"].concat(args));
    }
    function ImportSpecifier() {
      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {
        args[_key66] = arguments[_key66];
      }

      return builder.apply(void 0, ["ImportSpecifier"].concat(args));
    }
    function MetaProperty() {
      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {
        args[_key67] = arguments[_key67];
      }

      return builder.apply(void 0, ["MetaProperty"].concat(args));
    }
    function ClassMethod() {
      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {
        args[_key68] = arguments[_key68];
      }

      return builder.apply(void 0, ["ClassMethod"].concat(args));
    }
    function ObjectPattern() {
      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {
        args[_key69] = arguments[_key69];
      }

      return builder.apply(void 0, ["ObjectPattern"].concat(args));
    }
    function SpreadElement() {
      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {
        args[_key70] = arguments[_key70];
      }

      return builder.apply(void 0, ["SpreadElement"].concat(args));
    }
    function Super() {
      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {
        args[_key71] = arguments[_key71];
      }

      return builder.apply(void 0, ["Super"].concat(args));
    }
    function TaggedTemplateExpression() {
      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {
        args[_key72] = arguments[_key72];
      }

      return builder.apply(void 0, ["TaggedTemplateExpression"].concat(args));
    }
    function TemplateElement() {
      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {
        args[_key73] = arguments[_key73];
      }

      return builder.apply(void 0, ["TemplateElement"].concat(args));
    }
    function TemplateLiteral() {
      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {
        args[_key74] = arguments[_key74];
      }

      return builder.apply(void 0, ["TemplateLiteral"].concat(args));
    }
    function YieldExpression() {
      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {
        args[_key75] = arguments[_key75];
      }

      return builder.apply(void 0, ["YieldExpression"].concat(args));
    }
    function AnyTypeAnnotation() {
      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {
        args[_key76] = arguments[_key76];
      }

      return builder.apply(void 0, ["AnyTypeAnnotation"].concat(args));
    }
    function ArrayTypeAnnotation() {
      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {
        args[_key77] = arguments[_key77];
      }

      return builder.apply(void 0, ["ArrayTypeAnnotation"].concat(args));
    }
    function BooleanTypeAnnotation() {
      for (var _len78 = arguments.length, args = new Array(_len78), _key78 = 0; _key78 < _len78; _key78++) {
        args[_key78] = arguments[_key78];
      }

      return builder.apply(void 0, ["BooleanTypeAnnotation"].concat(args));
    }
    function BooleanLiteralTypeAnnotation() {
      for (var _len79 = arguments.length, args = new Array(_len79), _key79 = 0; _key79 < _len79; _key79++) {
        args[_key79] = arguments[_key79];
      }

      return builder.apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(args));
    }
    function NullLiteralTypeAnnotation() {
      for (var _len80 = arguments.length, args = new Array(_len80), _key80 = 0; _key80 < _len80; _key80++) {
        args[_key80] = arguments[_key80];
      }

      return builder.apply(void 0, ["NullLiteralTypeAnnotation"].concat(args));
    }
    function ClassImplements() {
      for (var _len81 = arguments.length, args = new Array(_len81), _key81 = 0; _key81 < _len81; _key81++) {
        args[_key81] = arguments[_key81];
      }

      return builder.apply(void 0, ["ClassImplements"].concat(args));
    }
    function DeclareClass() {
      for (var _len82 = arguments.length, args = new Array(_len82), _key82 = 0; _key82 < _len82; _key82++) {
        args[_key82] = arguments[_key82];
      }

      return builder.apply(void 0, ["DeclareClass"].concat(args));
    }
    function DeclareFunction() {
      for (var _len83 = arguments.length, args = new Array(_len83), _key83 = 0; _key83 < _len83; _key83++) {
        args[_key83] = arguments[_key83];
      }

      return builder.apply(void 0, ["DeclareFunction"].concat(args));
    }
    function DeclareInterface() {
      for (var _len84 = arguments.length, args = new Array(_len84), _key84 = 0; _key84 < _len84; _key84++) {
        args[_key84] = arguments[_key84];
      }

      return builder.apply(void 0, ["DeclareInterface"].concat(args));
    }
    function DeclareModule() {
      for (var _len85 = arguments.length, args = new Array(_len85), _key85 = 0; _key85 < _len85; _key85++) {
        args[_key85] = arguments[_key85];
      }

      return builder.apply(void 0, ["DeclareModule"].concat(args));
    }
    function DeclareModuleExports() {
      for (var _len86 = arguments.length, args = new Array(_len86), _key86 = 0; _key86 < _len86; _key86++) {
        args[_key86] = arguments[_key86];
      }

      return builder.apply(void 0, ["DeclareModuleExports"].concat(args));
    }
    function DeclareTypeAlias() {
      for (var _len87 = arguments.length, args = new Array(_len87), _key87 = 0; _key87 < _len87; _key87++) {
        args[_key87] = arguments[_key87];
      }

      return builder.apply(void 0, ["DeclareTypeAlias"].concat(args));
    }
    function DeclareOpaqueType() {
      for (var _len88 = arguments.length, args = new Array(_len88), _key88 = 0; _key88 < _len88; _key88++) {
        args[_key88] = arguments[_key88];
      }

      return builder.apply(void 0, ["DeclareOpaqueType"].concat(args));
    }
    function DeclareVariable() {
      for (var _len89 = arguments.length, args = new Array(_len89), _key89 = 0; _key89 < _len89; _key89++) {
        args[_key89] = arguments[_key89];
      }

      return builder.apply(void 0, ["DeclareVariable"].concat(args));
    }
    function DeclareExportDeclaration() {
      for (var _len90 = arguments.length, args = new Array(_len90), _key90 = 0; _key90 < _len90; _key90++) {
        args[_key90] = arguments[_key90];
      }

      return builder.apply(void 0, ["DeclareExportDeclaration"].concat(args));
    }
    function DeclareExportAllDeclaration() {
      for (var _len91 = arguments.length, args = new Array(_len91), _key91 = 0; _key91 < _len91; _key91++) {
        args[_key91] = arguments[_key91];
      }

      return builder.apply(void 0, ["DeclareExportAllDeclaration"].concat(args));
    }
    function DeclaredPredicate() {
      for (var _len92 = arguments.length, args = new Array(_len92), _key92 = 0; _key92 < _len92; _key92++) {
        args[_key92] = arguments[_key92];
      }

      return builder.apply(void 0, ["DeclaredPredicate"].concat(args));
    }
    function ExistsTypeAnnotation() {
      for (var _len93 = arguments.length, args = new Array(_len93), _key93 = 0; _key93 < _len93; _key93++) {
        args[_key93] = arguments[_key93];
      }

      return builder.apply(void 0, ["ExistsTypeAnnotation"].concat(args));
    }
    function FunctionTypeAnnotation() {
      for (var _len94 = arguments.length, args = new Array(_len94), _key94 = 0; _key94 < _len94; _key94++) {
        args[_key94] = arguments[_key94];
      }

      return builder.apply(void 0, ["FunctionTypeAnnotation"].concat(args));
    }
    function FunctionTypeParam() {
      for (var _len95 = arguments.length, args = new Array(_len95), _key95 = 0; _key95 < _len95; _key95++) {
        args[_key95] = arguments[_key95];
      }

      return builder.apply(void 0, ["FunctionTypeParam"].concat(args));
    }
    function GenericTypeAnnotation() {
      for (var _len96 = arguments.length, args = new Array(_len96), _key96 = 0; _key96 < _len96; _key96++) {
        args[_key96] = arguments[_key96];
      }

      return builder.apply(void 0, ["GenericTypeAnnotation"].concat(args));
    }
    function InferredPredicate() {
      for (var _len97 = arguments.length, args = new Array(_len97), _key97 = 0; _key97 < _len97; _key97++) {
        args[_key97] = arguments[_key97];
      }

      return builder.apply(void 0, ["InferredPredicate"].concat(args));
    }
    function InterfaceExtends() {
      for (var _len98 = arguments.length, args = new Array(_len98), _key98 = 0; _key98 < _len98; _key98++) {
        args[_key98] = arguments[_key98];
      }

      return builder.apply(void 0, ["InterfaceExtends"].concat(args));
    }
    function InterfaceDeclaration() {
      for (var _len99 = arguments.length, args = new Array(_len99), _key99 = 0; _key99 < _len99; _key99++) {
        args[_key99] = arguments[_key99];
      }

      return builder.apply(void 0, ["InterfaceDeclaration"].concat(args));
    }
    function InterfaceTypeAnnotation() {
      for (var _len100 = arguments.length, args = new Array(_len100), _key100 = 0; _key100 < _len100; _key100++) {
        args[_key100] = arguments[_key100];
      }

      return builder.apply(void 0, ["InterfaceTypeAnnotation"].concat(args));
    }
    function IntersectionTypeAnnotation() {
      for (var _len101 = arguments.length, args = new Array(_len101), _key101 = 0; _key101 < _len101; _key101++) {
        args[_key101] = arguments[_key101];
      }

      return builder.apply(void 0, ["IntersectionTypeAnnotation"].concat(args));
    }
    function MixedTypeAnnotation() {
      for (var _len102 = arguments.length, args = new Array(_len102), _key102 = 0; _key102 < _len102; _key102++) {
        args[_key102] = arguments[_key102];
      }

      return builder.apply(void 0, ["MixedTypeAnnotation"].concat(args));
    }
    function EmptyTypeAnnotation() {
      for (var _len103 = arguments.length, args = new Array(_len103), _key103 = 0; _key103 < _len103; _key103++) {
        args[_key103] = arguments[_key103];
      }

      return builder.apply(void 0, ["EmptyTypeAnnotation"].concat(args));
    }
    function NullableTypeAnnotation() {
      for (var _len104 = arguments.length, args = new Array(_len104), _key104 = 0; _key104 < _len104; _key104++) {
        args[_key104] = arguments[_key104];
      }

      return builder.apply(void 0, ["NullableTypeAnnotation"].concat(args));
    }
    function NumberLiteralTypeAnnotation() {
      for (var _len105 = arguments.length, args = new Array(_len105), _key105 = 0; _key105 < _len105; _key105++) {
        args[_key105] = arguments[_key105];
      }

      return builder.apply(void 0, ["NumberLiteralTypeAnnotation"].concat(args));
    }
    function NumberTypeAnnotation() {
      for (var _len106 = arguments.length, args = new Array(_len106), _key106 = 0; _key106 < _len106; _key106++) {
        args[_key106] = arguments[_key106];
      }

      return builder.apply(void 0, ["NumberTypeAnnotation"].concat(args));
    }
    function ObjectTypeAnnotation() {
      for (var _len107 = arguments.length, args = new Array(_len107), _key107 = 0; _key107 < _len107; _key107++) {
        args[_key107] = arguments[_key107];
      }

      return builder.apply(void 0, ["ObjectTypeAnnotation"].concat(args));
    }
    function ObjectTypeInternalSlot() {
      for (var _len108 = arguments.length, args = new Array(_len108), _key108 = 0; _key108 < _len108; _key108++) {
        args[_key108] = arguments[_key108];
      }

      return builder.apply(void 0, ["ObjectTypeInternalSlot"].concat(args));
    }
    function ObjectTypeCallProperty() {
      for (var _len109 = arguments.length, args = new Array(_len109), _key109 = 0; _key109 < _len109; _key109++) {
        args[_key109] = arguments[_key109];
      }

      return builder.apply(void 0, ["ObjectTypeCallProperty"].concat(args));
    }
    function ObjectTypeIndexer() {
      for (var _len110 = arguments.length, args = new Array(_len110), _key110 = 0; _key110 < _len110; _key110++) {
        args[_key110] = arguments[_key110];
      }

      return builder.apply(void 0, ["ObjectTypeIndexer"].concat(args));
    }
    function ObjectTypeProperty() {
      for (var _len111 = arguments.length, args = new Array(_len111), _key111 = 0; _key111 < _len111; _key111++) {
        args[_key111] = arguments[_key111];
      }

      return builder.apply(void 0, ["ObjectTypeProperty"].concat(args));
    }
    function ObjectTypeSpreadProperty() {
      for (var _len112 = arguments.length, args = new Array(_len112), _key112 = 0; _key112 < _len112; _key112++) {
        args[_key112] = arguments[_key112];
      }

      return builder.apply(void 0, ["ObjectTypeSpreadProperty"].concat(args));
    }
    function OpaqueType() {
      for (var _len113 = arguments.length, args = new Array(_len113), _key113 = 0; _key113 < _len113; _key113++) {
        args[_key113] = arguments[_key113];
      }

      return builder.apply(void 0, ["OpaqueType"].concat(args));
    }
    function QualifiedTypeIdentifier() {
      for (var _len114 = arguments.length, args = new Array(_len114), _key114 = 0; _key114 < _len114; _key114++) {
        args[_key114] = arguments[_key114];
      }

      return builder.apply(void 0, ["QualifiedTypeIdentifier"].concat(args));
    }
    function StringLiteralTypeAnnotation() {
      for (var _len115 = arguments.length, args = new Array(_len115), _key115 = 0; _key115 < _len115; _key115++) {
        args[_key115] = arguments[_key115];
      }

      return builder.apply(void 0, ["StringLiteralTypeAnnotation"].concat(args));
    }
    function StringTypeAnnotation() {
      for (var _len116 = arguments.length, args = new Array(_len116), _key116 = 0; _key116 < _len116; _key116++) {
        args[_key116] = arguments[_key116];
      }

      return builder.apply(void 0, ["StringTypeAnnotation"].concat(args));
    }
    function SymbolTypeAnnotation() {
      for (var _len117 = arguments.length, args = new Array(_len117), _key117 = 0; _key117 < _len117; _key117++) {
        args[_key117] = arguments[_key117];
      }

      return builder.apply(void 0, ["SymbolTypeAnnotation"].concat(args));
    }
    function ThisTypeAnnotation() {
      for (var _len118 = arguments.length, args = new Array(_len118), _key118 = 0; _key118 < _len118; _key118++) {
        args[_key118] = arguments[_key118];
      }

      return builder.apply(void 0, ["ThisTypeAnnotation"].concat(args));
    }
    function TupleTypeAnnotation() {
      for (var _len119 = arguments.length, args = new Array(_len119), _key119 = 0; _key119 < _len119; _key119++) {
        args[_key119] = arguments[_key119];
      }

      return builder.apply(void 0, ["TupleTypeAnnotation"].concat(args));
    }
    function TypeofTypeAnnotation() {
      for (var _len120 = arguments.length, args = new Array(_len120), _key120 = 0; _key120 < _len120; _key120++) {
        args[_key120] = arguments[_key120];
      }

      return builder.apply(void 0, ["TypeofTypeAnnotation"].concat(args));
    }
    function TypeAlias() {
      for (var _len121 = arguments.length, args = new Array(_len121), _key121 = 0; _key121 < _len121; _key121++) {
        args[_key121] = arguments[_key121];
      }

      return builder.apply(void 0, ["TypeAlias"].concat(args));
    }
    function TypeAnnotation() {
      for (var _len122 = arguments.length, args = new Array(_len122), _key122 = 0; _key122 < _len122; _key122++) {
        args[_key122] = arguments[_key122];
      }

      return builder.apply(void 0, ["TypeAnnotation"].concat(args));
    }
    function TypeCastExpression() {
      for (var _len123 = arguments.length, args = new Array(_len123), _key123 = 0; _key123 < _len123; _key123++) {
        args[_key123] = arguments[_key123];
      }

      return builder.apply(void 0, ["TypeCastExpression"].concat(args));
    }
    function TypeParameter() {
      for (var _len124 = arguments.length, args = new Array(_len124), _key124 = 0; _key124 < _len124; _key124++) {
        args[_key124] = arguments[_key124];
      }

      return builder.apply(void 0, ["TypeParameter"].concat(args));
    }
    function TypeParameterDeclaration() {
      for (var _len125 = arguments.length, args = new Array(_len125), _key125 = 0; _key125 < _len125; _key125++) {
        args[_key125] = arguments[_key125];
      }

      return builder.apply(void 0, ["TypeParameterDeclaration"].concat(args));
    }
    function TypeParameterInstantiation() {
      for (var _len126 = arguments.length, args = new Array(_len126), _key126 = 0; _key126 < _len126; _key126++) {
        args[_key126] = arguments[_key126];
      }

      return builder.apply(void 0, ["TypeParameterInstantiation"].concat(args));
    }
    function UnionTypeAnnotation() {
      for (var _len127 = arguments.length, args = new Array(_len127), _key127 = 0; _key127 < _len127; _key127++) {
        args[_key127] = arguments[_key127];
      }

      return builder.apply(void 0, ["UnionTypeAnnotation"].concat(args));
    }
    function Variance() {
      for (var _len128 = arguments.length, args = new Array(_len128), _key128 = 0; _key128 < _len128; _key128++) {
        args[_key128] = arguments[_key128];
      }

      return builder.apply(void 0, ["Variance"].concat(args));
    }
    function VoidTypeAnnotation() {
      for (var _len129 = arguments.length, args = new Array(_len129), _key129 = 0; _key129 < _len129; _key129++) {
        args[_key129] = arguments[_key129];
      }

      return builder.apply(void 0, ["VoidTypeAnnotation"].concat(args));
    }
    function EnumDeclaration() {
      for (var _len130 = arguments.length, args = new Array(_len130), _key130 = 0; _key130 < _len130; _key130++) {
        args[_key130] = arguments[_key130];
      }

      return builder.apply(void 0, ["EnumDeclaration"].concat(args));
    }
    function EnumBooleanBody() {
      for (var _len131 = arguments.length, args = new Array(_len131), _key131 = 0; _key131 < _len131; _key131++) {
        args[_key131] = arguments[_key131];
      }

      return builder.apply(void 0, ["EnumBooleanBody"].concat(args));
    }
    function EnumNumberBody() {
      for (var _len132 = arguments.length, args = new Array(_len132), _key132 = 0; _key132 < _len132; _key132++) {
        args[_key132] = arguments[_key132];
      }

      return builder.apply(void 0, ["EnumNumberBody"].concat(args));
    }
    function EnumStringBody() {
      for (var _len133 = arguments.length, args = new Array(_len133), _key133 = 0; _key133 < _len133; _key133++) {
        args[_key133] = arguments[_key133];
      }

      return builder.apply(void 0, ["EnumStringBody"].concat(args));
    }
    function EnumSymbolBody() {
      for (var _len134 = arguments.length, args = new Array(_len134), _key134 = 0; _key134 < _len134; _key134++) {
        args[_key134] = arguments[_key134];
      }

      return builder.apply(void 0, ["EnumSymbolBody"].concat(args));
    }
    function EnumBooleanMember() {
      for (var _len135 = arguments.length, args = new Array(_len135), _key135 = 0; _key135 < _len135; _key135++) {
        args[_key135] = arguments[_key135];
      }

      return builder.apply(void 0, ["EnumBooleanMember"].concat(args));
    }
    function EnumNumberMember() {
      for (var _len136 = arguments.length, args = new Array(_len136), _key136 = 0; _key136 < _len136; _key136++) {
        args[_key136] = arguments[_key136];
      }

      return builder.apply(void 0, ["EnumNumberMember"].concat(args));
    }
    function EnumStringMember() {
      for (var _len137 = arguments.length, args = new Array(_len137), _key137 = 0; _key137 < _len137; _key137++) {
        args[_key137] = arguments[_key137];
      }

      return builder.apply(void 0, ["EnumStringMember"].concat(args));
    }
    function EnumDefaultedMember() {
      for (var _len138 = arguments.length, args = new Array(_len138), _key138 = 0; _key138 < _len138; _key138++) {
        args[_key138] = arguments[_key138];
      }

      return builder.apply(void 0, ["EnumDefaultedMember"].concat(args));
    }
    function JSXAttribute() {
      for (var _len139 = arguments.length, args = new Array(_len139), _key139 = 0; _key139 < _len139; _key139++) {
        args[_key139] = arguments[_key139];
      }

      return builder.apply(void 0, ["JSXAttribute"].concat(args));
    }
    function JSXClosingElement() {
      for (var _len140 = arguments.length, args = new Array(_len140), _key140 = 0; _key140 < _len140; _key140++) {
        args[_key140] = arguments[_key140];
      }

      return builder.apply(void 0, ["JSXClosingElement"].concat(args));
    }
    function JSXElement() {
      for (var _len141 = arguments.length, args = new Array(_len141), _key141 = 0; _key141 < _len141; _key141++) {
        args[_key141] = arguments[_key141];
      }

      return builder.apply(void 0, ["JSXElement"].concat(args));
    }
    function JSXEmptyExpression() {
      for (var _len142 = arguments.length, args = new Array(_len142), _key142 = 0; _key142 < _len142; _key142++) {
        args[_key142] = arguments[_key142];
      }

      return builder.apply(void 0, ["JSXEmptyExpression"].concat(args));
    }
    function JSXExpressionContainer() {
      for (var _len143 = arguments.length, args = new Array(_len143), _key143 = 0; _key143 < _len143; _key143++) {
        args[_key143] = arguments[_key143];
      }

      return builder.apply(void 0, ["JSXExpressionContainer"].concat(args));
    }
    function JSXSpreadChild() {
      for (var _len144 = arguments.length, args = new Array(_len144), _key144 = 0; _key144 < _len144; _key144++) {
        args[_key144] = arguments[_key144];
      }

      return builder.apply(void 0, ["JSXSpreadChild"].concat(args));
    }
    function JSXIdentifier() {
      for (var _len145 = arguments.length, args = new Array(_len145), _key145 = 0; _key145 < _len145; _key145++) {
        args[_key145] = arguments[_key145];
      }

      return builder.apply(void 0, ["JSXIdentifier"].concat(args));
    }
    function JSXMemberExpression() {
      for (var _len146 = arguments.length, args = new Array(_len146), _key146 = 0; _key146 < _len146; _key146++) {
        args[_key146] = arguments[_key146];
      }

      return builder.apply(void 0, ["JSXMemberExpression"].concat(args));
    }
    function JSXNamespacedName() {
      for (var _len147 = arguments.length, args = new Array(_len147), _key147 = 0; _key147 < _len147; _key147++) {
        args[_key147] = arguments[_key147];
      }

      return builder.apply(void 0, ["JSXNamespacedName"].concat(args));
    }
    function JSXOpeningElement() {
      for (var _len148 = arguments.length, args = new Array(_len148), _key148 = 0; _key148 < _len148; _key148++) {
        args[_key148] = arguments[_key148];
      }

      return builder.apply(void 0, ["JSXOpeningElement"].concat(args));
    }
    function JSXSpreadAttribute() {
      for (var _len149 = arguments.length, args = new Array(_len149), _key149 = 0; _key149 < _len149; _key149++) {
        args[_key149] = arguments[_key149];
      }

      return builder.apply(void 0, ["JSXSpreadAttribute"].concat(args));
    }
    function JSXText() {
      for (var _len150 = arguments.length, args = new Array(_len150), _key150 = 0; _key150 < _len150; _key150++) {
        args[_key150] = arguments[_key150];
      }

      return builder.apply(void 0, ["JSXText"].concat(args));
    }
    function JSXFragment() {
      for (var _len151 = arguments.length, args = new Array(_len151), _key151 = 0; _key151 < _len151; _key151++) {
        args[_key151] = arguments[_key151];
      }

      return builder.apply(void 0, ["JSXFragment"].concat(args));
    }
    function JSXOpeningFragment() {
      for (var _len152 = arguments.length, args = new Array(_len152), _key152 = 0; _key152 < _len152; _key152++) {
        args[_key152] = arguments[_key152];
      }

      return builder.apply(void 0, ["JSXOpeningFragment"].concat(args));
    }
    function JSXClosingFragment() {
      for (var _len153 = arguments.length, args = new Array(_len153), _key153 = 0; _key153 < _len153; _key153++) {
        args[_key153] = arguments[_key153];
      }

      return builder.apply(void 0, ["JSXClosingFragment"].concat(args));
    }
    function Noop() {
      for (var _len154 = arguments.length, args = new Array(_len154), _key154 = 0; _key154 < _len154; _key154++) {
        args[_key154] = arguments[_key154];
      }

      return builder.apply(void 0, ["Noop"].concat(args));
    }
    function Placeholder() {
      for (var _len155 = arguments.length, args = new Array(_len155), _key155 = 0; _key155 < _len155; _key155++) {
        args[_key155] = arguments[_key155];
      }

      return builder.apply(void 0, ["Placeholder"].concat(args));
    }
    function V8IntrinsicIdentifier() {
      for (var _len156 = arguments.length, args = new Array(_len156), _key156 = 0; _key156 < _len156; _key156++) {
        args[_key156] = arguments[_key156];
      }

      return builder.apply(void 0, ["V8IntrinsicIdentifier"].concat(args));
    }
    function ArgumentPlaceholder() {
      for (var _len157 = arguments.length, args = new Array(_len157), _key157 = 0; _key157 < _len157; _key157++) {
        args[_key157] = arguments[_key157];
      }

      return builder.apply(void 0, ["ArgumentPlaceholder"].concat(args));
    }
    function AwaitExpression() {
      for (var _len158 = arguments.length, args = new Array(_len158), _key158 = 0; _key158 < _len158; _key158++) {
        args[_key158] = arguments[_key158];
      }

      return builder.apply(void 0, ["AwaitExpression"].concat(args));
    }
    function BindExpression() {
      for (var _len159 = arguments.length, args = new Array(_len159), _key159 = 0; _key159 < _len159; _key159++) {
        args[_key159] = arguments[_key159];
      }

      return builder.apply(void 0, ["BindExpression"].concat(args));
    }
    function ClassProperty() {
      for (var _len160 = arguments.length, args = new Array(_len160), _key160 = 0; _key160 < _len160; _key160++) {
        args[_key160] = arguments[_key160];
      }

      return builder.apply(void 0, ["ClassProperty"].concat(args));
    }
    function EventualMemberExpression() {
      for (var _len161 = arguments.length, args = new Array(_len161), _key161 = 0; _key161 < _len161; _key161++) {
        args[_key161] = arguments[_key161];
      }

      return builder.apply(void 0, ["EventualMemberExpression"].concat(args));
    }
    function EventualMemberCallExpression() {
      for (var _len162 = arguments.length, args = new Array(_len162), _key162 = 0; _key162 < _len162; _key162++) {
        args[_key162] = arguments[_key162];
      }

      return builder.apply(void 0, ["EventualMemberCallExpression"].concat(args));
    }
    function OptionalMemberExpression() {
      for (var _len163 = arguments.length, args = new Array(_len163), _key163 = 0; _key163 < _len163; _key163++) {
        args[_key163] = arguments[_key163];
      }

      return builder.apply(void 0, ["OptionalMemberExpression"].concat(args));
    }
    function PipelineTopicExpression() {
      for (var _len164 = arguments.length, args = new Array(_len164), _key164 = 0; _key164 < _len164; _key164++) {
        args[_key164] = arguments[_key164];
      }

      return builder.apply(void 0, ["PipelineTopicExpression"].concat(args));
    }
    function PipelineBareFunction() {
      for (var _len165 = arguments.length, args = new Array(_len165), _key165 = 0; _key165 < _len165; _key165++) {
        args[_key165] = arguments[_key165];
      }

      return builder.apply(void 0, ["PipelineBareFunction"].concat(args));
    }
    function PipelinePrimaryTopicReference() {
      for (var _len166 = arguments.length, args = new Array(_len166), _key166 = 0; _key166 < _len166; _key166++) {
        args[_key166] = arguments[_key166];
      }

      return builder.apply(void 0, ["PipelinePrimaryTopicReference"].concat(args));
    }
    function EventualCallExpression() {
      for (var _len167 = arguments.length, args = new Array(_len167), _key167 = 0; _key167 < _len167; _key167++) {
        args[_key167] = arguments[_key167];
      }

      return builder.apply(void 0, ["EventualCallExpression"].concat(args));
    }
    function OptionalCallExpression() {
      for (var _len168 = arguments.length, args = new Array(_len168), _key168 = 0; _key168 < _len168; _key168++) {
        args[_key168] = arguments[_key168];
      }

      return builder.apply(void 0, ["OptionalCallExpression"].concat(args));
    }
    function ClassPrivateProperty() {
      for (var _len169 = arguments.length, args = new Array(_len169), _key169 = 0; _key169 < _len169; _key169++) {
        args[_key169] = arguments[_key169];
      }

      return builder.apply(void 0, ["ClassPrivateProperty"].concat(args));
    }
    function ClassPrivateMethod() {
      for (var _len170 = arguments.length, args = new Array(_len170), _key170 = 0; _key170 < _len170; _key170++) {
        args[_key170] = arguments[_key170];
      }

      return builder.apply(void 0, ["ClassPrivateMethod"].concat(args));
    }
    function Import() {
      for (var _len171 = arguments.length, args = new Array(_len171), _key171 = 0; _key171 < _len171; _key171++) {
        args[_key171] = arguments[_key171];
      }

      return builder.apply(void 0, ["Import"].concat(args));
    }
    function Decorator() {
      for (var _len172 = arguments.length, args = new Array(_len172), _key172 = 0; _key172 < _len172; _key172++) {
        args[_key172] = arguments[_key172];
      }

      return builder.apply(void 0, ["Decorator"].concat(args));
    }
    function DoExpression() {
      for (var _len173 = arguments.length, args = new Array(_len173), _key173 = 0; _key173 < _len173; _key173++) {
        args[_key173] = arguments[_key173];
      }

      return builder.apply(void 0, ["DoExpression"].concat(args));
    }
    function ExportDefaultSpecifier() {
      for (var _len174 = arguments.length, args = new Array(_len174), _key174 = 0; _key174 < _len174; _key174++) {
        args[_key174] = arguments[_key174];
      }

      return builder.apply(void 0, ["ExportDefaultSpecifier"].concat(args));
    }
    function ExportNamespaceSpecifier() {
      for (var _len175 = arguments.length, args = new Array(_len175), _key175 = 0; _key175 < _len175; _key175++) {
        args[_key175] = arguments[_key175];
      }

      return builder.apply(void 0, ["ExportNamespaceSpecifier"].concat(args));
    }
    function PrivateName() {
      for (var _len176 = arguments.length, args = new Array(_len176), _key176 = 0; _key176 < _len176; _key176++) {
        args[_key176] = arguments[_key176];
      }

      return builder.apply(void 0, ["PrivateName"].concat(args));
    }
    function BigIntLiteral() {
      for (var _len177 = arguments.length, args = new Array(_len177), _key177 = 0; _key177 < _len177; _key177++) {
        args[_key177] = arguments[_key177];
      }

      return builder.apply(void 0, ["BigIntLiteral"].concat(args));
    }
    function RecordExpression() {
      for (var _len178 = arguments.length, args = new Array(_len178), _key178 = 0; _key178 < _len178; _key178++) {
        args[_key178] = arguments[_key178];
      }

      return builder.apply(void 0, ["RecordExpression"].concat(args));
    }
    function TupleExpression() {
      for (var _len179 = arguments.length, args = new Array(_len179), _key179 = 0; _key179 < _len179; _key179++) {
        args[_key179] = arguments[_key179];
      }

      return builder.apply(void 0, ["TupleExpression"].concat(args));
    }
    function TSParameterProperty() {
      for (var _len180 = arguments.length, args = new Array(_len180), _key180 = 0; _key180 < _len180; _key180++) {
        args[_key180] = arguments[_key180];
      }

      return builder.apply(void 0, ["TSParameterProperty"].concat(args));
    }
    function TSDeclareFunction() {
      for (var _len181 = arguments.length, args = new Array(_len181), _key181 = 0; _key181 < _len181; _key181++) {
        args[_key181] = arguments[_key181];
      }

      return builder.apply(void 0, ["TSDeclareFunction"].concat(args));
    }
    function TSDeclareMethod() {
      for (var _len182 = arguments.length, args = new Array(_len182), _key182 = 0; _key182 < _len182; _key182++) {
        args[_key182] = arguments[_key182];
      }

      return builder.apply(void 0, ["TSDeclareMethod"].concat(args));
    }
    function TSQualifiedName() {
      for (var _len183 = arguments.length, args = new Array(_len183), _key183 = 0; _key183 < _len183; _key183++) {
        args[_key183] = arguments[_key183];
      }

      return builder.apply(void 0, ["TSQualifiedName"].concat(args));
    }
    function TSCallSignatureDeclaration() {
      for (var _len184 = arguments.length, args = new Array(_len184), _key184 = 0; _key184 < _len184; _key184++) {
        args[_key184] = arguments[_key184];
      }

      return builder.apply(void 0, ["TSCallSignatureDeclaration"].concat(args));
    }
    function TSConstructSignatureDeclaration() {
      for (var _len185 = arguments.length, args = new Array(_len185), _key185 = 0; _key185 < _len185; _key185++) {
        args[_key185] = arguments[_key185];
      }

      return builder.apply(void 0, ["TSConstructSignatureDeclaration"].concat(args));
    }
    function TSPropertySignature() {
      for (var _len186 = arguments.length, args = new Array(_len186), _key186 = 0; _key186 < _len186; _key186++) {
        args[_key186] = arguments[_key186];
      }

      return builder.apply(void 0, ["TSPropertySignature"].concat(args));
    }
    function TSMethodSignature() {
      for (var _len187 = arguments.length, args = new Array(_len187), _key187 = 0; _key187 < _len187; _key187++) {
        args[_key187] = arguments[_key187];
      }

      return builder.apply(void 0, ["TSMethodSignature"].concat(args));
    }
    function TSIndexSignature() {
      for (var _len188 = arguments.length, args = new Array(_len188), _key188 = 0; _key188 < _len188; _key188++) {
        args[_key188] = arguments[_key188];
      }

      return builder.apply(void 0, ["TSIndexSignature"].concat(args));
    }
    function TSAnyKeyword() {
      for (var _len189 = arguments.length, args = new Array(_len189), _key189 = 0; _key189 < _len189; _key189++) {
        args[_key189] = arguments[_key189];
      }

      return builder.apply(void 0, ["TSAnyKeyword"].concat(args));
    }
    function TSBooleanKeyword() {
      for (var _len190 = arguments.length, args = new Array(_len190), _key190 = 0; _key190 < _len190; _key190++) {
        args[_key190] = arguments[_key190];
      }

      return builder.apply(void 0, ["TSBooleanKeyword"].concat(args));
    }
    function TSBigIntKeyword() {
      for (var _len191 = arguments.length, args = new Array(_len191), _key191 = 0; _key191 < _len191; _key191++) {
        args[_key191] = arguments[_key191];
      }

      return builder.apply(void 0, ["TSBigIntKeyword"].concat(args));
    }
    function TSNeverKeyword() {
      for (var _len192 = arguments.length, args = new Array(_len192), _key192 = 0; _key192 < _len192; _key192++) {
        args[_key192] = arguments[_key192];
      }

      return builder.apply(void 0, ["TSNeverKeyword"].concat(args));
    }
    function TSNullKeyword() {
      for (var _len193 = arguments.length, args = new Array(_len193), _key193 = 0; _key193 < _len193; _key193++) {
        args[_key193] = arguments[_key193];
      }

      return builder.apply(void 0, ["TSNullKeyword"].concat(args));
    }
    function TSNumberKeyword() {
      for (var _len194 = arguments.length, args = new Array(_len194), _key194 = 0; _key194 < _len194; _key194++) {
        args[_key194] = arguments[_key194];
      }

      return builder.apply(void 0, ["TSNumberKeyword"].concat(args));
    }
    function TSObjectKeyword() {
      for (var _len195 = arguments.length, args = new Array(_len195), _key195 = 0; _key195 < _len195; _key195++) {
        args[_key195] = arguments[_key195];
      }

      return builder.apply(void 0, ["TSObjectKeyword"].concat(args));
    }
    function TSStringKeyword() {
      for (var _len196 = arguments.length, args = new Array(_len196), _key196 = 0; _key196 < _len196; _key196++) {
        args[_key196] = arguments[_key196];
      }

      return builder.apply(void 0, ["TSStringKeyword"].concat(args));
    }
    function TSSymbolKeyword() {
      for (var _len197 = arguments.length, args = new Array(_len197), _key197 = 0; _key197 < _len197; _key197++) {
        args[_key197] = arguments[_key197];
      }

      return builder.apply(void 0, ["TSSymbolKeyword"].concat(args));
    }
    function TSUndefinedKeyword() {
      for (var _len198 = arguments.length, args = new Array(_len198), _key198 = 0; _key198 < _len198; _key198++) {
        args[_key198] = arguments[_key198];
      }

      return builder.apply(void 0, ["TSUndefinedKeyword"].concat(args));
    }
    function TSUnknownKeyword() {
      for (var _len199 = arguments.length, args = new Array(_len199), _key199 = 0; _key199 < _len199; _key199++) {
        args[_key199] = arguments[_key199];
      }

      return builder.apply(void 0, ["TSUnknownKeyword"].concat(args));
    }
    function TSVoidKeyword() {
      for (var _len200 = arguments.length, args = new Array(_len200), _key200 = 0; _key200 < _len200; _key200++) {
        args[_key200] = arguments[_key200];
      }

      return builder.apply(void 0, ["TSVoidKeyword"].concat(args));
    }
    function TSThisType() {
      for (var _len201 = arguments.length, args = new Array(_len201), _key201 = 0; _key201 < _len201; _key201++) {
        args[_key201] = arguments[_key201];
      }

      return builder.apply(void 0, ["TSThisType"].concat(args));
    }
    function TSFunctionType() {
      for (var _len202 = arguments.length, args = new Array(_len202), _key202 = 0; _key202 < _len202; _key202++) {
        args[_key202] = arguments[_key202];
      }

      return builder.apply(void 0, ["TSFunctionType"].concat(args));
    }
    function TSConstructorType() {
      for (var _len203 = arguments.length, args = new Array(_len203), _key203 = 0; _key203 < _len203; _key203++) {
        args[_key203] = arguments[_key203];
      }

      return builder.apply(void 0, ["TSConstructorType"].concat(args));
    }
    function TSTypeReference() {
      for (var _len204 = arguments.length, args = new Array(_len204), _key204 = 0; _key204 < _len204; _key204++) {
        args[_key204] = arguments[_key204];
      }

      return builder.apply(void 0, ["TSTypeReference"].concat(args));
    }
    function TSTypePredicate() {
      for (var _len205 = arguments.length, args = new Array(_len205), _key205 = 0; _key205 < _len205; _key205++) {
        args[_key205] = arguments[_key205];
      }

      return builder.apply(void 0, ["TSTypePredicate"].concat(args));
    }
    function TSTypeQuery() {
      for (var _len206 = arguments.length, args = new Array(_len206), _key206 = 0; _key206 < _len206; _key206++) {
        args[_key206] = arguments[_key206];
      }

      return builder.apply(void 0, ["TSTypeQuery"].concat(args));
    }
    function TSTypeLiteral() {
      for (var _len207 = arguments.length, args = new Array(_len207), _key207 = 0; _key207 < _len207; _key207++) {
        args[_key207] = arguments[_key207];
      }

      return builder.apply(void 0, ["TSTypeLiteral"].concat(args));
    }
    function TSArrayType() {
      for (var _len208 = arguments.length, args = new Array(_len208), _key208 = 0; _key208 < _len208; _key208++) {
        args[_key208] = arguments[_key208];
      }

      return builder.apply(void 0, ["TSArrayType"].concat(args));
    }
    function TSTupleType() {
      for (var _len209 = arguments.length, args = new Array(_len209), _key209 = 0; _key209 < _len209; _key209++) {
        args[_key209] = arguments[_key209];
      }

      return builder.apply(void 0, ["TSTupleType"].concat(args));
    }
    function TSOptionalType() {
      for (var _len210 = arguments.length, args = new Array(_len210), _key210 = 0; _key210 < _len210; _key210++) {
        args[_key210] = arguments[_key210];
      }

      return builder.apply(void 0, ["TSOptionalType"].concat(args));
    }
    function TSRestType() {
      for (var _len211 = arguments.length, args = new Array(_len211), _key211 = 0; _key211 < _len211; _key211++) {
        args[_key211] = arguments[_key211];
      }

      return builder.apply(void 0, ["TSRestType"].concat(args));
    }
    function TSUnionType() {
      for (var _len212 = arguments.length, args = new Array(_len212), _key212 = 0; _key212 < _len212; _key212++) {
        args[_key212] = arguments[_key212];
      }

      return builder.apply(void 0, ["TSUnionType"].concat(args));
    }
    function TSIntersectionType() {
      for (var _len213 = arguments.length, args = new Array(_len213), _key213 = 0; _key213 < _len213; _key213++) {
        args[_key213] = arguments[_key213];
      }

      return builder.apply(void 0, ["TSIntersectionType"].concat(args));
    }
    function TSConditionalType() {
      for (var _len214 = arguments.length, args = new Array(_len214), _key214 = 0; _key214 < _len214; _key214++) {
        args[_key214] = arguments[_key214];
      }

      return builder.apply(void 0, ["TSConditionalType"].concat(args));
    }
    function TSInferType() {
      for (var _len215 = arguments.length, args = new Array(_len215), _key215 = 0; _key215 < _len215; _key215++) {
        args[_key215] = arguments[_key215];
      }

      return builder.apply(void 0, ["TSInferType"].concat(args));
    }
    function TSParenthesizedType() {
      for (var _len216 = arguments.length, args = new Array(_len216), _key216 = 0; _key216 < _len216; _key216++) {
        args[_key216] = arguments[_key216];
      }

      return builder.apply(void 0, ["TSParenthesizedType"].concat(args));
    }
    function TSTypeOperator() {
      for (var _len217 = arguments.length, args = new Array(_len217), _key217 = 0; _key217 < _len217; _key217++) {
        args[_key217] = arguments[_key217];
      }

      return builder.apply(void 0, ["TSTypeOperator"].concat(args));
    }
    function TSIndexedAccessType() {
      for (var _len218 = arguments.length, args = new Array(_len218), _key218 = 0; _key218 < _len218; _key218++) {
        args[_key218] = arguments[_key218];
      }

      return builder.apply(void 0, ["TSIndexedAccessType"].concat(args));
    }
    function TSMappedType() {
      for (var _len219 = arguments.length, args = new Array(_len219), _key219 = 0; _key219 < _len219; _key219++) {
        args[_key219] = arguments[_key219];
      }

      return builder.apply(void 0, ["TSMappedType"].concat(args));
    }
    function TSLiteralType() {
      for (var _len220 = arguments.length, args = new Array(_len220), _key220 = 0; _key220 < _len220; _key220++) {
        args[_key220] = arguments[_key220];
      }

      return builder.apply(void 0, ["TSLiteralType"].concat(args));
    }
    function TSExpressionWithTypeArguments() {
      for (var _len221 = arguments.length, args = new Array(_len221), _key221 = 0; _key221 < _len221; _key221++) {
        args[_key221] = arguments[_key221];
      }

      return builder.apply(void 0, ["TSExpressionWithTypeArguments"].concat(args));
    }
    function TSInterfaceDeclaration() {
      for (var _len222 = arguments.length, args = new Array(_len222), _key222 = 0; _key222 < _len222; _key222++) {
        args[_key222] = arguments[_key222];
      }

      return builder.apply(void 0, ["TSInterfaceDeclaration"].concat(args));
    }
    function TSInterfaceBody() {
      for (var _len223 = arguments.length, args = new Array(_len223), _key223 = 0; _key223 < _len223; _key223++) {
        args[_key223] = arguments[_key223];
      }

      return builder.apply(void 0, ["TSInterfaceBody"].concat(args));
    }
    function TSTypeAliasDeclaration() {
      for (var _len224 = arguments.length, args = new Array(_len224), _key224 = 0; _key224 < _len224; _key224++) {
        args[_key224] = arguments[_key224];
      }

      return builder.apply(void 0, ["TSTypeAliasDeclaration"].concat(args));
    }
    function TSAsExpression() {
      for (var _len225 = arguments.length, args = new Array(_len225), _key225 = 0; _key225 < _len225; _key225++) {
        args[_key225] = arguments[_key225];
      }

      return builder.apply(void 0, ["TSAsExpression"].concat(args));
    }
    function TSTypeAssertion() {
      for (var _len226 = arguments.length, args = new Array(_len226), _key226 = 0; _key226 < _len226; _key226++) {
        args[_key226] = arguments[_key226];
      }

      return builder.apply(void 0, ["TSTypeAssertion"].concat(args));
    }
    function TSEnumDeclaration() {
      for (var _len227 = arguments.length, args = new Array(_len227), _key227 = 0; _key227 < _len227; _key227++) {
        args[_key227] = arguments[_key227];
      }

      return builder.apply(void 0, ["TSEnumDeclaration"].concat(args));
    }
    function TSEnumMember() {
      for (var _len228 = arguments.length, args = new Array(_len228), _key228 = 0; _key228 < _len228; _key228++) {
        args[_key228] = arguments[_key228];
      }

      return builder.apply(void 0, ["TSEnumMember"].concat(args));
    }
    function TSModuleDeclaration() {
      for (var _len229 = arguments.length, args = new Array(_len229), _key229 = 0; _key229 < _len229; _key229++) {
        args[_key229] = arguments[_key229];
      }

      return builder.apply(void 0, ["TSModuleDeclaration"].concat(args));
    }
    function TSModuleBlock() {
      for (var _len230 = arguments.length, args = new Array(_len230), _key230 = 0; _key230 < _len230; _key230++) {
        args[_key230] = arguments[_key230];
      }

      return builder.apply(void 0, ["TSModuleBlock"].concat(args));
    }
    function TSImportType() {
      for (var _len231 = arguments.length, args = new Array(_len231), _key231 = 0; _key231 < _len231; _key231++) {
        args[_key231] = arguments[_key231];
      }

      return builder.apply(void 0, ["TSImportType"].concat(args));
    }
    function TSImportEqualsDeclaration() {
      for (var _len232 = arguments.length, args = new Array(_len232), _key232 = 0; _key232 < _len232; _key232++) {
        args[_key232] = arguments[_key232];
      }

      return builder.apply(void 0, ["TSImportEqualsDeclaration"].concat(args));
    }
    function TSExternalModuleReference() {
      for (var _len233 = arguments.length, args = new Array(_len233), _key233 = 0; _key233 < _len233; _key233++) {
        args[_key233] = arguments[_key233];
      }

      return builder.apply(void 0, ["TSExternalModuleReference"].concat(args));
    }
    function TSNonNullExpression() {
      for (var _len234 = arguments.length, args = new Array(_len234), _key234 = 0; _key234 < _len234; _key234++) {
        args[_key234] = arguments[_key234];
      }

      return builder.apply(void 0, ["TSNonNullExpression"].concat(args));
    }
    function TSExportAssignment() {
      for (var _len235 = arguments.length, args = new Array(_len235), _key235 = 0; _key235 < _len235; _key235++) {
        args[_key235] = arguments[_key235];
      }

      return builder.apply(void 0, ["TSExportAssignment"].concat(args));
    }
    function TSNamespaceExportDeclaration() {
      for (var _len236 = arguments.length, args = new Array(_len236), _key236 = 0; _key236 < _len236; _key236++) {
        args[_key236] = arguments[_key236];
      }

      return builder.apply(void 0, ["TSNamespaceExportDeclaration"].concat(args));
    }
    function TSTypeAnnotation() {
      for (var _len237 = arguments.length, args = new Array(_len237), _key237 = 0; _key237 < _len237; _key237++) {
        args[_key237] = arguments[_key237];
      }

      return builder.apply(void 0, ["TSTypeAnnotation"].concat(args));
    }
    function TSTypeParameterInstantiation() {
      for (var _len238 = arguments.length, args = new Array(_len238), _key238 = 0; _key238 < _len238; _key238++) {
        args[_key238] = arguments[_key238];
      }

      return builder.apply(void 0, ["TSTypeParameterInstantiation"].concat(args));
    }
    function TSTypeParameterDeclaration() {
      for (var _len239 = arguments.length, args = new Array(_len239), _key239 = 0; _key239 < _len239; _key239++) {
        args[_key239] = arguments[_key239];
      }

      return builder.apply(void 0, ["TSTypeParameterDeclaration"].concat(args));
    }
    function TSTypeParameter() {
      for (var _len240 = arguments.length, args = new Array(_len240), _key240 = 0; _key240 < _len240; _key240++) {
        args[_key240] = arguments[_key240];
      }

      return builder.apply(void 0, ["TSTypeParameter"].concat(args));
    }
    function NumberLiteral() {
      console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

      for (var _len241 = arguments.length, args = new Array(_len241), _key241 = 0; _key241 < _len241; _key241++) {
        args[_key241] = arguments[_key241];
      }

      return NumberLiteral.apply(void 0, ["NumberLiteral"].concat(args));
    }
    function RegexLiteral() {
      console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

      for (var _len242 = arguments.length, args = new Array(_len242), _key242 = 0; _key242 < _len242; _key242++) {
        args[_key242] = arguments[_key242];
      }

      return RegexLiteral.apply(void 0, ["RegexLiteral"].concat(args));
    }
    function RestProperty() {
      console.trace("The node type RestProperty has been renamed to RestElement");

      for (var _len243 = arguments.length, args = new Array(_len243), _key243 = 0; _key243 < _len243; _key243++) {
        args[_key243] = arguments[_key243];
      }

      return RestProperty.apply(void 0, ["RestProperty"].concat(args));
    }
    function SpreadProperty() {
      console.trace("The node type SpreadProperty has been renamed to SpreadElement");

      for (var _len244 = arguments.length, args = new Array(_len244), _key244 = 0; _key244 < _len244; _key244++) {
        args[_key244] = arguments[_key244];
      }

      return SpreadProperty.apply(void 0, ["SpreadProperty"].concat(args));
    }

    function cleanJSXElementLiteralChild(child, args) {
      var lines = child.value.split(/\r\n|\n|\r/);
      var lastNonEmptyLine = 0;

      for (var i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }

      var str = "";

      for (var _i = 0; _i < lines.length; _i++) {
        var line = lines[_i];
        var isFirstLine = _i === 0;
        var isLastLine = _i === lines.length - 1;
        var isLastNonEmptyLine = _i === lastNonEmptyLine;
        var trimmedLine = line.replace(/\t/g, " ");

        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }

        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }

        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }

          str += trimmedLine;
        }
      }

      if (str) args.push(StringLiteral(str));
    }

    function buildChildren(node) {
      var elements = [];

      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];

        if (isJSXText(child)) {
          cleanJSXElementLiteralChild(child, elements);
          continue;
        }

        if (isJSXExpressionContainer(child)) child = child.expression;
        if (isJSXEmptyExpression(child)) continue;
        elements.push(child);
      }

      return elements;
    }

    function isNode(node) {
      return !!(node && VISITOR_KEYS[node.type]);
    }

    function assertNode(node) {
      if (!isNode(node)) {
        var type = node && node.type || JSON.stringify(node);
        throw new TypeError("Not a valid node of type \"" + type + "\"");
      }
    }

    function assert(type, node, opts) {
      if (!is(type, node, opts)) {
        throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", " + ("but instead got \"" + node.type + "\"."));
      }
    }

    function assertArrayExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ImportSpecifier", node, opts);
    }
    function assertMetaProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("YieldExpression", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumDefaultedMember", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ArgumentPlaceholder", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("AwaitExpression", node, opts);
    }
    function assertBindExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BindExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassProperty", node, opts);
    }
    function assertEventualMemberExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EventualMemberExpression", node, opts);
    }
    function assertEventualMemberCallExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EventualMemberCallExpression", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("OptionalMemberExpression", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertEventualCallExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EventualCallExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("OptionalCallExpression", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ClassPrivateMethod", node, opts);
    }
    function assertImport(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Import", node, opts);
    }
    function assertDecorator(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertPrivateName(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("PrivateName", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BigIntLiteral", node, opts);
    }
    function assertRecordExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TupleExpression", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSRestType", node, opts);
    }
    function assertTSUnionType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSMappedType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSAsExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeParameter", node, opts);
    }
    function assertExpression(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Class", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ModuleDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("ModuleSpecifier", node, opts);
    }
    function assertFlow(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("JSX", node, opts);
    }
    function assertPrivate(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("Private", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      console.trace("The node type RestProperty has been renamed to RestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      console.trace("The node type SpreadProperty has been renamed to SpreadElement");
      assert("SpreadProperty", node, opts);
    }

    function createTypeAnnotationBasedOnTypeof(type) {
      if (type === "string") {
        return StringTypeAnnotation();
      } else if (type === "number") {
        return NumberTypeAnnotation();
      } else if (type === "undefined") {
        return VoidTypeAnnotation();
      } else if (type === "boolean") {
        return BooleanTypeAnnotation();
      } else if (type === "function") {
        return GenericTypeAnnotation(Identifier("Function"));
      } else if (type === "object") {
        return GenericTypeAnnotation(Identifier("Object"));
      } else if (type === "symbol") {
        return GenericTypeAnnotation(Identifier("Symbol"));
      } else {
        throw new Error("Invalid typeof value");
      }
    }

    function removeTypeDuplicates(nodes) {
      var generics = {};
      var bases = {};
      var typeGroups = [];
      var types = [];

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;

        if (types.indexOf(node) >= 0) {
          continue;
        }

        if (isAnyTypeAnnotation(node)) {
          return [node];
        }

        if (isFlowBaseAnnotation(node)) {
          bases[node.type] = node;
          continue;
        }

        if (isUnionTypeAnnotation(node)) {
          if (typeGroups.indexOf(node.types) < 0) {
            nodes = nodes.concat(node.types);
            typeGroups.push(node.types);
          }

          continue;
        }

        if (isGenericTypeAnnotation(node)) {
          var name = node.id.name;

          if (generics[name]) {
            var existing = generics[name];

            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics[name] = node;
          }

          continue;
        }

        types.push(node);
      }

      for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
        var type = _Object$keys[_i];
        types.push(bases[type]);
      }

      for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
        var _name = _Object$keys2[_i2];
        types.push(generics[_name]);
      }

      return types;
    }

    function createFlowUnionType(types) {
      var flattened = removeTypeDuplicates(types);

      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return UnionTypeAnnotation(flattened);
      }
    }

    function removeTypeDuplicates$1(nodes) {
      var generics = {};
      var bases = {};
      var typeGroups = [];
      var types = [];

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;

        if (types.indexOf(node) >= 0) {
          continue;
        }

        if (isTSAnyKeyword(node.type)) {
          return [node];
        }

        if (isTSBaseType(node)) {
          bases[node.type] = node;
          continue;
        }

        if (isTSUnionType(node)) {
          if (typeGroups.indexOf(node.types) < 0) {
            nodes = nodes.concat(node.types);
            typeGroups.push(node.types);
          }

          continue;
        }

        types.push(node);
      }

      for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
        var type = _Object$keys[_i];
        types.push(bases[type]);
      }

      for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
        var name = _Object$keys2[_i2];
        types.push(generics[name]);
      }

      return types;
    }

    function createTSUnionType(typeAnnotations) {
      var types = typeAnnotations.map(function (type) {
        return type.typeAnnotations;
      });
      var flattened = removeTypeDuplicates$1(types);

      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return TSUnionType(flattened);
      }
    }

    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    function cloneIfNode(obj, deep, withoutLoc) {
      if (obj && typeof obj.type === "string") {
        return cloneNode(obj, deep, withoutLoc);
      }

      return obj;
    }

    function cloneIfNodeOrArray(obj, deep, withoutLoc) {
      if (Array.isArray(obj)) {
        return obj.map(function (node) {
          return cloneIfNode(node, deep, withoutLoc);
        });
      }

      return cloneIfNode(obj, deep, withoutLoc);
    }

    function cloneNode(node, deep, withoutLoc) {
      if (deep === void 0) {
        deep = true;
      }

      if (withoutLoc === void 0) {
        withoutLoc = false;
      }

      if (!node) return node;
      var type = node.type;
      var newNode = {
        type: type
      };

      if (type === "Identifier") {
        newNode.name = node.name;

        if (has(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }

        if (has(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
        }
      } else if (!has(NODE_FIELDS, type)) {
        throw new Error("Unknown node type: \"" + type + "\"");
      } else {
        for (var _i = 0, _Object$keys = Object.keys(NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
          var field = _Object$keys[_i];

          if (has(node, field)) {
            if (deep) {
              newNode[field] = type === "File" && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }

      if (has(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }

      if (has(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
      }

      if (has(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
      }

      if (has(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
      }

      if (has(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }

      return newNode;
    }

    function cloneCommentsWithoutLoc(comments) {
      return comments.map(function (_ref) {
        var type = _ref.type,
            value = _ref.value;
        return {
          type: type,
          value: value,
          loc: null
        };
      });
    }

    function maybeCloneComments(comments, deep, withoutLoc) {
      return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;
    }

    function clone$1(node) {
      return cloneNode(node, false);
    }

    function cloneDeep(node) {
      return cloneNode(node);
    }

    function cloneDeepWithoutLoc(node) {
      return cloneNode(node, true, true);
    }

    function cloneWithoutLoc(node) {
      return cloneNode(node, false, true);
    }

    function addComments(node, type, comments) {
      if (!comments || !node) return node;
      var key = type + "Comments";

      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key] = node[key].concat(comments);
        }
      } else {
        node[key] = comments;
      }

      return node;
    }

    function addComment(node, type, content, line) {
      return addComments(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }

    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED$2);

      return this;
    }

    var _setCacheAdd = setCacheAdd;

    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas;

    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;
      this.__data__ = new _MapCache();

      while (++index < length) {
        this.add(values[index]);
      }
    }

    SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
    SetCache.prototype.has = _setCacheHas;
    var _SetCache = SetCache;

    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }

      return -1;
    }

    var _baseFindIndex = baseFindIndex;

    function baseIsNaN(value) {
      return value !== value;
    }

    var _baseIsNaN = baseIsNaN;

    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }

      return -1;
    }

    var _strictIndexOf = strictIndexOf;

    function baseIndexOf(array, value, fromIndex) {
      return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
    }

    var _baseIndexOf = baseIndexOf;

    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && _baseIndexOf(array, value, 0) > -1;
    }

    var _arrayIncludes = arrayIncludes;

    function arrayIncludesWith(array, value, comparator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }

      return false;
    }

    var _arrayIncludesWith = arrayIncludesWith;

    function cacheHas(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas;

    function noop$1() {}

    var noop_1 = noop$1;

    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray;

    var INFINITY = 1 / 0;
    var createSet = !(_Set && 1 / _setToArray(new _Set([, -0]))[1] == INFINITY) ? noop_1 : function (values) {
      return new _Set(values);
    };
    var _createSet = createSet;

    var LARGE_ARRAY_SIZE$1 = 200;

    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = _arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = _arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE$1) {
        var set = iteratee ? null : _createSet(array);

        if (set) {
          return _setToArray(set);
        }

        isCommon = false;
        includes = _cacheHas;
        seen = new _SetCache();
      } else {
        seen = iteratee ? [] : result;
      }

      outer: while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;

        if (isCommon && computed === computed) {
          var seenIndex = seen.length;

          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }

          if (iteratee) {
            seen.push(computed);
          }

          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }

          result.push(value);
        }
      }

      return result;
    }

    var _baseUniq = baseUniq;

    function uniq(array) {
      return array && array.length ? _baseUniq(array) : [];
    }

    var uniq_1 = uniq;

    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = uniq_1([].concat(child[key], parent[key]).filter(Boolean));
      }
    }

    function inheritInnerComments(child, parent) {
      inherit("innerComments", child, parent);
    }

    function inheritLeadingComments(child, parent) {
      inherit("leadingComments", child, parent);
    }

    function inheritTrailingComments(child, parent) {
      inherit("trailingComments", child, parent);
    }

    function inheritsComments(child, parent) {
      inheritTrailingComments(child, parent);
      inheritLeadingComments(child, parent);
      inheritInnerComments(child, parent);
      return child;
    }

    function removeComments(node) {
      COMMENT_KEYS.forEach(function (key) {
        node[key] = null;
      });
      return node;
    }

    var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS["Expression"];
    var BINARY_TYPES = FLIPPED_ALIAS_KEYS["Binary"];
    var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS["Scopable"];
    var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS["BlockParent"];
    var BLOCK_TYPES = FLIPPED_ALIAS_KEYS["Block"];
    var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS["Statement"];
    var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS["Terminatorless"];
    var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["CompletionStatement"];
    var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS["Conditional"];
    var LOOP_TYPES = FLIPPED_ALIAS_KEYS["Loop"];
    var WHILE_TYPES = FLIPPED_ALIAS_KEYS["While"];
    var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    var FOR_TYPES = FLIPPED_ALIAS_KEYS["For"];
    var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["ForXStatement"];
    var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS["Function"];
    var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS["FunctionParent"];
    var PUREISH_TYPES = FLIPPED_ALIAS_KEYS["Pureish"];
    var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS["Declaration"];
    var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS["PatternLike"];
    var LVAL_TYPES = FLIPPED_ALIAS_KEYS["LVal"];
    var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS["TSEntityName"];
    var LITERAL_TYPES = FLIPPED_ALIAS_KEYS["Literal"];
    var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS["Immutable"];
    var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    var METHOD_TYPES = FLIPPED_ALIAS_KEYS["Method"];
    var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS["ObjectMember"];
    var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS["Property"];
    var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS["UnaryLike"];
    var PATTERN_TYPES = FLIPPED_ALIAS_KEYS["Pattern"];
    var CLASS_TYPES = FLIPPED_ALIAS_KEYS["Class"];
    var MODULEDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
    var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    var FLOW_TYPES = FLIPPED_ALIAS_KEYS["Flow"];
    var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS["FlowType"];
    var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS["FlowPredicate"];
    var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS["EnumBody"];
    var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS["EnumMember"];
    var JSX_TYPES = FLIPPED_ALIAS_KEYS["JSX"];
    var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS["Private"];
    var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS["TSTypeElement"];
    var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS["TSType"];
    var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS["TSBaseType"];

    function toBlock(node, parent) {
      if (isBlockStatement(node)) {
        return node;
      }

      var blockNodes = [];

      if (isEmptyStatement(node)) {
        blockNodes = [];
      } else {
        if (!isStatement(node)) {
          if (isFunction(parent)) {
            node = ReturnStatement(node);
          } else {
            node = ExpressionStatement(node);
          }
        }

        blockNodes = [node];
      }

      return BlockStatement(blockNodes);
    }

    function ensureBlock(node, key) {
      if (key === void 0) {
        key = "body";
      }

      return node[key] = toBlock(node[key], node);
    }

    function toIdentifier(name) {
      name = name + "";
      name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function (match, c) {
        return c ? c.toUpperCase() : "";
      });

      if (!isValidIdentifier(name)) {
        name = "_" + name;
      }

      return name || "_";
    }

    function toBindingIdentifierName(name) {
      name = toIdentifier(name);
      if (name === "eval" || name === "arguments") name = "_" + name;
      return name;
    }

    function toComputedKey(node, key) {
      if (key === void 0) {
        key = node.key || node.property;
      }

      if (!node.computed && isIdentifier(key)) key = StringLiteral(key.name);
      return key;
    }

    function toExpression(node) {
      if (isExpressionStatement(node)) {
        node = node.expression;
      }

      if (isExpression(node)) {
        return node;
      }

      if (isClass(node)) {
        node.type = "ClassExpression";
      } else if (isFunction(node)) {
        node.type = "FunctionExpression";
      }

      if (!isExpression(node)) {
        throw new Error("cannot turn " + node.type + " to an expression");
      }

      return node;
    }

    function traverseFast(node, enter, opts) {
      if (!node) return;
      var keys = VISITOR_KEYS[node.type];
      if (!keys) return;
      opts = opts || {};
      enter(node, opts);

      for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        var subNode = node[key];

        if (Array.isArray(subNode)) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(subNode), _step2; !(_step2 = _iterator2()).done;) {
            var _node = _step2.value;
            traverseFast(_node, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }

    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
    function removeProperties(node, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

      for (var _iterator = _createForOfIteratorHelperLoose(map), _step; !(_step = _iterator()).done;) {
        var _key = _step.value;
        if (node[_key] != null) node[_key] = undefined;
      }

      for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (key[0] === "_" && node[key] != null) node[key] = undefined;
      }

      var symbols = Object.getOwnPropertySymbols(node);

      for (var _iterator2 = _createForOfIteratorHelperLoose(symbols), _step2; !(_step2 = _iterator2()).done;) {
        var sym = _step2.value;
        node[sym] = null;
      }
    }

    function removePropertiesDeep(tree, opts) {
      traverseFast(tree, removeProperties, opts);
      return tree;
    }

    function toKeyAlias(node, key) {
      if (key === void 0) {
        key = node.key;
      }

      var alias;

      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if (isIdentifier(key)) {
        alias = key.name;
      } else if (isStringLiteral(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));
      }

      if (node.computed) {
        alias = "[" + alias + "]";
      }

      if (node["static"]) {
        alias = "static:" + alias;
      }

      return alias;
    }
    toKeyAlias.uid = 0;

    toKeyAlias.increment = function () {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };

    function getBindingIdentifiers(node, duplicates, outerOnly) {
      var search = [].concat(node);
      var ids = Object.create(null);

      while (search.length) {
        var id = search.shift();
        if (!id) continue;
        var keys = getBindingIdentifiers.keys[id.type];

        if (isIdentifier(id)) {
          if (duplicates) {
            var _ids = ids[id.name] = ids[id.name] || [];

            _ids.push(id);
          } else {
            ids[id.name] = id;
          }

          continue;
        }

        if (isExportDeclaration(id)) {
          if (isDeclaration(id.declaration)) {
            search.push(id.declaration);
          }

          continue;
        }

        if (outerOnly) {
          if (isFunctionDeclaration(id)) {
            search.push(id.id);
            continue;
          }

          if (isFunctionExpression(id)) {
            continue;
          }
        }

        if (keys) {
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];

            if (id[key]) {
              search = search.concat(id[key]);
            }
          }
        }
      }

      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };

    function gatherSequenceExpressions(nodes, scope, declars) {
      var exprs = [];
      var ensureLastUndefined = true;

      for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {
        var node = _step.value;
        ensureLastUndefined = false;

        if (isExpression(node)) {
          exprs.push(node);
        } else if (isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (isVariableDeclaration(node)) {
          if (node.kind !== "var") return;

          for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
            var declar = _arr[_i];
            var bindings = getBindingIdentifiers(declar);

            for (var _i2 = 0, _Object$keys = Object.keys(bindings); _i2 < _Object$keys.length; _i2++) {
              var key = _Object$keys[_i2];
              declars.push({
                kind: node.kind,
                id: cloneNode(bindings[key])
              });
            }

            if (declar.init) {
              exprs.push(AssignmentExpression("=", declar.id, declar.init));
            }
          }

          ensureLastUndefined = true;
        } else if (isIfStatement(node)) {
          var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
          var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(ConditionalExpression(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          var body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node)) {
          ensureLastUndefined = true;
        } else {
          return;
        }
      }

      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }

      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return SequenceExpression(exprs);
      }
    }

    function toSequenceExpression(nodes, scope) {
      if (!nodes || !nodes.length) return;
      var declars = [];
      var result = gatherSequenceExpressions(nodes, scope, declars);
      if (!result) return;

      for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
        var declar = _declars[_i];
        scope.push(declar);
      }

      return result;
    }

    function toStatement(node, ignore) {
      if (isStatement(node)) {
        return node;
      }

      var mustHaveId = false;
      var newType;

      if (isClass(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if (isFunction(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if (isAssignmentExpression(node)) {
        return ExpressionStatement(node);
      }

      if (mustHaveId && !node.id) {
        newType = false;
      }

      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error("cannot turn " + node.type + " to a statement");
        }
      }

      node.type = newType;
      return node;
    }

    var objectTag$3 = '[object Object]';
    var funcProto$2 = Function.prototype,
        objectProto$d = Object.prototype;
    var funcToString$2 = funcProto$2.toString;
    var hasOwnProperty$a = objectProto$d.hasOwnProperty;
    var objectCtorString = funcToString$2.call(Object);

    function isPlainObject(value) {
      if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
        return false;
      }

      var proto = _getPrototype(value);

      if (proto === null) {
        return true;
      }

      var Ctor = hasOwnProperty$a.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
    }

    var isPlainObject_1 = isPlainObject;

    var regexpTag$3 = '[object RegExp]';

    function baseIsRegExp(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == regexpTag$3;
    }

    var _baseIsRegExp = baseIsRegExp;

    var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;
    var isRegExp_1 = isRegExp;

    function valueToNode(value) {
      if (value === undefined) {
        return Identifier("undefined");
      }

      if (value === true || value === false) {
        return BooleanLiteral(value);
      }

      if (value === null) {
        return NullLiteral();
      }

      if (typeof value === "string") {
        return StringLiteral(value);
      }

      if (typeof value === "number") {
        var result;

        if (Number.isFinite(value)) {
          result = NumericLiteral(Math.abs(value));
        } else {
          var numerator;

          if (Number.isNaN(value)) {
            numerator = NumericLiteral(0);
          } else {
            numerator = NumericLiteral(1);
          }

          result = BinaryExpression("/", numerator, NumericLiteral(0));
        }

        if (value < 0 || Object.is(value, -0)) {
          result = UnaryExpression("-", result);
        }

        return result;
      }

      if (isRegExp_1(value)) {
        var pattern = value.source;
        var flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return RegExpLiteral(pattern, flags);
      }

      if (Array.isArray(value)) {
        return ArrayExpression(value.map(valueToNode));
      }

      if (isPlainObject_1(value)) {
        var props = [];

        for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          var nodeKey = void 0;

          if (isValidIdentifier(key)) {
            nodeKey = Identifier(key);
          } else {
            nodeKey = StringLiteral(key);
          }

          props.push(ObjectProperty(nodeKey, valueToNode(value[key])));
        }

        return ObjectExpression(props);
      }

      throw new Error("don't know how to turn this value into a node");
    }

    function appendToMemberExpression(member, append, computed) {
      if (computed === void 0) {
        computed = false;
      }

      member.object = MemberExpression(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }

    function inherits(child, parent) {
      if (!child || !parent) return child;

      for (var _i = 0, _arr = INHERIT_KEYS.optional; _i < _arr.length; _i++) {
        var key = _arr[_i];

        if (child[key] == null) {
          child[key] = parent[key];
        }
      }

      for (var _i2 = 0, _Object$keys = Object.keys(parent); _i2 < _Object$keys.length; _i2++) {
        var _key = _Object$keys[_i2];
        if (_key[0] === "_" && _key !== "__clone") child[_key] = parent[_key];
      }

      for (var _i3 = 0, _arr2 = INHERIT_KEYS.force; _i3 < _arr2.length; _i3++) {
        var _key2 = _arr2[_i3];
        child[_key2] = parent[_key2];
      }

      inheritsComments(child, parent);
      return child;
    }

    function prependToMemberExpression(member, prepend) {
      member.object = MemberExpression(prepend, member.object);
      return member;
    }

    function getOuterBindingIdentifiers(node, duplicates) {
      return getBindingIdentifiers(node, duplicates, true);
    }

    function traverse(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }

      var _ref = handlers,
          enter = _ref.enter,
          exit = _ref.exit;
      traverseSimpleImpl(node, enter, exit, state, []);
    }

    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      var keys = VISITOR_KEYS[node.type];
      if (!keys) return;
      if (enter) enter(node, ancestors, state);

      for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        var subNode = node[key];

        if (Array.isArray(subNode)) {
          for (var i = 0; i < subNode.length; i++) {
            var child = subNode[i];
            if (!child) continue;
            ancestors.push({
              node: node,
              key: key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node: node,
            key: key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }

      if (exit) exit(node, ancestors, state);
    }

    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }

      var keys = getBindingIdentifiers.keys[parent.type];

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = parent[key];

          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0) return true;
          } else {
            if (val === node) return true;
          }
        }
      }

      return false;
    }

    function isLet(node) {
      return isVariableDeclaration(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
    }

    function isBlockScoped(node) {
      return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);
    }

    function isImmutable(node) {
      if (isType(node.type, "Immutable")) return true;

      if (isIdentifier(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }

      return false;
    }

    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }

      if (a.type !== b.type) {
        return false;
      }

      var fields = Object.keys(NODE_FIELDS[a.type] || a.type);
      var visitorKeys = VISITOR_KEYS[a.type];

      for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
        var field = _fields[_i];

        if (typeof a[field] !== typeof b[field]) {
          return false;
        }

        if (a[field] == null && b[field] == null) {
          continue;
        } else if (a[field] == null || b[field] == null) {
          return false;
        }

        if (Array.isArray(a[field])) {
          if (!Array.isArray(b[field])) {
            return false;
          }

          if (a[field].length !== b[field].length) {
            return false;
          }

          for (var i = 0; i < a[field].length; i++) {
            if (!isNodesEquivalent(a[field][i], b[field][i])) {
              return false;
            }
          }

          continue;
        }

        if (typeof a[field] === "object" && (!visitorKeys || !visitorKeys.includes(field))) {
          for (var _i2 = 0, _Object$keys = Object.keys(a[field]); _i2 < _Object$keys.length; _i2++) {
            var key = _Object$keys[_i2];

            if (a[field][key] !== b[field][key]) {
              return false;
            }
          }

          continue;
        }

        if (!isNodesEquivalent(a[field], b[field])) {
          return false;
        }
      }

      return true;
    }

    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "JSXMemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }

          return parent.object === node;

        case "VariableDeclarator":
          return parent.init === node;

        case "ArrowFunctionExpression":
          return parent.body === node;

        case "ExportSpecifier":
          if (parent.source) {
            return false;
          }

          return parent.local === node;

        case "PrivateName":
          return false;

        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.params.includes(node)) {
            return false;
          }

        case "ObjectProperty":
        case "ClassProperty":
        case "ClassPrivateProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }

          if (parent.value === node) {
            return !grandparent || grandparent.type !== "ObjectPattern";
          }

          return true;

        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;

        case "AssignmentExpression":
          return parent.right === node;

        case "AssignmentPattern":
          return parent.right === node;

        case "LabeledStatement":
          return false;

        case "CatchClause":
          return false;

        case "RestElement":
          return false;

        case "BreakStatement":
        case "ContinueStatement":
          return false;

        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;

        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;

        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;

        case "JSXAttribute":
          return false;

        case "ObjectPattern":
        case "ArrayPattern":
          return false;

        case "MetaProperty":
          return false;

        case "ObjectTypeProperty":
          return parent.key !== node;

        case "TSEnumMember":
          return parent.id !== node;

        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }

          return true;
      }

      return true;
    }

    function isScope(node, parent) {
      if (isBlockStatement(node) && isFunction(parent, {
        body: node
      })) {
        return false;
      }

      if (isBlockStatement(node) && isCatchClause(parent, {
        body: node
      })) {
        return false;
      }

      if (isPattern(node) && isFunction(parent)) {
        return true;
      }

      return isScopable(node);
    }

    function isSpecifierDefault(specifier) {
      return isImportDefaultSpecifier(specifier) || isIdentifier(specifier.imported || specifier.exported, {
        name: "default"
      });
    }

    var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }

    function isVar(node) {
      return isVariableDeclaration(node, {
        kind: "var"
      }) && !node[BLOCK_SCOPED_SYMBOL];
    }

    var react = {
      isReactComponent: isReactComponent,
      isCompatTag: isCompatTag,
      buildChildren: buildChildren
    };

    var t = /*#__PURE__*/Object.freeze({
      __proto__: null,
      react: react,
      assertNode: assertNode,
      createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof,
      createUnionTypeAnnotation: createFlowUnionType,
      createFlowUnionType: createFlowUnionType,
      createTSUnionType: createTSUnionType,
      cloneNode: cloneNode,
      clone: clone$1,
      cloneDeep: cloneDeep,
      cloneDeepWithoutLoc: cloneDeepWithoutLoc,
      cloneWithoutLoc: cloneWithoutLoc,
      addComment: addComment,
      addComments: addComments,
      inheritInnerComments: inheritInnerComments,
      inheritLeadingComments: inheritLeadingComments,
      inheritsComments: inheritsComments,
      inheritTrailingComments: inheritTrailingComments,
      removeComments: removeComments,
      ensureBlock: ensureBlock,
      toBindingIdentifierName: toBindingIdentifierName,
      toBlock: toBlock,
      toComputedKey: toComputedKey,
      toExpression: toExpression,
      toIdentifier: toIdentifier,
      toKeyAlias: toKeyAlias,
      toSequenceExpression: toSequenceExpression,
      toStatement: toStatement,
      valueToNode: valueToNode,
      appendToMemberExpression: appendToMemberExpression,
      inherits: inherits,
      prependToMemberExpression: prependToMemberExpression,
      removeProperties: removeProperties,
      removePropertiesDeep: removePropertiesDeep,
      removeTypeDuplicates: removeTypeDuplicates,
      getBindingIdentifiers: getBindingIdentifiers,
      getOuterBindingIdentifiers: getOuterBindingIdentifiers,
      traverse: traverse,
      traverseFast: traverseFast,
      shallowEqual: shallowEqual,
      is: is,
      isBinding: isBinding,
      isBlockScoped: isBlockScoped,
      isImmutable: isImmutable,
      isLet: isLet,
      isNode: isNode,
      isNodesEquivalent: isNodesEquivalent,
      isPlaceholderType: isPlaceholderType,
      isReferenced: isReferenced,
      isScope: isScope,
      isSpecifierDefault: isSpecifierDefault,
      isType: isType,
      isValidES3Identifier: isValidES3Identifier,
      isValidIdentifier: isValidIdentifier,
      isVar: isVar,
      matchesPattern: matchesPattern,
      validate: validate,
      buildMatchMemberExpression: buildMatchMemberExpression,
      assertArrayExpression: assertArrayExpression,
      assertAssignmentExpression: assertAssignmentExpression,
      assertBinaryExpression: assertBinaryExpression,
      assertInterpreterDirective: assertInterpreterDirective,
      assertDirective: assertDirective,
      assertDirectiveLiteral: assertDirectiveLiteral,
      assertBlockStatement: assertBlockStatement,
      assertBreakStatement: assertBreakStatement,
      assertCallExpression: assertCallExpression,
      assertCatchClause: assertCatchClause,
      assertConditionalExpression: assertConditionalExpression,
      assertContinueStatement: assertContinueStatement,
      assertDebuggerStatement: assertDebuggerStatement,
      assertDoWhileStatement: assertDoWhileStatement,
      assertEmptyStatement: assertEmptyStatement,
      assertExpressionStatement: assertExpressionStatement,
      assertFile: assertFile,
      assertForInStatement: assertForInStatement,
      assertForStatement: assertForStatement,
      assertFunctionDeclaration: assertFunctionDeclaration,
      assertFunctionExpression: assertFunctionExpression,
      assertIdentifier: assertIdentifier,
      assertIfStatement: assertIfStatement,
      assertLabeledStatement: assertLabeledStatement,
      assertStringLiteral: assertStringLiteral,
      assertNumericLiteral: assertNumericLiteral,
      assertNullLiteral: assertNullLiteral,
      assertBooleanLiteral: assertBooleanLiteral,
      assertRegExpLiteral: assertRegExpLiteral,
      assertLogicalExpression: assertLogicalExpression,
      assertMemberExpression: assertMemberExpression,
      assertNewExpression: assertNewExpression,
      assertProgram: assertProgram,
      assertObjectExpression: assertObjectExpression,
      assertObjectMethod: assertObjectMethod,
      assertObjectProperty: assertObjectProperty,
      assertRestElement: assertRestElement,
      assertReturnStatement: assertReturnStatement,
      assertSequenceExpression: assertSequenceExpression,
      assertParenthesizedExpression: assertParenthesizedExpression,
      assertSwitchCase: assertSwitchCase,
      assertSwitchStatement: assertSwitchStatement,
      assertThisExpression: assertThisExpression,
      assertThrowStatement: assertThrowStatement,
      assertTryStatement: assertTryStatement,
      assertUnaryExpression: assertUnaryExpression,
      assertUpdateExpression: assertUpdateExpression,
      assertVariableDeclaration: assertVariableDeclaration,
      assertVariableDeclarator: assertVariableDeclarator,
      assertWhileStatement: assertWhileStatement,
      assertWithStatement: assertWithStatement,
      assertAssignmentPattern: assertAssignmentPattern,
      assertArrayPattern: assertArrayPattern,
      assertArrowFunctionExpression: assertArrowFunctionExpression,
      assertClassBody: assertClassBody,
      assertClassExpression: assertClassExpression,
      assertClassDeclaration: assertClassDeclaration,
      assertExportAllDeclaration: assertExportAllDeclaration,
      assertExportDefaultDeclaration: assertExportDefaultDeclaration,
      assertExportNamedDeclaration: assertExportNamedDeclaration,
      assertExportSpecifier: assertExportSpecifier,
      assertForOfStatement: assertForOfStatement,
      assertImportDeclaration: assertImportDeclaration,
      assertImportDefaultSpecifier: assertImportDefaultSpecifier,
      assertImportNamespaceSpecifier: assertImportNamespaceSpecifier,
      assertImportSpecifier: assertImportSpecifier,
      assertMetaProperty: assertMetaProperty,
      assertClassMethod: assertClassMethod,
      assertObjectPattern: assertObjectPattern,
      assertSpreadElement: assertSpreadElement,
      assertSuper: assertSuper,
      assertTaggedTemplateExpression: assertTaggedTemplateExpression,
      assertTemplateElement: assertTemplateElement,
      assertTemplateLiteral: assertTemplateLiteral,
      assertYieldExpression: assertYieldExpression,
      assertAnyTypeAnnotation: assertAnyTypeAnnotation,
      assertArrayTypeAnnotation: assertArrayTypeAnnotation,
      assertBooleanTypeAnnotation: assertBooleanTypeAnnotation,
      assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation,
      assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation,
      assertClassImplements: assertClassImplements,
      assertDeclareClass: assertDeclareClass,
      assertDeclareFunction: assertDeclareFunction,
      assertDeclareInterface: assertDeclareInterface,
      assertDeclareModule: assertDeclareModule,
      assertDeclareModuleExports: assertDeclareModuleExports,
      assertDeclareTypeAlias: assertDeclareTypeAlias,
      assertDeclareOpaqueType: assertDeclareOpaqueType,
      assertDeclareVariable: assertDeclareVariable,
      assertDeclareExportDeclaration: assertDeclareExportDeclaration,
      assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration,
      assertDeclaredPredicate: assertDeclaredPredicate,
      assertExistsTypeAnnotation: assertExistsTypeAnnotation,
      assertFunctionTypeAnnotation: assertFunctionTypeAnnotation,
      assertFunctionTypeParam: assertFunctionTypeParam,
      assertGenericTypeAnnotation: assertGenericTypeAnnotation,
      assertInferredPredicate: assertInferredPredicate,
      assertInterfaceExtends: assertInterfaceExtends,
      assertInterfaceDeclaration: assertInterfaceDeclaration,
      assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation,
      assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation,
      assertMixedTypeAnnotation: assertMixedTypeAnnotation,
      assertEmptyTypeAnnotation: assertEmptyTypeAnnotation,
      assertNullableTypeAnnotation: assertNullableTypeAnnotation,
      assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation,
      assertNumberTypeAnnotation: assertNumberTypeAnnotation,
      assertObjectTypeAnnotation: assertObjectTypeAnnotation,
      assertObjectTypeInternalSlot: assertObjectTypeInternalSlot,
      assertObjectTypeCallProperty: assertObjectTypeCallProperty,
      assertObjectTypeIndexer: assertObjectTypeIndexer,
      assertObjectTypeProperty: assertObjectTypeProperty,
      assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty,
      assertOpaqueType: assertOpaqueType,
      assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier,
      assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation,
      assertStringTypeAnnotation: assertStringTypeAnnotation,
      assertSymbolTypeAnnotation: assertSymbolTypeAnnotation,
      assertThisTypeAnnotation: assertThisTypeAnnotation,
      assertTupleTypeAnnotation: assertTupleTypeAnnotation,
      assertTypeofTypeAnnotation: assertTypeofTypeAnnotation,
      assertTypeAlias: assertTypeAlias,
      assertTypeAnnotation: assertTypeAnnotation,
      assertTypeCastExpression: assertTypeCastExpression,
      assertTypeParameter: assertTypeParameter,
      assertTypeParameterDeclaration: assertTypeParameterDeclaration,
      assertTypeParameterInstantiation: assertTypeParameterInstantiation,
      assertUnionTypeAnnotation: assertUnionTypeAnnotation,
      assertVariance: assertVariance,
      assertVoidTypeAnnotation: assertVoidTypeAnnotation,
      assertEnumDeclaration: assertEnumDeclaration,
      assertEnumBooleanBody: assertEnumBooleanBody,
      assertEnumNumberBody: assertEnumNumberBody,
      assertEnumStringBody: assertEnumStringBody,
      assertEnumSymbolBody: assertEnumSymbolBody,
      assertEnumBooleanMember: assertEnumBooleanMember,
      assertEnumNumberMember: assertEnumNumberMember,
      assertEnumStringMember: assertEnumStringMember,
      assertEnumDefaultedMember: assertEnumDefaultedMember,
      assertJSXAttribute: assertJSXAttribute,
      assertJSXClosingElement: assertJSXClosingElement,
      assertJSXElement: assertJSXElement,
      assertJSXEmptyExpression: assertJSXEmptyExpression,
      assertJSXExpressionContainer: assertJSXExpressionContainer,
      assertJSXSpreadChild: assertJSXSpreadChild,
      assertJSXIdentifier: assertJSXIdentifier,
      assertJSXMemberExpression: assertJSXMemberExpression,
      assertJSXNamespacedName: assertJSXNamespacedName,
      assertJSXOpeningElement: assertJSXOpeningElement,
      assertJSXSpreadAttribute: assertJSXSpreadAttribute,
      assertJSXText: assertJSXText,
      assertJSXFragment: assertJSXFragment,
      assertJSXOpeningFragment: assertJSXOpeningFragment,
      assertJSXClosingFragment: assertJSXClosingFragment,
      assertNoop: assertNoop,
      assertPlaceholder: assertPlaceholder,
      assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier,
      assertArgumentPlaceholder: assertArgumentPlaceholder,
      assertAwaitExpression: assertAwaitExpression,
      assertBindExpression: assertBindExpression,
      assertClassProperty: assertClassProperty,
      assertEventualMemberExpression: assertEventualMemberExpression,
      assertEventualMemberCallExpression: assertEventualMemberCallExpression,
      assertOptionalMemberExpression: assertOptionalMemberExpression,
      assertPipelineTopicExpression: assertPipelineTopicExpression,
      assertPipelineBareFunction: assertPipelineBareFunction,
      assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference,
      assertEventualCallExpression: assertEventualCallExpression,
      assertOptionalCallExpression: assertOptionalCallExpression,
      assertClassPrivateProperty: assertClassPrivateProperty,
      assertClassPrivateMethod: assertClassPrivateMethod,
      assertImport: assertImport,
      assertDecorator: assertDecorator,
      assertDoExpression: assertDoExpression,
      assertExportDefaultSpecifier: assertExportDefaultSpecifier,
      assertExportNamespaceSpecifier: assertExportNamespaceSpecifier,
      assertPrivateName: assertPrivateName,
      assertBigIntLiteral: assertBigIntLiteral,
      assertRecordExpression: assertRecordExpression,
      assertTupleExpression: assertTupleExpression,
      assertTSParameterProperty: assertTSParameterProperty,
      assertTSDeclareFunction: assertTSDeclareFunction,
      assertTSDeclareMethod: assertTSDeclareMethod,
      assertTSQualifiedName: assertTSQualifiedName,
      assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration,
      assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration,
      assertTSPropertySignature: assertTSPropertySignature,
      assertTSMethodSignature: assertTSMethodSignature,
      assertTSIndexSignature: assertTSIndexSignature,
      assertTSAnyKeyword: assertTSAnyKeyword,
      assertTSBooleanKeyword: assertTSBooleanKeyword,
      assertTSBigIntKeyword: assertTSBigIntKeyword,
      assertTSNeverKeyword: assertTSNeverKeyword,
      assertTSNullKeyword: assertTSNullKeyword,
      assertTSNumberKeyword: assertTSNumberKeyword,
      assertTSObjectKeyword: assertTSObjectKeyword,
      assertTSStringKeyword: assertTSStringKeyword,
      assertTSSymbolKeyword: assertTSSymbolKeyword,
      assertTSUndefinedKeyword: assertTSUndefinedKeyword,
      assertTSUnknownKeyword: assertTSUnknownKeyword,
      assertTSVoidKeyword: assertTSVoidKeyword,
      assertTSThisType: assertTSThisType,
      assertTSFunctionType: assertTSFunctionType,
      assertTSConstructorType: assertTSConstructorType,
      assertTSTypeReference: assertTSTypeReference,
      assertTSTypePredicate: assertTSTypePredicate,
      assertTSTypeQuery: assertTSTypeQuery,
      assertTSTypeLiteral: assertTSTypeLiteral,
      assertTSArrayType: assertTSArrayType,
      assertTSTupleType: assertTSTupleType,
      assertTSOptionalType: assertTSOptionalType,
      assertTSRestType: assertTSRestType,
      assertTSUnionType: assertTSUnionType,
      assertTSIntersectionType: assertTSIntersectionType,
      assertTSConditionalType: assertTSConditionalType,
      assertTSInferType: assertTSInferType,
      assertTSParenthesizedType: assertTSParenthesizedType,
      assertTSTypeOperator: assertTSTypeOperator,
      assertTSIndexedAccessType: assertTSIndexedAccessType,
      assertTSMappedType: assertTSMappedType,
      assertTSLiteralType: assertTSLiteralType,
      assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments,
      assertTSInterfaceDeclaration: assertTSInterfaceDeclaration,
      assertTSInterfaceBody: assertTSInterfaceBody,
      assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration,
      assertTSAsExpression: assertTSAsExpression,
      assertTSTypeAssertion: assertTSTypeAssertion,
      assertTSEnumDeclaration: assertTSEnumDeclaration,
      assertTSEnumMember: assertTSEnumMember,
      assertTSModuleDeclaration: assertTSModuleDeclaration,
      assertTSModuleBlock: assertTSModuleBlock,
      assertTSImportType: assertTSImportType,
      assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration,
      assertTSExternalModuleReference: assertTSExternalModuleReference,
      assertTSNonNullExpression: assertTSNonNullExpression,
      assertTSExportAssignment: assertTSExportAssignment,
      assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration,
      assertTSTypeAnnotation: assertTSTypeAnnotation,
      assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation,
      assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration,
      assertTSTypeParameter: assertTSTypeParameter,
      assertExpression: assertExpression,
      assertBinary: assertBinary,
      assertScopable: assertScopable,
      assertBlockParent: assertBlockParent,
      assertBlock: assertBlock,
      assertStatement: assertStatement,
      assertTerminatorless: assertTerminatorless,
      assertCompletionStatement: assertCompletionStatement,
      assertConditional: assertConditional,
      assertLoop: assertLoop,
      assertWhile: assertWhile,
      assertExpressionWrapper: assertExpressionWrapper,
      assertFor: assertFor,
      assertForXStatement: assertForXStatement,
      assertFunction: assertFunction,
      assertFunctionParent: assertFunctionParent,
      assertPureish: assertPureish,
      assertDeclaration: assertDeclaration,
      assertPatternLike: assertPatternLike,
      assertLVal: assertLVal,
      assertTSEntityName: assertTSEntityName,
      assertLiteral: assertLiteral,
      assertImmutable: assertImmutable,
      assertUserWhitespacable: assertUserWhitespacable,
      assertMethod: assertMethod,
      assertObjectMember: assertObjectMember,
      assertProperty: assertProperty,
      assertUnaryLike: assertUnaryLike,
      assertPattern: assertPattern,
      assertClass: assertClass,
      assertModuleDeclaration: assertModuleDeclaration,
      assertExportDeclaration: assertExportDeclaration,
      assertModuleSpecifier: assertModuleSpecifier,
      assertFlow: assertFlow,
      assertFlowType: assertFlowType,
      assertFlowBaseAnnotation: assertFlowBaseAnnotation,
      assertFlowDeclaration: assertFlowDeclaration,
      assertFlowPredicate: assertFlowPredicate,
      assertEnumBody: assertEnumBody,
      assertEnumMember: assertEnumMember,
      assertJSX: assertJSX,
      assertPrivate: assertPrivate,
      assertTSTypeElement: assertTSTypeElement,
      assertTSType: assertTSType,
      assertTSBaseType: assertTSBaseType,
      assertNumberLiteral: assertNumberLiteral,
      assertRegexLiteral: assertRegexLiteral,
      assertRestProperty: assertRestProperty,
      assertSpreadProperty: assertSpreadProperty,
      ArrayExpression: ArrayExpression,
      arrayExpression: ArrayExpression,
      AssignmentExpression: AssignmentExpression,
      assignmentExpression: AssignmentExpression,
      BinaryExpression: BinaryExpression,
      binaryExpression: BinaryExpression,
      InterpreterDirective: InterpreterDirective,
      interpreterDirective: InterpreterDirective,
      Directive: Directive,
      directive: Directive,
      DirectiveLiteral: DirectiveLiteral,
      directiveLiteral: DirectiveLiteral,
      BlockStatement: BlockStatement,
      blockStatement: BlockStatement,
      BreakStatement: BreakStatement,
      breakStatement: BreakStatement,
      CallExpression: CallExpression,
      callExpression: CallExpression,
      CatchClause: CatchClause,
      catchClause: CatchClause,
      ConditionalExpression: ConditionalExpression,
      conditionalExpression: ConditionalExpression,
      ContinueStatement: ContinueStatement,
      continueStatement: ContinueStatement,
      DebuggerStatement: DebuggerStatement,
      debuggerStatement: DebuggerStatement,
      DoWhileStatement: DoWhileStatement,
      doWhileStatement: DoWhileStatement,
      EmptyStatement: EmptyStatement,
      emptyStatement: EmptyStatement,
      ExpressionStatement: ExpressionStatement,
      expressionStatement: ExpressionStatement,
      File: File,
      file: File,
      ForInStatement: ForInStatement,
      forInStatement: ForInStatement,
      ForStatement: ForStatement,
      forStatement: ForStatement,
      FunctionDeclaration: FunctionDeclaration,
      functionDeclaration: FunctionDeclaration,
      FunctionExpression: FunctionExpression,
      functionExpression: FunctionExpression,
      Identifier: Identifier,
      identifier: Identifier,
      IfStatement: IfStatement,
      ifStatement: IfStatement,
      LabeledStatement: LabeledStatement,
      labeledStatement: LabeledStatement,
      StringLiteral: StringLiteral,
      stringLiteral: StringLiteral,
      NumericLiteral: NumericLiteral,
      numericLiteral: NumericLiteral,
      NullLiteral: NullLiteral,
      nullLiteral: NullLiteral,
      BooleanLiteral: BooleanLiteral,
      booleanLiteral: BooleanLiteral,
      RegExpLiteral: RegExpLiteral,
      regExpLiteral: RegExpLiteral,
      LogicalExpression: LogicalExpression,
      logicalExpression: LogicalExpression,
      MemberExpression: MemberExpression,
      memberExpression: MemberExpression,
      NewExpression: NewExpression,
      newExpression: NewExpression,
      Program: Program,
      program: Program,
      ObjectExpression: ObjectExpression,
      objectExpression: ObjectExpression,
      ObjectMethod: ObjectMethod,
      objectMethod: ObjectMethod,
      ObjectProperty: ObjectProperty,
      objectProperty: ObjectProperty,
      RestElement: RestElement,
      restElement: RestElement,
      ReturnStatement: ReturnStatement,
      returnStatement: ReturnStatement,
      SequenceExpression: SequenceExpression,
      sequenceExpression: SequenceExpression,
      ParenthesizedExpression: ParenthesizedExpression,
      parenthesizedExpression: ParenthesizedExpression,
      SwitchCase: SwitchCase,
      switchCase: SwitchCase,
      SwitchStatement: SwitchStatement,
      switchStatement: SwitchStatement,
      ThisExpression: ThisExpression,
      thisExpression: ThisExpression,
      ThrowStatement: ThrowStatement,
      throwStatement: ThrowStatement,
      TryStatement: TryStatement,
      tryStatement: TryStatement,
      UnaryExpression: UnaryExpression,
      unaryExpression: UnaryExpression,
      UpdateExpression: UpdateExpression,
      updateExpression: UpdateExpression,
      VariableDeclaration: VariableDeclaration,
      variableDeclaration: VariableDeclaration,
      VariableDeclarator: VariableDeclarator,
      variableDeclarator: VariableDeclarator,
      WhileStatement: WhileStatement,
      whileStatement: WhileStatement,
      WithStatement: WithStatement,
      withStatement: WithStatement,
      AssignmentPattern: AssignmentPattern,
      assignmentPattern: AssignmentPattern,
      ArrayPattern: ArrayPattern,
      arrayPattern: ArrayPattern,
      ArrowFunctionExpression: ArrowFunctionExpression,
      arrowFunctionExpression: ArrowFunctionExpression,
      ClassBody: ClassBody,
      classBody: ClassBody,
      ClassExpression: ClassExpression,
      classExpression: ClassExpression,
      ClassDeclaration: ClassDeclaration,
      classDeclaration: ClassDeclaration,
      ExportAllDeclaration: ExportAllDeclaration,
      exportAllDeclaration: ExportAllDeclaration,
      ExportDefaultDeclaration: ExportDefaultDeclaration,
      exportDefaultDeclaration: ExportDefaultDeclaration,
      ExportNamedDeclaration: ExportNamedDeclaration,
      exportNamedDeclaration: ExportNamedDeclaration,
      ExportSpecifier: ExportSpecifier,
      exportSpecifier: ExportSpecifier,
      ForOfStatement: ForOfStatement,
      forOfStatement: ForOfStatement,
      ImportDeclaration: ImportDeclaration,
      importDeclaration: ImportDeclaration,
      ImportDefaultSpecifier: ImportDefaultSpecifier,
      importDefaultSpecifier: ImportDefaultSpecifier,
      ImportNamespaceSpecifier: ImportNamespaceSpecifier,
      importNamespaceSpecifier: ImportNamespaceSpecifier,
      ImportSpecifier: ImportSpecifier,
      importSpecifier: ImportSpecifier,
      MetaProperty: MetaProperty,
      metaProperty: MetaProperty,
      ClassMethod: ClassMethod,
      classMethod: ClassMethod,
      ObjectPattern: ObjectPattern,
      objectPattern: ObjectPattern,
      SpreadElement: SpreadElement,
      spreadElement: SpreadElement,
      Super: Super,
      'super': Super,
      TaggedTemplateExpression: TaggedTemplateExpression,
      taggedTemplateExpression: TaggedTemplateExpression,
      TemplateElement: TemplateElement,
      templateElement: TemplateElement,
      TemplateLiteral: TemplateLiteral,
      templateLiteral: TemplateLiteral,
      YieldExpression: YieldExpression,
      yieldExpression: YieldExpression,
      AnyTypeAnnotation: AnyTypeAnnotation,
      anyTypeAnnotation: AnyTypeAnnotation,
      ArrayTypeAnnotation: ArrayTypeAnnotation,
      arrayTypeAnnotation: ArrayTypeAnnotation,
      BooleanTypeAnnotation: BooleanTypeAnnotation,
      booleanTypeAnnotation: BooleanTypeAnnotation,
      BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
      booleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
      NullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
      nullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
      ClassImplements: ClassImplements,
      classImplements: ClassImplements,
      DeclareClass: DeclareClass,
      declareClass: DeclareClass,
      DeclareFunction: DeclareFunction,
      declareFunction: DeclareFunction,
      DeclareInterface: DeclareInterface,
      declareInterface: DeclareInterface,
      DeclareModule: DeclareModule,
      declareModule: DeclareModule,
      DeclareModuleExports: DeclareModuleExports,
      declareModuleExports: DeclareModuleExports,
      DeclareTypeAlias: DeclareTypeAlias,
      declareTypeAlias: DeclareTypeAlias,
      DeclareOpaqueType: DeclareOpaqueType,
      declareOpaqueType: DeclareOpaqueType,
      DeclareVariable: DeclareVariable,
      declareVariable: DeclareVariable,
      DeclareExportDeclaration: DeclareExportDeclaration,
      declareExportDeclaration: DeclareExportDeclaration,
      DeclareExportAllDeclaration: DeclareExportAllDeclaration,
      declareExportAllDeclaration: DeclareExportAllDeclaration,
      DeclaredPredicate: DeclaredPredicate,
      declaredPredicate: DeclaredPredicate,
      ExistsTypeAnnotation: ExistsTypeAnnotation,
      existsTypeAnnotation: ExistsTypeAnnotation,
      FunctionTypeAnnotation: FunctionTypeAnnotation,
      functionTypeAnnotation: FunctionTypeAnnotation,
      FunctionTypeParam: FunctionTypeParam,
      functionTypeParam: FunctionTypeParam,
      GenericTypeAnnotation: GenericTypeAnnotation,
      genericTypeAnnotation: GenericTypeAnnotation,
      InferredPredicate: InferredPredicate,
      inferredPredicate: InferredPredicate,
      InterfaceExtends: InterfaceExtends,
      interfaceExtends: InterfaceExtends,
      InterfaceDeclaration: InterfaceDeclaration,
      interfaceDeclaration: InterfaceDeclaration,
      InterfaceTypeAnnotation: InterfaceTypeAnnotation,
      interfaceTypeAnnotation: InterfaceTypeAnnotation,
      IntersectionTypeAnnotation: IntersectionTypeAnnotation,
      intersectionTypeAnnotation: IntersectionTypeAnnotation,
      MixedTypeAnnotation: MixedTypeAnnotation,
      mixedTypeAnnotation: MixedTypeAnnotation,
      EmptyTypeAnnotation: EmptyTypeAnnotation,
      emptyTypeAnnotation: EmptyTypeAnnotation,
      NullableTypeAnnotation: NullableTypeAnnotation,
      nullableTypeAnnotation: NullableTypeAnnotation,
      NumberLiteralTypeAnnotation: NumberLiteralTypeAnnotation,
      numberLiteralTypeAnnotation: NumberLiteralTypeAnnotation,
      NumberTypeAnnotation: NumberTypeAnnotation,
      numberTypeAnnotation: NumberTypeAnnotation,
      ObjectTypeAnnotation: ObjectTypeAnnotation,
      objectTypeAnnotation: ObjectTypeAnnotation,
      ObjectTypeInternalSlot: ObjectTypeInternalSlot,
      objectTypeInternalSlot: ObjectTypeInternalSlot,
      ObjectTypeCallProperty: ObjectTypeCallProperty,
      objectTypeCallProperty: ObjectTypeCallProperty,
      ObjectTypeIndexer: ObjectTypeIndexer,
      objectTypeIndexer: ObjectTypeIndexer,
      ObjectTypeProperty: ObjectTypeProperty,
      objectTypeProperty: ObjectTypeProperty,
      ObjectTypeSpreadProperty: ObjectTypeSpreadProperty,
      objectTypeSpreadProperty: ObjectTypeSpreadProperty,
      OpaqueType: OpaqueType,
      opaqueType: OpaqueType,
      QualifiedTypeIdentifier: QualifiedTypeIdentifier,
      qualifiedTypeIdentifier: QualifiedTypeIdentifier,
      StringLiteralTypeAnnotation: StringLiteralTypeAnnotation,
      stringLiteralTypeAnnotation: StringLiteralTypeAnnotation,
      StringTypeAnnotation: StringTypeAnnotation,
      stringTypeAnnotation: StringTypeAnnotation,
      SymbolTypeAnnotation: SymbolTypeAnnotation,
      symbolTypeAnnotation: SymbolTypeAnnotation,
      ThisTypeAnnotation: ThisTypeAnnotation,
      thisTypeAnnotation: ThisTypeAnnotation,
      TupleTypeAnnotation: TupleTypeAnnotation,
      tupleTypeAnnotation: TupleTypeAnnotation,
      TypeofTypeAnnotation: TypeofTypeAnnotation,
      typeofTypeAnnotation: TypeofTypeAnnotation,
      TypeAlias: TypeAlias,
      typeAlias: TypeAlias,
      TypeAnnotation: TypeAnnotation,
      typeAnnotation: TypeAnnotation,
      TypeCastExpression: TypeCastExpression,
      typeCastExpression: TypeCastExpression,
      TypeParameter: TypeParameter,
      typeParameter: TypeParameter,
      TypeParameterDeclaration: TypeParameterDeclaration,
      typeParameterDeclaration: TypeParameterDeclaration,
      TypeParameterInstantiation: TypeParameterInstantiation,
      typeParameterInstantiation: TypeParameterInstantiation,
      UnionTypeAnnotation: UnionTypeAnnotation,
      unionTypeAnnotation: UnionTypeAnnotation,
      Variance: Variance,
      variance: Variance,
      VoidTypeAnnotation: VoidTypeAnnotation,
      voidTypeAnnotation: VoidTypeAnnotation,
      EnumDeclaration: EnumDeclaration,
      enumDeclaration: EnumDeclaration,
      EnumBooleanBody: EnumBooleanBody,
      enumBooleanBody: EnumBooleanBody,
      EnumNumberBody: EnumNumberBody,
      enumNumberBody: EnumNumberBody,
      EnumStringBody: EnumStringBody,
      enumStringBody: EnumStringBody,
      EnumSymbolBody: EnumSymbolBody,
      enumSymbolBody: EnumSymbolBody,
      EnumBooleanMember: EnumBooleanMember,
      enumBooleanMember: EnumBooleanMember,
      EnumNumberMember: EnumNumberMember,
      enumNumberMember: EnumNumberMember,
      EnumStringMember: EnumStringMember,
      enumStringMember: EnumStringMember,
      EnumDefaultedMember: EnumDefaultedMember,
      enumDefaultedMember: EnumDefaultedMember,
      JSXAttribute: JSXAttribute,
      jsxAttribute: JSXAttribute,
      jSXAttribute: JSXAttribute,
      JSXClosingElement: JSXClosingElement,
      jsxClosingElement: JSXClosingElement,
      jSXClosingElement: JSXClosingElement,
      JSXElement: JSXElement,
      jsxElement: JSXElement,
      jSXElement: JSXElement,
      JSXEmptyExpression: JSXEmptyExpression,
      jsxEmptyExpression: JSXEmptyExpression,
      jSXEmptyExpression: JSXEmptyExpression,
      JSXExpressionContainer: JSXExpressionContainer,
      jsxExpressionContainer: JSXExpressionContainer,
      jSXExpressionContainer: JSXExpressionContainer,
      JSXSpreadChild: JSXSpreadChild,
      jsxSpreadChild: JSXSpreadChild,
      jSXSpreadChild: JSXSpreadChild,
      JSXIdentifier: JSXIdentifier,
      jsxIdentifier: JSXIdentifier,
      jSXIdentifier: JSXIdentifier,
      JSXMemberExpression: JSXMemberExpression,
      jsxMemberExpression: JSXMemberExpression,
      jSXMemberExpression: JSXMemberExpression,
      JSXNamespacedName: JSXNamespacedName,
      jsxNamespacedName: JSXNamespacedName,
      jSXNamespacedName: JSXNamespacedName,
      JSXOpeningElement: JSXOpeningElement,
      jsxOpeningElement: JSXOpeningElement,
      jSXOpeningElement: JSXOpeningElement,
      JSXSpreadAttribute: JSXSpreadAttribute,
      jsxSpreadAttribute: JSXSpreadAttribute,
      jSXSpreadAttribute: JSXSpreadAttribute,
      JSXText: JSXText,
      jsxText: JSXText,
      jSXText: JSXText,
      JSXFragment: JSXFragment,
      jsxFragment: JSXFragment,
      jSXFragment: JSXFragment,
      JSXOpeningFragment: JSXOpeningFragment,
      jsxOpeningFragment: JSXOpeningFragment,
      jSXOpeningFragment: JSXOpeningFragment,
      JSXClosingFragment: JSXClosingFragment,
      jsxClosingFragment: JSXClosingFragment,
      jSXClosingFragment: JSXClosingFragment,
      Noop: Noop,
      noop: Noop,
      Placeholder: Placeholder,
      placeholder: Placeholder,
      V8IntrinsicIdentifier: V8IntrinsicIdentifier,
      v8IntrinsicIdentifier: V8IntrinsicIdentifier,
      ArgumentPlaceholder: ArgumentPlaceholder,
      argumentPlaceholder: ArgumentPlaceholder,
      AwaitExpression: AwaitExpression,
      awaitExpression: AwaitExpression,
      BindExpression: BindExpression,
      bindExpression: BindExpression,
      ClassProperty: ClassProperty,
      classProperty: ClassProperty,
      EventualMemberExpression: EventualMemberExpression,
      eventualMemberExpression: EventualMemberExpression,
      EventualMemberCallExpression: EventualMemberCallExpression,
      eventualMemberCallExpression: EventualMemberCallExpression,
      OptionalMemberExpression: OptionalMemberExpression,
      optionalMemberExpression: OptionalMemberExpression,
      PipelineTopicExpression: PipelineTopicExpression,
      pipelineTopicExpression: PipelineTopicExpression,
      PipelineBareFunction: PipelineBareFunction,
      pipelineBareFunction: PipelineBareFunction,
      PipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
      pipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
      EventualCallExpression: EventualCallExpression,
      eventualCallExpression: EventualCallExpression,
      OptionalCallExpression: OptionalCallExpression,
      optionalCallExpression: OptionalCallExpression,
      ClassPrivateProperty: ClassPrivateProperty,
      classPrivateProperty: ClassPrivateProperty,
      ClassPrivateMethod: ClassPrivateMethod,
      classPrivateMethod: ClassPrivateMethod,
      Import: Import,
      'import': Import,
      Decorator: Decorator,
      decorator: Decorator,
      DoExpression: DoExpression,
      doExpression: DoExpression,
      ExportDefaultSpecifier: ExportDefaultSpecifier,
      exportDefaultSpecifier: ExportDefaultSpecifier,
      ExportNamespaceSpecifier: ExportNamespaceSpecifier,
      exportNamespaceSpecifier: ExportNamespaceSpecifier,
      PrivateName: PrivateName,
      privateName: PrivateName,
      BigIntLiteral: BigIntLiteral,
      bigIntLiteral: BigIntLiteral,
      RecordExpression: RecordExpression,
      recordExpression: RecordExpression,
      TupleExpression: TupleExpression,
      tupleExpression: TupleExpression,
      TSParameterProperty: TSParameterProperty,
      tsParameterProperty: TSParameterProperty,
      tSParameterProperty: TSParameterProperty,
      TSDeclareFunction: TSDeclareFunction,
      tsDeclareFunction: TSDeclareFunction,
      tSDeclareFunction: TSDeclareFunction,
      TSDeclareMethod: TSDeclareMethod,
      tsDeclareMethod: TSDeclareMethod,
      tSDeclareMethod: TSDeclareMethod,
      TSQualifiedName: TSQualifiedName,
      tsQualifiedName: TSQualifiedName,
      tSQualifiedName: TSQualifiedName,
      TSCallSignatureDeclaration: TSCallSignatureDeclaration,
      tsCallSignatureDeclaration: TSCallSignatureDeclaration,
      tSCallSignatureDeclaration: TSCallSignatureDeclaration,
      TSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
      tsConstructSignatureDeclaration: TSConstructSignatureDeclaration,
      tSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
      TSPropertySignature: TSPropertySignature,
      tsPropertySignature: TSPropertySignature,
      tSPropertySignature: TSPropertySignature,
      TSMethodSignature: TSMethodSignature,
      tsMethodSignature: TSMethodSignature,
      tSMethodSignature: TSMethodSignature,
      TSIndexSignature: TSIndexSignature,
      tsIndexSignature: TSIndexSignature,
      tSIndexSignature: TSIndexSignature,
      TSAnyKeyword: TSAnyKeyword,
      tsAnyKeyword: TSAnyKeyword,
      tSAnyKeyword: TSAnyKeyword,
      TSBooleanKeyword: TSBooleanKeyword,
      tsBooleanKeyword: TSBooleanKeyword,
      tSBooleanKeyword: TSBooleanKeyword,
      TSBigIntKeyword: TSBigIntKeyword,
      tsBigIntKeyword: TSBigIntKeyword,
      tSBigIntKeyword: TSBigIntKeyword,
      TSNeverKeyword: TSNeverKeyword,
      tsNeverKeyword: TSNeverKeyword,
      tSNeverKeyword: TSNeverKeyword,
      TSNullKeyword: TSNullKeyword,
      tsNullKeyword: TSNullKeyword,
      tSNullKeyword: TSNullKeyword,
      TSNumberKeyword: TSNumberKeyword,
      tsNumberKeyword: TSNumberKeyword,
      tSNumberKeyword: TSNumberKeyword,
      TSObjectKeyword: TSObjectKeyword,
      tsObjectKeyword: TSObjectKeyword,
      tSObjectKeyword: TSObjectKeyword,
      TSStringKeyword: TSStringKeyword,
      tsStringKeyword: TSStringKeyword,
      tSStringKeyword: TSStringKeyword,
      TSSymbolKeyword: TSSymbolKeyword,
      tsSymbolKeyword: TSSymbolKeyword,
      tSSymbolKeyword: TSSymbolKeyword,
      TSUndefinedKeyword: TSUndefinedKeyword,
      tsUndefinedKeyword: TSUndefinedKeyword,
      tSUndefinedKeyword: TSUndefinedKeyword,
      TSUnknownKeyword: TSUnknownKeyword,
      tsUnknownKeyword: TSUnknownKeyword,
      tSUnknownKeyword: TSUnknownKeyword,
      TSVoidKeyword: TSVoidKeyword,
      tsVoidKeyword: TSVoidKeyword,
      tSVoidKeyword: TSVoidKeyword,
      TSThisType: TSThisType,
      tsThisType: TSThisType,
      tSThisType: TSThisType,
      TSFunctionType: TSFunctionType,
      tsFunctionType: TSFunctionType,
      tSFunctionType: TSFunctionType,
      TSConstructorType: TSConstructorType,
      tsConstructorType: TSConstructorType,
      tSConstructorType: TSConstructorType,
      TSTypeReference: TSTypeReference,
      tsTypeReference: TSTypeReference,
      tSTypeReference: TSTypeReference,
      TSTypePredicate: TSTypePredicate,
      tsTypePredicate: TSTypePredicate,
      tSTypePredicate: TSTypePredicate,
      TSTypeQuery: TSTypeQuery,
      tsTypeQuery: TSTypeQuery,
      tSTypeQuery: TSTypeQuery,
      TSTypeLiteral: TSTypeLiteral,
      tsTypeLiteral: TSTypeLiteral,
      tSTypeLiteral: TSTypeLiteral,
      TSArrayType: TSArrayType,
      tsArrayType: TSArrayType,
      tSArrayType: TSArrayType,
      TSTupleType: TSTupleType,
      tsTupleType: TSTupleType,
      tSTupleType: TSTupleType,
      TSOptionalType: TSOptionalType,
      tsOptionalType: TSOptionalType,
      tSOptionalType: TSOptionalType,
      TSRestType: TSRestType,
      tsRestType: TSRestType,
      tSRestType: TSRestType,
      TSUnionType: TSUnionType,
      tsUnionType: TSUnionType,
      tSUnionType: TSUnionType,
      TSIntersectionType: TSIntersectionType,
      tsIntersectionType: TSIntersectionType,
      tSIntersectionType: TSIntersectionType,
      TSConditionalType: TSConditionalType,
      tsConditionalType: TSConditionalType,
      tSConditionalType: TSConditionalType,
      TSInferType: TSInferType,
      tsInferType: TSInferType,
      tSInferType: TSInferType,
      TSParenthesizedType: TSParenthesizedType,
      tsParenthesizedType: TSParenthesizedType,
      tSParenthesizedType: TSParenthesizedType,
      TSTypeOperator: TSTypeOperator,
      tsTypeOperator: TSTypeOperator,
      tSTypeOperator: TSTypeOperator,
      TSIndexedAccessType: TSIndexedAccessType,
      tsIndexedAccessType: TSIndexedAccessType,
      tSIndexedAccessType: TSIndexedAccessType,
      TSMappedType: TSMappedType,
      tsMappedType: TSMappedType,
      tSMappedType: TSMappedType,
      TSLiteralType: TSLiteralType,
      tsLiteralType: TSLiteralType,
      tSLiteralType: TSLiteralType,
      TSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
      tsExpressionWithTypeArguments: TSExpressionWithTypeArguments,
      tSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
      TSInterfaceDeclaration: TSInterfaceDeclaration,
      tsInterfaceDeclaration: TSInterfaceDeclaration,
      tSInterfaceDeclaration: TSInterfaceDeclaration,
      TSInterfaceBody: TSInterfaceBody,
      tsInterfaceBody: TSInterfaceBody,
      tSInterfaceBody: TSInterfaceBody,
      TSTypeAliasDeclaration: TSTypeAliasDeclaration,
      tsTypeAliasDeclaration: TSTypeAliasDeclaration,
      tSTypeAliasDeclaration: TSTypeAliasDeclaration,
      TSAsExpression: TSAsExpression,
      tsAsExpression: TSAsExpression,
      tSAsExpression: TSAsExpression,
      TSTypeAssertion: TSTypeAssertion,
      tsTypeAssertion: TSTypeAssertion,
      tSTypeAssertion: TSTypeAssertion,
      TSEnumDeclaration: TSEnumDeclaration,
      tsEnumDeclaration: TSEnumDeclaration,
      tSEnumDeclaration: TSEnumDeclaration,
      TSEnumMember: TSEnumMember,
      tsEnumMember: TSEnumMember,
      tSEnumMember: TSEnumMember,
      TSModuleDeclaration: TSModuleDeclaration,
      tsModuleDeclaration: TSModuleDeclaration,
      tSModuleDeclaration: TSModuleDeclaration,
      TSModuleBlock: TSModuleBlock,
      tsModuleBlock: TSModuleBlock,
      tSModuleBlock: TSModuleBlock,
      TSImportType: TSImportType,
      tsImportType: TSImportType,
      tSImportType: TSImportType,
      TSImportEqualsDeclaration: TSImportEqualsDeclaration,
      tsImportEqualsDeclaration: TSImportEqualsDeclaration,
      tSImportEqualsDeclaration: TSImportEqualsDeclaration,
      TSExternalModuleReference: TSExternalModuleReference,
      tsExternalModuleReference: TSExternalModuleReference,
      tSExternalModuleReference: TSExternalModuleReference,
      TSNonNullExpression: TSNonNullExpression,
      tsNonNullExpression: TSNonNullExpression,
      tSNonNullExpression: TSNonNullExpression,
      TSExportAssignment: TSExportAssignment,
      tsExportAssignment: TSExportAssignment,
      tSExportAssignment: TSExportAssignment,
      TSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
      tsNamespaceExportDeclaration: TSNamespaceExportDeclaration,
      tSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
      TSTypeAnnotation: TSTypeAnnotation,
      tsTypeAnnotation: TSTypeAnnotation,
      tSTypeAnnotation: TSTypeAnnotation,
      TSTypeParameterInstantiation: TSTypeParameterInstantiation,
      tsTypeParameterInstantiation: TSTypeParameterInstantiation,
      tSTypeParameterInstantiation: TSTypeParameterInstantiation,
      TSTypeParameterDeclaration: TSTypeParameterDeclaration,
      tsTypeParameterDeclaration: TSTypeParameterDeclaration,
      tSTypeParameterDeclaration: TSTypeParameterDeclaration,
      TSTypeParameter: TSTypeParameter,
      tsTypeParameter: TSTypeParameter,
      tSTypeParameter: TSTypeParameter,
      NumberLiteral: NumberLiteral,
      numberLiteral: NumberLiteral,
      RegexLiteral: RegexLiteral,
      regexLiteral: RegexLiteral,
      RestProperty: RestProperty,
      restProperty: RestProperty,
      SpreadProperty: SpreadProperty,
      spreadProperty: SpreadProperty,
      EXPRESSION_TYPES: EXPRESSION_TYPES,
      BINARY_TYPES: BINARY_TYPES,
      SCOPABLE_TYPES: SCOPABLE_TYPES,
      BLOCKPARENT_TYPES: BLOCKPARENT_TYPES,
      BLOCK_TYPES: BLOCK_TYPES,
      STATEMENT_TYPES: STATEMENT_TYPES,
      TERMINATORLESS_TYPES: TERMINATORLESS_TYPES,
      COMPLETIONSTATEMENT_TYPES: COMPLETIONSTATEMENT_TYPES,
      CONDITIONAL_TYPES: CONDITIONAL_TYPES,
      LOOP_TYPES: LOOP_TYPES,
      WHILE_TYPES: WHILE_TYPES,
      EXPRESSIONWRAPPER_TYPES: EXPRESSIONWRAPPER_TYPES,
      FOR_TYPES: FOR_TYPES,
      FORXSTATEMENT_TYPES: FORXSTATEMENT_TYPES,
      FUNCTION_TYPES: FUNCTION_TYPES,
      FUNCTIONPARENT_TYPES: FUNCTIONPARENT_TYPES,
      PUREISH_TYPES: PUREISH_TYPES,
      DECLARATION_TYPES: DECLARATION_TYPES,
      PATTERNLIKE_TYPES: PATTERNLIKE_TYPES,
      LVAL_TYPES: LVAL_TYPES,
      TSENTITYNAME_TYPES: TSENTITYNAME_TYPES,
      LITERAL_TYPES: LITERAL_TYPES,
      IMMUTABLE_TYPES: IMMUTABLE_TYPES,
      USERWHITESPACABLE_TYPES: USERWHITESPACABLE_TYPES,
      METHOD_TYPES: METHOD_TYPES,
      OBJECTMEMBER_TYPES: OBJECTMEMBER_TYPES,
      PROPERTY_TYPES: PROPERTY_TYPES,
      UNARYLIKE_TYPES: UNARYLIKE_TYPES,
      PATTERN_TYPES: PATTERN_TYPES,
      CLASS_TYPES: CLASS_TYPES,
      MODULEDECLARATION_TYPES: MODULEDECLARATION_TYPES,
      EXPORTDECLARATION_TYPES: EXPORTDECLARATION_TYPES,
      MODULESPECIFIER_TYPES: MODULESPECIFIER_TYPES,
      FLOW_TYPES: FLOW_TYPES,
      FLOWTYPE_TYPES: FLOWTYPE_TYPES,
      FLOWBASEANNOTATION_TYPES: FLOWBASEANNOTATION_TYPES,
      FLOWDECLARATION_TYPES: FLOWDECLARATION_TYPES,
      FLOWPREDICATE_TYPES: FLOWPREDICATE_TYPES,
      ENUMBODY_TYPES: ENUMBODY_TYPES,
      ENUMMEMBER_TYPES: ENUMMEMBER_TYPES,
      JSX_TYPES: JSX_TYPES,
      PRIVATE_TYPES: PRIVATE_TYPES,
      TSTYPEELEMENT_TYPES: TSTYPEELEMENT_TYPES,
      TSTYPE_TYPES: TSTYPE_TYPES,
      TSBASETYPE_TYPES: TSBASETYPE_TYPES,
      STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS,
      FLATTENABLE_KEYS: FLATTENABLE_KEYS,
      FOR_INIT_KEYS: FOR_INIT_KEYS,
      COMMENT_KEYS: COMMENT_KEYS,
      LOGICAL_OPERATORS: LOGICAL_OPERATORS,
      UPDATE_OPERATORS: UPDATE_OPERATORS,
      BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS,
      EQUALITY_BINARY_OPERATORS: EQUALITY_BINARY_OPERATORS,
      COMPARISON_BINARY_OPERATORS: COMPARISON_BINARY_OPERATORS,
      BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS,
      NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS,
      BINARY_OPERATORS: BINARY_OPERATORS,
      ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
      BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS,
      NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS,
      UNARY_OPERATORS: UNARY_OPERATORS,
      INHERIT_KEYS: INHERIT_KEYS,
      BLOCK_SCOPED_SYMBOL: BLOCK_SCOPED_SYMBOL,
      NOT_LOCAL_BINDING: NOT_LOCAL_BINDING,
      VISITOR_KEYS: VISITOR_KEYS,
      ALIAS_KEYS: ALIAS_KEYS,
      FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS,
      NODE_FIELDS: NODE_FIELDS,
      BUILDER_KEYS: BUILDER_KEYS,
      DEPRECATED_KEYS: DEPRECATED_KEYS,
      NODE_PARENT_VALIDATIONS: NODE_PARENT_VALIDATIONS,
      PLACEHOLDERS: PLACEHOLDERS,
      PLACEHOLDERS_ALIAS: PLACEHOLDERS_ALIAS,
      PLACEHOLDERS_FLIPPED_ALIAS: PLACEHOLDERS_FLIPPED_ALIAS,
      TYPES: TYPES,
      isArrayExpression: isArrayExpression,
      isAssignmentExpression: isAssignmentExpression,
      isBinaryExpression: isBinaryExpression,
      isInterpreterDirective: isInterpreterDirective,
      isDirective: isDirective,
      isDirectiveLiteral: isDirectiveLiteral,
      isBlockStatement: isBlockStatement,
      isBreakStatement: isBreakStatement,
      isCallExpression: isCallExpression,
      isCatchClause: isCatchClause,
      isConditionalExpression: isConditionalExpression,
      isContinueStatement: isContinueStatement,
      isDebuggerStatement: isDebuggerStatement,
      isDoWhileStatement: isDoWhileStatement,
      isEmptyStatement: isEmptyStatement,
      isExpressionStatement: isExpressionStatement,
      isFile: isFile,
      isForInStatement: isForInStatement,
      isForStatement: isForStatement,
      isFunctionDeclaration: isFunctionDeclaration,
      isFunctionExpression: isFunctionExpression,
      isIdentifier: isIdentifier,
      isIfStatement: isIfStatement,
      isLabeledStatement: isLabeledStatement,
      isStringLiteral: isStringLiteral,
      isNumericLiteral: isNumericLiteral,
      isNullLiteral: isNullLiteral,
      isBooleanLiteral: isBooleanLiteral,
      isRegExpLiteral: isRegExpLiteral,
      isLogicalExpression: isLogicalExpression,
      isMemberExpression: isMemberExpression,
      isNewExpression: isNewExpression,
      isProgram: isProgram,
      isObjectExpression: isObjectExpression,
      isObjectMethod: isObjectMethod,
      isObjectProperty: isObjectProperty,
      isRestElement: isRestElement,
      isReturnStatement: isReturnStatement,
      isSequenceExpression: isSequenceExpression,
      isParenthesizedExpression: isParenthesizedExpression,
      isSwitchCase: isSwitchCase,
      isSwitchStatement: isSwitchStatement,
      isThisExpression: isThisExpression,
      isThrowStatement: isThrowStatement,
      isTryStatement: isTryStatement,
      isUnaryExpression: isUnaryExpression,
      isUpdateExpression: isUpdateExpression,
      isVariableDeclaration: isVariableDeclaration,
      isVariableDeclarator: isVariableDeclarator,
      isWhileStatement: isWhileStatement,
      isWithStatement: isWithStatement,
      isAssignmentPattern: isAssignmentPattern,
      isArrayPattern: isArrayPattern,
      isArrowFunctionExpression: isArrowFunctionExpression,
      isClassBody: isClassBody,
      isClassExpression: isClassExpression,
      isClassDeclaration: isClassDeclaration,
      isExportAllDeclaration: isExportAllDeclaration,
      isExportDefaultDeclaration: isExportDefaultDeclaration,
      isExportNamedDeclaration: isExportNamedDeclaration,
      isExportSpecifier: isExportSpecifier,
      isForOfStatement: isForOfStatement,
      isImportDeclaration: isImportDeclaration,
      isImportDefaultSpecifier: isImportDefaultSpecifier,
      isImportNamespaceSpecifier: isImportNamespaceSpecifier,
      isImportSpecifier: isImportSpecifier,
      isMetaProperty: isMetaProperty,
      isClassMethod: isClassMethod,
      isObjectPattern: isObjectPattern,
      isSpreadElement: isSpreadElement,
      isSuper: isSuper,
      isTaggedTemplateExpression: isTaggedTemplateExpression,
      isTemplateElement: isTemplateElement,
      isTemplateLiteral: isTemplateLiteral,
      isYieldExpression: isYieldExpression,
      isAnyTypeAnnotation: isAnyTypeAnnotation,
      isArrayTypeAnnotation: isArrayTypeAnnotation,
      isBooleanTypeAnnotation: isBooleanTypeAnnotation,
      isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation,
      isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation,
      isClassImplements: isClassImplements,
      isDeclareClass: isDeclareClass,
      isDeclareFunction: isDeclareFunction,
      isDeclareInterface: isDeclareInterface,
      isDeclareModule: isDeclareModule,
      isDeclareModuleExports: isDeclareModuleExports,
      isDeclareTypeAlias: isDeclareTypeAlias,
      isDeclareOpaqueType: isDeclareOpaqueType,
      isDeclareVariable: isDeclareVariable,
      isDeclareExportDeclaration: isDeclareExportDeclaration,
      isDeclareExportAllDeclaration: isDeclareExportAllDeclaration,
      isDeclaredPredicate: isDeclaredPredicate,
      isExistsTypeAnnotation: isExistsTypeAnnotation,
      isFunctionTypeAnnotation: isFunctionTypeAnnotation,
      isFunctionTypeParam: isFunctionTypeParam,
      isGenericTypeAnnotation: isGenericTypeAnnotation,
      isInferredPredicate: isInferredPredicate,
      isInterfaceExtends: isInterfaceExtends,
      isInterfaceDeclaration: isInterfaceDeclaration,
      isInterfaceTypeAnnotation: isInterfaceTypeAnnotation,
      isIntersectionTypeAnnotation: isIntersectionTypeAnnotation,
      isMixedTypeAnnotation: isMixedTypeAnnotation,
      isEmptyTypeAnnotation: isEmptyTypeAnnotation,
      isNullableTypeAnnotation: isNullableTypeAnnotation,
      isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation,
      isNumberTypeAnnotation: isNumberTypeAnnotation,
      isObjectTypeAnnotation: isObjectTypeAnnotation,
      isObjectTypeInternalSlot: isObjectTypeInternalSlot,
      isObjectTypeCallProperty: isObjectTypeCallProperty,
      isObjectTypeIndexer: isObjectTypeIndexer,
      isObjectTypeProperty: isObjectTypeProperty,
      isObjectTypeSpreadProperty: isObjectTypeSpreadProperty,
      isOpaqueType: isOpaqueType,
      isQualifiedTypeIdentifier: isQualifiedTypeIdentifier,
      isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation,
      isStringTypeAnnotation: isStringTypeAnnotation,
      isSymbolTypeAnnotation: isSymbolTypeAnnotation,
      isThisTypeAnnotation: isThisTypeAnnotation,
      isTupleTypeAnnotation: isTupleTypeAnnotation,
      isTypeofTypeAnnotation: isTypeofTypeAnnotation,
      isTypeAlias: isTypeAlias,
      isTypeAnnotation: isTypeAnnotation,
      isTypeCastExpression: isTypeCastExpression,
      isTypeParameter: isTypeParameter,
      isTypeParameterDeclaration: isTypeParameterDeclaration,
      isTypeParameterInstantiation: isTypeParameterInstantiation,
      isUnionTypeAnnotation: isUnionTypeAnnotation,
      isVariance: isVariance,
      isVoidTypeAnnotation: isVoidTypeAnnotation,
      isEnumDeclaration: isEnumDeclaration,
      isEnumBooleanBody: isEnumBooleanBody,
      isEnumNumberBody: isEnumNumberBody,
      isEnumStringBody: isEnumStringBody,
      isEnumSymbolBody: isEnumSymbolBody,
      isEnumBooleanMember: isEnumBooleanMember,
      isEnumNumberMember: isEnumNumberMember,
      isEnumStringMember: isEnumStringMember,
      isEnumDefaultedMember: isEnumDefaultedMember,
      isJSXAttribute: isJSXAttribute,
      isJSXClosingElement: isJSXClosingElement,
      isJSXElement: isJSXElement,
      isJSXEmptyExpression: isJSXEmptyExpression,
      isJSXExpressionContainer: isJSXExpressionContainer,
      isJSXSpreadChild: isJSXSpreadChild,
      isJSXIdentifier: isJSXIdentifier,
      isJSXMemberExpression: isJSXMemberExpression,
      isJSXNamespacedName: isJSXNamespacedName,
      isJSXOpeningElement: isJSXOpeningElement,
      isJSXSpreadAttribute: isJSXSpreadAttribute,
      isJSXText: isJSXText,
      isJSXFragment: isJSXFragment,
      isJSXOpeningFragment: isJSXOpeningFragment,
      isJSXClosingFragment: isJSXClosingFragment,
      isNoop: isNoop,
      isPlaceholder: isPlaceholder,
      isV8IntrinsicIdentifier: isV8IntrinsicIdentifier,
      isArgumentPlaceholder: isArgumentPlaceholder,
      isAwaitExpression: isAwaitExpression,
      isBindExpression: isBindExpression,
      isClassProperty: isClassProperty,
      isEventualMemberExpression: isEventualMemberExpression,
      isEventualMemberCallExpression: isEventualMemberCallExpression,
      isOptionalMemberExpression: isOptionalMemberExpression,
      isPipelineTopicExpression: isPipelineTopicExpression,
      isPipelineBareFunction: isPipelineBareFunction,
      isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference,
      isEventualCallExpression: isEventualCallExpression,
      isOptionalCallExpression: isOptionalCallExpression,
      isClassPrivateProperty: isClassPrivateProperty,
      isClassPrivateMethod: isClassPrivateMethod,
      isImport: isImport,
      isDecorator: isDecorator,
      isDoExpression: isDoExpression,
      isExportDefaultSpecifier: isExportDefaultSpecifier,
      isExportNamespaceSpecifier: isExportNamespaceSpecifier,
      isPrivateName: isPrivateName,
      isBigIntLiteral: isBigIntLiteral,
      isRecordExpression: isRecordExpression,
      isTupleExpression: isTupleExpression,
      isTSParameterProperty: isTSParameterProperty,
      isTSDeclareFunction: isTSDeclareFunction,
      isTSDeclareMethod: isTSDeclareMethod,
      isTSQualifiedName: isTSQualifiedName,
      isTSCallSignatureDeclaration: isTSCallSignatureDeclaration,
      isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration,
      isTSPropertySignature: isTSPropertySignature,
      isTSMethodSignature: isTSMethodSignature,
      isTSIndexSignature: isTSIndexSignature,
      isTSAnyKeyword: isTSAnyKeyword,
      isTSBooleanKeyword: isTSBooleanKeyword,
      isTSBigIntKeyword: isTSBigIntKeyword,
      isTSNeverKeyword: isTSNeverKeyword,
      isTSNullKeyword: isTSNullKeyword,
      isTSNumberKeyword: isTSNumberKeyword,
      isTSObjectKeyword: isTSObjectKeyword,
      isTSStringKeyword: isTSStringKeyword,
      isTSSymbolKeyword: isTSSymbolKeyword,
      isTSUndefinedKeyword: isTSUndefinedKeyword,
      isTSUnknownKeyword: isTSUnknownKeyword,
      isTSVoidKeyword: isTSVoidKeyword,
      isTSThisType: isTSThisType,
      isTSFunctionType: isTSFunctionType,
      isTSConstructorType: isTSConstructorType,
      isTSTypeReference: isTSTypeReference,
      isTSTypePredicate: isTSTypePredicate,
      isTSTypeQuery: isTSTypeQuery,
      isTSTypeLiteral: isTSTypeLiteral,
      isTSArrayType: isTSArrayType,
      isTSTupleType: isTSTupleType,
      isTSOptionalType: isTSOptionalType,
      isTSRestType: isTSRestType,
      isTSUnionType: isTSUnionType,
      isTSIntersectionType: isTSIntersectionType,
      isTSConditionalType: isTSConditionalType,
      isTSInferType: isTSInferType,
      isTSParenthesizedType: isTSParenthesizedType,
      isTSTypeOperator: isTSTypeOperator,
      isTSIndexedAccessType: isTSIndexedAccessType,
      isTSMappedType: isTSMappedType,
      isTSLiteralType: isTSLiteralType,
      isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments,
      isTSInterfaceDeclaration: isTSInterfaceDeclaration,
      isTSInterfaceBody: isTSInterfaceBody,
      isTSTypeAliasDeclaration: isTSTypeAliasDeclaration,
      isTSAsExpression: isTSAsExpression,
      isTSTypeAssertion: isTSTypeAssertion,
      isTSEnumDeclaration: isTSEnumDeclaration,
      isTSEnumMember: isTSEnumMember,
      isTSModuleDeclaration: isTSModuleDeclaration,
      isTSModuleBlock: isTSModuleBlock,
      isTSImportType: isTSImportType,
      isTSImportEqualsDeclaration: isTSImportEqualsDeclaration,
      isTSExternalModuleReference: isTSExternalModuleReference,
      isTSNonNullExpression: isTSNonNullExpression,
      isTSExportAssignment: isTSExportAssignment,
      isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration,
      isTSTypeAnnotation: isTSTypeAnnotation,
      isTSTypeParameterInstantiation: isTSTypeParameterInstantiation,
      isTSTypeParameterDeclaration: isTSTypeParameterDeclaration,
      isTSTypeParameter: isTSTypeParameter,
      isExpression: isExpression,
      isBinary: isBinary,
      isScopable: isScopable,
      isBlockParent: isBlockParent,
      isBlock: isBlock,
      isStatement: isStatement,
      isTerminatorless: isTerminatorless,
      isCompletionStatement: isCompletionStatement,
      isConditional: isConditional,
      isLoop: isLoop,
      isWhile: isWhile,
      isExpressionWrapper: isExpressionWrapper,
      isFor: isFor,
      isForXStatement: isForXStatement,
      isFunction: isFunction,
      isFunctionParent: isFunctionParent,
      isPureish: isPureish,
      isDeclaration: isDeclaration,
      isPatternLike: isPatternLike,
      isLVal: isLVal,
      isTSEntityName: isTSEntityName,
      isLiteral: isLiteral,
      isUserWhitespacable: isUserWhitespacable,
      isMethod: isMethod,
      isObjectMember: isObjectMember,
      isProperty: isProperty,
      isUnaryLike: isUnaryLike,
      isPattern: isPattern,
      isClass: isClass,
      isModuleDeclaration: isModuleDeclaration,
      isExportDeclaration: isExportDeclaration,
      isModuleSpecifier: isModuleSpecifier,
      isFlow: isFlow,
      isFlowType: isFlowType,
      isFlowBaseAnnotation: isFlowBaseAnnotation,
      isFlowDeclaration: isFlowDeclaration,
      isFlowPredicate: isFlowPredicate,
      isEnumBody: isEnumBody,
      isEnumMember: isEnumMember,
      isJSX: isJSX,
      isPrivate: isPrivate,
      isTSTypeElement: isTSTypeElement,
      isTSType: isTSType,
      isTSBaseType: isTSBaseType,
      isNumberLiteral: isNumberLiteral,
      isRegexLiteral: isRegexLiteral,
      isRestProperty: isRestProperty,
      isSpreadProperty: isSpreadProperty
    });

    var ReferencedIdentifier = {
      types: ["Identifier", "JSXIdentifier"],
      checkPath: function checkPath(path, opts) {
        var node = path.node,
            parent = path.parent;

        if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
          if (isJSXIdentifier(node, opts)) {
            if (react.isCompatTag(node.name)) return false;
          } else {
            return false;
          }
        }

        return isReferenced(node, parent, path.parentPath.parent);
      }
    };
    var ReferencedMemberExpression = {
      types: ["MemberExpression"],
      checkPath: function checkPath(_ref) {
        var node = _ref.node,
            parent = _ref.parent;
        return isMemberExpression(node) && isReferenced(node, parent);
      }
    };
    var BindingIdentifier = {
      types: ["Identifier"],
      checkPath: function checkPath(path) {
        var node = path.node,
            parent = path.parent;
        var grandparent = path.parentPath.parent;
        return isIdentifier(node) && isBinding(node, parent, grandparent);
      }
    };
    var Statement = {
      types: ["Statement"],
      checkPath: function checkPath(_ref2) {
        var node = _ref2.node,
            parent = _ref2.parent;

        if (isStatement(node)) {
          if (isVariableDeclaration(node)) {
            if (isForXStatement(parent, {
              left: node
            })) return false;
            if (isForStatement(parent, {
              init: node
            })) return false;
          }

          return true;
        } else {
          return false;
        }
      }
    };
    var Expression = {
      types: ["Expression"],
      checkPath: function checkPath(path) {
        if (path.isIdentifier()) {
          return path.isReferencedIdentifier();
        } else {
          return isExpression(path.node);
        }
      }
    };
    var Scope = {
      types: ["Scopable", "Pattern"],
      checkPath: function checkPath(path) {
        return isScope(path.node, path.parent);
      }
    };
    var Referenced = {
      checkPath: function checkPath(path) {
        return isReferenced(path.node, path.parent);
      }
    };
    var BlockScoped = {
      checkPath: function checkPath(path) {
        return isBlockScoped(path.node);
      }
    };
    var Var = {
      types: ["VariableDeclaration"],
      checkPath: function checkPath(path) {
        return isVar(path.node);
      }
    };
    var User = {
      checkPath: function checkPath(path) {
        return path.node && !!path.node.loc;
      }
    };
    var Generated = {
      checkPath: function checkPath(path) {
        return !path.isUser();
      }
    };
    var Pure = {
      checkPath: function checkPath(path, opts) {
        return path.scope.isPure(path.node, opts);
      }
    };
    var Flow = {
      types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
      checkPath: function checkPath(_ref3) {
        var node = _ref3.node;

        if (isFlow(node)) {
          return true;
        } else if (isImportDeclaration(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else if (isExportDeclaration(node)) {
          return node.exportKind === "type";
        } else if (isImportSpecifier(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else {
          return false;
        }
      }
    };
    var RestProperty$1 = {
      types: ["RestElement"],
      checkPath: function checkPath(path) {
        return path.parentPath && path.parentPath.isObjectPattern();
      }
    };
    var SpreadProperty$1 = {
      types: ["RestElement"],
      checkPath: function checkPath(path) {
        return path.parentPath && path.parentPath.isObjectExpression();
      }
    };
    var ExistentialTypeParam = {
      types: ["ExistsTypeAnnotation"]
    };
    var NumericLiteralTypeAnnotation = {
      types: ["NumberLiteralTypeAnnotation"]
    };
    var ForAwaitStatement = {
      types: ["ForOfStatement"],
      checkPath: function checkPath(_ref4) {
        var node = _ref4.node;
        return node["await"] === true;
      }
    };

    var virtualTypes = /*#__PURE__*/Object.freeze({
      __proto__: null,
      ReferencedIdentifier: ReferencedIdentifier,
      ReferencedMemberExpression: ReferencedMemberExpression,
      BindingIdentifier: BindingIdentifier,
      Statement: Statement,
      Expression: Expression,
      Scope: Scope,
      Referenced: Referenced,
      BlockScoped: BlockScoped,
      Var: Var,
      User: User,
      Generated: Generated,
      Pure: Pure,
      Flow: Flow,
      RestProperty: RestProperty$1,
      SpreadProperty: SpreadProperty$1,
      ExistentialTypeParam: ExistentialTypeParam,
      NumericLiteralTypeAnnotation: NumericLiteralTypeAnnotation,
      ForAwaitStatement: ForAwaitStatement
    });

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    var ms = function (val, options) {
      options = options || {};
      var type = typeof val;

      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options["long"] ? fmtLong(val) : fmtShort(val);
      }

      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };

    function parse(str) {
      str = String(str);

      if (str.length > 100) {
        return;
      }

      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

      if (!match) {
        return;
      }

      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();

      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;

        case 'weeks':
        case 'week':
        case 'w':
          return n * w;

        case 'days':
        case 'day':
        case 'd':
          return n * d;

        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;

        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;

        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;

        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;

        default:
          return undefined;
      }
    }

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);

      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }

      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }

      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }

      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }

      return ms + 'ms';
    }

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);

      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }

      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }

      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }

      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }

      return ms + ' ms';
    }

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    function setup(env) {
      createDebug.debug = createDebug;
      createDebug["default"] = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms;
      Object.keys(env).forEach(function (key) {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};

      function selectColor(namespace) {
        var hash = 0;

        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }

      createDebug.selectColor = selectColor;

      function createDebug(namespace) {
        var prevTime;

        function debug() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (!debug.enabled) {
            return;
          }

          var self = debug;
          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== 'string') {
            args.unshift('%O');
          }

          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            if (match === '%%') {
              return match;
            }

            index++;
            var formatter = createDebug.formatters[format];

            if (typeof formatter === 'function') {
              var val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }

            return match;
          });
          createDebug.formatArgs.call(self, args);
          var logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;

        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }

        createDebug.instances.push(debug);
        return debug;
      }

      function destroy() {
        var index = createDebug.instances.indexOf(this);

        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }

        return false;
      }

      function extend(namespace, delimiter) {
        var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }

      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }

          namespaces = split[i].replace(/\*/g, '.*?');

          if (namespaces[0] === '-') {
            createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            createDebug.names.push(new RegExp('^' + namespaces + '$'));
          }
        }

        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }

      function disable() {
        var namespaces = [].concat(createDebug.names.map(toNamespace), createDebug.skips.map(toNamespace).map(function (namespace) {
          return '-' + namespace;
        })).join(',');
        createDebug.enable('');
        return namespaces;
      }

      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }

        var i;
        var len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }

      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
      }

      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }

        return val;
      }

      createDebug.enable(createDebug.load());
      return createDebug;
    }

    var common = setup;

    var browser$1 = createCommonjsModule(function (module, exports) {
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    function useColors() {
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    function log() {
      var _console;

      return typeof console === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {}
    }

    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {}

      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }

    module.exports = common(exports);
    var formatters = module.exports.formatters;

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
    });
    var browser_1 = browser$1.log;
    var browser_2 = browser$1.formatArgs;
    var browser_3 = browser$1.save;
    var browser_4 = browser$1.load;
    var browser_5 = browser$1.useColors;
    var browser_6 = browser$1.storage;
    var browser_7 = browser$1.colors;

    var stringTag$3 = '[object String]';

    function isString(value) {
      return typeof value == 'string' || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$3;
    }

    var isString_1 = isString;

    var symbolTag$2 = '[object Symbol]';

    function isSymbol(value) {
      return typeof value == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2;
    }

    var isSymbol_1 = isSymbol;

    var NAN = 0 / 0;
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;

    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }

      if (isSymbol_1(value)) {
        return NAN;
      }

      if (isObject_1(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject_1(other) ? other + '' : other;
      }

      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }

      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }

    var toNumber_1 = toNumber;

    var INFINITY$1 = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }

      value = toNumber_1(value);

      if (value === INFINITY$1 || value === -INFINITY$1) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }

      return value === value ? value : 0;
    }

    var toFinite_1 = toFinite;

    function toInteger(value) {
      var result = toFinite_1(value),
          remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }

    var toInteger_1 = toInteger;

    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    var _arrayMap = arrayMap;

    function baseValues(object, props) {
      return _arrayMap(props, function (key) {
        return object[key];
      });
    }

    var _baseValues = baseValues;

    function values(object) {
      return object == null ? [] : _baseValues(object, keys_1(object));
    }

    var values_1 = values;

    var nativeMax = Math.max;

    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike_1(collection) ? collection : values_1(collection);
      fromIndex = fromIndex && !guard ? toInteger_1(fromIndex) : 0;
      var length = collection.length;

      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }

      return isString_1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _baseIndexOf(collection, value, fromIndex) > -1;
    }

    var includes_1 = includes;

    var MAX_SAFE_INTEGER$2 = 9007199254740991;
    var nativeFloor = Math.floor;

    function baseRepeat(string, n) {
      var result = '';

      if (!string || n < 1 || n > MAX_SAFE_INTEGER$2) {
        return result;
      }

      do {
        if (n % 2) {
          result += string;
        }

        n = nativeFloor(n / 2);

        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    var _baseRepeat = baseRepeat;

    function isIterateeCall(value, index, object) {
      if (!isObject_1(object)) {
        return false;
      }

      var type = typeof index;

      if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
        return eq_1(object[index], value);
      }

      return false;
    }

    var _isIterateeCall = isIterateeCall;

    var INFINITY$2 = 1 / 0;
    var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    function baseToString(value) {
      if (typeof value == 'string') {
        return value;
      }

      if (isArray_1(value)) {
        return _arrayMap(value, baseToString) + '';
      }

      if (isSymbol_1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }

      var result = value + '';
      return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
    }

    var _baseToString = baseToString;

    function toString(value) {
      return value == null ? '' : _baseToString(value);
    }

    var toString_1 = toString;

    function repeat(string, n, guard) {
      if (guard ? _isIterateeCall(string, n, guard) : n === undefined) {
        n = 1;
      } else {
        n = toInteger_1(n);
      }

      return _baseRepeat(toString_1(string), n);
    }

    var repeat_1 = repeat;

    var Binding = function () {
      function Binding(_ref) {
        var identifier = _ref.identifier,
            scope = _ref.scope,
            path = _ref.path,
            kind = _ref.kind;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.clearValue();
      }

      var _proto = Binding.prototype;

      _proto.deoptValue = function deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      };

      _proto.setValue = function setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      };

      _proto.clearValue = function clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      };

      _proto.reassign = function reassign(path) {
        this.constant = false;

        if (this.constantViolations.indexOf(path) !== -1) {
          return;
        }

        this.constantViolations.push(path);
      };

      _proto.reference = function reference(path) {
        if (this.referencePaths.indexOf(path) !== -1) {
          return;
        }

        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      };

      _proto.dereference = function dereference() {
        this.references--;
        this.referenced = !!this.references;
      };

      return Binding;
    }();

    function splitExportDeclaration(exportDeclaration) {
      if (!exportDeclaration.isExportDeclaration()) {
        throw new Error("Only export declarations can be splitted.");
      }

      var isDefault = exportDeclaration.isExportDefaultDeclaration();
      var declaration = exportDeclaration.get("declaration");
      var isClassDeclaration = declaration.isClassDeclaration();

      if (isDefault) {
        var standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
        var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        var id = declaration.node.id;
        var needBindingRegistration = false;

        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");

          if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
            declaration.node.id = cloneNode(id);
          }
        }

        var updatedDeclaration = standaloneDeclaration ? declaration : VariableDeclaration("var", [VariableDeclarator(cloneNode(id), declaration.node)]);
        var updatedExportDeclaration = ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(id), Identifier("default"))]);
        exportDeclaration.insertAfter(updatedExportDeclaration);
        exportDeclaration.replaceWith(updatedDeclaration);

        if (needBindingRegistration) {
          scope.registerDeclaration(exportDeclaration);
        }

        return exportDeclaration;
      }

      if (exportDeclaration.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }

      var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
        return ExportSpecifier(Identifier(name), Identifier(name));
      });
      var aliasDeclar = ExportNamedDeclaration(null, specifiers);
      exportDeclaration.insertAfter(aliasDeclar);
      exportDeclaration.replaceWith(declaration.node);
      return exportDeclaration;
    }

    var renameVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
        var node = _ref.node;

        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope: function Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
        }
      },
      "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
        var ids = path.getOuterBindingIdentifiers();

        for (var name in ids) {
          if (name === state.oldName) ids[name].name = state.newName;
        }
      }
    };

    var Renamer = function () {
      function Renamer(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }

      var _proto = Renamer.prototype;

      _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
        var maybeExportDeclar = parentDeclar.parentPath;

        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }

        if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
          return;
        }

        splitExportDeclaration(maybeExportDeclar);
      };

      _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
        return;
      };

      _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
        return;
      };

      _proto.rename = function rename(block) {
        var binding = this.binding,
            oldName = this.oldName,
            newName = this.newName;
        var scope = binding.scope,
            path = binding.path;
        var parentDeclar = path.find(function (path) {
          return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
        });

        if (parentDeclar) {
          var bindingIds = parentDeclar.getOuterBindingIdentifiers();

          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }

        scope.traverse(block || scope.block, renameVisitor, this);

        if (!block) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }

        if (binding.type === "hoisted") ;

        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
          this.maybeConvertFromClassFunctionExpression(parentDeclar);
        }
      };

      return Renamer;
    }();

    function identity(value) {
      return value;
    }

    var identity_1 = identity;

    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);

        case 1:
          return func.call(thisArg, args[0]);

        case 2:
          return func.call(thisArg, args[0], args[1]);

        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }

      return func.apply(thisArg, args);
    }

    var _apply = apply;

    var nativeMax$1 = Math.max;

    function overRest(func, start, transform) {
      start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
      return function () {
        var args = arguments,
            index = -1,
            length = nativeMax$1(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }

        index = -1;
        var otherArgs = Array(start + 1);

        while (++index < start) {
          otherArgs[index] = args[index];
        }

        otherArgs[start] = transform(array);
        return _apply(func, this, otherArgs);
      };
    }

    var _overRest = overRest;

    function constant(value) {
      return function () {
        return value;
      };
    }

    var constant_1 = constant;

    var baseSetToString = !_defineProperty$1 ? identity_1 : function (func, string) {
      return _defineProperty$1(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant_1(string),
        'writable': true
      });
    };
    var _baseSetToString = baseSetToString;

    var HOT_COUNT = 800,
        HOT_SPAN = 16;
    var nativeNow = Date.now;

    function shortOut(func) {
      var count = 0,
          lastCalled = 0;
      return function () {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;

        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }

        return func.apply(undefined, arguments);
      };
    }

    var _shortOut = shortOut;

    var setToString = _shortOut(_baseSetToString);
    var _setToString = setToString;

    function baseRest(func, start) {
      return _setToString(_overRest(func, start, identity_1), func + '');
    }

    var _baseRest = baseRest;

    var objectProto$e = Object.prototype;
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;
    var defaults = _baseRest(function (object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn_1(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined || eq_1(value, objectProto$e[key]) && !hasOwnProperty$b.call(object, key)) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });
    var defaults_1 = defaults;

    var builtin = {
    	"Array": false,
    	"ArrayBuffer": false,
    	Atomics: false,
    	BigInt: false,
    	BigInt64Array: false,
    	BigUint64Array: false,
    	"Boolean": false,
    	constructor: false,
    	"DataView": false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Float32Array": false,
    	"Float64Array": false,
    	"Function": false,
    	globalThis: false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"Int16Array": false,
    	"Int32Array": false,
    	"Int8Array": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Map": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	"Promise": false,
    	propertyIsEnumerable: false,
    	"Proxy": false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"Reflect": false,
    	"RegExp": false,
    	"Set": false,
    	SharedArrayBuffer: false,
    	"String": false,
    	"Symbol": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"Uint16Array": false,
    	"Uint32Array": false,
    	"Uint8Array": false,
    	"Uint8ClampedArray": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false,
    	"WeakMap": false,
    	"WeakSet": false
    };
    var es5 = {
    	"Array": false,
    	"Boolean": false,
    	constructor: false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Function": false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	propertyIsEnumerable: false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"RegExp": false,
    	"String": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false
    };
    var es2015 = {
    	"Array": false,
    	"ArrayBuffer": false,
    	"Boolean": false,
    	constructor: false,
    	"DataView": false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Float32Array": false,
    	"Float64Array": false,
    	"Function": false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"Int16Array": false,
    	"Int32Array": false,
    	"Int8Array": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Map": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	"Promise": false,
    	propertyIsEnumerable: false,
    	"Proxy": false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"Reflect": false,
    	"RegExp": false,
    	"Set": false,
    	"String": false,
    	"Symbol": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"Uint16Array": false,
    	"Uint32Array": false,
    	"Uint8Array": false,
    	"Uint8ClampedArray": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false,
    	"WeakMap": false,
    	"WeakSet": false
    };
    var es2017 = {
    	"Array": false,
    	"ArrayBuffer": false,
    	Atomics: false,
    	"Boolean": false,
    	constructor: false,
    	"DataView": false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Float32Array": false,
    	"Float64Array": false,
    	"Function": false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"Int16Array": false,
    	"Int32Array": false,
    	"Int8Array": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Map": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	"Promise": false,
    	propertyIsEnumerable: false,
    	"Proxy": false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"Reflect": false,
    	"RegExp": false,
    	"Set": false,
    	SharedArrayBuffer: false,
    	"String": false,
    	"Symbol": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"Uint16Array": false,
    	"Uint32Array": false,
    	"Uint8Array": false,
    	"Uint8ClampedArray": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false,
    	"WeakMap": false,
    	"WeakSet": false
    };
    var browser$2 = {
    	AbortController: false,
    	AbortSignal: false,
    	addEventListener: false,
    	alert: false,
    	AnalyserNode: false,
    	Animation: false,
    	AnimationEffectReadOnly: false,
    	AnimationEffectTiming: false,
    	AnimationEffectTimingReadOnly: false,
    	AnimationEvent: false,
    	AnimationPlaybackEvent: false,
    	AnimationTimeline: false,
    	applicationCache: false,
    	ApplicationCache: false,
    	ApplicationCacheErrorEvent: false,
    	atob: false,
    	Attr: false,
    	Audio: false,
    	AudioBuffer: false,
    	AudioBufferSourceNode: false,
    	AudioContext: false,
    	AudioDestinationNode: false,
    	AudioListener: false,
    	AudioNode: false,
    	AudioParam: false,
    	AudioProcessingEvent: false,
    	AudioScheduledSourceNode: false,
    	"AudioWorkletGlobalScope ": false,
    	AudioWorkletNode: false,
    	AudioWorkletProcessor: false,
    	BarProp: false,
    	BaseAudioContext: false,
    	BatteryManager: false,
    	BeforeUnloadEvent: false,
    	BiquadFilterNode: false,
    	Blob: false,
    	BlobEvent: false,
    	blur: false,
    	BroadcastChannel: false,
    	btoa: false,
    	BudgetService: false,
    	ByteLengthQueuingStrategy: false,
    	Cache: false,
    	caches: false,
    	CacheStorage: false,
    	cancelAnimationFrame: false,
    	cancelIdleCallback: false,
    	CanvasCaptureMediaStreamTrack: false,
    	CanvasGradient: false,
    	CanvasPattern: false,
    	CanvasRenderingContext2D: false,
    	ChannelMergerNode: false,
    	ChannelSplitterNode: false,
    	CharacterData: false,
    	clearInterval: false,
    	clearTimeout: false,
    	clientInformation: false,
    	ClipboardEvent: false,
    	close: false,
    	closed: false,
    	CloseEvent: false,
    	Comment: false,
    	CompositionEvent: false,
    	confirm: false,
    	console: false,
    	ConstantSourceNode: false,
    	ConvolverNode: false,
    	CountQueuingStrategy: false,
    	createImageBitmap: false,
    	Credential: false,
    	CredentialsContainer: false,
    	crypto: false,
    	Crypto: false,
    	CryptoKey: false,
    	CSS: false,
    	CSSConditionRule: false,
    	CSSFontFaceRule: false,
    	CSSGroupingRule: false,
    	CSSImportRule: false,
    	CSSKeyframeRule: false,
    	CSSKeyframesRule: false,
    	CSSMediaRule: false,
    	CSSNamespaceRule: false,
    	CSSPageRule: false,
    	CSSRule: false,
    	CSSRuleList: false,
    	CSSStyleDeclaration: false,
    	CSSStyleRule: false,
    	CSSStyleSheet: false,
    	CSSSupportsRule: false,
    	CustomElementRegistry: false,
    	customElements: false,
    	CustomEvent: false,
    	DataTransfer: false,
    	DataTransferItem: false,
    	DataTransferItemList: false,
    	defaultstatus: false,
    	defaultStatus: false,
    	DelayNode: false,
    	DeviceMotionEvent: false,
    	DeviceOrientationEvent: false,
    	devicePixelRatio: false,
    	dispatchEvent: false,
    	document: false,
    	Document: false,
    	DocumentFragment: false,
    	DocumentType: false,
    	DOMError: false,
    	DOMException: false,
    	DOMImplementation: false,
    	DOMMatrix: false,
    	DOMMatrixReadOnly: false,
    	DOMParser: false,
    	DOMPoint: false,
    	DOMPointReadOnly: false,
    	DOMQuad: false,
    	DOMRect: false,
    	DOMRectReadOnly: false,
    	DOMStringList: false,
    	DOMStringMap: false,
    	DOMTokenList: false,
    	DragEvent: false,
    	DynamicsCompressorNode: false,
    	Element: false,
    	ErrorEvent: false,
    	event: false,
    	Event: false,
    	EventSource: false,
    	EventTarget: false,
    	external: false,
    	fetch: false,
    	File: false,
    	FileList: false,
    	FileReader: false,
    	find: false,
    	focus: false,
    	FocusEvent: false,
    	FontFace: false,
    	FontFaceSetLoadEvent: false,
    	FormData: false,
    	frameElement: false,
    	frames: false,
    	GainNode: false,
    	Gamepad: false,
    	GamepadButton: false,
    	GamepadEvent: false,
    	getComputedStyle: false,
    	getSelection: false,
    	HashChangeEvent: false,
    	Headers: false,
    	history: false,
    	History: false,
    	HTMLAllCollection: false,
    	HTMLAnchorElement: false,
    	HTMLAreaElement: false,
    	HTMLAudioElement: false,
    	HTMLBaseElement: false,
    	HTMLBodyElement: false,
    	HTMLBRElement: false,
    	HTMLButtonElement: false,
    	HTMLCanvasElement: false,
    	HTMLCollection: false,
    	HTMLContentElement: false,
    	HTMLDataElement: false,
    	HTMLDataListElement: false,
    	HTMLDetailsElement: false,
    	HTMLDialogElement: false,
    	HTMLDirectoryElement: false,
    	HTMLDivElement: false,
    	HTMLDListElement: false,
    	HTMLDocument: false,
    	HTMLElement: false,
    	HTMLEmbedElement: false,
    	HTMLFieldSetElement: false,
    	HTMLFontElement: false,
    	HTMLFormControlsCollection: false,
    	HTMLFormElement: false,
    	HTMLFrameElement: false,
    	HTMLFrameSetElement: false,
    	HTMLHeadElement: false,
    	HTMLHeadingElement: false,
    	HTMLHRElement: false,
    	HTMLHtmlElement: false,
    	HTMLIFrameElement: false,
    	HTMLImageElement: false,
    	HTMLInputElement: false,
    	HTMLLabelElement: false,
    	HTMLLegendElement: false,
    	HTMLLIElement: false,
    	HTMLLinkElement: false,
    	HTMLMapElement: false,
    	HTMLMarqueeElement: false,
    	HTMLMediaElement: false,
    	HTMLMenuElement: false,
    	HTMLMetaElement: false,
    	HTMLMeterElement: false,
    	HTMLModElement: false,
    	HTMLObjectElement: false,
    	HTMLOListElement: false,
    	HTMLOptGroupElement: false,
    	HTMLOptionElement: false,
    	HTMLOptionsCollection: false,
    	HTMLOutputElement: false,
    	HTMLParagraphElement: false,
    	HTMLParamElement: false,
    	HTMLPictureElement: false,
    	HTMLPreElement: false,
    	HTMLProgressElement: false,
    	HTMLQuoteElement: false,
    	HTMLScriptElement: false,
    	HTMLSelectElement: false,
    	HTMLShadowElement: false,
    	HTMLSlotElement: false,
    	HTMLSourceElement: false,
    	HTMLSpanElement: false,
    	HTMLStyleElement: false,
    	HTMLTableCaptionElement: false,
    	HTMLTableCellElement: false,
    	HTMLTableColElement: false,
    	HTMLTableElement: false,
    	HTMLTableRowElement: false,
    	HTMLTableSectionElement: false,
    	HTMLTemplateElement: false,
    	HTMLTextAreaElement: false,
    	HTMLTimeElement: false,
    	HTMLTitleElement: false,
    	HTMLTrackElement: false,
    	HTMLUListElement: false,
    	HTMLUnknownElement: false,
    	HTMLVideoElement: false,
    	IDBCursor: false,
    	IDBCursorWithValue: false,
    	IDBDatabase: false,
    	IDBFactory: false,
    	IDBIndex: false,
    	IDBKeyRange: false,
    	IDBObjectStore: false,
    	IDBOpenDBRequest: false,
    	IDBRequest: false,
    	IDBTransaction: false,
    	IDBVersionChangeEvent: false,
    	IdleDeadline: false,
    	IIRFilterNode: false,
    	Image: false,
    	ImageBitmap: false,
    	ImageBitmapRenderingContext: false,
    	ImageCapture: false,
    	ImageData: false,
    	indexedDB: false,
    	innerHeight: false,
    	innerWidth: false,
    	InputEvent: false,
    	IntersectionObserver: false,
    	IntersectionObserverEntry: false,
    	"Intl": false,
    	isSecureContext: false,
    	KeyboardEvent: false,
    	KeyframeEffect: false,
    	KeyframeEffectReadOnly: false,
    	length: false,
    	localStorage: false,
    	location: true,
    	Location: false,
    	locationbar: false,
    	matchMedia: false,
    	MediaDeviceInfo: false,
    	MediaDevices: false,
    	MediaElementAudioSourceNode: false,
    	MediaEncryptedEvent: false,
    	MediaError: false,
    	MediaKeyMessageEvent: false,
    	MediaKeySession: false,
    	MediaKeyStatusMap: false,
    	MediaKeySystemAccess: false,
    	MediaList: false,
    	MediaQueryList: false,
    	MediaQueryListEvent: false,
    	MediaRecorder: false,
    	MediaSettingsRange: false,
    	MediaSource: false,
    	MediaStream: false,
    	MediaStreamAudioDestinationNode: false,
    	MediaStreamAudioSourceNode: false,
    	MediaStreamEvent: false,
    	MediaStreamTrack: false,
    	MediaStreamTrackEvent: false,
    	menubar: false,
    	MessageChannel: false,
    	MessageEvent: false,
    	MessagePort: false,
    	MIDIAccess: false,
    	MIDIConnectionEvent: false,
    	MIDIInput: false,
    	MIDIInputMap: false,
    	MIDIMessageEvent: false,
    	MIDIOutput: false,
    	MIDIOutputMap: false,
    	MIDIPort: false,
    	MimeType: false,
    	MimeTypeArray: false,
    	MouseEvent: false,
    	moveBy: false,
    	moveTo: false,
    	MutationEvent: false,
    	MutationObserver: false,
    	MutationRecord: false,
    	name: false,
    	NamedNodeMap: false,
    	NavigationPreloadManager: false,
    	navigator: false,
    	Navigator: false,
    	NetworkInformation: false,
    	Node: false,
    	NodeFilter: false,
    	NodeIterator: false,
    	NodeList: false,
    	Notification: false,
    	OfflineAudioCompletionEvent: false,
    	OfflineAudioContext: false,
    	offscreenBuffering: false,
    	OffscreenCanvas: true,
    	onabort: true,
    	onafterprint: true,
    	onanimationend: true,
    	onanimationiteration: true,
    	onanimationstart: true,
    	onappinstalled: true,
    	onauxclick: true,
    	onbeforeinstallprompt: true,
    	onbeforeprint: true,
    	onbeforeunload: true,
    	onblur: true,
    	oncancel: true,
    	oncanplay: true,
    	oncanplaythrough: true,
    	onchange: true,
    	onclick: true,
    	onclose: true,
    	oncontextmenu: true,
    	oncuechange: true,
    	ondblclick: true,
    	ondevicemotion: true,
    	ondeviceorientation: true,
    	ondeviceorientationabsolute: true,
    	ondrag: true,
    	ondragend: true,
    	ondragenter: true,
    	ondragleave: true,
    	ondragover: true,
    	ondragstart: true,
    	ondrop: true,
    	ondurationchange: true,
    	onemptied: true,
    	onended: true,
    	onerror: true,
    	onfocus: true,
    	ongotpointercapture: true,
    	onhashchange: true,
    	oninput: true,
    	oninvalid: true,
    	onkeydown: true,
    	onkeypress: true,
    	onkeyup: true,
    	onlanguagechange: true,
    	onload: true,
    	onloadeddata: true,
    	onloadedmetadata: true,
    	onloadstart: true,
    	onlostpointercapture: true,
    	onmessage: true,
    	onmessageerror: true,
    	onmousedown: true,
    	onmouseenter: true,
    	onmouseleave: true,
    	onmousemove: true,
    	onmouseout: true,
    	onmouseover: true,
    	onmouseup: true,
    	onmousewheel: true,
    	onoffline: true,
    	ononline: true,
    	onpagehide: true,
    	onpageshow: true,
    	onpause: true,
    	onplay: true,
    	onplaying: true,
    	onpointercancel: true,
    	onpointerdown: true,
    	onpointerenter: true,
    	onpointerleave: true,
    	onpointermove: true,
    	onpointerout: true,
    	onpointerover: true,
    	onpointerup: true,
    	onpopstate: true,
    	onprogress: true,
    	onratechange: true,
    	onrejectionhandled: true,
    	onreset: true,
    	onresize: true,
    	onscroll: true,
    	onsearch: true,
    	onseeked: true,
    	onseeking: true,
    	onselect: true,
    	onstalled: true,
    	onstorage: true,
    	onsubmit: true,
    	onsuspend: true,
    	ontimeupdate: true,
    	ontoggle: true,
    	ontransitionend: true,
    	onunhandledrejection: true,
    	onunload: true,
    	onvolumechange: true,
    	onwaiting: true,
    	onwheel: true,
    	open: false,
    	openDatabase: false,
    	opener: false,
    	Option: false,
    	origin: false,
    	OscillatorNode: false,
    	outerHeight: false,
    	outerWidth: false,
    	PageTransitionEvent: false,
    	pageXOffset: false,
    	pageYOffset: false,
    	PannerNode: false,
    	parent: false,
    	Path2D: false,
    	PaymentAddress: false,
    	PaymentRequest: false,
    	PaymentRequestUpdateEvent: false,
    	PaymentResponse: false,
    	performance: false,
    	Performance: false,
    	PerformanceEntry: false,
    	PerformanceLongTaskTiming: false,
    	PerformanceMark: false,
    	PerformanceMeasure: false,
    	PerformanceNavigation: false,
    	PerformanceNavigationTiming: false,
    	PerformanceObserver: false,
    	PerformanceObserverEntryList: false,
    	PerformancePaintTiming: false,
    	PerformanceResourceTiming: false,
    	PerformanceTiming: false,
    	PeriodicWave: false,
    	Permissions: false,
    	PermissionStatus: false,
    	personalbar: false,
    	PhotoCapabilities: false,
    	Plugin: false,
    	PluginArray: false,
    	PointerEvent: false,
    	PopStateEvent: false,
    	postMessage: false,
    	Presentation: false,
    	PresentationAvailability: false,
    	PresentationConnection: false,
    	PresentationConnectionAvailableEvent: false,
    	PresentationConnectionCloseEvent: false,
    	PresentationConnectionList: false,
    	PresentationReceiver: false,
    	PresentationRequest: false,
    	print: false,
    	ProcessingInstruction: false,
    	ProgressEvent: false,
    	PromiseRejectionEvent: false,
    	prompt: false,
    	PushManager: false,
    	PushSubscription: false,
    	PushSubscriptionOptions: false,
    	queueMicrotask: false,
    	RadioNodeList: false,
    	Range: false,
    	ReadableStream: false,
    	registerProcessor: false,
    	RemotePlayback: false,
    	removeEventListener: false,
    	Request: false,
    	requestAnimationFrame: false,
    	requestIdleCallback: false,
    	resizeBy: false,
    	ResizeObserver: false,
    	ResizeObserverEntry: false,
    	resizeTo: false,
    	Response: false,
    	RTCCertificate: false,
    	RTCDataChannel: false,
    	RTCDataChannelEvent: false,
    	RTCDtlsTransport: false,
    	RTCIceCandidate: false,
    	RTCIceGatherer: false,
    	RTCIceTransport: false,
    	RTCPeerConnection: false,
    	RTCPeerConnectionIceEvent: false,
    	RTCRtpContributingSource: false,
    	RTCRtpReceiver: false,
    	RTCRtpSender: false,
    	RTCSctpTransport: false,
    	RTCSessionDescription: false,
    	RTCStatsReport: false,
    	RTCTrackEvent: false,
    	screen: false,
    	Screen: false,
    	screenLeft: false,
    	ScreenOrientation: false,
    	screenTop: false,
    	screenX: false,
    	screenY: false,
    	ScriptProcessorNode: false,
    	scroll: false,
    	scrollbars: false,
    	scrollBy: false,
    	scrollTo: false,
    	scrollX: false,
    	scrollY: false,
    	SecurityPolicyViolationEvent: false,
    	Selection: false,
    	self: false,
    	ServiceWorker: false,
    	ServiceWorkerContainer: false,
    	ServiceWorkerRegistration: false,
    	sessionStorage: false,
    	setInterval: false,
    	setTimeout: false,
    	ShadowRoot: false,
    	SharedWorker: false,
    	SourceBuffer: false,
    	SourceBufferList: false,
    	speechSynthesis: false,
    	SpeechSynthesisEvent: false,
    	SpeechSynthesisUtterance: false,
    	StaticRange: false,
    	status: false,
    	statusbar: false,
    	StereoPannerNode: false,
    	stop: false,
    	Storage: false,
    	StorageEvent: false,
    	StorageManager: false,
    	styleMedia: false,
    	StyleSheet: false,
    	StyleSheetList: false,
    	SubtleCrypto: false,
    	SVGAElement: false,
    	SVGAngle: false,
    	SVGAnimatedAngle: false,
    	SVGAnimatedBoolean: false,
    	SVGAnimatedEnumeration: false,
    	SVGAnimatedInteger: false,
    	SVGAnimatedLength: false,
    	SVGAnimatedLengthList: false,
    	SVGAnimatedNumber: false,
    	SVGAnimatedNumberList: false,
    	SVGAnimatedPreserveAspectRatio: false,
    	SVGAnimatedRect: false,
    	SVGAnimatedString: false,
    	SVGAnimatedTransformList: false,
    	SVGAnimateElement: false,
    	SVGAnimateMotionElement: false,
    	SVGAnimateTransformElement: false,
    	SVGAnimationElement: false,
    	SVGCircleElement: false,
    	SVGClipPathElement: false,
    	SVGComponentTransferFunctionElement: false,
    	SVGDefsElement: false,
    	SVGDescElement: false,
    	SVGDiscardElement: false,
    	SVGElement: false,
    	SVGEllipseElement: false,
    	SVGFEBlendElement: false,
    	SVGFEColorMatrixElement: false,
    	SVGFEComponentTransferElement: false,
    	SVGFECompositeElement: false,
    	SVGFEConvolveMatrixElement: false,
    	SVGFEDiffuseLightingElement: false,
    	SVGFEDisplacementMapElement: false,
    	SVGFEDistantLightElement: false,
    	SVGFEDropShadowElement: false,
    	SVGFEFloodElement: false,
    	SVGFEFuncAElement: false,
    	SVGFEFuncBElement: false,
    	SVGFEFuncGElement: false,
    	SVGFEFuncRElement: false,
    	SVGFEGaussianBlurElement: false,
    	SVGFEImageElement: false,
    	SVGFEMergeElement: false,
    	SVGFEMergeNodeElement: false,
    	SVGFEMorphologyElement: false,
    	SVGFEOffsetElement: false,
    	SVGFEPointLightElement: false,
    	SVGFESpecularLightingElement: false,
    	SVGFESpotLightElement: false,
    	SVGFETileElement: false,
    	SVGFETurbulenceElement: false,
    	SVGFilterElement: false,
    	SVGForeignObjectElement: false,
    	SVGGElement: false,
    	SVGGeometryElement: false,
    	SVGGradientElement: false,
    	SVGGraphicsElement: false,
    	SVGImageElement: false,
    	SVGLength: false,
    	SVGLengthList: false,
    	SVGLinearGradientElement: false,
    	SVGLineElement: false,
    	SVGMarkerElement: false,
    	SVGMaskElement: false,
    	SVGMatrix: false,
    	SVGMetadataElement: false,
    	SVGMPathElement: false,
    	SVGNumber: false,
    	SVGNumberList: false,
    	SVGPathElement: false,
    	SVGPatternElement: false,
    	SVGPoint: false,
    	SVGPointList: false,
    	SVGPolygonElement: false,
    	SVGPolylineElement: false,
    	SVGPreserveAspectRatio: false,
    	SVGRadialGradientElement: false,
    	SVGRect: false,
    	SVGRectElement: false,
    	SVGScriptElement: false,
    	SVGSetElement: false,
    	SVGStopElement: false,
    	SVGStringList: false,
    	SVGStyleElement: false,
    	SVGSVGElement: false,
    	SVGSwitchElement: false,
    	SVGSymbolElement: false,
    	SVGTextContentElement: false,
    	SVGTextElement: false,
    	SVGTextPathElement: false,
    	SVGTextPositioningElement: false,
    	SVGTitleElement: false,
    	SVGTransform: false,
    	SVGTransformList: false,
    	SVGTSpanElement: false,
    	SVGUnitTypes: false,
    	SVGUseElement: false,
    	SVGViewElement: false,
    	TaskAttributionTiming: false,
    	Text: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	TextEvent: false,
    	TextMetrics: false,
    	TextTrack: false,
    	TextTrackCue: false,
    	TextTrackCueList: false,
    	TextTrackList: false,
    	TimeRanges: false,
    	toolbar: false,
    	top: false,
    	Touch: false,
    	TouchEvent: false,
    	TouchList: false,
    	TrackEvent: false,
    	TransitionEvent: false,
    	TreeWalker: false,
    	UIEvent: false,
    	URL: false,
    	URLSearchParams: false,
    	ValidityState: false,
    	visualViewport: false,
    	VisualViewport: false,
    	VTTCue: false,
    	WaveShaperNode: false,
    	WebAssembly: false,
    	WebGL2RenderingContext: false,
    	WebGLActiveInfo: false,
    	WebGLBuffer: false,
    	WebGLContextEvent: false,
    	WebGLFramebuffer: false,
    	WebGLProgram: false,
    	WebGLQuery: false,
    	WebGLRenderbuffer: false,
    	WebGLRenderingContext: false,
    	WebGLSampler: false,
    	WebGLShader: false,
    	WebGLShaderPrecisionFormat: false,
    	WebGLSync: false,
    	WebGLTexture: false,
    	WebGLTransformFeedback: false,
    	WebGLUniformLocation: false,
    	WebGLVertexArrayObject: false,
    	WebSocket: false,
    	WheelEvent: false,
    	window: false,
    	Window: false,
    	Worker: false,
    	WritableStream: false,
    	XMLDocument: false,
    	XMLHttpRequest: false,
    	XMLHttpRequestEventTarget: false,
    	XMLHttpRequestUpload: false,
    	XMLSerializer: false,
    	XPathEvaluator: false,
    	XPathExpression: false,
    	XPathResult: false,
    	XSLTProcessor: false
    };
    var worker = {
    	addEventListener: false,
    	applicationCache: false,
    	atob: false,
    	Blob: false,
    	BroadcastChannel: false,
    	btoa: false,
    	Cache: false,
    	caches: false,
    	clearInterval: false,
    	clearTimeout: false,
    	close: true,
    	console: false,
    	fetch: false,
    	FileReaderSync: false,
    	FormData: false,
    	Headers: false,
    	IDBCursor: false,
    	IDBCursorWithValue: false,
    	IDBDatabase: false,
    	IDBFactory: false,
    	IDBIndex: false,
    	IDBKeyRange: false,
    	IDBObjectStore: false,
    	IDBOpenDBRequest: false,
    	IDBRequest: false,
    	IDBTransaction: false,
    	IDBVersionChangeEvent: false,
    	ImageData: false,
    	importScripts: true,
    	indexedDB: false,
    	location: false,
    	MessageChannel: false,
    	MessagePort: false,
    	name: false,
    	navigator: false,
    	Notification: false,
    	onclose: true,
    	onconnect: true,
    	onerror: true,
    	onlanguagechange: true,
    	onmessage: true,
    	onoffline: true,
    	ononline: true,
    	onrejectionhandled: true,
    	onunhandledrejection: true,
    	performance: false,
    	Performance: false,
    	PerformanceEntry: false,
    	PerformanceMark: false,
    	PerformanceMeasure: false,
    	PerformanceNavigation: false,
    	PerformanceResourceTiming: false,
    	PerformanceTiming: false,
    	postMessage: true,
    	"Promise": false,
    	queueMicrotask: false,
    	removeEventListener: false,
    	Request: false,
    	Response: false,
    	self: true,
    	ServiceWorkerRegistration: false,
    	setInterval: false,
    	setTimeout: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	URL: false,
    	URLSearchParams: false,
    	WebSocket: false,
    	Worker: false,
    	WorkerGlobalScope: false,
    	XMLHttpRequest: false
    };
    var node = {
    	__dirname: false,
    	__filename: false,
    	Buffer: false,
    	clearImmediate: false,
    	clearInterval: false,
    	clearTimeout: false,
    	console: false,
    	exports: true,
    	global: false,
    	"Intl": false,
    	module: false,
    	process: false,
    	queueMicrotask: false,
    	require: false,
    	setImmediate: false,
    	setInterval: false,
    	setTimeout: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	URL: false,
    	URLSearchParams: false
    };
    var commonjs = {
    	exports: true,
    	global: false,
    	module: false,
    	require: false
    };
    var amd = {
    	define: false,
    	require: false
    };
    var mocha = {
    	after: false,
    	afterEach: false,
    	before: false,
    	beforeEach: false,
    	context: false,
    	describe: false,
    	it: false,
    	mocha: false,
    	run: false,
    	setup: false,
    	specify: false,
    	suite: false,
    	suiteSetup: false,
    	suiteTeardown: false,
    	teardown: false,
    	test: false,
    	xcontext: false,
    	xdescribe: false,
    	xit: false,
    	xspecify: false
    };
    var jasmine = {
    	afterAll: false,
    	afterEach: false,
    	beforeAll: false,
    	beforeEach: false,
    	describe: false,
    	expect: false,
    	fail: false,
    	fdescribe: false,
    	fit: false,
    	it: false,
    	jasmine: false,
    	pending: false,
    	runs: false,
    	spyOn: false,
    	spyOnProperty: false,
    	waits: false,
    	waitsFor: false,
    	xdescribe: false,
    	xit: false
    };
    var jest = {
    	afterAll: false,
    	afterEach: false,
    	beforeAll: false,
    	beforeEach: false,
    	describe: false,
    	expect: false,
    	fdescribe: false,
    	fit: false,
    	it: false,
    	jest: false,
    	pit: false,
    	require: false,
    	test: false,
    	xdescribe: false,
    	xit: false,
    	xtest: false
    };
    var qunit = {
    	asyncTest: false,
    	deepEqual: false,
    	equal: false,
    	expect: false,
    	module: false,
    	notDeepEqual: false,
    	notEqual: false,
    	notOk: false,
    	notPropEqual: false,
    	notStrictEqual: false,
    	ok: false,
    	propEqual: false,
    	QUnit: false,
    	raises: false,
    	start: false,
    	stop: false,
    	strictEqual: false,
    	test: false,
    	throws: false
    };
    var phantomjs = {
    	console: true,
    	exports: true,
    	phantom: true,
    	require: true,
    	WebPage: true
    };
    var couch = {
    	emit: false,
    	exports: false,
    	getRow: false,
    	log: false,
    	module: false,
    	provides: false,
    	require: false,
    	respond: false,
    	send: false,
    	start: false,
    	sum: false
    };
    var rhino = {
    	defineClass: false,
    	deserialize: false,
    	gc: false,
    	help: false,
    	importClass: false,
    	importPackage: false,
    	java: false,
    	load: false,
    	loadClass: false,
    	Packages: false,
    	print: false,
    	quit: false,
    	readFile: false,
    	readUrl: false,
    	runCommand: false,
    	seal: false,
    	serialize: false,
    	spawn: false,
    	sync: false,
    	toint32: false,
    	version: false
    };
    var nashorn = {
    	__DIR__: false,
    	__FILE__: false,
    	__LINE__: false,
    	com: false,
    	edu: false,
    	exit: false,
    	java: false,
    	Java: false,
    	javafx: false,
    	JavaImporter: false,
    	javax: false,
    	JSAdapter: false,
    	load: false,
    	loadWithNewGlobal: false,
    	org: false,
    	Packages: false,
    	print: false,
    	quit: false
    };
    var wsh = {
    	ActiveXObject: true,
    	Enumerator: true,
    	GetObject: true,
    	ScriptEngine: true,
    	ScriptEngineBuildVersion: true,
    	ScriptEngineMajorVersion: true,
    	ScriptEngineMinorVersion: true,
    	VBArray: true,
    	WScript: true,
    	WSH: true,
    	XDomainRequest: true
    };
    var jquery = {
    	$: false,
    	jQuery: false
    };
    var yui = {
    	YAHOO: false,
    	YAHOO_config: false,
    	YUI: false,
    	YUI_config: false
    };
    var shelljs = {
    	cat: false,
    	cd: false,
    	chmod: false,
    	config: false,
    	cp: false,
    	dirs: false,
    	echo: false,
    	env: false,
    	error: false,
    	exec: false,
    	exit: false,
    	find: false,
    	grep: false,
    	ln: false,
    	ls: false,
    	mkdir: false,
    	mv: false,
    	popd: false,
    	pushd: false,
    	pwd: false,
    	rm: false,
    	sed: false,
    	set: false,
    	target: false,
    	tempdir: false,
    	test: false,
    	touch: false,
    	which: false
    };
    var prototypejs = {
    	$: false,
    	$$: false,
    	$A: false,
    	$break: false,
    	$continue: false,
    	$F: false,
    	$H: false,
    	$R: false,
    	$w: false,
    	Abstract: false,
    	Ajax: false,
    	Autocompleter: false,
    	Builder: false,
    	Class: false,
    	Control: false,
    	Draggable: false,
    	Draggables: false,
    	Droppables: false,
    	Effect: false,
    	Element: false,
    	Enumerable: false,
    	Event: false,
    	Field: false,
    	Form: false,
    	Hash: false,
    	Insertion: false,
    	ObjectRange: false,
    	PeriodicalExecuter: false,
    	Position: false,
    	Prototype: false,
    	Scriptaculous: false,
    	Selector: false,
    	Sortable: false,
    	SortableObserver: false,
    	Sound: false,
    	Template: false,
    	Toggle: false,
    	Try: false
    };
    var meteor = {
    	_: false,
    	$: false,
    	Accounts: false,
    	AccountsClient: false,
    	AccountsCommon: false,
    	AccountsServer: false,
    	App: false,
    	Assets: false,
    	Blaze: false,
    	check: false,
    	Cordova: false,
    	DDP: false,
    	DDPRateLimiter: false,
    	DDPServer: false,
    	Deps: false,
    	EJSON: false,
    	Email: false,
    	HTTP: false,
    	Log: false,
    	Match: false,
    	Meteor: false,
    	Mongo: false,
    	MongoInternals: false,
    	Npm: false,
    	Package: false,
    	Plugin: false,
    	process: false,
    	Random: false,
    	ReactiveDict: false,
    	ReactiveVar: false,
    	Router: false,
    	ServiceConfiguration: false,
    	Session: false,
    	share: false,
    	Spacebars: false,
    	Template: false,
    	Tinytest: false,
    	Tracker: false,
    	UI: false,
    	Utils: false,
    	WebApp: false,
    	WebAppInternals: false
    };
    var mongo = {
    	_isWindows: false,
    	_rand: false,
    	BulkWriteResult: false,
    	cat: false,
    	cd: false,
    	connect: false,
    	db: false,
    	getHostName: false,
    	getMemInfo: false,
    	hostname: false,
    	ISODate: false,
    	listFiles: false,
    	load: false,
    	ls: false,
    	md5sumFile: false,
    	mkdir: false,
    	Mongo: false,
    	NumberInt: false,
    	NumberLong: false,
    	ObjectId: false,
    	PlanCache: false,
    	print: false,
    	printjson: false,
    	pwd: false,
    	quit: false,
    	removeFile: false,
    	rs: false,
    	sh: false,
    	UUID: false,
    	version: false,
    	WriteResult: false
    };
    var applescript = {
    	$: false,
    	Application: false,
    	Automation: false,
    	console: false,
    	delay: false,
    	Library: false,
    	ObjC: false,
    	ObjectSpecifier: false,
    	Path: false,
    	Progress: false,
    	Ref: false
    };
    var serviceworker = {
    	addEventListener: false,
    	applicationCache: false,
    	atob: false,
    	Blob: false,
    	BroadcastChannel: false,
    	btoa: false,
    	Cache: false,
    	caches: false,
    	CacheStorage: false,
    	clearInterval: false,
    	clearTimeout: false,
    	Client: false,
    	clients: false,
    	Clients: false,
    	close: true,
    	console: false,
    	ExtendableEvent: false,
    	ExtendableMessageEvent: false,
    	fetch: false,
    	FetchEvent: false,
    	FileReaderSync: false,
    	FormData: false,
    	Headers: false,
    	IDBCursor: false,
    	IDBCursorWithValue: false,
    	IDBDatabase: false,
    	IDBFactory: false,
    	IDBIndex: false,
    	IDBKeyRange: false,
    	IDBObjectStore: false,
    	IDBOpenDBRequest: false,
    	IDBRequest: false,
    	IDBTransaction: false,
    	IDBVersionChangeEvent: false,
    	ImageData: false,
    	importScripts: false,
    	indexedDB: false,
    	location: false,
    	MessageChannel: false,
    	MessagePort: false,
    	name: false,
    	navigator: false,
    	Notification: false,
    	onclose: true,
    	onconnect: true,
    	onerror: true,
    	onfetch: true,
    	oninstall: true,
    	onlanguagechange: true,
    	onmessage: true,
    	onmessageerror: true,
    	onnotificationclick: true,
    	onnotificationclose: true,
    	onoffline: true,
    	ononline: true,
    	onpush: true,
    	onpushsubscriptionchange: true,
    	onrejectionhandled: true,
    	onsync: true,
    	onunhandledrejection: true,
    	performance: false,
    	Performance: false,
    	PerformanceEntry: false,
    	PerformanceMark: false,
    	PerformanceMeasure: false,
    	PerformanceNavigation: false,
    	PerformanceResourceTiming: false,
    	PerformanceTiming: false,
    	postMessage: true,
    	"Promise": false,
    	queueMicrotask: false,
    	registration: false,
    	removeEventListener: false,
    	Request: false,
    	Response: false,
    	self: false,
    	ServiceWorker: false,
    	ServiceWorkerContainer: false,
    	ServiceWorkerGlobalScope: false,
    	ServiceWorkerMessageEvent: false,
    	ServiceWorkerRegistration: false,
    	setInterval: false,
    	setTimeout: false,
    	skipWaiting: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	URL: false,
    	URLSearchParams: false,
    	WebSocket: false,
    	WindowClient: false,
    	Worker: false,
    	WorkerGlobalScope: false,
    	XMLHttpRequest: false
    };
    var atomtest = {
    	advanceClock: false,
    	fakeClearInterval: false,
    	fakeClearTimeout: false,
    	fakeSetInterval: false,
    	fakeSetTimeout: false,
    	resetTimeouts: false,
    	waitsForPromise: false
    };
    var embertest = {
    	andThen: false,
    	click: false,
    	currentPath: false,
    	currentRouteName: false,
    	currentURL: false,
    	fillIn: false,
    	find: false,
    	findAll: false,
    	findWithAssert: false,
    	keyEvent: false,
    	pauseTest: false,
    	resumeTest: false,
    	triggerEvent: false,
    	visit: false,
    	wait: false
    };
    var protractor = {
    	$: false,
    	$$: false,
    	browser: false,
    	by: false,
    	By: false,
    	DartObject: false,
    	element: false,
    	protractor: false
    };
    var webextensions = {
    	browser: false,
    	chrome: false,
    	opr: false
    };
    var greasemonkey = {
    	cloneInto: false,
    	createObjectIn: false,
    	exportFunction: false,
    	GM: false,
    	GM_addStyle: false,
    	GM_deleteValue: false,
    	GM_getResourceText: false,
    	GM_getResourceURL: false,
    	GM_getValue: false,
    	GM_info: false,
    	GM_listValues: false,
    	GM_log: false,
    	GM_openInTab: false,
    	GM_registerMenuCommand: false,
    	GM_setClipboard: false,
    	GM_setValue: false,
    	GM_xmlhttpRequest: false,
    	unsafeWindow: false
    };
    var devtools = {
    	$: false,
    	$_: false,
    	$$: false,
    	$0: false,
    	$1: false,
    	$2: false,
    	$3: false,
    	$4: false,
    	$x: false,
    	chrome: false,
    	clear: false,
    	copy: false,
    	debug: false,
    	dir: false,
    	dirxml: false,
    	getEventListeners: false,
    	inspect: false,
    	keys: false,
    	monitor: false,
    	monitorEvents: false,
    	profile: false,
    	profileEnd: false,
    	queryObjects: false,
    	table: false,
    	undebug: false,
    	unmonitor: false,
    	unmonitorEvents: false,
    	values: false
    };
    var globals = {
    	builtin: builtin,
    	es5: es5,
    	es2015: es2015,
    	es2017: es2017,
    	browser: browser$2,
    	worker: worker,
    	node: node,
    	commonjs: commonjs,
    	amd: amd,
    	mocha: mocha,
    	jasmine: jasmine,
    	jest: jest,
    	qunit: qunit,
    	phantomjs: phantomjs,
    	couch: couch,
    	rhino: rhino,
    	nashorn: nashorn,
    	wsh: wsh,
    	jquery: jquery,
    	yui: yui,
    	shelljs: shelljs,
    	prototypejs: prototypejs,
    	meteor: meteor,
    	mongo: mongo,
    	applescript: applescript,
    	serviceworker: serviceworker,
    	atomtest: atomtest,
    	embertest: embertest,
    	protractor: protractor,
    	"shared-node-browser": {
    	clearInterval: false,
    	clearTimeout: false,
    	console: false,
    	setInterval: false,
    	setTimeout: false,
    	URL: false,
    	URLSearchParams: false
    },
    	webextensions: webextensions,
    	greasemonkey: greasemonkey,
    	devtools: devtools
    };

    var globals$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      builtin: builtin,
      es5: es5,
      es2015: es2015,
      es2017: es2017,
      browser: browser$2,
      worker: worker,
      node: node,
      commonjs: commonjs,
      amd: amd,
      mocha: mocha,
      jasmine: jasmine,
      jest: jest,
      qunit: qunit,
      phantomjs: phantomjs,
      couch: couch,
      rhino: rhino,
      nashorn: nashorn,
      wsh: wsh,
      jquery: jquery,
      yui: yui,
      shelljs: shelljs,
      prototypejs: prototypejs,
      meteor: meteor,
      mongo: mongo,
      applescript: applescript,
      serviceworker: serviceworker,
      atomtest: atomtest,
      embertest: embertest,
      protractor: protractor,
      webextensions: webextensions,
      greasemonkey: greasemonkey,
      devtools: devtools,
      'default': globals
    });

    var require$$0 = getCjsExportFromNamespace(globals$1);

    var globals$2 = require$$0;

    var path = new WeakMap();
    var scope = new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      path = new WeakMap();
    }
    function clearScope() {
      scope = new WeakMap();
    }

    var cache = /*#__PURE__*/Object.freeze({
      __proto__: null,
      get path () { return path; },
      get scope () { return scope; },
      clear: clear,
      clearPath: clearPath,
      clearScope: clearScope
    });

    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (isModuleDeclaration(node)) {
            if (node.source) {
              gatherNodeParts(node.source, parts);
            } else if (node.specifiers && node.specifiers.length) {
              for (var _iterator = _createForOfIteratorHelperLoose(node.specifiers), _step; !(_step = _iterator()).done;) {
                var e = _step.value;
                gatherNodeParts(e, parts);
              }
            } else if (node.declaration) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (isLiteral(node)) {
            parts.push(node.value);
          }

          break;

        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;

        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;

        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;

        case "ObjectExpression":
        case "ObjectPattern":
          for (var _iterator2 = _createForOfIteratorHelperLoose(node.properties), _step2; !(_step2 = _iterator2()).done;) {
            var _e = _step2.value;
            gatherNodeParts(_e, parts);
          }

          break;

        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;

        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;

        case "ThisExpression":
          parts.push("this");
          break;

        case "Super":
          parts.push("super");
          break;

        case "Import":
          parts.push("import");
          break;

        case "DoExpression":
          parts.push("do");
          break;

        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node.argument, parts);
          break;

        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node.argument, parts);
          break;

        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;

        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;

        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;

        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;

        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;

        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;

        case "MetaProperty":
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;

        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;

        case "JSXOpeningElement":
          parts.push(node.name);
          break;

        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;

        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;

        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }

    var collectorVisitor = {
      For: function For(path) {
        for (var _i = 0, _arr = FOR_INIT_KEYS; _i < _arr.length; _i++) {
          var key = _arr[_i];
          var declar = path.get(key);

          if (declar.isVar()) {
            var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
            parentScope.registerBinding("var", declar);
          }
        }
      },
      Declaration: function Declaration(path) {
        if (path.isBlockScoped()) return;

        if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) {
          return;
        }

        var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        state.references.push(path);
      },
      ForXStatement: function ForXStatement(path, state) {
        var left = path.get("left");

        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        }
      },
      ExportDeclaration: {
        exit: function exit(path) {
          var node = path.node,
              scope = path.scope;
          var declar = node.declaration;

          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            var id = declar.id;
            if (!id) return;
            var binding = scope.getBinding(id.name);
            if (binding) binding.reference(path);
          } else if (isVariableDeclaration(declar)) {
            for (var _i2 = 0, _arr2 = declar.declarations; _i2 < _arr2.length; _i2++) {
              var decl = _arr2[_i2];

              for (var _i3 = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i3 < _Object$keys.length; _i3++) {
                var name = _Object$keys[_i3];

                var _binding = scope.getBinding(name);

                if (_binding) _binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement: function LabeledStatement(path) {
        path.scope.getProgramParent().addGlobal(path.node);
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression: function AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression: function UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression: function UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped: function BlockScoped(path) {
        var scope = path.scope;
        if (scope.path === path) scope = scope.parent;
        var parent = scope.getBlockParent();
        parent.registerDeclaration(path);

        if (path.isClassDeclaration() && path.node.id) {
          var id = path.node.id;
          var name = id.name;
          path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
      },
      Block: function Block(path) {
        var paths = path.get("body");

        for (var _i4 = 0, _arr3 = paths; _i4 < _arr3.length; _i4++) {
          var bodyPath = _arr3[_i4];

          if (bodyPath.isFunctionDeclaration()) {
            path.scope.getBlockParent().registerDeclaration(bodyPath);
          }
        }
      },
      CatchClause: function CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function: function Function(path) {
        if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }

        var params = path.get("params");

        for (var _iterator3 = _createForOfIteratorHelperLoose(params), _step3; !(_step3 = _iterator3()).done;) {
          var param = _step3.value;
          path.scope.registerBinding("param", param);
        }
      },
      ClassExpression: function ClassExpression(path) {
        if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path);
        }
      }
    };
    var uid = 0;

    var Scope$1 = function () {
      function Scope(path) {
        var node = path.node;
        var cached = scope.get(node);

        if (cached && cached.path === path) {
          return cached;
        }

        scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels = new Map();
        this.inited = false;
      }

      var _proto = Scope.prototype;

      _proto.traverse = function traverse(node, opts, state) {
        traverse$1(node, opts, this, state, this.path);
      };

      _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {
        var id = this.generateUidIdentifier(name);
        this.push({
          id: id
        });
        return cloneNode(id);
      };

      _proto.generateUidIdentifier = function generateUidIdentifier(name) {
        return Identifier(this.generateUid(name));
      };

      _proto.generateUid = function generateUid(name) {
        if (name === void 0) {
          name = "temp";
        }

        name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
        var uid;
        var i = 0;

        do {
          uid = this._generateUid(name, i);
          i++;
        } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

        var program = this.getProgramParent();
        program.references[uid] = true;
        program.uids[uid] = true;
        return uid;
      };

      _proto._generateUid = function _generateUid(name, i) {
        var id = name;
        if (i > 1) id += i;
        return "_" + id;
      };

      _proto.generateUidBasedOnNode = function generateUidBasedOnNode(node, defaultName) {
        var parts = [];
        gatherNodeParts(node, parts);
        var id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      };

      _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(node, defaultName) {
        return Identifier(this.generateUidBasedOnNode(node, defaultName));
      };

      _proto.isStatic = function isStatic(node) {
        if (isThisExpression(node) || isSuper(node)) {
          return true;
        }

        if (isIdentifier(node)) {
          var binding = this.getBinding(node.name);

          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }

        return false;
      };

      _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          var id = this.generateUidIdentifierBasedOnNode(node);

          if (!dontPush) {
            this.push({
              id: id
            });
            return cloneNode(id);
          }

          return id;
        }
      };

      _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

        if (duplicate) {
          throw this.hub.buildError(id, "Duplicate declaration \"" + name + "\"", TypeError);
        }
      };

      _proto.rename = function rename(oldName, newName, block) {
        var binding = this.getBinding(oldName);

        if (binding) {
          newName = newName || this.generateUidIdentifier(oldName).name;
          return new Renamer(binding, oldName, newName).rename(block);
        }
      };

      _proto._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      };

      _proto.dump = function dump() {
        var sep = repeat_1("-", 60);
        console.log(sep);
        var scope = this;

        do {
          console.log("#", scope.block.type);

          for (var _i5 = 0, _Object$keys2 = Object.keys(scope.bindings); _i5 < _Object$keys2.length; _i5++) {
            var name = _Object$keys2[_i5];
            var binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);

        console.log(sep);
      };

      _proto.toArray = function toArray(node, i) {
        if (isIdentifier(node)) {
          var binding = this.getBinding(node.name);

          if (binding && binding.constant && binding.path.isGenericType("Array")) {
            return node;
          }
        }

        if (isArrayExpression(node)) {
          return node;
        }

        if (isIdentifier(node, {
          name: "arguments"
        })) {
          return CallExpression(MemberExpression(MemberExpression(MemberExpression(Identifier("Array"), Identifier("prototype")), Identifier("slice")), Identifier("call")), [node]);
        }

        var helperName;
        var args = [node];

        if (i === true) {
          helperName = "toConsumableArray";
        } else if (i) {
          args.push(NumericLiteral(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }

        return CallExpression(this.hub.addHelper(helperName), args);
      };

      _proto.hasLabel = function hasLabel(name) {
        return !!this.getLabel(name);
      };

      _proto.getLabel = function getLabel(name) {
        return this.labels.get(name);
      };

      _proto.registerLabel = function registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      };

      _proto.registerDeclaration = function registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          var declarations = path.get("declarations");

          for (var _i6 = 0, _arr4 = declarations; _i6 < _arr4.length; _i6++) {
            var declar = _arr4[_i6];
            this.registerBinding(path.node.kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          var specifiers = path.get("specifiers");

          for (var _i7 = 0, _arr5 = specifiers; _i7 < _arr5.length; _i7++) {
            var specifier = _arr5[_i7];
            this.registerBinding("module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          var _declar = path.get("declaration");

          if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
            this.registerDeclaration(_declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      };

      _proto.buildUndefinedNode = function buildUndefinedNode() {
        return UnaryExpression("void", NumericLiteral(0), true);
      };

      _proto.registerConstantViolation = function registerConstantViolation(path) {
        var ids = path.getBindingIdentifiers();

        for (var _i8 = 0, _Object$keys3 = Object.keys(ids); _i8 < _Object$keys3.length; _i8++) {
          var name = _Object$keys3[_i8];
          var binding = this.getBinding(name);
          if (binding) binding.reassign(path);
        }
      };

      _proto.registerBinding = function registerBinding(kind, path, bindingPath) {
        if (bindingPath === void 0) {
          bindingPath = path;
        }

        if (!kind) throw new ReferenceError("no `kind`");

        if (path.isVariableDeclaration()) {
          var declarators = path.get("declarations");

          for (var _iterator4 = _createForOfIteratorHelperLoose(declarators), _step4; !(_step4 = _iterator4()).done;) {
            var declar = _step4.value;
            this.registerBinding(kind, declar);
          }

          return;
        }

        var parent = this.getProgramParent();
        var ids = path.getOuterBindingIdentifiers(true);

        for (var _i9 = 0, _Object$keys4 = Object.keys(ids); _i9 < _Object$keys4.length; _i9++) {
          var name = _Object$keys4[_i9];
          parent.references[name] = true;

          for (var _i10 = 0, _arr6 = ids[name]; _i10 < _arr6.length; _i10++) {
            var id = _arr6[_i10];
            var local = this.getOwnBinding(name);

            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }

            if (local) {
              this.registerConstantViolation(bindingPath);
            } else {
              this.bindings[name] = new Binding({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind: kind
              });
            }
          }
        }
      };

      _proto.addGlobal = function addGlobal(node) {
        this.globals[node.name] = node;
      };

      _proto.hasUid = function hasUid(name) {
        var scope = this;

        do {
          if (scope.uids[name]) return true;
        } while (scope = scope.parent);

        return false;
      };

      _proto.hasGlobal = function hasGlobal(name) {
        var scope = this;

        do {
          if (scope.globals[name]) return true;
        } while (scope = scope.parent);

        return false;
      };

      _proto.hasReference = function hasReference(name) {
        return !!this.getProgramParent().references[name];
      };

      _proto.isPure = function isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isClass(node)) {
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }

          return this.isPure(node.body, constantsOnly);
        } else if (isClassBody(node)) {
          for (var _iterator5 = _createForOfIteratorHelperLoose(node.body), _step5; !(_step5 = _iterator5()).done;) {
            var method = _step5.value;
            if (!this.isPure(method, constantsOnly)) return false;
          }

          return true;
        } else if (isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression(node)) {
          for (var _i11 = 0, _arr7 = node.elements; _i11 < _arr7.length; _i11++) {
            var elem = _arr7[_i11];
            if (!this.isPure(elem, constantsOnly)) return false;
          }

          return true;
        } else if (isObjectExpression(node)) {
          for (var _i12 = 0, _arr8 = node.properties; _i12 < _arr8.length; _i12++) {
            var prop = _arr8[_i12];
            if (!this.isPure(prop, constantsOnly)) return false;
          }

          return true;
        } else if (isMethod(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (node.kind === "get" || node.kind === "set") return false;
          return true;
        } else if (isProperty(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          return this.isPure(node.value, constantsOnly);
        } else if (isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (isTaggedTemplateExpression(node)) {
          return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
        } else if (isTemplateLiteral(node)) {
          for (var _i13 = 0, _arr9 = node.expressions; _i13 < _arr9.length; _i13++) {
            var expression = _arr9[_i13];
            if (!this.isPure(expression, constantsOnly)) return false;
          }

          return true;
        } else {
          return isPureish(node);
        }
      };

      _proto.setData = function setData(key, val) {
        return this.data[key] = val;
      };

      _proto.getData = function getData(key) {
        var scope = this;

        do {
          var data = scope.data[key];
          if (data != null) return data;
        } while (scope = scope.parent);
      };

      _proto.removeData = function removeData(key) {
        var scope = this;

        do {
          var data = scope.data[key];
          if (data != null) scope.data[key] = null;
        } while (scope = scope.parent);
      };

      _proto.init = function init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      };

      _proto.crawl = function crawl() {
        var path = this.path;
        this.references = Object.create(null);
        this.bindings = Object.create(null);
        this.globals = Object.create(null);
        this.uids = Object.create(null);
        this.data = Object.create(null);

        if (path.isFunction()) {
          if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
            this.registerBinding("local", path.get("id"), path);
          }

          var params = path.get("params");

          for (var _iterator6 = _createForOfIteratorHelperLoose(params), _step6; !(_step6 = _iterator6()).done;) {
            var param = _step6.value;
            this.registerBinding("param", param);
          }
        }

        var programParent = this.getProgramParent();
        if (programParent.crawling) return;
        var state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        path.traverse(collectorVisitor, state);
        this.crawling = false;

        for (var _iterator7 = _createForOfIteratorHelperLoose(state.assignments), _step7; !(_step7 = _iterator7()).done;) {
          var _path = _step7.value;

          var ids = _path.getBindingIdentifiers();

          for (var _i14 = 0, _Object$keys5 = Object.keys(ids); _i14 < _Object$keys5.length; _i14++) {
            var name = _Object$keys5[_i14];
            if (_path.scope.getBinding(name)) continue;
            programParent.addGlobal(ids[name]);
          }

          _path.scope.registerConstantViolation(_path);
        }

        for (var _iterator8 = _createForOfIteratorHelperLoose(state.references), _step8; !(_step8 = _iterator8()).done;) {
          var ref = _step8.value;
          var binding = ref.scope.getBinding(ref.node.name);

          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }

        for (var _iterator9 = _createForOfIteratorHelperLoose(state.constantViolations), _step9; !(_step9 = _iterator9()).done;) {
          var _path2 = _step9.value;

          _path2.scope.registerConstantViolation(_path2);
        }
      };

      _proto.push = function push(opts) {
        var path = this.path;

        if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }

        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }

        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }

        var unique = opts.unique;
        var kind = opts.kind || "var";
        var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        var dataKey = "declaration:" + kind + ":" + blockHoist;
        var declarPath = !unique && path.getData(dataKey);

        if (!declarPath) {
          var declar = VariableDeclaration(kind, []);
          declar._blockHoist = blockHoist;

          var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

          declarPath = _path$unshiftContaine[0];
          if (!unique) path.setData(dataKey, declarPath);
        }

        var declarator = VariableDeclarator(opts.id, opts.init);
        declarPath.node.declarations.push(declarator);
        this.registerBinding(kind, declarPath.get("declarations").pop());
      };

      _proto.getProgramParent = function getProgramParent() {
        var scope = this;

        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);

        throw new Error("Couldn't find a Program");
      };

      _proto.getFunctionParent = function getFunctionParent() {
        var scope = this;

        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);

        return null;
      };

      _proto.getBlockParent = function getBlockParent() {
        var scope = this;

        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);

        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      };

      _proto.getAllBindings = function getAllBindings() {
        var ids = Object.create(null);
        var scope = this;

        do {
          defaults_1(ids, scope.bindings);
          scope = scope.parent;
        } while (scope);

        return ids;
      };

      _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {
        var ids = Object.create(null);

        for (var _i15 = 0, _arr10 = arguments; _i15 < _arr10.length; _i15++) {
          var kind = _arr10[_i15];
          var scope = this;

          do {
            for (var _i16 = 0, _Object$keys6 = Object.keys(scope.bindings); _i16 < _Object$keys6.length; _i16++) {
              var name = _Object$keys6[_i16];
              var binding = scope.bindings[name];
              if (binding.kind === kind) ids[name] = binding;
            }

            scope = scope.parent;
          } while (scope);
        }

        return ids;
      };

      _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      };

      _proto.getBinding = function getBinding(name) {
        var scope = this;
        var previousPath;

        do {
          var binding = scope.getOwnBinding(name);

          if (binding) {
            if (previousPath && previousPath.isPattern() && previousPath.parentPath.isFunction() && binding.kind !== "param") ; else {
              return binding;
            }
          }

          previousPath = scope.path;
        } while (scope = scope.parent);
      };

      _proto.getOwnBinding = function getOwnBinding(name) {
        return this.bindings[name];
      };

      _proto.getBindingIdentifier = function getBindingIdentifier(name) {
        var info = this.getBinding(name);
        return info && info.identifier;
      };

      _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
        var binding = this.bindings[name];
        return binding && binding.identifier;
      };

      _proto.hasOwnBinding = function hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      };

      _proto.hasBinding = function hasBinding(name, noGlobals) {
        if (!name) return false;
        if (this.hasOwnBinding(name)) return true;
        if (this.parentHasBinding(name, noGlobals)) return true;
        if (this.hasUid(name)) return true;
        if (!noGlobals && includes_1(Scope.globals, name)) return true;
        if (!noGlobals && includes_1(Scope.contextVariables, name)) return true;
        return false;
      };

      _proto.parentHasBinding = function parentHasBinding(name, noGlobals) {
        return this.parent && this.parent.hasBinding(name, noGlobals);
      };

      _proto.moveBindingTo = function moveBindingTo(name, scope) {
        var info = this.getBinding(name);

        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      };

      _proto.removeOwnBinding = function removeOwnBinding(name) {
        delete this.bindings[name];
      };

      _proto.removeBinding = function removeBinding(name) {
        var info = this.getBinding(name);

        if (info) {
          info.scope.removeOwnBinding(name);
        }

        var scope = this;

        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      };

      _createClass(Scope, [{
        key: "parent",
        get: function get() {
          var parent = this.path.findParent(function (p) {
            return p.isScope();
          });
          return parent && parent.scope;
        }
      }, {
        key: "parentBlock",
        get: function get() {
          return this.path.parent;
        }
      }, {
        key: "hub",
        get: function get() {
          return this.path.hub;
        }
      }]);

      return Scope;
    }();

    Scope$1.globals = Object.keys(globals$2.builtin);
    Scope$1.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

    var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

    var encode = function (number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }

      throw new TypeError("Must be between 0 and 63: " + number);
    };

    var decode = function (charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;

      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }

      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }

      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }

      if (charCode == plus) {
        return 62;
      }

      if (charCode == slash) {
        return 63;
      }

      return -1;
    };

    var base64 = {
    	encode: encode,
    	decode: decode
    };

    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;

    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }

    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }

    var encode$1 = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);

      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;

        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }

        encoded += base64.encode(digit);
      } while (vlq > 0);

      return encoded;
    };

    var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;

      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }

        digit = base64.decode(aStr.charCodeAt(aIndex++));

        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }

        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);

      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };

    var base64Vlq = {
    	encode: encode$1,
    	decode: decode$1
    };

    var util = createCommonjsModule(function (module, exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }

    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;

    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);

      if (!match) {
        return null;
      }

      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }

    exports.urlParse = urlParse;

    function urlGenerate(aParsedUrl) {
      var url = '';

      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }

      url += '//';

      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }

      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }

      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }

      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }

      return url;
    }

    exports.urlGenerate = urlGenerate;

    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);

      if (url) {
        if (!url.path) {
          return aPath;
        }

        path = url.path;
      }

      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);

      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];

        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }

      path = parts.join('/');

      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }

      if (url) {
        url.path = path;
        return urlGenerate(url);
      }

      return path;
    }

    exports.normalize = normalize;

    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }

      if (aPath === "") {
        aPath = ".";
      }

      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);

      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      }

      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }

        return urlGenerate(aPathUrl);
      }

      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }

      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }

      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }

      return joined;
    }

    exports.join = join;

    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
    };

    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }

      aRoot = aRoot.replace(/\/$/, '');
      var level = 0;

      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf("/");

        if (index < 0) {
          return aPath;
        }

        aRoot = aRoot.slice(0, index);

        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }

        ++level;
      }

      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }

    exports.relative = relative;

    var supportsNullProto = function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    }();

    function identity(s) {
      return s;
    }

    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }

      return aStr;
    }

    exports.toSetString = supportsNullProto ? identity : toSetString;

    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }

      return aStr;
    }

    exports.fromSetString = supportsNullProto ? identity : fromSetString;

    function isProtoString(s) {
      if (!s) {
        return false;
      }

      var length = s.length;

      if (length < 9) {
          return false;
        }

      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }

      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
            return false;
          }
      }

      return true;
    }

    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      return strcmp(mappingA.name, mappingB.name);
    }

    exports.compareByOriginalPositions = compareByOriginalPositions;

    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }

      cmp = strcmp(mappingA.source, mappingB.source);

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return strcmp(mappingA.name, mappingB.name);
    }

    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }

      if (aStr1 === null) {
        return 1;
      }

      if (aStr2 === null) {
        return -1;
      }

      if (aStr1 > aStr2) {
        return 1;
      }

      return -1;
    }

    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = strcmp(mappingA.source, mappingB.source);

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return strcmp(mappingA.name, mappingB.name);
    }

    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
    }

    exports.parseSourceMapInput = parseSourceMapInput;

    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || '';

      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
          sourceRoot += '/';
        }

        sourceURL = sourceRoot + sourceURL;
      }

      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);

        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }

        if (parsed.path) {
          var index = parsed.path.lastIndexOf('/');

          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }

        sourceURL = join(urlGenerate(parsed), sourceURL);
      }

      return normalize(sourceURL);
    }

    exports.computeSourceURL = computeSourceURL;
    });
    var util_1 = util.getArg;
    var util_2 = util.urlParse;
    var util_3 = util.urlGenerate;
    var util_4 = util.normalize;
    var util_5 = util.join;
    var util_6 = util.isAbsolute;
    var util_7 = util.relative;
    var util_8 = util.toSetString;
    var util_9 = util.fromSetString;
    var util_10 = util.compareByOriginalPositions;
    var util_11 = util.compareByGeneratedPositionsDeflated;
    var util_12 = util.compareByGeneratedPositionsInflated;
    var util_13 = util.parseSourceMapInput;
    var util_14 = util.computeSourceURL;

    var has$1 = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";

    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }

    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();

      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }

      return set;
    };

    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };

    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has$1.call(this._set, sStr);
      var idx = this._array.length;

      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }

      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };

    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has$1.call(this._set, sStr);
      }
    };

    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);

        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);

        if (has$1.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }

      throw new Error('"' + aStr + '" is not in the set.');
    };

    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }

      throw new Error('No element indexed by ' + aIdx);
    };

    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };

    var ArraySet_1 = ArraySet;

    var arraySet = {
    	ArraySet: ArraySet_1
    };

    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }

    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = {
        generatedLine: -1,
        generatedColumn: 0
      };
    }

    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;

        this._array.push(aMapping);
      } else {
        this._sorted = false;

        this._array.push(aMapping);
      }
    };

    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);

        this._sorted = true;
      }

      return this._array;
    };

    var MappingList_1 = MappingList;

    var mappingList = {
    	MappingList: MappingList_1
    };

    var ArraySet$1 = arraySet.ArraySet;

    var MappingList$1 = mappingList.MappingList;

    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }

      this._file = util.getArg(aArgs, 'file', null);
      this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
      this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
      this._sources = new ArraySet$1();
      this._names = new ArraySet$1();
      this._mappings = new MappingList$1();
      this._sourcesContents = null;
    }

    SourceMapGenerator.prototype._version = 3;

    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;

          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var sourceRelative = sourceFile;

        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }

        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }

        var content = aSourceMapConsumer.sourceContentFor(sourceFile);

        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
        source = String(source);

        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }

      if (name != null) {
        name = String(name);

        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;

      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }

        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];

        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;

      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
        }

        sourceFile = aSourceMapConsumer.file;
      }

      var sourceRoot = this._sourceRoot;

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      var newSources = new ArraySet$1();
      var newNames = new ArraySet$1();

      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });

          if (original.source != null) {
            mapping.source = original.source;

            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }

            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }

            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;

            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;

        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;

        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);

      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);

        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }

          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }

          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = '';

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;

          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }

            next += ',';
          }
        }

        next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64Vlq.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64Vlq.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    };

    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }

        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }

        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };

    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };

      if (this._file != null) {
        map.file = this._file;
      }

      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }

      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

    var SourceMapGenerator_1 = SourceMapGenerator;

    var sourceMapGenerator = {
    	SourceMapGenerator: SourceMapGenerator_1
    };

    var binarySearch = createCommonjsModule(function (module, exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;

    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);

      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }

    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }

      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

      if (index < 0) {
        return -1;
      }

      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }

        --index;
      }

      return index;
    };
    });
    var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
    var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
    var binarySearch_3 = binarySearch.search;

    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }

    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }

    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];

        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }

        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }

    var quickSort_1 = function (ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };

    var quickSort = {
    	quickSort: quickSort_1
    };

    var ArraySet$2 = arraySet.ArraySet;



    var quickSort$1 = quickSort.quickSort;

    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;

      if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }

    SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };

    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
      configurable: true,
      enumerable: true,
      get: function get() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }

        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
      configurable: true,
      enumerable: true,
      get: function get() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }

        return this.__originalMappings;
      }
    });

    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;

    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;

      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;

        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;

        default:
          throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };
      needle.source = this._findSourceIndex(needle.source);

      if (needle.source < 0) {
        return [];
      }

      var mappings = [];

      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

    var SourceMapConsumer_1 = SourceMapConsumer;

    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;

      if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      var version = util.getArg(sourceMap, 'version');
      var sources = util.getArg(sourceMap, 'sources');
      var names = util.getArg(sourceMap, 'names', []);
      var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
      var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
      var mappings = util.getArg(sourceMap, 'mappings');
      var file = util.getArg(sourceMap, 'file', null);

      if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
      }

      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }

      sources = sources.map(String).map(util.normalize).map(function (source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet$2.fromArray(names.map(String), true);
      this._sources = ArraySet$2.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function (s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }

    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

    BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
      var relativeSource = aSource;

      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }

      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }

      var i;

      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }

      return -1;
    };

    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function (s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });

      var generatedMappings = aSourceMap._mappings.toArray().slice();

      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };

    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
      get: function get() {
        return this._absoluteSources.slice();
      }
    });

    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }

    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ',') {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }

          str = aStr.slice(index, end);
          segment = cachedSegments[str];

          if (segment) {
            index += str.length;
          } else {
            segment = [];

            while (index < end) {
              base64Vlq.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);

          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort$1(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
      }

      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        mapping.lastGeneratedColumn = Infinity;
      }
    };

    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);

          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }

          var name = util.getArg(mapping, 'name', null);

          if (name !== null) {
            name = this._names.at(name);
          }

          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }

      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
        return sc == null;
      });
    };

    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      var index = this._findSourceIndex(aSource);

      if (index >= 0) {
        return this.sourcesContent[index];
      }

      var relativeSource = aSource;

      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }

      var url;

      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }

        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }

      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };

    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      source = this._findSourceIndex(source);

      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

    var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;

      if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }

      var version = util.getArg(sourceMap, 'version');
      var sections = util.getArg(sourceMap, 'sections');

      if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
      }

      this._sources = new ArraySet$2();
      this._names = new ArraySet$2();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function (s) {
        if (s.url) {
          throw new Error('Support for url field in sections not implemented.');
        }

        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');

        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error('Section offsets must be ordered and non-overlapping.');
        }

        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
        };
      });
    }

    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
      get: function get() {
        var sources = [];

        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }

        return sources;
      }
    });

    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

        if (cmp) {
          return cmp;
        }

        return needle.generatedColumn - section.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };

    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);

        if (content) {
          return content;
        }
      }

      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }

        var generatedPosition = section.consumer.generatedPositionFor(aArgs);

        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];

      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;

        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];

          var source = section.consumer._sources.at(mapping.source);

          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

          this._sources.add(source);

          source = this._sources.indexOf(source);
          var name = null;

          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);

            this._names.add(name);

            name = this._names.indexOf(name);
          }

          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);

          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
    };

    var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

    var sourceMapConsumer = {
    	SourceMapConsumer: SourceMapConsumer_1,
    	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
    	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
    };

    var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;



    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";

    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }

    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;

      var shiftNextLine = function shiftNextLine() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;

        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
        }
      };

      var lastGeneratedLine = 1,
          lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }

        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }

        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || '';
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }

        lastMapping = mapping;
      }, this);

      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }

        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }

      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);

        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }

          node.setSourceContent(sourceFile, content);
        }
      });
      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };

    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function (chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }

      return this;
    };

    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }

      return this;
    };

    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;

      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];

        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== '') {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };

    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;

      if (len > 0) {
        newChildren = [];

        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }

        newChildren.push(this.children[i]);
        this.children = newChildren;
      }

      return this;
    };

    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];

      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push(''.replace(aPattern, aReplacement));
      }

      return this;
    };

    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);

      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function (chunk) {
        str += chunk;
      });
      return str;
    };

    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator$1(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function (chunk, original) {
        generated.code += chunk;

        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }

          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }

        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;

            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function (sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return {
        code: generated.code,
        map: map
      };
    };

    var SourceNode_1 = SourceNode;

    var sourceNode = {
    	SourceNode: SourceNode_1
    };

    var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
    var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
    var SourceNode$1 = sourceNode.SourceNode;

    var sourceMap = {
    	SourceMapGenerator: SourceMapGenerator$2,
    	SourceMapConsumer: SourceMapConsumer$1,
    	SourceNode: SourceNode$1
    };

    var SourceMap = function () {
      function SourceMap(opts, code) {
        this._cachedMap = null;
        this._code = code;
        this._opts = opts;
        this._rawMappings = [];
      }

      var _proto = SourceMap.prototype;

      _proto.get = function get() {
        if (!this._cachedMap) {
          var map = this._cachedMap = new sourceMap.SourceMapGenerator({
            sourceRoot: this._opts.sourceRoot
          });
          var code = this._code;

          if (typeof code === "string") {
            map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
          } else if (typeof code === "object") {
            Object.keys(code).forEach(function (sourceFileName) {
              map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
            });
          }

          this._rawMappings.forEach(function (mapping) {
            return map.addMapping(mapping);
          }, map);
        }

        return this._cachedMap.toJSON();
      };

      _proto.getRawMappings = function getRawMappings() {
        return this._rawMappings.slice();
      };

      _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
        if (this._lastGenLine !== generatedLine && line === null) return;

        if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
          return;
        }

        this._cachedMap = null;
        this._lastGenLine = generatedLine;
        this._lastSourceLine = line;
        this._lastSourceColumn = column;

        this._rawMappings.push({
          name: identifierName || undefined,
          generated: {
            line: generatedLine,
            column: generatedColumn
          },
          source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
          original: line == null ? undefined : {
            line: line,
            column: column
          }
        });
      };

      return SourceMap;
    }();

    function isInteger(value) {
      return typeof value == 'number' && value == toInteger_1(value);
    }

    var isInteger_1 = isInteger;

    var SPACES_RE = /^[ \t]+$/;

    var Buffer = function () {
      function Buffer(map) {
        this._map = null;
        this._buf = [];
        this._last = "";
        this._queue = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: null,
          line: null,
          column: null,
          filename: null
        };
        this._disallowedPop = null;
        this._map = map;
      }

      var _proto = Buffer.prototype;

      _proto.get = function get() {
        this._flush();

        var map = this._map;
        var result = {
          code: this._buf.join("").trimRight(),
          map: null,
          rawMappings: map && map.getRawMappings()
        };

        if (map) {
          Object.defineProperty(result, "map", {
            configurable: true,
            enumerable: true,
            get: function get() {
              return this.map = map.get();
            },
            set: function set(value) {
              Object.defineProperty(this, "map", {
                value: value,
                writable: true
              });
            }
          });
        }

        return result;
      };

      _proto.append = function append(str) {
        this._flush();

        var _this$_sourcePosition = this._sourcePosition,
            line = _this$_sourcePosition.line,
            column = _this$_sourcePosition.column,
            filename = _this$_sourcePosition.filename,
            identifierName = _this$_sourcePosition.identifierName,
            force = _this$_sourcePosition.force;

        this._append(str, line, column, identifierName, filename, force);
      };

      _proto.queue = function queue(str) {
        if (str === "\n") {
          while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
            this._queue.shift();
          }
        }

        var _this$_sourcePosition2 = this._sourcePosition,
            line = _this$_sourcePosition2.line,
            column = _this$_sourcePosition2.column,
            filename = _this$_sourcePosition2.filename,
            identifierName = _this$_sourcePosition2.identifierName,
            force = _this$_sourcePosition2.force;

        this._queue.unshift([str, line, column, identifierName, filename, force]);
      };

      _proto._flush = function _flush() {
        var item;

        while (item = this._queue.pop()) {
          this._append.apply(this, item);
        }
      };

      _proto._append = function _append(str, line, column, identifierName, filename, force) {
        if (this._map && str[0] !== "\n") {
          this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
        }

        this._buf.push(str);

        this._last = str[str.length - 1];

        for (var i = 0; i < str.length; i++) {
          if (str[i] === "\n") {
            this._position.line++;
            this._position.column = 0;
          } else {
            this._position.column++;
          }
        }
      };

      _proto.removeTrailingNewline = function removeTrailingNewline() {
        if (this._queue.length > 0 && this._queue[0][0] === "\n") {
          this._queue.shift();
        }
      };

      _proto.removeLastSemicolon = function removeLastSemicolon() {
        if (this._queue.length > 0 && this._queue[0][0] === ";") {
          this._queue.shift();
        }
      };

      _proto.endsWith = function endsWith(suffix) {
        if (suffix.length === 1) {
          var last;

          if (this._queue.length > 0) {
            var str = this._queue[0][0];
            last = str[str.length - 1];
          } else {
            last = this._last;
          }

          return last === suffix;
        }

        var end = this._last + this._queue.reduce(function (acc, item) {
          return item[0] + acc;
        }, "");

        if (suffix.length <= end.length) {
          return end.slice(-suffix.length) === suffix;
        }

        return false;
      };

      _proto.hasContent = function hasContent() {
        return this._queue.length > 0 || !!this._last;
      };

      _proto.exactSource = function exactSource(loc, cb) {
        this.source("start", loc, true);
        cb();
        this.source("end", loc);

        this._disallowPop("start", loc);
      };

      _proto.source = function source(prop, loc, force) {
        if (prop && !loc) return;

        this._normalizePosition(prop, loc, this._sourcePosition, force);
      };

      _proto.withSource = function withSource(prop, loc, cb) {
        if (!this._map) return cb();
        var originalLine = this._sourcePosition.line;
        var originalColumn = this._sourcePosition.column;
        var originalFilename = this._sourcePosition.filename;
        var originalIdentifierName = this._sourcePosition.identifierName;
        this.source(prop, loc);
        cb();

        if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
          this._sourcePosition.line = originalLine;
          this._sourcePosition.column = originalColumn;
          this._sourcePosition.filename = originalFilename;
          this._sourcePosition.identifierName = originalIdentifierName;
          this._sourcePosition.force = false;
          this._disallowedPop = null;
        }
      };

      _proto._disallowPop = function _disallowPop(prop, loc) {
        if (prop && !loc) return;
        this._disallowedPop = this._normalizePosition(prop, loc);
      };

      _proto._normalizePosition = function _normalizePosition(prop, loc, targetObj, force) {
        var pos = loc ? loc[prop] : null;

        if (targetObj === undefined) {
          targetObj = {
            identifierName: null,
            line: null,
            column: null,
            filename: null,
            force: false
          };
        }

        var origLine = targetObj.line;
        var origColumn = targetObj.column;
        var origFilename = targetObj.filename;
        targetObj.identifierName = prop === "start" && loc && loc.identifierName || null;
        targetObj.line = pos ? pos.line : null;
        targetObj.column = pos ? pos.column : null;
        targetObj.filename = loc && loc.filename || null;

        if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
          targetObj.force = force;
        }

        return targetObj;
      };

      _proto.getCurrentColumn = function getCurrentColumn() {
        var extra = this._queue.reduce(function (acc, item) {
          return item[0] + acc;
        }, "");

        var lastIndex = extra.lastIndexOf("\n");
        return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
      };

      _proto.getCurrentLine = function getCurrentLine() {
        var extra = this._queue.reduce(function (acc, item) {
          return item[0] + acc;
        }, "");

        var count = 0;

        for (var i = 0; i < extra.length; i++) {
          if (extra[i] === "\n") count++;
        }

        return this._position.line + count;
      };

      return Buffer;
    }();

    function crawl(node, state) {
      if (state === void 0) {
        state = {};
      }

      if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
        crawl(node.object, state);
        if (node.computed) crawl(node.property, state);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        crawl(node.left, state);
        crawl(node.right, state);
      } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawl(node.callee, state);
      } else if (isFunction(node)) {
        state.hasFunction = true;
      } else if (isIdentifier(node)) {
        state.hasHelper = state.hasHelper || isHelper(node.callee);
      }

      return state;
    }

    function isHelper(node) {
      if (isMemberExpression(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (isIdentifier(node)) {
        return node.name === "require" || node.name[0] === "_";
      } else if (isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
      } else {
        return false;
      }
    }

    function isType$1(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
    }

    var nodes = {
      AssignmentExpression: function AssignmentExpression(node) {
        var state = crawl(node.right);

        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return {
            before: state.hasFunction,
            after: true
          };
        }
      },
      SwitchCase: function SwitchCase(node, parent) {
        return {
          before: node.consequent.length || parent.cases[0] === node,
          after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
        };
      },
      LogicalExpression: function LogicalExpression(node) {
        if (isFunction(node.left) || isFunction(node.right)) {
          return {
            after: true
          };
        }
      },
      Literal: function Literal(node) {
        if (node.value === "use strict") {
          return {
            after: true
          };
        }
      },
      CallExpression: function CallExpression(node) {
        if (isFunction(node.callee) || isHelper(node)) {
          return {
            before: true,
            after: true
          };
        }
      },
      OptionalCallExpression: function OptionalCallExpression(node) {
        if (isFunction(node.callee)) {
          return {
            before: true,
            after: true
          };
        }
      },
      VariableDeclaration: function VariableDeclaration(node) {
        for (var i = 0; i < node.declarations.length; i++) {
          var declar = node.declarations[i];
          var enabled = isHelper(declar.id) && !isType$1(declar.init);

          if (!enabled) {
            var state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }

          if (enabled) {
            return {
              before: true,
              after: true
            };
          }
        }
      },
      IfStatement: function IfStatement(node) {
        if (isBlockStatement(node.consequent)) {
          return {
            before: true,
            after: true
          };
        }
      }
    };

    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
      if (parent.properties[0] === node) {
        return {
          before: true
        };
      }
    };

    nodes.ObjectTypeCallProperty = function (node, parent) {
      if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {
        return {
          before: true
        };
      }
    };

    nodes.ObjectTypeIndexer = function (node, parent) {
      if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {
        return {
          before: true
        };
      }
    };

    nodes.ObjectTypeInternalSlot = function (node, parent) {
      if (parent.internalSlots[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length) && (!parent.indexers || !parent.indexers.length)) {
        return {
          before: true
        };
      }
    };

    var list = {
      VariableDeclaration: function VariableDeclaration(node) {
        return node.declarations.map(function (decl) {
          return decl.init;
        });
      },
      ArrayExpression: function ArrayExpression(node) {
        return node.elements;
      },
      ObjectExpression: function ObjectExpression(node) {
        return node.properties;
      }
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
      var type = _ref[0],
          amounts = _ref[1];

      if (typeof amounts === "boolean") {
        amounts = {
          after: amounts,
          before: amounts
        };
      }

      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
        nodes[type] = function () {
          return amounts;
        };
      });
    });

    var PRECEDENCE = {
      "||": 0,
      "??": 0,
      "&&": 1,
      "|": 2,
      "^": 3,
      "&": 4,
      "==": 5,
      "===": 5,
      "!=": 5,
      "!==": 5,
      "<": 6,
      ">": 6,
      "<=": 6,
      ">=": 6,
      "in": 6,
      "instanceof": 6,
      ">>": 7,
      "<<": 7,
      ">>>": 7,
      "+": 8,
      "-": 8,
      "*": 9,
      "/": 9,
      "%": 9,
      "**": 10
    };

    var isClassExtendsClause = function isClassExtendsClause(node, parent) {
      return (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;
    };

    var hasPostfixPart = function hasPostfixPart(node, parent) {
      return (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
    };

    function NullableTypeAnnotation$1(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation$1(node, parent, printStack) {
      return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
    }
    function UpdateExpression$1(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function ObjectExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack, {
        considerArrow: true
      });
    }
    function DoExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack);
    }
    function Binary(node, parent) {
      if (node.operator === "**" && isBinaryExpression(parent, {
        operator: "**"
      })) {
        return parent.left === node;
      }

      if (isClassExtendsClause(node, parent)) {
        return true;
      }

      if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
        return true;
      }

      if (isBinary(parent)) {
        var parentOp = parent.operator;
        var parentPos = PRECEDENCE[parentOp];
        var nodeOp = node.operator;
        var nodePos = PRECEDENCE[nodeOp];

        if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
          return true;
        }
      }
    }
    function UnionTypeAnnotation$1(node, parent) {
      return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
    }
    function TSAsExpression$1() {
      return true;
    }
    function TSTypeAssertion$1() {
      return true;
    }
    function TSUnionType$1(node, parent) {
      return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
    }
    function TSInferType$1(node, parent) {
      return isTSArrayType(parent) || isTSOptionalType(parent);
    }
    function BinaryExpression$1(node, parent) {
      return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
    }
    function SequenceExpression$1(node, parent) {
      if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
        return false;
      }

      return true;
    }
    function YieldExpression$1(node, parent) {
      return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
    }
    function ClassExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack, {
        considerDefaultExports: true
      });
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
        operator: "**",
        left: node
      }) || isClassExtendsClause(node, parent);
    }
    function FunctionExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack, {
        considerDefaultExports: true
      });
    }
    function ArrowFunctionExpression$1(node, parent) {
      return isExportDeclaration(parent) || ConditionalExpression$1(node, parent);
    }
    function ConditionalExpression$1(node, parent) {
      if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
        test: node
      }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {
        return true;
      }

      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression$1(node, parent) {
      return isCallExpression(parent, {
        callee: node
      }) || isMemberExpression(parent, {
        object: node
      });
    }
    function AssignmentExpression$1(node, parent, printStack) {
      if (isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression$1(node, parent);
      }
    }
    function LogicalExpression$1(node, parent) {
      switch (node.operator) {
        case "||":
          if (!isLogicalExpression(parent)) return false;
          return parent.operator === "??" || parent.operator === "&&";

        case "&&":
          return isLogicalExpression(parent, {
            operator: "??"
          });

        case "??":
          return isLogicalExpression(parent) && parent.operator !== "??";
      }
    }

    function isFirstInStatement(printStack, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$considerArrow = _ref.considerArrow,
          considerArrow = _ref$considerArrow === void 0 ? false : _ref$considerArrow,
          _ref$considerDefaultE = _ref.considerDefaultExports,
          considerDefaultExports = _ref$considerDefaultE === void 0 ? false : _ref$considerDefaultE;

      var i = printStack.length - 1;
      var node = printStack[i];
      i--;
      var parent = printStack[i];

      while (i > 0) {
        if (isExpressionStatement(parent, {
          expression: node
        }) || considerDefaultExports && isExportDefaultDeclaration(parent, {
          declaration: node
        }) || considerArrow && isArrowFunctionExpression(parent, {
          body: node
        })) {
          return true;
        }

        if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {
          test: node
        }) || isBinary(parent, {
          left: node
        }) || isAssignmentExpression(parent, {
          left: node
        })) {
          node = parent;
          i--;
          parent = printStack[i];
        } else {
          return false;
        }
      }

      return false;
    }

    var parens = /*#__PURE__*/Object.freeze({
      __proto__: null,
      NullableTypeAnnotation: NullableTypeAnnotation$1,
      FunctionTypeAnnotation: FunctionTypeAnnotation$1,
      UpdateExpression: UpdateExpression$1,
      ObjectExpression: ObjectExpression$1,
      DoExpression: DoExpression$1,
      Binary: Binary,
      UnionTypeAnnotation: UnionTypeAnnotation$1,
      IntersectionTypeAnnotation: UnionTypeAnnotation$1,
      TSAsExpression: TSAsExpression$1,
      TSTypeAssertion: TSTypeAssertion$1,
      TSUnionType: TSUnionType$1,
      TSIntersectionType: TSUnionType$1,
      TSInferType: TSInferType$1,
      BinaryExpression: BinaryExpression$1,
      SequenceExpression: SequenceExpression$1,
      YieldExpression: YieldExpression$1,
      AwaitExpression: YieldExpression$1,
      ClassExpression: ClassExpression$1,
      UnaryLike: UnaryLike,
      FunctionExpression: FunctionExpression$1,
      ArrowFunctionExpression: ArrowFunctionExpression$1,
      ConditionalExpression: ConditionalExpression$1,
      OptionalMemberExpression: OptionalMemberExpression$1,
      OptionalCallExpression: OptionalMemberExpression$1,
      AssignmentExpression: AssignmentExpression$1,
      LogicalExpression: LogicalExpression$1
    });

    function expandAliases(obj) {
      var newObj = {};

      function add(type, func) {
        var fn = newObj[type];
        newObj[type] = fn ? function (node, parent, stack) {
          var result = fn(node, parent, stack);
          return result == null ? func(node, parent, stack) : result;
        } : func;
      }

      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var type = _Object$keys[_i];
        var aliases = FLIPPED_ALIAS_KEYS[type];

        if (aliases) {
          for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
            var alias = _step.value;
            add(alias, obj[type]);
          }
        } else {
          add(type, obj[type]);
        }
      }

      return newObj;
    }

    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(nodes);
    var expandedWhitespaceList = expandAliases(list);

    function find(obj, node, parent, printStack) {
      var fn = obj[node.type];
      return fn ? fn(node, parent, printStack) : null;
    }

    function isOrHasCallExpression(node) {
      if (isCallExpression(node)) {
        return true;
      }

      return isMemberExpression(node) && isOrHasCallExpression(node.object);
    }

    function needsWhitespace(node, parent, type) {
      if (!node) return 0;

      if (isExpressionStatement(node)) {
        node = node.expression;
      }

      var linesInfo = find(expandedWhitespaceNodes, node, parent);

      if (!linesInfo) {
        var items = find(expandedWhitespaceList, node, parent);

        if (items) {
          for (var i = 0; i < items.length; i++) {
            linesInfo = needsWhitespace(items[i], node, type);
            if (linesInfo) break;
          }
        }
      }

      if (typeof linesInfo === "object" && linesInfo !== null) {
        return linesInfo[type] || 0;
      }

      return 0;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, "before");
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, "after");
    }
    function needsParens(node, parent, printStack) {
      if (!parent) return false;

      if (isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node)) return true;
      }

      return find(expandedParens, node, parent, printStack);
    }

    function TaggedTemplateExpression$1(node) {
      this.print(node.tag, node);
      this.print(node.typeParameters, node);
      this.print(node.quasi, node);
    }
    function TemplateElement$1(node, parent) {
      var isFirst = parent.quasis[0] === node;
      var isLast = parent.quasis[parent.quasis.length - 1] === node;
      var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
      this.token(value);
    }
    function TemplateLiteral$1(node) {
      var quasis = node.quasis;

      for (var i = 0; i < quasis.length; i++) {
        this.print(quasis[i], node);

        if (i + 1 < quasis.length) {
          this.print(node.expressions[i], node);
        }
      }
    }

    function UnaryExpression$1(node) {
      if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
        this.word(node.operator);
        this.space();
      } else {
        this.token(node.operator);
      }

      this.print(node.argument, node);
    }
    function DoExpression$2(node) {
      this.word("do");
      this.space();
      this.print(node.body, node);
    }
    function ParenthesizedExpression$1(node) {
      this.token("(");
      this.print(node.expression, node);
      this.token(")");
    }
    function UpdateExpression$2(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument, node);
      } else {
        this.startTerminatorless(true);
        this.print(node.argument, node);
        this.endTerminatorless();
        this.token(node.operator);
      }
    }
    function ConditionalExpression$2(node) {
      this.print(node.test, node);
      this.space();
      this.token("?");
      this.space();
      this.print(node.consequent, node);
      this.space();
      this.token(":");
      this.space();
      this.print(node.alternate, node);
    }
    function NewExpression$1(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee, node);

      if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
        return;
      }

      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);

      if (node.optional) {
        this.token("?.");
      }

      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function SequenceExpression$2(node) {
      this.printList(node.expressions, node);
    }
    function ThisExpression$1() {
      this.word("this");
    }
    function Super$1() {
      this.word("super");
    }
    function Decorator$1(node) {
      this.token("@");
      this.print(node.expression, node);
      this.newline();
    }
    function OptionalMemberExpression$2(node) {
      this.print(node.object, node);

      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }

      var computed = node.computed;

      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }

      if (node.optional) {
        this.token("?.");
      }

      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        if (!node.optional) {
          this.token(".");
        }

        this.print(node.property, node);
      }
    }
    function OptionalCallExpression$1(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);

      if (node.optional) {
        this.token("?.");
      }

      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function EventualMemberExpression$1(node) {
      this.print(node.object, node);

      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }

      var computed = node.computed;

      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }

      this.token("~.");

      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        this.print(node.property, node);
      }
    }
    function EventualCallExpression$1(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      this.token("~.");
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function EventualMemberCallExpression$1(node) {
      this.print(node.callee, node);

      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }

      var computed = node.computed;

      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }

      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      this.token("~.");

      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        this.print(node.property, node);
      }

      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function CallExpression$1(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function Import$1() {
      this.word("import");
    }

    function buildYieldAwait(keyword) {
      return function (node) {
        this.word(keyword);

        if (node.delegate) {
          this.token("*");
        }

        if (node.argument) {
          this.space();
          var terminatorState = this.startTerminatorless();
          this.print(node.argument, node);
          this.endTerminatorless(terminatorState);
        }
      };
    }

    var YieldExpression$2 = buildYieldAwait("yield");
    var AwaitExpression$1 = buildYieldAwait("await");
    function EmptyStatement$1() {
      this.semicolon(true);
    }
    function ExpressionStatement$1(node) {
      this.print(node.expression, node);
      this.semicolon();
    }
    function AssignmentPattern$1(node) {
      this.print(node.left, node);
      if (node.left.optional) this.token("?");
      this.print(node.left.typeAnnotation, node);
      this.space();
      this.token("=");
      this.space();
      this.print(node.right, node);
    }
    function AssignmentExpression$2(node, parent) {
      var parens = this.inForStatementInitCounter && node.operator === "in" && !needsParens(node, parent);

      if (parens) {
        this.token("(");
      }

      this.print(node.left, node);
      this.space();

      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
      }

      this.space();
      this.print(node.right, node);

      if (parens) {
        this.token(")");
      }
    }
    function BindExpression$1(node) {
      this.print(node.object, node);
      this.token("::");
      this.print(node.callee, node);
    }
    function MemberExpression$1(node) {
      this.print(node.object, node);

      if (!node.computed && isMemberExpression(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }

      var computed = node.computed;

      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }

      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        this.token(".");
        this.print(node.property, node);
      }
    }
    function MetaProperty$1(node) {
      this.print(node.meta, node);
      this.token(".");
      this.print(node.property, node);
    }
    function PrivateName$1(node) {
      this.token("#");
      this.print(node.id, node);
    }
    function V8IntrinsicIdentifier$1(node) {
      this.token("%");
      this.word(node.name);
    }

    function WithStatement$1(node) {
      this.word("with");
      this.space();
      this.token("(");
      this.print(node.object, node);
      this.token(")");
      this.printBlock(node);
    }
    function IfStatement$1(node) {
      this.word("if");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.space();
      var needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));

      if (needsBlock) {
        this.token("{");
        this.newline();
        this.indent();
      }

      this.printAndIndentOnComments(node.consequent, node);

      if (needsBlock) {
        this.dedent();
        this.newline();
        this.token("}");
      }

      if (node.alternate) {
        if (this.endsWith("}")) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate, node);
      }
    }

    function getLastStatement(statement) {
      if (!isStatement(statement.body)) return statement;
      return getLastStatement(statement.body);
    }

    function ForStatement$1(node) {
      this.word("for");
      this.space();
      this.token("(");
      this.inForStatementInitCounter++;
      this.print(node.init, node);
      this.inForStatementInitCounter--;
      this.token(";");

      if (node.test) {
        this.space();
        this.print(node.test, node);
      }

      this.token(";");

      if (node.update) {
        this.space();
        this.print(node.update, node);
      }

      this.token(")");
      this.printBlock(node);
    }
    function WhileStatement$1(node) {
      this.word("while");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.printBlock(node);
    }

    var buildForXStatement = function buildForXStatement(op) {
      return function (node) {
        this.word("for");
        this.space();

        if (op === "of" && node["await"]) {
          this.word("await");
          this.space();
        }

        this.token("(");
        this.print(node.left, node);
        this.space();
        this.word(op);
        this.space();
        this.print(node.right, node);
        this.token(")");
        this.printBlock(node);
      };
    };

    var ForInStatement$1 = buildForXStatement("in");
    var ForOfStatement$1 = buildForXStatement("of");
    function DoWhileStatement$1(node) {
      this.word("do");
      this.space();
      this.print(node.body, node);
      this.space();
      this.word("while");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.semicolon();
    }

    function buildLabelStatement(prefix, key) {
      if (key === void 0) {
        key = "label";
      }

      return function (node) {
        this.word(prefix);
        var label = node[key];

        if (label) {
          this.space();
          var isLabel = key == "label";
          var terminatorState = this.startTerminatorless(isLabel);
          this.print(label, node);
          this.endTerminatorless(terminatorState);
        }

        this.semicolon();
      };
    }

    var ContinueStatement$1 = buildLabelStatement("continue");
    var ReturnStatement$1 = buildLabelStatement("return", "argument");
    var BreakStatement$1 = buildLabelStatement("break");
    var ThrowStatement$1 = buildLabelStatement("throw", "argument");
    function LabeledStatement$1(node) {
      this.print(node.label, node);
      this.token(":");
      this.space();
      this.print(node.body, node);
    }
    function TryStatement$1(node) {
      this.word("try");
      this.space();
      this.print(node.block, node);
      this.space();

      if (node.handlers) {
        this.print(node.handlers[0], node);
      } else {
        this.print(node.handler, node);
      }

      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer, node);
      }
    }
    function CatchClause$1(node) {
      this.word("catch");
      this.space();

      if (node.param) {
        this.token("(");
        this.print(node.param, node);
        this.token(")");
        this.space();
      }

      this.print(node.body, node);
    }
    function SwitchStatement$1(node) {
      this.word("switch");
      this.space();
      this.token("(");
      this.print(node.discriminant, node);
      this.token(")");
      this.space();
      this.token("{");
      this.printSequence(node.cases, node, {
        indent: true,
        addNewlines: function addNewlines(leading, cas) {
          if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
        }
      });
      this.token("}");
    }
    function SwitchCase$1(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test, node);
        this.token(":");
      } else {
        this.word("default");
        this.token(":");
      }

      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, node, {
          indent: true
        });
      }
    }
    function DebuggerStatement$1() {
      this.word("debugger");
      this.semicolon();
    }

    function variableDeclarationIndent() {
      this.token(",");
      this.newline();
      if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
        this.space(true);
      }
    }

    function constDeclarationIndent() {
      this.token(",");
      this.newline();
      if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
        this.space(true);
      }
    }

    function VariableDeclaration$1(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }

      this.word(node.kind);
      this.space();
      var hasInits = false;

      if (!isFor(parent)) {
        for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
          var declar = _arr[_i];

          if (declar.init) {
            hasInits = true;
          }
        }
      }

      var separator;

      if (hasInits) {
        separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
      }

      this.printList(node.declarations, node, {
        separator: separator
      });

      if (isFor(parent)) {
        if (parent.left === node || parent.init === node) return;
      }

      this.semicolon();
    }
    function VariableDeclarator$1(node) {
      this.print(node.id, node);
      if (node.definite) this.token("!");
      this.print(node.id.typeAnnotation, node);

      if (node.init) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.init, node);
      }
    }

    function ClassDeclaration$1(node, parent) {
      if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
        this.printJoin(node.decorators, node);
      }

      if (node.declare) {
        this.word("declare");
        this.space();
      }

      if (node["abstract"]) {
        this.word("abstract");
        this.space();
      }

      this.word("class");

      if (node.id) {
        this.space();
        this.print(node.id, node);
      }

      this.print(node.typeParameters, node);

      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass, node);
        this.print(node.superTypeParameters, node);
      }

      if (node["implements"]) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node["implements"], node);
      }

      this.space();
      this.print(node.body, node);
    }
    function ClassBody$1(node) {
      this.token("{");
      this.printInnerComments(node);

      if (node.body.length === 0) {
        this.token("}");
      } else {
        this.newline();
        this.indent();
        this.printSequence(node.body, node);
        this.dedent();
        if (!this.endsWith("\n")) this.newline();
        this.rightBrace();
      }
    }
    function ClassProperty$1(node) {
      this.printJoin(node.decorators, node);
      this.tsPrintClassMemberModifiers(node, true);

      if (node.computed) {
        this.token("[");
        this.print(node.key, node);
        this.token("]");
      } else {
        this._variance(node);

        this.print(node.key, node);
      }

      if (node.optional) {
        this.token("?");
      }

      if (node.definite) {
        this.token("!");
      }

      this.print(node.typeAnnotation, node);

      if (node.value) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.value, node);
      }

      this.semicolon();
    }
    function ClassPrivateProperty$1(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }

      this.print(node.key, node);
      this.print(node.typeAnnotation, node);

      if (node.value) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.value, node);
      }

      this.semicolon();
    }
    function ClassMethod$1(node) {
      this._classMethodHead(node);

      this.space();
      this.print(node.body, node);
    }
    function ClassPrivateMethod$1(node) {
      this._classMethodHead(node);

      this.space();
      this.print(node.body, node);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators, node);
      this.tsPrintClassMemberModifiers(node, false);

      this._methodHead(node);
    }

    function _params(node) {
      this.print(node.typeParameters, node);
      this.token("(");

      this._parameters(node.params, node);

      this.token(")");
      this.print(node.returnType, node);
    }
    function _parameters(parameters, parent) {
      for (var i = 0; i < parameters.length; i++) {
        this._param(parameters[i], parent);

        if (i < parameters.length - 1) {
          this.token(",");
          this.space();
        }
      }
    }
    function _param(parameter, parent) {
      this.printJoin(parameter.decorators, parameter);
      this.print(parameter, parent);
      if (parameter.optional) this.token("?");
      this.print(parameter.typeAnnotation, parameter);
    }
    function _methodHead(node) {
      var kind = node.kind;
      var key = node.key;

      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }

      if (node.async) {
        this.word("async");
        this.space();
      }

      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.token("*");
        }
      }

      if (node.computed) {
        this.token("[");
        this.print(key, node);
        this.token("]");
      } else {
        this.print(key, node);
      }

      if (node.optional) {
        this.token("?");
      }

      this._params(node);
    }
    function _predicate(node) {
      if (node.predicate) {
        if (!node.returnType) {
          this.token(":");
        }

        this.space();
        this.print(node.predicate, node);
      }
    }
    function _functionHead(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }

      this.word("function");
      if (node.generator) this.token("*");
      this.space();

      if (node.id) {
        this.print(node.id, node);
      }

      this._params(node);

      this._predicate(node);
    }
    function FunctionExpression$2(node) {
      this._functionHead(node);

      this.space();
      this.print(node.body, node);
    }
    function ArrowFunctionExpression$2(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }

      var firstParam = node.params[0];

      if (node.params.length === 1 && isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
        if (this.format.retainLines && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line) {
          this.token("(");

          if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
            this.indent();
            this.print(firstParam, node);
            this.dedent();

            this._catchUp("start", node.body.loc);
          } else {
            this.print(firstParam, node);
          }

          this.token(")");
        } else {
          this.print(firstParam, node);
        }
      } else {
        this._params(node);
      }

      this._predicate(node);

      this.space();
      this.token("=>");
      this.space();
      this.print(node.body, node);
    }

    function hasTypes(node, param) {
      return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
    }

    function ImportSpecifier$1(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }

      this.print(node.imported, node);

      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local, node);
      }
    }
    function ImportDefaultSpecifier$1(node) {
      this.print(node.local, node);
    }
    function ExportDefaultSpecifier$1(node) {
      this.print(node.exported, node);
    }
    function ExportSpecifier$1(node) {
      this.print(node.local, node);

      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported, node);
      }
    }
    function ExportNamespaceSpecifier$1(node) {
      this.token("*");
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
    function ExportAllDeclaration$1(node) {
      this.word("export");
      this.space();

      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }

      this.token("*");
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
      this.semicolon();
    }
    function ExportNamedDeclaration$1(node) {
      if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
        this.printJoin(node.declaration.decorators, node);
      }

      this.word("export");
      this.space();
      ExportDeclaration.apply(this, arguments);
    }
    function ExportDefaultDeclaration$1(node) {
      if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
        this.printJoin(node.declaration.decorators, node);
      }

      this.word("export");
      this.space();
      this.word("default");
      this.space();
      ExportDeclaration.apply(this, arguments);
    }

    function ExportDeclaration(node) {
      if (node.declaration) {
        var declar = node.declaration;
        this.print(declar, node);
        if (!isStatement(declar)) this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }

        var specifiers = node.specifiers.slice(0);
        var hasSpecial = false;

        for (;;) {
          var first = specifiers[0];

          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift(), node);

            if (specifiers.length) {
              this.token(",");
              this.space();
            }
          } else {
            break;
          }
        }

        if (specifiers.length || !specifiers.length && !hasSpecial) {
          this.token("{");

          if (specifiers.length) {
            this.space();
            this.printList(specifiers, node);
            this.space();
          }

          this.token("}");
        }

        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source, node);
        }

        this.semicolon();
      }
    }

    function ImportDeclaration$1(node) {
      this.word("import");
      this.space();

      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }

      var specifiers = node.specifiers.slice(0);

      if (specifiers && specifiers.length) {
        for (;;) {
          var first = specifiers[0];

          if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
            this.print(specifiers.shift(), node);

            if (specifiers.length) {
              this.token(",");
              this.space();
            }
          } else {
            break;
          }
        }

        if (specifiers.length) {
          this.token("{");
          this.space();
          this.printList(specifiers, node);
          this.space();
          this.token("}");
        }

        this.space();
        this.word("from");
        this.space();
      }

      this.print(node.source, node);
      this.semicolon();
    }
    function ImportNamespaceSpecifier$1(node) {
      this.token("*");
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;

    function init() {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray(b64) {
      if (!inited) {
        init();
      }

      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }

      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
      arr = new Arr(len * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? len - 4 : len;
      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = tmp >> 16 & 0xFF;
        arr[L++] = tmp >> 8 & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[L++] = tmp >> 8 & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr;
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
    }

    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];

      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
        output.push(tripletToBase64(tmp));
      }

      return output.join('');
    }

    function fromByteArray(uint8) {
      if (!inited) {
        init();
      }

      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3;
      var output = '';
      var parts = [];
      var maxChunkLength = 16383;

      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
      }

      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[tmp << 4 & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        output += lookup[tmp >> 10];
        output += lookup[tmp >> 4 & 0x3F];
        output += lookup[tmp << 2 & 0x3F];
        output += '=';
      }

      parts.push(output);
      return parts.join('');
    }

    function read(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;

      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;

      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }

      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }
    function write(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);

        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }

        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }

        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = e << mLen | m;
      eLen += mLen;

      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString$1 = {}.toString;
    var isArray$1 = Array.isArray || function (arr) {
      return toString$1.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;
    Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

    var _kMaxLength = kMaxLength();

    function kMaxLength() {
      return Buffer$1.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
    }

    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length');
      }

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        that = new Uint8Array(length);
        that.__proto__ = Buffer$1.prototype;
      } else {
        if (that === null) {
          that = new Buffer$1(length);
        }

        that.length = length;
      }

      return that;
    }

    function Buffer$1(arg, encodingOrOffset, length) {
      if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
        return new Buffer$1(arg, encodingOrOffset, length);
      }

      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error('If encoding is specified then the first argument must be a string');
        }

        return allocUnsafe(this, arg);
      }

      return from(this, arg, encodingOrOffset, length);
    }
    Buffer$1.poolSize = 8192;

    Buffer$1._augment = function (arr) {
      arr.__proto__ = Buffer$1.prototype;
      return arr;
    };

    function from(that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length);
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset);
      }

      return fromObject(that, value);
    }

    Buffer$1.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      Buffer$1.prototype.__proto__ = Uint8Array.prototype;
      Buffer$1.__proto__ = Uint8Array;
    }

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }

    function alloc(that, size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(that, size);
      }

      if (fill !== undefined) {
        return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
      }

      return createBuffer(that, size);
    }

    Buffer$1.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding);
    };

    function allocUnsafe(that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

      if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }

      return that;
    }

    Buffer$1.allocUnsafe = function (size) {
      return allocUnsafe(null, size);
    };

    Buffer$1.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size);
    };

    function fromString(that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer$1.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);
      var actual = that.write(string, encoding);

      if (actual !== length) {
        that = that.slice(0, actual);
      }

      return that;
    }

    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);

      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }

      return that;
    }

    function fromArrayBuffer(that, array, byteOffset, length) {
      array.byteLength;

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds');
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        that = array;
        that.__proto__ = Buffer$1.prototype;
      } else {
        that = fromArrayLike(that, array);
      }

      return that;
    }

    function fromObject(that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that;
        }

        obj.copy(that, 0, 0, len);
        return that;
      }

      if (obj) {
        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0);
          }

          return fromArrayLike(that, obj);
        }

        if (obj.type === 'Buffer' && isArray$1(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
    }

    function checked(length) {
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }

      return Buffer$1.alloc(+length);
    }
    Buffer$1.isBuffer = isBuffer;

    function internalIsBuffer(b) {
      return !!(b != null && b._isBuffer);
    }

    Buffer$1.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer$1.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer$1.concat = function concat(list, length) {
      if (!isArray$1(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer$1.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer$1.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        buf.copy(buffer, pos);
        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length;
      }

      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0;
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) return utf8ToBytes(string).length;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer$1.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false;

      if (start === undefined || start < 0) {
        start = 0;
      }

      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      }

      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer$1.prototype._isBuffer = true;

    function swap$1(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer$1.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap$1(this, i, i + 1);
      }

      return this;
    };

    Buffer$1.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap$1(this, i, i + 3);
        swap$1(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer$1.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap$1(this, i, i + 7);
        swap$1(this, i + 1, i + 6);
        swap$1(this, i + 2, i + 5);
        swap$1(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer$1.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer$1.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer$1.compare(this, b) === 0;
    };

    Buffer$1.prototype.inspect = function inspect() {
      var str = '';
      var max = INSPECT_MAX_BYTES;

      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }

      return '<Buffer ' + str + '>';
    };

    Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer');
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset;

      if (isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }

      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      }

      if (typeof val === 'string') {
        val = Buffer$1.from(val, encoding);
      }

      if (internalIsBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF;

        if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer$1.prototype.write = function write(string, offset, length, encoding) {
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;

        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
            return asciiWrite(this, string, offset, length);

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length);

          case 'base64':
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer$1.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf);
      } else {
        return fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    }

    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }

      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';

      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer$1.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf;

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer$1.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer$1(sliceLen, undefined);

        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf;
    };

    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };

    Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };

    Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };

    Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;

      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }

      return offset + 2;
    };

    Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }

      return offset + 2;
    };

    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;

      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
      }
    }

    Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }

      return offset + 4;
    };

    Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }

      return offset + 4;
    };

    Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }

      return offset + 2;
    };

    Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }

      return offset + 2;
    };

    Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }

      return offset + 4;
    };

    Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }

      return offset + 4;
    };

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };

    Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
      if (end < 0) throw new RangeError('sourceEnd out of bounds');
      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }

      return len;
    };

    Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (code < 256) {
            val = code;
          }
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
        var len = bytes.length;

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    };

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean(str) {
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      if (str.length < 2) return '';

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function stringtrim(str) {
      if (str.trim) return str.trim();
      return str.replace(/^\s+|\s+$/g, '');
    }

    function toHex(n) {
      if (n < 16) return '0' + n.toString(16);
      return n.toString(16);
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          if (!leadSurrogate) {
            if (codePoint > 0xDBFF) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            }

            leadSurrogate = codePoint;
            continue;
          }

          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          }

          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    }

    function isnan(val) {
      return val !== val;
    }

    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
    }

    function isFastBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
    }

    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
    }

    var bufferEs6 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
      kMaxLength: _kMaxLength,
      Buffer: Buffer$1,
      SlowBuffer: SlowBuffer,
      isBuffer: isBuffer
    });

    var object = {};
    var hasOwnProperty$c = object.hasOwnProperty;

    var forOwn = function forOwn(object, callback) {
      for (var key in object) {
        if (hasOwnProperty$c.call(object, key)) {
          callback(key, object[key]);
        }
      }
    };

    var extend = function extend(destination, source) {
      if (!source) {
        return destination;
      }

      forOwn(source, function (key, value) {
        destination[key] = value;
      });
      return destination;
    };

    var forEach = function forEach(array, callback) {
      var length = array.length;
      var index = -1;

      while (++index < length) {
        callback(array[index]);
      }
    };

    var toString$2 = object.toString;
    var isArray$2 = Array.isArray;
    var isBuffer$1 = isBuffer;

    var isObject$1 = function isObject(value) {
      return toString$2.call(value) == '[object Object]';
    };

    var isString$1 = function isString(value) {
      return typeof value == 'string' || toString$2.call(value) == '[object String]';
    };

    var isNumber = function isNumber(value) {
      return typeof value == 'number' || toString$2.call(value) == '[object Number]';
    };

    var isFunction$2 = function isFunction(value) {
      return typeof value == 'function';
    };

    var isMap$1 = function isMap(value) {
      return toString$2.call(value) == '[object Map]';
    };

    var isSet$1 = function isSet(value) {
      return toString$2.call(value) == '[object Set]';
    };

    var singleEscapes = {
      '"': '\\"',
      '\'': '\\\'',
      '\\': '\\\\',
      '\b': '\\b',
      '\f': '\\f',
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t'
    };
    var regexSingleEscape = /["'\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

    var jsesc = function jsesc(argument, options) {
      var increaseIndentation = function increaseIndentation() {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };

      var defaults = {
        'escapeEverything': false,
        'minimal': false,
        'isScriptContext': false,
        'quotes': 'single',
        'wrap': false,
        'es6': false,
        'json': false,
        'compact': true,
        'lowercaseHex': false,
        'numbers': 'decimal',
        'indent': '\t',
        'indentLevel': 0,
        '__inline1__': false,
        '__inline2__': false
      };
      var json = options && options.json;

      if (json) {
        defaults.quotes = 'double';
        defaults.wrap = true;
      }

      options = extend(defaults, options);

      if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
        options.quotes = 'single';
      }

      var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
      var compact = options.compact;
      var lowercaseHex = options.lowercaseHex;
      var indent = options.indent.repeat(options.indentLevel);
      var oldIndent = '';
      var inline1 = options.__inline1__;
      var inline2 = options.__inline2__;
      var newLine = compact ? '' : '\n';
      var result;
      var isEmpty = true;
      var useBinNumbers = options.numbers == 'binary';
      var useOctNumbers = options.numbers == 'octal';
      var useDecNumbers = options.numbers == 'decimal';
      var useHexNumbers = options.numbers == 'hexadecimal';

      if (json && argument && isFunction$2(argument.toJSON)) {
        argument = argument.toJSON();
      }

      if (!isString$1(argument)) {
        if (isMap$1(argument)) {
          if (argument.size == 0) {
            return 'new Map()';
          }

          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }

          return 'new Map(' + jsesc(Array.from(argument), options) + ')';
        }

        if (isSet$1(argument)) {
          if (argument.size == 0) {
            return 'new Set()';
          }

          return 'new Set(' + jsesc(Array.from(argument), options) + ')';
        }

        if (isBuffer$1(argument)) {
          if (argument.length == 0) {
            return 'Buffer.from([])';
          }

          return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
        }

        if (isArray$2(argument)) {
          result = [];
          options.wrap = true;

          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }

          if (!inline2) {
            increaseIndentation();
          }

          forEach(argument, function (value) {
            isEmpty = false;

            if (inline2) {
              options.__inline2__ = false;
            }

            result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
          });

          if (isEmpty) {
            return '[]';
          }

          if (inline2) {
            return '[' + result.join(', ') + ']';
          }

          return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
        } else if (isNumber(argument)) {
          if (json) {
            return JSON.stringify(argument);
          }

          if (useDecNumbers) {
            return String(argument);
          }

          if (useHexNumbers) {
            var hexadecimal = argument.toString(16);

            if (!lowercaseHex) {
              hexadecimal = hexadecimal.toUpperCase();
            }

            return '0x' + hexadecimal;
          }

          if (useBinNumbers) {
            return '0b' + argument.toString(2);
          }

          if (useOctNumbers) {
            return '0o' + argument.toString(8);
          }
        } else if (!isObject$1(argument)) {
          if (json) {
            return JSON.stringify(argument) || 'null';
          }

          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, function (key, value) {
            isEmpty = false;
            result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
          });

          if (isEmpty) {
            return '{}';
          }

          return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
        }
      }

      var string = argument;
      var index = -1;
      var length = string.length;
      result = '';

      while (++index < length) {
        var character = string.charAt(index);

        if (options.es6) {
          var first = string.charCodeAt(index);

          if (first >= 0xD800 && first <= 0xDBFF && length > index + 1) {
              var second = string.charCodeAt(index + 1);

              if (second >= 0xDC00 && second <= 0xDFFF) {
                var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

                var _hexadecimal2 = codePoint.toString(16);

                if (!lowercaseHex) {
                  _hexadecimal2 = _hexadecimal2.toUpperCase();
                }

                result += "\\u{" + _hexadecimal2 + '}';
                ++index;
                continue;
              }
            }
        }

        if (!options.escapeEverything) {
          if (regexWhitelist.test(character)) {
            result += character;
            continue;
          }

          if (character == '"') {
            result += quote == character ? '\\"' : character;
            continue;
          }

          if (character == '`') {
            result += quote == character ? '\\`' : character;
            continue;
          }

          if (character == '\'') {
            result += quote == character ? '\\\'' : character;
            continue;
          }
        }

        if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
          result += '\\0';
          continue;
        }

        if (regexSingleEscape.test(character)) {
          result += singleEscapes[character];
          continue;
        }

        var charCode = character.charCodeAt(0);

        if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
          result += character;
          continue;
        }

        var _hexadecimal = charCode.toString(16);

        if (!lowercaseHex) {
          _hexadecimal = _hexadecimal.toUpperCase();
        }

        var longhand = _hexadecimal.length > 2 || json;

        var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + _hexadecimal).slice(longhand ? -4 : -2);

        result += escaped;
        continue;
      }

      if (options.wrap) {
        result = quote + result + quote;
      }

      if (quote == '`') {
        result = result.replace(/\$\{/g, '\\\$\{');
      }

      if (options.isScriptContext) {
        return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
      }

      return result;
    };

    jsesc.version = '2.5.2';
    var jsesc_1 = jsesc;

    function Identifier$1(node) {
      var _this = this;

      this.exactSource(node.loc, function () {
        _this.word(node.name);
      });
    }
    function ArgumentPlaceholder$1() {
      this.token("?");
    }
    function RestElement$1(node) {
      this.token("...");
      this.print(node.argument, node);
    }
    function ObjectExpression$2(node) {
      var props = node.properties;
      this.token("{");
      this.printInnerComments(node);

      if (props.length) {
        this.space();
        this.printList(props, node, {
          indent: true,
          statement: true
        });
        this.space();
      }

      this.token("}");
    }
    function ObjectMethod$1(node) {
      this.printJoin(node.decorators, node);

      this._methodHead(node);

      this.space();
      this.print(node.body, node);
    }
    function ObjectProperty$1(node) {
      this.printJoin(node.decorators, node);

      if (node.computed) {
        this.token("[");
        this.print(node.key, node);
        this.token("]");
      } else {
        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value, node);
          return;
        }

        this.print(node.key, node);

        if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
          return;
        }
      }

      this.token(":");
      this.space();
      this.print(node.value, node);
    }
    function ArrayExpression$1(node) {
      var elems = node.elements;
      var len = elems.length;
      this.token("[");
      this.printInnerComments(node);

      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];

        if (elem) {
          if (i > 0) this.space();
          this.print(elem, node);
          if (i < len - 1) this.token(",");
        } else {
          this.token(",");
        }
      }

      this.token("]");
    }
    function RecordExpression$1(node) {
      var props = node.properties;
      var startToken;
      var endToken;

      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#{";
        endToken = "}";
      } else {
        throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (" + JSON.stringify(this.format.recordAndTupleSyntaxType) + " received).");
      }

      this.token(startToken);
      this.printInnerComments(node);

      if (props.length) {
        this.space();
        this.printList(props, node, {
          indent: true,
          statement: true
        });
        this.space();
      }

      this.token(endToken);
    }
    function TupleExpression$1(node) {
      var elems = node.elements;
      var len = elems.length;
      var startToken;
      var endToken;

      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
      }

      this.token(startToken);
      this.printInnerComments(node);

      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];

        if (elem) {
          if (i > 0) this.space();
          this.print(elem, node);
          if (i < len - 1) this.token(",");
        }
      }

      this.token(endToken);
    }
    function RegExpLiteral$1(node) {
      this.word("/" + node.pattern + "/" + node.flags);
    }
    function BooleanLiteral$1(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral$1() {
      this.word("null");
    }
    function NumericLiteral$1(node) {
      var raw = this.getPossibleRaw(node);
      var opts = this.format.jsescOption;
      var value = node.value + "";

      if (opts.numbers) {
        this.number(jsesc_1(node.value, opts));
      } else if (raw == null) {
        this.number(value);
      } else if (this.format.minified) {
        this.number(raw.length < value.length ? raw : value);
      } else {
        this.number(raw);
      }
    }
    function StringLiteral$1(node) {
      var raw = this.getPossibleRaw(node);

      if (!this.format.minified && raw != null) {
        this.token(raw);
        return;
      }

      var opts = this.format.jsescOption;

      if (this.format.jsonCompatibleStrings) {
        opts.json = true;
      }

      var val = jsesc_1(node.value, opts);
      return this.token(val);
    }
    function BigIntLiteral$1(node) {
      var raw = this.getPossibleRaw(node);

      if (!this.format.minified && raw != null) {
        this.token(raw);
        return;
      }

      this.token(node.value);
    }
    function PipelineTopicExpression$1(node) {
      this.print(node.expression, node);
    }
    function PipelineBareFunction$1(node) {
      this.print(node.callee, node);
    }
    function PipelinePrimaryTopicReference$1() {
      this.token("#");
    }

    function AnyTypeAnnotation$1() {
      this.word("any");
    }
    function ArrayTypeAnnotation$1(node) {
      this.print(node.elementType, node);
      this.token("[");
      this.token("]");
    }
    function BooleanTypeAnnotation$1() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation$1(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation$1() {
      this.word("null");
    }
    function DeclareClass$1(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }

      this.word("class");
      this.space();

      this._interfaceish(node);
    }
    function DeclareFunction$1(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }

      this.word("function");
      this.space();
      this.print(node.id, node);
      this.print(node.id.typeAnnotation.typeAnnotation, node);

      if (node.predicate) {
        this.space();
        this.print(node.predicate, node);
      }

      this.semicolon();
    }
    function InferredPredicate$1() {
      this.token("%");
      this.word("checks");
    }
    function DeclaredPredicate$1(node) {
      this.token("%");
      this.word("checks");
      this.token("(");
      this.print(node.value, node);
      this.token(")");
    }
    function DeclareInterface$1(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule$1(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id, node);
      this.space();
      this.print(node.body, node);
    }
    function DeclareModuleExports$1(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.token(".");
      this.word("exports");
      this.print(node.typeAnnotation, node);
    }
    function DeclareTypeAlias$1(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType$1(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }

      this.OpaqueType(node);
    }
    function DeclareVariable$1(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }

      this.word("var");
      this.space();
      this.print(node.id, node);
      this.print(node.id.typeAnnotation, node);
      this.semicolon();
    }
    function DeclareExportDeclaration$1(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();

      if (node["default"]) {
        this.word("default");
        this.space();
      }

      FlowExportDeclaration.apply(this, arguments);
    }
    function DeclareExportAllDeclaration$1() {
      this.word("declare");
      this.space();
      ExportAllDeclaration$1.apply(this, arguments);
    }
    function EnumDeclaration$1(node) {
      var id = node.id,
          body = node.body;
      this.word("enum");
      this.space();
      this.print(id, node);
      this.print(body, node);
    }

    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name);
      }

      context.space();
    }

    function enumBody(context, node) {
      var members = node.members;
      context.token("{");
      context.indent();
      context.newline();

      for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
        var member = _step.value;
        context.print(member, node);
        context.newline();
      }

      context.dedent();
      context.token("}");
    }

    function EnumBooleanBody$1(node) {
      var explicitType = node.explicitType;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody$1(node) {
      var explicitType = node.explicitType;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody$1(node) {
      var explicitType = node.explicitType;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody$1(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember$1(node) {
      var id = node.id;
      this.print(id, node);
      this.token(",");
    }

    function enumInitializedMember(context, node) {
      var id = node.id,
          init = node.init;
      context.print(id, node);
      context.space();
      context.token("=");
      context.space();
      context.print(init, node);
      context.token(",");
    }

    function EnumBooleanMember$1(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember$1(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember$1(node) {
      enumInitializedMember(this, node);
    }

    function FlowExportDeclaration(node) {
      if (node.declaration) {
        var declar = node.declaration;
        this.print(declar, node);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.token("{");

        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers, node);
          this.space();
        }

        this.token("}");

        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source, node);
        }

        this.semicolon();
      }
    }

    function ExistsTypeAnnotation$1() {
      this.token("*");
    }
    function FunctionTypeAnnotation$2(node, parent) {
      this.print(node.typeParameters, node);
      this.token("(");
      this.printList(node.params, node);

      if (node.rest) {
        if (node.params.length) {
          this.token(",");
          this.space();
        }

        this.token("...");
        this.print(node.rest, node);
      }

      this.token(")");

      if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
        this.token(":");
      } else {
        this.space();
        this.token("=>");
      }

      this.space();
      this.print(node.returnType, node);
    }
    function FunctionTypeParam$1(node) {
      this.print(node.name, node);
      if (node.optional) this.token("?");

      if (node.name) {
        this.token(":");
        this.space();
      }

      this.print(node.typeAnnotation, node);
    }
    function InterfaceExtends$1(node) {
      this.print(node.id, node);
      this.print(node.typeParameters, node);
    }
    function _interfaceish(node) {
      this.print(node.id, node);
      this.print(node.typeParameters, node);

      if (node["extends"].length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node["extends"], node);
      }

      if (node.mixins && node.mixins.length) {
        this.space();
        this.word("mixins");
        this.space();
        this.printList(node.mixins, node);
      }

      if (node["implements"] && node["implements"].length) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node["implements"], node);
      }

      this.space();
      this.print(node.body, node);
    }
    function _variance(node) {
      if (node.variance) {
        if (node.variance.kind === "plus") {
          this.token("+");
        } else if (node.variance.kind === "minus") {
          this.token("-");
        }
      }
    }
    function InterfaceDeclaration$1(node) {
      this.word("interface");
      this.space();

      this._interfaceish(node);
    }

    function andSeparator() {
      this.space();
      this.token("&");
      this.space();
    }

    function InterfaceTypeAnnotation$1(node) {
      this.word("interface");

      if (node["extends"] && node["extends"].length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node["extends"], node);
      }

      this.space();
      this.print(node.body, node);
    }
    function IntersectionTypeAnnotation$1(node) {
      this.printJoin(node.types, node, {
        separator: andSeparator
      });
    }
    function MixedTypeAnnotation$1() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation$1() {
      this.word("empty");
    }
    function NullableTypeAnnotation$2(node) {
      this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function NumberTypeAnnotation$1() {
      this.word("number");
    }
    function StringTypeAnnotation$1() {
      this.word("string");
    }
    function ThisTypeAnnotation$1() {
      this.word("this");
    }
    function TupleTypeAnnotation$1(node) {
      this.token("[");
      this.printList(node.types, node);
      this.token("]");
    }
    function TypeofTypeAnnotation$1(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument, node);
    }
    function TypeAlias$1(node) {
      this.word("type");
      this.space();
      this.print(node.id, node);
      this.print(node.typeParameters, node);
      this.space();
      this.token("=");
      this.space();
      this.print(node.right, node);
      this.semicolon();
    }
    function TypeAnnotation$1(node) {
      this.token(":");
      this.space();
      if (node.optional) this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function TypeParameterInstantiation$1(node) {
      this.token("<");
      this.printList(node.params, node, {});
      this.token(">");
    }
    function TypeParameter$1(node) {
      this._variance(node);

      this.word(node.name);

      if (node.bound) {
        this.print(node.bound, node);
      }

      if (node["default"]) {
        this.space();
        this.token("=");
        this.space();
        this.print(node["default"], node);
      }
    }
    function OpaqueType$1(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id, node);
      this.print(node.typeParameters, node);

      if (node.supertype) {
        this.token(":");
        this.space();
        this.print(node.supertype, node);
      }

      if (node.impltype) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.impltype, node);
      }

      this.semicolon();
    }
    function ObjectTypeAnnotation$1(node) {
      var _this = this;

      if (node.exact) {
        this.token("{|");
      } else {
        this.token("{");
      }

      var props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);

      if (props.length) {
        this.space();
        this.printJoin(props, node, {
          addNewlines: function addNewlines(leading) {
            if (leading && !props[0]) return 1;
          },
          indent: true,
          statement: true,
          iterator: function iterator() {
            if (props.length !== 1 || node.inexact) {
              _this.token(",");

              _this.space();
            }
          }
        });
        this.space();
      }

      if (node.inexact) {
        this.indent();
        this.token("...");

        if (props.length) {
          this.newline();
        }

        this.dedent();
      }

      if (node.exact) {
        this.token("|}");
      } else {
        this.token("}");
      }
    }
    function ObjectTypeInternalSlot$1(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }

      this.token("[");
      this.token("[");
      this.print(node.id, node);
      this.token("]");
      this.token("]");
      if (node.optional) this.token("?");

      if (!node.method) {
        this.token(":");
        this.space();
      }

      this.print(node.value, node);
    }
    function ObjectTypeCallProperty$1(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }

      this.print(node.value, node);
    }
    function ObjectTypeIndexer$1(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }

      this._variance(node);

      this.token("[");

      if (node.id) {
        this.print(node.id, node);
        this.token(":");
        this.space();
      }

      this.print(node.key, node);
      this.token("]");
      this.token(":");
      this.space();
      this.print(node.value, node);
    }
    function ObjectTypeProperty$1(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }

      if (node["static"]) {
        this.word("static");
        this.space();
      }

      this._variance(node);

      this.print(node.key, node);
      if (node.optional) this.token("?");

      if (!node.method) {
        this.token(":");
        this.space();
      }

      this.print(node.value, node);
    }
    function ObjectTypeSpreadProperty$1(node) {
      this.token("...");
      this.print(node.argument, node);
    }
    function QualifiedTypeIdentifier$1(node) {
      this.print(node.qualification, node);
      this.token(".");
      this.print(node.id, node);
    }
    function SymbolTypeAnnotation$1() {
      this.word("symbol");
    }

    function orSeparator() {
      this.space();
      this.token("|");
      this.space();
    }

    function UnionTypeAnnotation$2(node) {
      this.printJoin(node.types, node, {
        separator: orSeparator
      });
    }
    function TypeCastExpression$1(node) {
      this.token("(");
      this.print(node.expression, node);
      this.print(node.typeAnnotation, node);
      this.token(")");
    }
    function Variance$1(node) {
      if (node.kind === "plus") {
        this.token("+");
      } else {
        this.token("-");
      }
    }
    function VoidTypeAnnotation$1() {
      this.word("void");
    }

    function File$1(node) {
      if (node.program) {
        this.print(node.program.interpreter, node);
      }

      this.print(node.program, node);
    }
    function Program$1(node) {
      this.printInnerComments(node, false);
      this.printSequence(node.directives, node);
      if (node.directives && node.directives.length) this.newline();
      this.printSequence(node.body, node);
    }
    function BlockStatement$1(node) {
      this.token("{");
      this.printInnerComments(node);
      var hasDirectives = node.directives && node.directives.length;

      if (node.body.length || hasDirectives) {
        this.newline();
        this.printSequence(node.directives, node, {
          indent: true
        });
        if (hasDirectives) this.newline();
        this.printSequence(node.body, node, {
          indent: true
        });
        this.removeTrailingNewline();
        this.source("end", node.loc);
        if (!this.endsWith("\n")) this.newline();
        this.rightBrace();
      } else {
        this.source("end", node.loc);
        this.token("}");
      }
    }
    function Noop$1() {}
    function Directive$1(node) {
      this.print(node.value, node);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral$1(node) {
      var raw = this.getPossibleRaw(node);

      if (raw != null) {
        this.token(raw);
        return;
      }

      var value = node.value;

      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token("\"" + value + "\"");
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token("'" + value + "'");
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective$1(node) {
      this.token("#!" + node.value + "\n");
    }
    function Placeholder$1(node) {
      this.token("%%");
      this.print(node.name);
      this.token("%%");

      if (node.expectedNode === "Statement") {
        this.semicolon();
      }
    }

    function JSXAttribute$1(node) {
      this.print(node.name, node);

      if (node.value) {
        this.token("=");
        this.print(node.value, node);
      }
    }
    function JSXIdentifier$1(node) {
      this.word(node.name);
    }
    function JSXNamespacedName$1(node) {
      this.print(node.namespace, node);
      this.token(":");
      this.print(node.name, node);
    }
    function JSXMemberExpression$1(node) {
      this.print(node.object, node);
      this.token(".");
      this.print(node.property, node);
    }
    function JSXSpreadAttribute$1(node) {
      this.token("{");
      this.token("...");
      this.print(node.argument, node);
      this.token("}");
    }
    function JSXExpressionContainer$1(node) {
      this.token("{");
      this.print(node.expression, node);
      this.token("}");
    }
    function JSXSpreadChild$1(node) {
      this.token("{");
      this.token("...");
      this.print(node.expression, node);
      this.token("}");
    }
    function JSXText$1(node) {
      var raw = this.getPossibleRaw(node);

      if (raw != null) {
        this.token(raw);
      } else {
        this.token(node.value);
      }
    }
    function JSXElement$1(node) {
      var open = node.openingElement;
      this.print(open, node);
      if (open.selfClosing) return;
      this.indent();

      for (var _i = 0, _arr = node.children; _i < _arr.length; _i++) {
        var child = _arr[_i];
        this.print(child, node);
      }

      this.dedent();
      this.print(node.closingElement, node);
    }

    function spaceSeparator() {
      this.space();
    }

    function JSXOpeningElement$1(node) {
      this.token("<");
      this.print(node.name, node);
      this.print(node.typeParameters, node);

      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, node, {
          separator: spaceSeparator
        });
      }

      if (node.selfClosing) {
        this.space();
        this.token("/>");
      } else {
        this.token(">");
      }
    }
    function JSXClosingElement$1(node) {
      this.token("</");
      this.print(node.name, node);
      this.token(">");
    }
    function JSXEmptyExpression$1(node) {
      this.printInnerComments(node);
    }
    function JSXFragment$1(node) {
      this.print(node.openingFragment, node);
      this.indent();

      for (var _i2 = 0, _arr2 = node.children; _i2 < _arr2.length; _i2++) {
        var child = _arr2[_i2];
        this.print(child, node);
      }

      this.dedent();
      this.print(node.closingFragment, node);
    }
    function JSXOpeningFragment$1() {
      this.token("<");
      this.token(">");
    }
    function JSXClosingFragment$1() {
      this.token("</");
      this.token(">");
    }

    function TSTypeAnnotation$1(node) {
      this.token(":");
      this.space();
      if (node.optional) this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function TSTypeParameterInstantiation$1(node) {
      this.token("<");
      this.printList(node.params, node, {});
      this.token(">");
    }
    function TSTypeParameter$1(node) {
      this.word(node.name);

      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint, node);
      }

      if (node["default"]) {
        this.space();
        this.token("=");
        this.space();
        this.print(node["default"], node);
      }
    }
    function TSParameterProperty$1(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }

      if (node.readonly) {
        this.word("readonly");
        this.space();
      }

      this._param(node.parameter);
    }
    function TSDeclareFunction$1(node) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }

      this._functionHead(node);

      this.token(";");
    }
    function TSDeclareMethod$1(node) {
      this._classMethodHead(node);

      this.token(";");
    }
    function TSQualifiedName$1(node) {
      this.print(node.left, node);
      this.token(".");
      this.print(node.right, node);
    }
    function TSCallSignatureDeclaration$1(node) {
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSConstructSignatureDeclaration$1(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSPropertySignature$1(node) {
      var readonly = node.readonly,
          initializer = node.initializer;

      if (readonly) {
        this.word("readonly");
        this.space();
      }

      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation, node);

      if (initializer) {
        this.space();
        this.token("=");
        this.space();
        this.print(initializer, node);
      }

      this.token(";");
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.token("[");
      }

      this.print(node.key, node);

      if (node.computed) {
        this.token("]");
      }

      if (node.optional) {
        this.token("?");
      }
    }
    function TSMethodSignature$1(node) {
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSIndexSignature$1(node) {
      var readonly = node.readonly;

      if (readonly) {
        this.word("readonly");
        this.space();
      }

      this.token("[");

      this._parameters(node.parameters, node);

      this.token("]");
      this.print(node.typeAnnotation, node);
      this.token(";");
    }
    function TSAnyKeyword$1() {
      this.word("any");
    }
    function TSBigIntKeyword$1() {
      this.word("bigint");
    }
    function TSUnknownKeyword$1() {
      this.word("unknown");
    }
    function TSNumberKeyword$1() {
      this.word("number");
    }
    function TSObjectKeyword$1() {
      this.word("object");
    }
    function TSBooleanKeyword$1() {
      this.word("boolean");
    }
    function TSStringKeyword$1() {
      this.word("string");
    }
    function TSSymbolKeyword$1() {
      this.word("symbol");
    }
    function TSVoidKeyword$1() {
      this.word("void");
    }
    function TSUndefinedKeyword$1() {
      this.word("undefined");
    }
    function TSNullKeyword$1() {
      this.word("null");
    }
    function TSNeverKeyword$1() {
      this.word("never");
    }
    function TSThisType$1() {
      this.word("this");
    }
    function TSFunctionType$1(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType$1(node) {
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      var typeParameters = node.typeParameters,
          parameters = node.parameters;
      this.print(typeParameters, node);
      this.token("(");

      this._parameters(parameters, node);

      this.token(")");
      this.space();
      this.token("=>");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation, node);
    }
    function TSTypeReference$1(node) {
      this.print(node.typeName, node);
      this.print(node.typeParameters, node);
    }
    function TSTypePredicate$1(node) {
      if (node.asserts) {
        this.word("asserts");
        this.space();
      }

      this.print(node.parameterName);

      if (node.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery$1(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
    }
    function TSTypeLiteral$1(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
    }
    function tsPrintTypeLiteralOrInterfaceBody(members, node) {
      this.tsPrintBraced(members, node);
    }
    function tsPrintBraced(members, node) {
      this.token("{");

      if (members.length) {
        this.indent();
        this.newline();

        for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
          var member = _step.value;
          this.print(member, node);
          this.newline();
        }

        this.dedent();
        this.rightBrace();
      } else {
        this.token("}");
      }
    }
    function TSArrayType$1(node) {
      this.print(node.elementType, node);
      this.token("[]");
    }
    function TSTupleType$1(node) {
      this.token("[");
      this.printList(node.elementTypes, node);
      this.token("]");
    }
    function TSOptionalType$1(node) {
      this.print(node.typeAnnotation, node);
      this.token("?");
    }
    function TSRestType$1(node) {
      this.token("...");
      this.print(node.typeAnnotation, node);
    }
    function TSUnionType$2(node) {
      this.tsPrintUnionOrIntersectionType(node, "|");
    }
    function TSIntersectionType$1(node) {
      this.tsPrintUnionOrIntersectionType(node, "&");
    }
    function tsPrintUnionOrIntersectionType(node, sep) {
      this.printJoin(node.types, node, {
        separator: function separator() {
          this.space();
          this.token(sep);
          this.space();
        }
      });
    }
    function TSConditionalType$1(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.token("?");
      this.space();
      this.print(node.trueType);
      this.space();
      this.token(":");
      this.space();
      this.print(node.falseType);
    }
    function TSInferType$2(node) {
      this.token("infer");
      this.space();
      this.print(node.typeParameter);
    }
    function TSParenthesizedType$1(node) {
      this.token("(");
      this.print(node.typeAnnotation, node);
      this.token(")");
    }
    function TSTypeOperator$1(node) {
      this.token(node.operator);
      this.space();
      this.print(node.typeAnnotation, node);
    }
    function TSIndexedAccessType$1(node) {
      this.print(node.objectType, node);
      this.token("[");
      this.print(node.indexType, node);
      this.token("]");
    }
    function TSMappedType$1(node) {
      var readonly = node.readonly,
          typeParameter = node.typeParameter,
          optional = node.optional;
      this.token("{");
      this.space();

      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }

      this.token("[");
      this.word(typeParameter.name);
      this.space();
      this.word("in");
      this.space();
      this.print(typeParameter.constraint, typeParameter);
      this.token("]");

      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.token("?");
      }

      this.token(":");
      this.space();
      this.print(node.typeAnnotation, node);
      this.space();
      this.token("}");
    }

    function tokenIfPlusMinus(self, tok) {
      if (tok !== true) {
        self.token(tok);
      }
    }

    function TSLiteralType$1(node) {
      this.print(node.literal, node);
    }
    function TSExpressionWithTypeArguments$1(node) {
      this.print(node.expression, node);
      this.print(node.typeParameters, node);
    }
    function TSInterfaceDeclaration$1(node) {
      var declare = node.declare,
          id = node.id,
          typeParameters = node.typeParameters,
          extendz = node["extends"],
          body = node.body;

      if (declare) {
        this.word("declare");
        this.space();
      }

      this.word("interface");
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);

      if (extendz) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz, node);
      }

      this.space();
      this.print(body, node);
    }
    function TSInterfaceBody$1(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
    }
    function TSTypeAliasDeclaration$1(node) {
      var declare = node.declare,
          id = node.id,
          typeParameters = node.typeParameters,
          typeAnnotation = node.typeAnnotation;

      if (declare) {
        this.word("declare");
        this.space();
      }

      this.word("type");
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);
      this.space();
      this.token("=");
      this.space();
      this.print(typeAnnotation, node);
      this.token(";");
    }
    function TSAsExpression$2(node) {
      var expression = node.expression,
          typeAnnotation = node.typeAnnotation;
      this.print(expression, node);
      this.space();
      this.word("as");
      this.space();
      this.print(typeAnnotation, node);
    }
    function TSTypeAssertion$2(node) {
      var typeAnnotation = node.typeAnnotation,
          expression = node.expression;
      this.token("<");
      this.print(typeAnnotation, node);
      this.token(">");
      this.space();
      this.print(expression, node);
    }
    function TSEnumDeclaration$1(node) {
      var declare = node.declare,
          isConst = node["const"],
          id = node.id,
          members = node.members;

      if (declare) {
        this.word("declare");
        this.space();
      }

      if (isConst) {
        this.word("const");
        this.space();
      }

      this.word("enum");
      this.space();
      this.print(id, node);
      this.space();
      this.tsPrintBraced(members, node);
    }
    function TSEnumMember$1(node) {
      var id = node.id,
          initializer = node.initializer;
      this.print(id, node);

      if (initializer) {
        this.space();
        this.token("=");
        this.space();
        this.print(initializer, node);
      }

      this.token(",");
    }
    function TSModuleDeclaration$1(node) {
      var declare = node.declare,
          id = node.id;

      if (declare) {
        this.word("declare");
        this.space();
      }

      if (!node.global) {
        this.word(id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }

      this.print(id, node);

      if (!node.body) {
        this.token(";");
        return;
      }

      var body = node.body;

      while (body.type === "TSModuleDeclaration") {
        this.token(".");
        this.print(body.id, body);
        body = body.body;
      }

      this.space();
      this.print(body, node);
    }
    function TSModuleBlock$1(node) {
      this.tsPrintBraced(node.body, node);
    }
    function TSImportType$1(node) {
      var argument = node.argument,
          qualifier = node.qualifier,
          typeParameters = node.typeParameters;
      this.word("import");
      this.token("(");
      this.print(argument, node);
      this.token(")");

      if (qualifier) {
        this.token(".");
        this.print(qualifier, node);
      }

      if (typeParameters) {
        this.print(typeParameters, node);
      }
    }
    function TSImportEqualsDeclaration$1(node) {
      var isExport = node.isExport,
          id = node.id,
          moduleReference = node.moduleReference;

      if (isExport) {
        this.word("export");
        this.space();
      }

      this.word("import");
      this.space();
      this.print(id, node);
      this.space();
      this.token("=");
      this.space();
      this.print(moduleReference, node);
      this.token(";");
    }
    function TSExternalModuleReference$1(node) {
      this.token("require(");
      this.print(node.expression, node);
      this.token(")");
    }
    function TSNonNullExpression$1(node) {
      this.print(node.expression, node);
      this.token("!");
    }
    function TSExportAssignment$1(node) {
      this.word("export");
      this.space();
      this.token("=");
      this.space();
      this.print(node.expression, node);
      this.token(";");
    }
    function TSNamespaceExportDeclaration$1(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id, node);
    }
    function tsPrintSignatureDeclarationBase(node) {
      var typeParameters = node.typeParameters,
          parameters = node.parameters;
      this.print(typeParameters, node);
      this.token("(");

      this._parameters(parameters, node);

      this.token(")");
      this.print(node.typeAnnotation, node);
    }
    function tsPrintClassMemberModifiers(node, isField) {
      if (isField && node.declare) {
        this.word("declare");
        this.space();
      }

      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }

      if (node["static"]) {
        this.word("static");
        this.space();
      }

      if (node["abstract"]) {
        this.word("abstract");
        this.space();
      }

      if (isField && node.readonly) {
        this.word("readonly");
        this.space();
      }
    }



    var generatorFunctions = /*#__PURE__*/Object.freeze({
      __proto__: null,
      TaggedTemplateExpression: TaggedTemplateExpression$1,
      TemplateElement: TemplateElement$1,
      TemplateLiteral: TemplateLiteral$1,
      UnaryExpression: UnaryExpression$1,
      DoExpression: DoExpression$2,
      ParenthesizedExpression: ParenthesizedExpression$1,
      UpdateExpression: UpdateExpression$2,
      ConditionalExpression: ConditionalExpression$2,
      NewExpression: NewExpression$1,
      SequenceExpression: SequenceExpression$2,
      ThisExpression: ThisExpression$1,
      Super: Super$1,
      Decorator: Decorator$1,
      OptionalMemberExpression: OptionalMemberExpression$2,
      OptionalCallExpression: OptionalCallExpression$1,
      EventualMemberExpression: EventualMemberExpression$1,
      EventualCallExpression: EventualCallExpression$1,
      EventualMemberCallExpression: EventualMemberCallExpression$1,
      CallExpression: CallExpression$1,
      Import: Import$1,
      YieldExpression: YieldExpression$2,
      AwaitExpression: AwaitExpression$1,
      EmptyStatement: EmptyStatement$1,
      ExpressionStatement: ExpressionStatement$1,
      AssignmentPattern: AssignmentPattern$1,
      AssignmentExpression: AssignmentExpression$2,
      BindExpression: BindExpression$1,
      BinaryExpression: AssignmentExpression$2,
      LogicalExpression: AssignmentExpression$2,
      MemberExpression: MemberExpression$1,
      MetaProperty: MetaProperty$1,
      PrivateName: PrivateName$1,
      V8IntrinsicIdentifier: V8IntrinsicIdentifier$1,
      WithStatement: WithStatement$1,
      IfStatement: IfStatement$1,
      ForStatement: ForStatement$1,
      WhileStatement: WhileStatement$1,
      ForInStatement: ForInStatement$1,
      ForOfStatement: ForOfStatement$1,
      DoWhileStatement: DoWhileStatement$1,
      ContinueStatement: ContinueStatement$1,
      ReturnStatement: ReturnStatement$1,
      BreakStatement: BreakStatement$1,
      ThrowStatement: ThrowStatement$1,
      LabeledStatement: LabeledStatement$1,
      TryStatement: TryStatement$1,
      CatchClause: CatchClause$1,
      SwitchStatement: SwitchStatement$1,
      SwitchCase: SwitchCase$1,
      DebuggerStatement: DebuggerStatement$1,
      VariableDeclaration: VariableDeclaration$1,
      VariableDeclarator: VariableDeclarator$1,
      ClassDeclaration: ClassDeclaration$1,
      ClassExpression: ClassDeclaration$1,
      ClassBody: ClassBody$1,
      ClassProperty: ClassProperty$1,
      ClassPrivateProperty: ClassPrivateProperty$1,
      ClassMethod: ClassMethod$1,
      ClassPrivateMethod: ClassPrivateMethod$1,
      _classMethodHead: _classMethodHead,
      _params: _params,
      _parameters: _parameters,
      _param: _param,
      _methodHead: _methodHead,
      _predicate: _predicate,
      _functionHead: _functionHead,
      FunctionExpression: FunctionExpression$2,
      FunctionDeclaration: FunctionExpression$2,
      ArrowFunctionExpression: ArrowFunctionExpression$2,
      ImportSpecifier: ImportSpecifier$1,
      ImportDefaultSpecifier: ImportDefaultSpecifier$1,
      ExportDefaultSpecifier: ExportDefaultSpecifier$1,
      ExportSpecifier: ExportSpecifier$1,
      ExportNamespaceSpecifier: ExportNamespaceSpecifier$1,
      ExportAllDeclaration: ExportAllDeclaration$1,
      ExportNamedDeclaration: ExportNamedDeclaration$1,
      ExportDefaultDeclaration: ExportDefaultDeclaration$1,
      ImportDeclaration: ImportDeclaration$1,
      ImportNamespaceSpecifier: ImportNamespaceSpecifier$1,
      Identifier: Identifier$1,
      ArgumentPlaceholder: ArgumentPlaceholder$1,
      RestElement: RestElement$1,
      SpreadElement: RestElement$1,
      ObjectExpression: ObjectExpression$2,
      ObjectPattern: ObjectExpression$2,
      ObjectMethod: ObjectMethod$1,
      ObjectProperty: ObjectProperty$1,
      ArrayExpression: ArrayExpression$1,
      ArrayPattern: ArrayExpression$1,
      RecordExpression: RecordExpression$1,
      TupleExpression: TupleExpression$1,
      RegExpLiteral: RegExpLiteral$1,
      BooleanLiteral: BooleanLiteral$1,
      NullLiteral: NullLiteral$1,
      NumericLiteral: NumericLiteral$1,
      StringLiteral: StringLiteral$1,
      BigIntLiteral: BigIntLiteral$1,
      PipelineTopicExpression: PipelineTopicExpression$1,
      PipelineBareFunction: PipelineBareFunction$1,
      PipelinePrimaryTopicReference: PipelinePrimaryTopicReference$1,
      AnyTypeAnnotation: AnyTypeAnnotation$1,
      ArrayTypeAnnotation: ArrayTypeAnnotation$1,
      BooleanTypeAnnotation: BooleanTypeAnnotation$1,
      BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation$1,
      NullLiteralTypeAnnotation: NullLiteralTypeAnnotation$1,
      DeclareClass: DeclareClass$1,
      DeclareFunction: DeclareFunction$1,
      InferredPredicate: InferredPredicate$1,
      DeclaredPredicate: DeclaredPredicate$1,
      DeclareInterface: DeclareInterface$1,
      DeclareModule: DeclareModule$1,
      DeclareModuleExports: DeclareModuleExports$1,
      DeclareTypeAlias: DeclareTypeAlias$1,
      DeclareOpaqueType: DeclareOpaqueType$1,
      DeclareVariable: DeclareVariable$1,
      DeclareExportDeclaration: DeclareExportDeclaration$1,
      DeclareExportAllDeclaration: DeclareExportAllDeclaration$1,
      EnumDeclaration: EnumDeclaration$1,
      EnumBooleanBody: EnumBooleanBody$1,
      EnumNumberBody: EnumNumberBody$1,
      EnumStringBody: EnumStringBody$1,
      EnumSymbolBody: EnumSymbolBody$1,
      EnumDefaultedMember: EnumDefaultedMember$1,
      EnumBooleanMember: EnumBooleanMember$1,
      EnumNumberMember: EnumNumberMember$1,
      EnumStringMember: EnumStringMember$1,
      ExistsTypeAnnotation: ExistsTypeAnnotation$1,
      FunctionTypeAnnotation: FunctionTypeAnnotation$2,
      FunctionTypeParam: FunctionTypeParam$1,
      InterfaceExtends: InterfaceExtends$1,
      ClassImplements: InterfaceExtends$1,
      GenericTypeAnnotation: InterfaceExtends$1,
      _interfaceish: _interfaceish,
      _variance: _variance,
      InterfaceDeclaration: InterfaceDeclaration$1,
      InterfaceTypeAnnotation: InterfaceTypeAnnotation$1,
      IntersectionTypeAnnotation: IntersectionTypeAnnotation$1,
      MixedTypeAnnotation: MixedTypeAnnotation$1,
      EmptyTypeAnnotation: EmptyTypeAnnotation$1,
      NullableTypeAnnotation: NullableTypeAnnotation$2,
      NumberTypeAnnotation: NumberTypeAnnotation$1,
      StringTypeAnnotation: StringTypeAnnotation$1,
      ThisTypeAnnotation: ThisTypeAnnotation$1,
      TupleTypeAnnotation: TupleTypeAnnotation$1,
      TypeofTypeAnnotation: TypeofTypeAnnotation$1,
      TypeAlias: TypeAlias$1,
      TypeAnnotation: TypeAnnotation$1,
      TypeParameterInstantiation: TypeParameterInstantiation$1,
      TypeParameterDeclaration: TypeParameterInstantiation$1,
      TypeParameter: TypeParameter$1,
      OpaqueType: OpaqueType$1,
      ObjectTypeAnnotation: ObjectTypeAnnotation$1,
      ObjectTypeInternalSlot: ObjectTypeInternalSlot$1,
      ObjectTypeCallProperty: ObjectTypeCallProperty$1,
      ObjectTypeIndexer: ObjectTypeIndexer$1,
      ObjectTypeProperty: ObjectTypeProperty$1,
      ObjectTypeSpreadProperty: ObjectTypeSpreadProperty$1,
      QualifiedTypeIdentifier: QualifiedTypeIdentifier$1,
      SymbolTypeAnnotation: SymbolTypeAnnotation$1,
      UnionTypeAnnotation: UnionTypeAnnotation$2,
      TypeCastExpression: TypeCastExpression$1,
      Variance: Variance$1,
      VoidTypeAnnotation: VoidTypeAnnotation$1,
      NumberLiteralTypeAnnotation: NumericLiteral$1,
      StringLiteralTypeAnnotation: StringLiteral$1,
      File: File$1,
      Program: Program$1,
      BlockStatement: BlockStatement$1,
      Noop: Noop$1,
      Directive: Directive$1,
      DirectiveLiteral: DirectiveLiteral$1,
      InterpreterDirective: InterpreterDirective$1,
      Placeholder: Placeholder$1,
      JSXAttribute: JSXAttribute$1,
      JSXIdentifier: JSXIdentifier$1,
      JSXNamespacedName: JSXNamespacedName$1,
      JSXMemberExpression: JSXMemberExpression$1,
      JSXSpreadAttribute: JSXSpreadAttribute$1,
      JSXExpressionContainer: JSXExpressionContainer$1,
      JSXSpreadChild: JSXSpreadChild$1,
      JSXText: JSXText$1,
      JSXElement: JSXElement$1,
      JSXOpeningElement: JSXOpeningElement$1,
      JSXClosingElement: JSXClosingElement$1,
      JSXEmptyExpression: JSXEmptyExpression$1,
      JSXFragment: JSXFragment$1,
      JSXOpeningFragment: JSXOpeningFragment$1,
      JSXClosingFragment: JSXClosingFragment$1,
      TSTypeAnnotation: TSTypeAnnotation$1,
      TSTypeParameterInstantiation: TSTypeParameterInstantiation$1,
      TSTypeParameterDeclaration: TSTypeParameterInstantiation$1,
      TSTypeParameter: TSTypeParameter$1,
      TSParameterProperty: TSParameterProperty$1,
      TSDeclareFunction: TSDeclareFunction$1,
      TSDeclareMethod: TSDeclareMethod$1,
      TSQualifiedName: TSQualifiedName$1,
      TSCallSignatureDeclaration: TSCallSignatureDeclaration$1,
      TSConstructSignatureDeclaration: TSConstructSignatureDeclaration$1,
      TSPropertySignature: TSPropertySignature$1,
      tsPrintPropertyOrMethodName: tsPrintPropertyOrMethodName,
      TSMethodSignature: TSMethodSignature$1,
      TSIndexSignature: TSIndexSignature$1,
      TSAnyKeyword: TSAnyKeyword$1,
      TSBigIntKeyword: TSBigIntKeyword$1,
      TSUnknownKeyword: TSUnknownKeyword$1,
      TSNumberKeyword: TSNumberKeyword$1,
      TSObjectKeyword: TSObjectKeyword$1,
      TSBooleanKeyword: TSBooleanKeyword$1,
      TSStringKeyword: TSStringKeyword$1,
      TSSymbolKeyword: TSSymbolKeyword$1,
      TSVoidKeyword: TSVoidKeyword$1,
      TSUndefinedKeyword: TSUndefinedKeyword$1,
      TSNullKeyword: TSNullKeyword$1,
      TSNeverKeyword: TSNeverKeyword$1,
      TSThisType: TSThisType$1,
      TSFunctionType: TSFunctionType$1,
      TSConstructorType: TSConstructorType$1,
      tsPrintFunctionOrConstructorType: tsPrintFunctionOrConstructorType,
      TSTypeReference: TSTypeReference$1,
      TSTypePredicate: TSTypePredicate$1,
      TSTypeQuery: TSTypeQuery$1,
      TSTypeLiteral: TSTypeLiteral$1,
      tsPrintTypeLiteralOrInterfaceBody: tsPrintTypeLiteralOrInterfaceBody,
      tsPrintBraced: tsPrintBraced,
      TSArrayType: TSArrayType$1,
      TSTupleType: TSTupleType$1,
      TSOptionalType: TSOptionalType$1,
      TSRestType: TSRestType$1,
      TSUnionType: TSUnionType$2,
      TSIntersectionType: TSIntersectionType$1,
      tsPrintUnionOrIntersectionType: tsPrintUnionOrIntersectionType,
      TSConditionalType: TSConditionalType$1,
      TSInferType: TSInferType$2,
      TSParenthesizedType: TSParenthesizedType$1,
      TSTypeOperator: TSTypeOperator$1,
      TSIndexedAccessType: TSIndexedAccessType$1,
      TSMappedType: TSMappedType$1,
      TSLiteralType: TSLiteralType$1,
      TSExpressionWithTypeArguments: TSExpressionWithTypeArguments$1,
      TSInterfaceDeclaration: TSInterfaceDeclaration$1,
      TSInterfaceBody: TSInterfaceBody$1,
      TSTypeAliasDeclaration: TSTypeAliasDeclaration$1,
      TSAsExpression: TSAsExpression$2,
      TSTypeAssertion: TSTypeAssertion$2,
      TSEnumDeclaration: TSEnumDeclaration$1,
      TSEnumMember: TSEnumMember$1,
      TSModuleDeclaration: TSModuleDeclaration$1,
      TSModuleBlock: TSModuleBlock$1,
      TSImportType: TSImportType$1,
      TSImportEqualsDeclaration: TSImportEqualsDeclaration$1,
      TSExternalModuleReference: TSExternalModuleReference$1,
      TSNonNullExpression: TSNonNullExpression$1,
      TSExportAssignment: TSExportAssignment$1,
      TSNamespaceExportDeclaration: TSNamespaceExportDeclaration$1,
      tsPrintSignatureDeclarationBase: tsPrintSignatureDeclarationBase,
      tsPrintClassMemberModifiers: tsPrintClassMemberModifiers
    });

    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var NON_DECIMAL_LITERAL = /^0[box]/;
    var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;

    var Printer = function () {
      function Printer(format, map) {
        this.inForStatementInitCounter = 0;
        this._printStack = [];
        this._indent = 0;
        this._insideAux = false;
        this._printedCommentStarts = {};
        this._parenPushNewlineState = null;
        this._noLineTerminator = false;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = new WeakSet();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this.format = format || {};
        this._buf = new Buffer(map);
      }

      var _proto = Printer.prototype;

      _proto.generate = function generate(ast) {
        this.print(ast);

        this._maybeAddAuxComment();

        return this._buf.get();
      };

      _proto.indent = function indent() {
        if (this.format.compact || this.format.concise) return;
        this._indent++;
      };

      _proto.dedent = function dedent() {
        if (this.format.compact || this.format.concise) return;
        this._indent--;
      };

      _proto.semicolon = function semicolon(force) {
        if (force === void 0) {
          force = false;
        }

        this._maybeAddAuxComment();

        this._append(";", !force);
      };

      _proto.rightBrace = function rightBrace() {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }

        this.token("}");
      };

      _proto.space = function space(force) {
        if (force === void 0) {
          force = false;
        }

        if (this.format.compact) return;

        if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
          this._space();
        }
      };

      _proto.word = function word(str) {
        if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
          this._space();
        }

        this._maybeAddAuxComment();

        this._append(str);

        this._endsWithWord = true;
      };

      _proto.number = function number(str) {
        this.word(str);
        this._endsWithInteger = isInteger_1(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
      };

      _proto.token = function token(str) {
        if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
          this._space();
        }

        this._maybeAddAuxComment();

        this._append(str);
      };

      _proto.newline = function newline(i) {
        if (this.format.retainLines || this.format.compact) return;

        if (this.format.concise) {
          this.space();
          return;
        }

        if (this.endsWith("\n\n")) return;
        if (typeof i !== "number") i = 1;
        i = Math.min(2, i);
        if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
        if (i <= 0) return;

        for (var j = 0; j < i; j++) {
          this._newline();
        }
      };

      _proto.endsWith = function endsWith(str) {
        return this._buf.endsWith(str);
      };

      _proto.removeTrailingNewline = function removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      };

      _proto.exactSource = function exactSource(loc, cb) {
        this._catchUp("start", loc);

        this._buf.exactSource(loc, cb);
      };

      _proto.source = function source(prop, loc) {
        this._catchUp(prop, loc);

        this._buf.source(prop, loc);
      };

      _proto.withSource = function withSource(prop, loc, cb) {
        this._catchUp(prop, loc);

        this._buf.withSource(prop, loc, cb);
      };

      _proto._space = function _space() {
        this._append(" ", true);
      };

      _proto._newline = function _newline() {
        this._append("\n", true);
      };

      _proto._append = function _append(str, queue) {
        if (queue === void 0) {
          queue = false;
        }

        this._maybeAddParen(str);

        this._maybeIndent(str);

        if (queue) this._buf.queue(str);else this._buf.append(str);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      };

      _proto._maybeIndent = function _maybeIndent(str) {
        if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
          this._buf.queue(this._getIndent());
        }
      };

      _proto._maybeAddParen = function _maybeAddParen(str) {
        var parenPushNewlineState = this._parenPushNewlineState;
        if (!parenPushNewlineState) return;
        var i;

        for (i = 0; i < str.length && str[i] === " "; i++) {
          continue;
        }

        if (i === str.length) {
          return;
        }

        var cha = str[i];

        if (cha !== "\n") {
          if (cha !== "/" || i + 1 === str.length) {
            this._parenPushNewlineState = null;
            return;
          }

          var chaPost = str[i + 1];

          if (chaPost === "*") {
            if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
              return;
            }
          } else if (chaPost !== "/") {
            this._parenPushNewlineState = null;
            return;
          }
        }

        this.token("(");
        this.indent();
        parenPushNewlineState.printed = true;
      };

      _proto._catchUp = function _catchUp(prop, loc) {
        if (!this.format.retainLines) return;
        var pos = loc ? loc[prop] : null;

        if (pos && pos.line !== null) {
          var count = pos.line - this._buf.getCurrentLine();

          for (var i = 0; i < count; i++) {
            this._newline();
          }
        }
      };

      _proto._getIndent = function _getIndent() {
        return repeat_1(this.format.indent.style, this._indent);
      };

      _proto.startTerminatorless = function startTerminatorless(isLabel) {
        if (isLabel === void 0) {
          isLabel = false;
        }

        if (isLabel) {
          this._noLineTerminator = true;
          return null;
        } else {
          return this._parenPushNewlineState = {
            printed: false
          };
        }
      };

      _proto.endTerminatorless = function endTerminatorless(state) {
        this._noLineTerminator = false;

        if (state && state.printed) {
          this.dedent();
          this.newline();
          this.token(")");
        }
      };

      _proto.print = function print(node, parent) {
        var _this = this;

        if (!node) return;
        var oldConcise = this.format.concise;

        if (node._compact) {
          this.format.concise = true;
        }

        var printMethod = this[node.type];

        if (!printMethod) {
          throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
        }

        this._printStack.push(node);

        var oldInAux = this._insideAux;
        this._insideAux = !node.loc;

        this._maybeAddAuxComment(this._insideAux && !oldInAux);

        var needsParens$1 = needsParens(node, parent, this._printStack);

        if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
          needsParens$1 = true;
        }

        if (needsParens$1) this.token("(");

        this._printLeadingComments(node);

        var loc = isProgram(node) || isFile(node) ? null : node.loc;
        this.withSource("start", loc, function () {
          printMethod.call(_this, node, parent);
        });

        this._printTrailingComments(node);

        if (needsParens$1) this.token(")");

        this._printStack.pop();

        this.format.concise = oldConcise;
        this._insideAux = oldInAux;
      };

      _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      };

      _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        var comment = this.format.auxiliaryCommentBefore;

        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          });
        }
      };

      _proto._printAuxAfterComment = function _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        var comment = this.format.auxiliaryCommentAfter;

        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          });
        }
      };

      _proto.getPossibleRaw = function getPossibleRaw(node) {
        var extra = node.extra;

        if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      };

      _proto.printJoin = function printJoin(nodes, parent, opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (!nodes || !nodes.length) return;
        if (opts.indent) this.indent();
        var newlineOpts = {
          addNewlines: opts.addNewlines
        };

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (!node) continue;
          if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
          this.print(node, parent);

          if (opts.iterator) {
            opts.iterator(node, i);
          }

          if (opts.separator && i < nodes.length - 1) {
            opts.separator.call(this);
          }

          if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
        }

        if (opts.indent) this.dedent();
      };

      _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
        var indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node, parent);
        if (indent) this.dedent();
      };

      _proto.printBlock = function printBlock(parent) {
        var node = parent.body;

        if (!isEmptyStatement(node)) {
          this.space();
        }

        this.print(node, parent);
      };

      _proto._printTrailingComments = function _printTrailingComments(node) {
        this._printComments(this._getComments(false, node));
      };

      _proto._printLeadingComments = function _printLeadingComments(node) {
        this._printComments(this._getComments(true, node), true);
      };

      _proto.printInnerComments = function printInnerComments(node, indent) {
        if (indent === void 0) {
          indent = true;
        }

        if (!node.innerComments || !node.innerComments.length) return;
        if (indent) this.indent();

        this._printComments(node.innerComments);

        if (indent) this.dedent();
      };

      _proto.printSequence = function printSequence(nodes, parent, opts) {
        if (opts === void 0) {
          opts = {};
        }

        opts.statement = true;
        return this.printJoin(nodes, parent, opts);
      };

      _proto.printList = function printList(items, parent, opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (opts.separator == null) {
          opts.separator = commaSeparator;
        }

        return this.printJoin(items, parent, opts);
      };

      _proto._printNewline = function _printNewline(leading, node, parent, opts) {
        if (this.format.retainLines || this.format.compact) return;

        if (this.format.concise) {
          this.space();
          return;
        }

        var lines = 0;

        if (this._buf.hasContent()) {
          if (!leading) lines++;
          if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
          var needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
          if (needs(node, parent)) lines++;
        }

        this.newline(lines);
      };

      _proto._getComments = function _getComments(leading, node) {
        return node && (leading ? node.leadingComments : node.trailingComments) || [];
      };

      _proto._printComment = function _printComment(comment, skipNewLines) {
        var _this2 = this;

        if (!this.format.shouldPrintComment(comment.value)) return;
        if (comment.ignore) return;
        if (this._printedComments.has(comment)) return;

        this._printedComments.add(comment);

        if (comment.start != null) {
          if (this._printedCommentStarts[comment.start]) return;
          this._printedCommentStarts[comment.start] = true;
        }

        var isBlockComment = comment.type === "CommentBlock";
        var printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent()) this.newline(1);
        if (!this.endsWith("[") && !this.endsWith("{")) this.space();
        var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

        if (isBlockComment && this.format.indent.adjustMultilineComment) {
          var offset = comment.loc && comment.loc.start.column;

          if (offset) {
            var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, "\n");
          }

          var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
          val = val.replace(/\n(?!$)/g, "\n" + repeat_1(" ", indentSize));
        }

        if (this.endsWith("/")) this._space();
        this.withSource("start", comment.loc, function () {
          _this2._append(val);
        });
        if (printNewLines) this.newline(1);
      };

      _proto._printComments = function _printComments(comments, inlinePureAnnotation) {
        if (!comments || !comments.length) return;

        if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
          this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\n"));
        } else {
          for (var _iterator = _createForOfIteratorHelperLoose(comments), _step; !(_step = _iterator()).done;) {
            var _comment = _step.value;

            this._printComment(_comment);
          }
        }
      };

      return Printer;
    }();
    Object.assign(Printer.prototype, generatorFunctions);

    function commaSeparator() {
      this.token(",");
      this.space();
    }

    var Generator = function (_Printer) {
      _inheritsLoose(Generator, _Printer);

      function Generator(ast, opts, code) {
        var _this;

        if (opts === void 0) {
          opts = {};
        }

        var format = normalizeOptions(code, opts);
        var map = opts.sourceMaps ? new SourceMap(opts, code) : null;
        _this = _Printer.call(this, format, map) || this;
        _this.ast = ast;
        return _this;
      }

      var _proto = Generator.prototype;

      _proto.generate = function generate() {
        return _Printer.prototype.generate.call(this, this.ast);
      };

      return Generator;
    }(Printer);

    function normalizeOptions(code, opts) {
      var format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        jsonCompatibleStrings: opts.jsonCompatibleStrings,
        indent: {
          adjustMultilineComment: true,
          style: "  ",
          base: 0
        },
        decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true
        }, opts.jsescOption),
        recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType
      };

      if (format.minified) {
        format.compact = true;

        format.shouldPrintComment = format.shouldPrintComment || function () {
          return format.comments;
        };
      } else {
        format.shouldPrintComment = format.shouldPrintComment || function (value) {
          return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
        };
      }

      if (format.compact === "auto") {
        format.compact = code.length > 500000;

        if (format.compact) {
          console.error("[BABEL] Note: The code generator has deoptimised the styling of " + (opts.filename + " as it exceeds the max of " + "500KB" + "."));
        }
      }

      if (format.compact) {
        format.indent.adjustMultilineComment = false;
      }

      return format;
    }
    function generateCode (ast, opts, code) {
      var gen = new Generator(ast, opts, code);
      return gen.generate();
    }

    function findParent(callback) {
      var path = this;

      while (path = path.parentPath) {
        if (callback(path)) return path;
      }

      return null;
    }
    function find$1(callback) {
      var path = this;

      do {
        if (callback(path)) return path;
      } while (path = path.parentPath);

      return null;
    }
    function getFunctionParent() {
      return this.findParent(function (p) {
        return p.isFunction();
      });
    }
    function getStatementParent() {
      var path = this;

      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);

      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }

      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
        var earliest;
        var keys = VISITOR_KEYS[deepest.type];

        for (var _i = 0, _arr = ancestries; _i < _arr.length; _i++) {
          var ancestry = _arr[_i];
          var path = ancestry[i + 1];

          if (!earliest) {
            earliest = path;
            continue;
          }

          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }

          var earliestKeyIndex = keys.indexOf(earliest.parentKey);
          var currentKeyIndex = keys.indexOf(path.parentKey);

          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }

        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      var _this = this;

      if (!paths.length) {
        return this;
      }

      if (paths.length === 1) {
        return paths[0];
      }

      var minDepth = Infinity;
      var lastCommonIndex, lastCommon;
      var ancestries = paths.map(function (path) {
        var ancestry = [];

        do {
          ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== _this);

        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }

        return ancestry;
      });
      var first = ancestries[0];

      depthLoop: for (var i = 0; i < minDepth; i++) {
        var shouldMatch = first[i];

        for (var _i2 = 0, _arr2 = ancestries; _i2 < _arr2.length; _i2++) {
          var ancestry = _arr2[_i2];

          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }

        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }

      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      var path = this;
      var paths = [];

      do {
        paths.push(path);
      } while (path = path.parentPath);

      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent(function (parent) {
        return parent === maybeAncestor;
      });
    }
    function inType() {
      var path = this;

      while (path) {
        for (var _i3 = 0, _arr3 = arguments; _i3 < _arr3.length; _i3++) {
          var type = _arr3[_i3];
          if (path.node.type === type) return true;
        }

        path = path.parentPath;
      }

      return false;
    }

    var NodePath_ancestry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      findParent: findParent,
      find: find$1,
      getFunctionParent: getFunctionParent,
      getStatementParent: getStatementParent,
      getEarliestCommonAncestorFrom: getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: getDeepestCommonAncestorFrom,
      getAncestry: getAncestry,
      isAncestor: isAncestor,
      isDescendant: isDescendant,
      inType: inType
    });

    function infererReference (node) {
      if (!this.isReferenced()) return;
      var binding = this.scope.getBinding(node.name);

      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
      }

      if (node.name === "undefined") {
        return VoidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return NumberTypeAnnotation();
      } else if (node.name === "arguments") ;
    }

    function getTypeAnnotationBindingConstantViolations(binding, path, name) {
      var types = [];
      var functionConstantViolations = [];
      var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      var testType = getConditionalAnnotation(binding, path, name);

      if (testType) {
        var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter(function (path) {
          return testConstantViolations.indexOf(path) < 0;
        });
        types.push(testType.typeAnnotation);
      }

      if (constantViolations.length) {
        constantViolations = constantViolations.concat(functionConstantViolations);

        for (var _i = 0, _arr = constantViolations; _i < _arr.length; _i++) {
          var violation = _arr[_i];
          types.push(violation.getTypeAnnotation());
        }
      }

      if (!types.length) {
        return;
      }

      if (isTSTypeAnnotation(types[0]) && createTSUnionType) {
        return createTSUnionType(types);
      }

      if (createFlowUnionType) {
        return createFlowUnionType(types);
      }

      return createFlowUnionType(types);
    }

    function getConstantViolationsBefore(binding, path, functions) {
      var violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter(function (violation) {
        violation = violation.resolve();

        var status = violation._guessExecutionStatusRelativeTo(path);

        if (functions && status === "unknown") functions.push(violation);
        return status === "before";
      });
    }

    function inferAnnotationFromBinaryExpression(name, path) {
      var operator = path.node.operator;
      var right = path.get("right").resolve();
      var left = path.get("left").resolve();
      var target;

      if (left.isIdentifier({
        name: name
      })) {
        target = right;
      } else if (right.isIdentifier({
        name: name
      })) {
        target = left;
      }

      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }

        if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return NumberTypeAnnotation();
        }

        return;
      }

      if (operator !== "===" && operator !== "==") return;
      var typeofPath;
      var typePath;

      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }

      if (!typeofPath) return;
      if (!typeofPath.get("argument").isIdentifier({
        name: name
      })) return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral()) return;
      var typeValue = typePath.node.value;
      if (typeof typeValue !== "string") return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }

    function getParentConditionalPath(binding, path, name) {
      var parentPath;

      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }

          return parentPath;
        }

        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
        }

        path = parentPath;
      }
    }

    function getConditionalAnnotation(binding, path, name) {
      var ifStatement = getParentConditionalPath(binding, path, name);
      if (!ifStatement) return;
      var test = ifStatement.get("test");
      var paths = [test];
      var types = [];

      for (var i = 0; i < paths.length; i++) {
        var _path = paths[i];

        if (_path.isLogicalExpression()) {
          if (_path.node.operator === "&&") {
            paths.push(_path.get("left"));
            paths.push(_path.get("right"));
          }
        } else if (_path.isBinaryExpression()) {
          var type = inferAnnotationFromBinaryExpression(name, _path);
          if (type) types.push(type);
        }
      }

      if (types.length) {
        if (isTSTypeAnnotation(types[0]) && createTSUnionType) {
          return {
            typeAnnotation: createTSUnionType(types),
            ifStatement: ifStatement
          };
        }

        if (createFlowUnionType) {
          return {
            typeAnnotation: createFlowUnionType(types),
            ifStatement: ifStatement
          };
        }

        return {
          typeAnnotation: createFlowUnionType(types),
          ifStatement: ifStatement
        };
      }

      return getConditionalAnnotation(ifStatement, name);
    }

    function VariableDeclarator$2() {
      var id = this.get("id");
      if (!id.isIdentifier()) return;
      var init = this.get("init");
      var type = init.getTypeAnnotation();

      if (type && type.type === "AnyTypeAnnotation") {
        if (init.isCallExpression() && init.get("callee").isIdentifier({
          name: "Array"
        }) && !init.scope.hasBinding("Array", true)) {
          type = ArrayExpression$2();
        }
      }

      return type;
    }
    function TypeCastExpression$2(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression$2.validParent = true;
    function NewExpression$2(node) {
      if (this.get("callee").isIdentifier()) {
        return GenericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral$2() {
      return StringTypeAnnotation();
    }
    function UnaryExpression$2(node) {
      var operator = node.operator;

      if (operator === "void") {
        return VoidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return NumberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return StringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return BooleanTypeAnnotation();
      }
    }
    function BinaryExpression$2(node) {
      var operator = node.operator;

      if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return NumberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return BooleanTypeAnnotation();
      } else if (operator === "+") {
        var right = this.get("right");
        var left = this.get("left");

        if (left.isBaseType("number") && right.isBaseType("number")) {
          return NumberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return StringTypeAnnotation();
        }

        return UnionTypeAnnotation([StringTypeAnnotation(), NumberTypeAnnotation()]);
      }
    }
    function LogicalExpression$2() {
      var argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];

      if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
        return createTSUnionType(argumentTypes);
      }

      if (createFlowUnionType) {
        return createFlowUnionType(argumentTypes);
      }

      return createFlowUnionType(argumentTypes);
    }
    function ConditionalExpression$3() {
      var argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];

      if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
        return createTSUnionType(argumentTypes);
      }

      if (createFlowUnionType) {
        return createFlowUnionType(argumentTypes);
      }

      return createFlowUnionType(argumentTypes);
    }
    function SequenceExpression$3() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression$2() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression$3() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression$3(node) {
      var operator = node.operator;

      if (operator === "++" || operator === "--") {
        return NumberTypeAnnotation();
      }
    }
    function StringLiteral$2() {
      return StringTypeAnnotation();
    }
    function NumericLiteral$2() {
      return NumberTypeAnnotation();
    }
    function BooleanLiteral$2() {
      return BooleanTypeAnnotation();
    }
    function NullLiteral$2() {
      return NullLiteralTypeAnnotation();
    }
    function RegExpLiteral$2() {
      return GenericTypeAnnotation(Identifier("RegExp"));
    }
    function ObjectExpression$3() {
      return GenericTypeAnnotation(Identifier("Object"));
    }
    function ArrayExpression$2() {
      return GenericTypeAnnotation(Identifier("Array"));
    }
    function RestElement$2() {
      return ArrayExpression$2();
    }
    RestElement$2.validParent = true;

    function Func() {
      return GenericTypeAnnotation(Identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression$2() {
      var callee = this.node.callee;

      if (isObjectKeys(callee)) {
        return ArrayTypeAnnotation(StringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee)) {
        return ArrayTypeAnnotation(AnyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return ArrayTypeAnnotation(TupleTypeAnnotation([StringTypeAnnotation(), AnyTypeAnnotation()]));
      }

      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression$2() {
      return resolveCall(this.get("tag"));
    }

    function resolveCall(callee) {
      callee = callee.resolve();

      if (callee.isFunction()) {
        if (callee.is("async")) {
          if (callee.is("generator")) {
            return GenericTypeAnnotation(Identifier("AsyncIterator"));
          } else {
            return GenericTypeAnnotation(Identifier("Promise"));
          }
        } else {
          if (callee.node.returnType) {
            return callee.node.returnType;
          }
        }
      }
    }

    var inferers = /*#__PURE__*/Object.freeze({
      __proto__: null,
      VariableDeclarator: VariableDeclarator$2,
      TypeCastExpression: TypeCastExpression$2,
      NewExpression: NewExpression$2,
      TemplateLiteral: TemplateLiteral$2,
      UnaryExpression: UnaryExpression$2,
      BinaryExpression: BinaryExpression$2,
      LogicalExpression: LogicalExpression$2,
      ConditionalExpression: ConditionalExpression$3,
      SequenceExpression: SequenceExpression$3,
      ParenthesizedExpression: ParenthesizedExpression$2,
      AssignmentExpression: AssignmentExpression$3,
      UpdateExpression: UpdateExpression$3,
      StringLiteral: StringLiteral$2,
      NumericLiteral: NumericLiteral$2,
      BooleanLiteral: BooleanLiteral$2,
      NullLiteral: NullLiteral$2,
      RegExpLiteral: RegExpLiteral$2,
      ObjectExpression: ObjectExpression$3,
      ArrayExpression: ArrayExpression$2,
      RestElement: RestElement$2,
      FunctionExpression: Func,
      ArrowFunctionExpression: Func,
      FunctionDeclaration: Func,
      ClassExpression: Func,
      ClassDeclaration: Func,
      CallExpression: CallExpression$2,
      TaggedTemplateExpression: TaggedTemplateExpression$2,
      Identifier: infererReference
    });

    function getTypeAnnotation() {
      if (this.typeAnnotation) return this.typeAnnotation;
      var type = this._getTypeAnnotation() || AnyTypeAnnotation();
      if (isTypeAnnotation(type)) type = type.typeAnnotation;
      return this.typeAnnotation = type;
    }
    function _getTypeAnnotation() {
      var node = this.node;

      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          var declar = this.parentPath.parentPath;
          var declarParent = declar.parentPath;

          if (declar.key === "left" && declarParent.isForInStatement()) {
            return StringTypeAnnotation();
          }

          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return AnyTypeAnnotation();
          }

          return VoidTypeAnnotation();
        } else {
          return;
        }
      }

      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }

      var inferer = inferers[node.type];

      if (inferer) {
        return inferer.call(this, node);
      }

      inferer = inferers[this.parentPath.type];

      if (inferer && inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }

    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error("Unknown base type " + baseName);
        }
      }
    }

    function couldBeBaseType(name) {
      var type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return true;

      if (isUnionTypeAnnotation(type)) {
        for (var _i = 0, _arr = type.types; _i < _arr.length; _i++) {
          var type2 = _arr[_i];

          if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
            return true;
          }
        }

        return false;
      } else {
        return _isBaseType(name, type, true);
      }
    }
    function baseTypeStrictlyMatches(right) {
      var left = this.getTypeAnnotation();
      right = right.getTypeAnnotation();

      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
    }
    function isGenericType(genericName) {
      var type = this.getTypeAnnotation();
      return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
        name: genericName
      });
    }

    var NodePath_inference = /*#__PURE__*/Object.freeze({
      __proto__: null,
      getTypeAnnotation: getTypeAnnotation,
      _getTypeAnnotation: _getTypeAnnotation,
      isBaseType: isBaseType,
      couldBeBaseType: couldBeBaseType,
      baseTypeStrictlyMatches: baseTypeStrictlyMatches,
      isGenericType: isGenericType
    });

    var jsTokens = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

    exports.matchToToken = function (match) {
      var token = {
        type: "invalid",
        value: match[0],
        closed: undefined
      };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
      return token;
    };
    });

    var jsTokens$1 = unwrapExports(jsTokens);
    var jsTokens_1 = jsTokens.matchToToken;

    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

    var escapeStringRegexp = function (str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }

      return str.replace(matchOperatorsRe, '\\$&');
    };

    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };

    var conversions = createCommonjsModule(function (module) {
    var reverseKeywords = {};

    for (var key in colorName) {
      if (colorName.hasOwnProperty(key)) {
        reverseKeywords[colorName[key]] = key;
      }
    }

    var convert = module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb'
      },
      hsl: {
        channels: 3,
        labels: 'hsl'
      },
      hsv: {
        channels: 3,
        labels: 'hsv'
      },
      hwb: {
        channels: 3,
        labels: 'hwb'
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk'
      },
      xyz: {
        channels: 3,
        labels: 'xyz'
      },
      lab: {
        channels: 3,
        labels: 'lab'
      },
      lch: {
        channels: 3,
        labels: 'lch'
      },
      hex: {
        channels: 1,
        labels: ['hex']
      },
      keyword: {
        channels: 1,
        labels: ['keyword']
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16']
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256']
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g']
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16']
      },
      gray: {
        channels: 1,
        labels: ['gray']
      }
    };

    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }

        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }

        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }

        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {
          value: channels
        });
        Object.defineProperty(convert[model], 'labels', {
          value: labels
        });
      }
    }

    convert.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);

      var diffc = function diffc(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };

      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);

        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }

        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }

      return [h * 360, s * 100, v * 100];
    };

    convert.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };

    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }

    convert.rgb.keyword = function (rgb) {
      var reversed = reverseKeywords[rgb];

      if (reversed) {
        return reversed;
      }

      var currentClosestDistance = Infinity;
      var currentClosestKeyword;

      for (var keyword in colorName) {
        if (colorName.hasOwnProperty(keyword)) {
          var value = colorName[keyword];
          var distance = comparativeDistance(rgb, value);

          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }

      return currentClosestKeyword;
    };

    convert.keyword.rgb = function (keyword) {
      return colorName[keyword];
    };

    convert.rgb.xyz = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };

    convert.rgb.lab = function (rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.hsl.rgb = function (hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    };

    convert.hsl.hsv = function (hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };

    convert.hsv.rgb = function (hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    };

    convert.hsv.hsl = function (hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };

    convert.hwb.rgb = function (hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh);
      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    };

    convert.cmyk.rgb = function (cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.rgb = function (xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570;
      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.lab = function (xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.lab.xyz = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };

    convert.lab.lch = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };

    convert.lch.lab = function (lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };

    convert.rgb.ansi16 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);

      if (value === 0) {
        return 30;
      }

      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

      if (value === 2) {
        ansi += 60;
      }

      return ansi;
    };

    convert.hsv.ansi16 = function (args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };

    convert.rgb.ansi256 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];

      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }

        if (r > 248) {
          return 231;
        }

        return Math.round((r - 8) / 247 * 24) + 232;
      }

      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };

    convert.ansi16.rgb = function (args) {
      var color = args % 10;

      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }

        color = color / 10.5 * 255;
        return [color, color, color];
      }

      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };

    convert.ansi256.rgb = function (args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }

      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };

    convert.rgb.hex = function (args) {
      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.hex.rgb = function (args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

      if (!match) {
        return [0, 0, 0];
      }

      var colorString = match[0];

      if (match[0].length === 3) {
        colorString = colorString.split('').map(function (_char) {
          return _char + _char;
        }).join('');
      }

      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 0xFF;
      var g = integer >> 8 & 0xFF;
      var b = integer & 0xFF;
      return [r, g, b];
    };

    convert.rgb.hcg = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;

      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }

      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }

      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert.hsl.hcg = function (hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;

      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }

      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }

      return [hsl[0], c * 100, f * 100];
    };

    convert.hsv.hcg = function (hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;

      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }

      return [hsv[0], c * 100, f * 100];
    };

    convert.hcg.rgb = function (hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;

      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }

      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;

      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;

        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;

        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;

        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;

        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;

        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }

      mg = (1.0 - c) * g;
      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };

    convert.hcg.hsv = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;

      if (v > 0.0) {
        f = c / v;
      }

      return [hcg[0], f * 100, v * 100];
    };

    convert.hcg.hsl = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;

      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }

      return [hcg[0], s * 100, l * 100];
    };

    convert.hcg.hwb = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert.hwb.hcg = function (hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;

      if (c < 1) {
        g = (v - c) / (1 - c);
      }

      return [hwb[0], c * 100, g * 100];
    };

    convert.apple.rgb = function (apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };

    convert.rgb.apple = function (rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };

    convert.gray.rgb = function (args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert.gray.hsl = convert.gray.hsv = function (args) {
      return [0, 0, args[0]];
    };

    convert.gray.hwb = function (gray) {
      return [0, 100, gray[0]];
    };

    convert.gray.cmyk = function (gray) {
      return [0, 0, 0, gray[0]];
    };

    convert.gray.lab = function (gray) {
      return [gray[0], 0, 0];
    };

    convert.gray.hex = function (gray) {
      var val = Math.round(gray[0] / 100 * 255) & 0xFF;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.rgb.gray = function (rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
    });
    var conversions_1 = conversions.rgb;
    var conversions_2 = conversions.hsl;
    var conversions_3 = conversions.hsv;
    var conversions_4 = conversions.hwb;
    var conversions_5 = conversions.cmyk;
    var conversions_6 = conversions.xyz;
    var conversions_7 = conversions.lab;
    var conversions_8 = conversions.lch;
    var conversions_9 = conversions.hex;
    var conversions_10 = conversions.keyword;
    var conversions_11 = conversions.ansi16;
    var conversions_12 = conversions.ansi256;
    var conversions_13 = conversions.hcg;
    var conversions_14 = conversions.apple;
    var conversions_15 = conversions.gray;

    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);

      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }

      return graph;
    }

    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;

      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);

        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];

          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }

      return graph;
    }

    function link(from, to) {
      return function (args) {
        return to(from(args));
      };
    }

    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;

      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }

      fn.conversion = path;
      return fn;
    }

    var route = function (fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);

      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];

        if (node.parent === null) {
          continue;
        }

        conversion[toModel] = wrapConversion(toModel, graph);
      }

      return conversion;
    };

    var convert = {};
    var models = Object.keys(conversions);

    function wrapRaw(fn) {
      var wrappedFn = function wrappedFn(args) {
        if (args === undefined || args === null) {
          return args;
        }

        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }

        return fn(args);
      };

      if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
      }

      return wrappedFn;
    }

    function wrapRounded(fn) {
      var wrappedFn = function wrappedFn(args) {
        if (args === undefined || args === null) {
          return args;
        }

        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }

        var result = fn(args);

        if (typeof result === 'object') {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }

        return result;
      };

      if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
      }

      return wrappedFn;
    }

    models.forEach(function (fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], 'channels', {
        value: conversions[fromModel].channels
      });
      Object.defineProperty(convert[fromModel], 'labels', {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function (toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    var colorConvert = convert;

    var ansiStyles = createCommonjsModule(function (module) {



    var wrapAnsi16 = function wrapAnsi16(fn, offset) {
      return function () {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[" + (code + offset) + "m";
      };
    };

    var wrapAnsi256 = function wrapAnsi256(fn, offset) {
      return function () {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[" + (38 + offset) + ";5;" + code + "m";
      };
    };

    var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
      return function () {
        var rgb = fn.apply(colorConvert, arguments);
        return "\x1B[" + (38 + offset) + ";2;" + rgb[0] + ";" + rgb[1] + ";" + rgb[2] + "m";
      };
    };

    function assembleStyles() {
      var codes = new Map();
      var styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;

      for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
        var groupName = _Object$keys[_i];
        var group = styles[groupName];

        for (var _i2 = 0, _Object$keys2 = Object.keys(group); _i2 < _Object$keys2.length; _i2++) {
          var styleName = _Object$keys2[_i2];
          var style = group[styleName];
          styles[styleName] = {
            open: "\x1B[" + style[0] + "m",
            close: "\x1B[" + style[1] + "m"
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }

        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, 'codes', {
          value: codes,
          enumerable: false
        });
      }

      var ansi2ansi = function ansi2ansi(n) {
        return n;
      };

      var rgb2rgb = function rgb2rgb(r, g, b) {
        return [r, g, b];
      };

      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };

      for (var _i3 = 0, _Object$keys3 = Object.keys(colorConvert); _i3 < _Object$keys3.length; _i3++) {
        var key = _Object$keys3[_i3];

        if (typeof colorConvert[key] !== 'object') {
          continue;
        }

        var suite = colorConvert[key];

        if (key === 'ansi16') {
          key = 'ansi';
        }

        if ('ansi16' in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }

        if ('ansi256' in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }

        if ('rgb' in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }

      return styles;
    }

    Object.defineProperty(module, 'exports', {
      enumerable: true,
      get: assembleStyles
    });
    });

    var browser$3 = {
      stdout: false,
      stderr: false
    };

    var require$$0$1 = getCjsExportFromNamespace(_rollupPluginBabelHelpers);

    var _createForOfIteratorHelperLoose$1 = require$$0$1.createForOfIteratorHelperLoose;

    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

    function unescape(c) {
      if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }

      return ESCAPES.get(c) || c;
    }

    function parseArguments(name, args) {
      var results = [];
      var chunks = args.trim().split(/\s*,\s*/g);
      var matches;

      for (var _iterator = _createForOfIteratorHelperLoose$1(chunks), _step; !(_step = _iterator()).done;) {
        var chunk = _step.value;

        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
            return escape ? unescape(escape) : chr;
          }));
        } else {
          throw new Error("Invalid Chalk template style argument: " + chunk + " (in style '" + name + "')");
        }
      }

      return results;
    }

    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      var results = [];
      var matches;

      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        var name = matches[1];

        if (matches[2]) {
          var args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }

      return results;
    }

    function buildStyle(chalk, styles) {
      var enabled = {};

      for (var _iterator2 = _createForOfIteratorHelperLoose$1(styles), _step2; !(_step2 = _iterator2()).done;) {
        var layer = _step2.value;

        for (var _iterator3 = _createForOfIteratorHelperLoose$1(layer.styles), _step3; !(_step3 = _iterator3()).done;) {
          var style = _step3.value;
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }

      var current = chalk;

      for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {
        var styleName = _Object$keys[_i];

        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error("Unknown Chalk style: " + styleName);
          }

          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }

      return current;
    }

    var templates = function (chalk, tmp) {
      var styles = [];
      var chunks = [];
      var chunk = [];
      tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          var str = chunk.join('');
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({
            inverse: inverse,
            styles: parseStyle(style)
          });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error('Found extraneous } in Chalk template literal');
          }

          chunks.push(buildStyle(chalk, styles)(chunk.join('')));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(''));

      if (styles.length > 0) {
        var errMsg = "Chalk template literal is missing " + styles.length + " closing bracket" + (styles.length === 1 ? '' : 's') + " (`}`)";
        throw new Error(errMsg);
      }

      return chunks.join('');
    };

    var chalk = createCommonjsModule(function (module) {

    var _createForOfIteratorHelperLoose = require$$0$1.createForOfIteratorHelperLoose;





    var stdoutColor = browser$3.stdout;



    var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');
    var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
    var skipModels = new Set(['gray']);
    var styles = Object.create(null);

    function applyOptions(obj, options) {
      options = options || {};
      var scLevel =  0;
      obj.level = options.level === undefined ? scLevel : options.level;
      obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
    }

    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        var chalk = {};
        applyOptions(chalk, options);

        chalk.template = function () {
          var args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };

        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }

      applyOptions(this, options);
    }

    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }

    var _loop = function _loop() {
      var key = _Object$keys[_i];
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
      styles[key] = {
        get: function get() {
          var codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    };

    for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
      _loop();
    }

    styles.visible = {
      get: function get() {
        return build.call(this, this._styles || [], true, 'visible');
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

    var _loop2 = function _loop2() {
      var model = _Object$keys2[_i2];

      if (skipModels.has(model)) {
        return "continue";
      }

      styles[model] = {
        get: function get() {
          var level = this.level;
          return function () {
            var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            var codes = {
              open: open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    };

    for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
      var _ret = _loop2();

      if (_ret === "continue") continue;
    }

    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

    var _loop3 = function _loop3() {
      var model = _Object$keys3[_i3];

      if (skipModels.has(model)) {
        return "continue";
      }

      var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get: function get() {
          var level = this.level;
          return function () {
            var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            var codes = {
              open: open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    };

    for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
      var _ret2 = _loop3();

      if (_ret2 === "continue") continue;
    }

    var proto = Object.defineProperties(function () {}, styles);

    function build(_styles, _empty, key) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };

      builder._styles = _styles;
      builder._empty = _empty;
      var self = this;
      Object.defineProperty(builder, 'level', {
        enumerable: true,
        get: function get() {
          return self.level;
        },
        set: function set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, 'enabled', {
        enumerable: true,
        get: function get() {
          return self.enabled;
        },
        set: function set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
      builder.__proto__ = proto;
      return builder;
    }

    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = String(arguments[0]);

      if (argsLen === 0) {
        return '';
      }

      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }

      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? '' : str;
      }

      var originalDim = ansiStyles.dim.open;

      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = '';
      }

      for (var _iterator = _createForOfIteratorHelperLoose(this._styles.slice().reverse()), _step; !(_step = _iterator()).done;) {
        var code = _step.value;
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, code.close + "$&" + code.open);
      }

      ansiStyles.dim.open = originalDim;
      return str;
    }

    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(' ');
      }

      var args = [].slice.call(arguments, 2);
      var parts = [strings.raw[0]];

      for (var i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
        parts.push(String(strings.raw[i]));
      }

      return templates(chalk, parts.join(''));
    }

    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports["default"] = module.exports;
    });
    var chalk_1 = chalk.supportsColor;

    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsx_tag: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }

    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var BRACKET = /^[()[\]{}]$/;

    function getTokenType(match) {
      var _match$slice = match.slice(-2),
          offset = _match$slice[0],
          text = _match$slice[1];

      var token = jsTokens_1(match);

      if (token.type === "name") {
        if (isKeyword(token.value) || isReservedWord(token.value)) {
          return "keyword";
        }

        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsx_tag";
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }

      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }

      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }

      return token.type;
    }

    function highlightTokens(defs, text) {
      return text.replace(jsTokens$1, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var type = getTokenType(args);
        var colorize = defs[type];

        if (colorize) {
          return args[0].split(NEWLINE).map(function (str) {
            return colorize(str);
          }).join("\n");
        } else {
          return args[0];
        }
      });
    }

    function shouldHighlight(options) {
      return chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      var chalk$1 = chalk;

      if (options.forceColor) {
        chalk$1 = new chalk.constructor({
          enabled: true,
          level: 1
        });
      }

      return chalk$1;
    }
    function highlight(code, options) {
      if (options === void 0) {
        options = {};
      }

      if (shouldHighlight(options)) {
        var chalk = getChalk(options);
        var defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }

    function getDefs$1(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }

    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;

    function getMarkerLines(loc, source, opts) {
      var startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      var endLoc = Object.assign({}, startLoc, {}, loc.end);

      var _ref = opts || {},
          _ref$linesAbove = _ref.linesAbove,
          linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
          _ref$linesBelow = _ref.linesBelow,
          linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

      var startLine = startLoc.line;
      var startColumn = startLoc.column;
      var endLine = endLoc.line;
      var endColumn = endLoc.column;
      var start = Math.max(startLine - (linesAbove + 1), 0);
      var end = Math.min(source.length, endLine + linesBelow);

      if (startLine === -1) {
        start = 0;
      }

      if (endLine === -1) {
        end = source.length;
      }

      var lineDiff = endLine - startLine;
      var markerLines = {};

      if (lineDiff) {
        for (var i = 0; i <= lineDiff; i++) {
          var lineNumber = i + startLine;

          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            var sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            var _sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, _sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }

      return {
        start: start,
        end: end,
        markerLines: markerLines
      };
    }

    function codeFrameColumns(rawLines, loc, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var highlighted = (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
      var chalk = getChalk(opts);
      var defs = getDefs$1(chalk);

      var maybeHighlight = function maybeHighlight(chalkFn, string) {
        return highlighted ? chalkFn(string) : string;
      };

      var lines = rawLines.split(NEWLINE$1);

      var _getMarkerLines = getMarkerLines(loc, lines, opts),
          start = _getMarkerLines.start,
          end = _getMarkerLines.end,
          markerLines = _getMarkerLines.markerLines;

      var hasColumns = loc.start && typeof loc.start.column === "number";
      var numberMaxWidth = String(end).length;
      var highlightedLines = highlighted ? highlight(rawLines, opts) : rawLines;
      var frame = highlightedLines.split(NEWLINE$1).slice(start, end).map(function (line, index) {
        var number = start + 1 + index;
        var paddedNumber = (" " + number).slice(-numberMaxWidth);
        var gutter = " " + paddedNumber + " | ";
        var hasMarker = markerLines[number];
        var lastMarkerLine = !markerLines[number + 1];

        if (hasMarker) {
          var markerLine = "";

          if (Array.isArray(hasMarker)) {
            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            var numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }

          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
        } else {
          return " " + maybeHighlight(defs.gutter, gutter) + line;
        }
      }).join("\n");

      if (opts.message && !hasColumns) {
        frame = "" + " ".repeat(numberMaxWidth + 1) + opts.message + "\n" + frame;
      }

      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }

    var beforeExpr = true;
    var startsExpr = true;
    var isLoop$1 = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var TokenType = function TokenType(label, conf) {
      if (conf === void 0) {
        conf = {};
      }

      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      this.updateContext = null;
    };
    var keywords$1 = new Map();

    function createKeyword(name, options) {
      if (options === void 0) {
        options = {};
      }

      options.keyword = name;
      var token = new TokenType(name, options);
      keywords$1.set(name, token);
      return token;
    }

    function createBinop(name, binop) {
      return new TokenType(name, {
        beforeExpr: beforeExpr,
        binop: binop
      });
    }

    var types = {
      num: new TokenType("num", {
        startsExpr: startsExpr
      }),
      bigint: new TokenType("bigint", {
        startsExpr: startsExpr
      }),
      regexp: new TokenType("regexp", {
        startsExpr: startsExpr
      }),
      string: new TokenType("string", {
        startsExpr: startsExpr
      }),
      name: new TokenType("name", {
        startsExpr: startsExpr
      }),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      bracketHashL: new TokenType("#[", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      bracketBarL: new TokenType("[|", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      bracketR: new TokenType("]"),
      bracketBarR: new TokenType("|]"),
      braceL: new TokenType("{", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      braceBarL: new TokenType("{|", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      braceHashL: new TokenType("#{", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      braceR: new TokenType("}"),
      braceBarR: new TokenType("|}"),
      parenL: new TokenType("(", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", {
        beforeExpr: beforeExpr
      }),
      semi: new TokenType(";", {
        beforeExpr: beforeExpr
      }),
      colon: new TokenType(":", {
        beforeExpr: beforeExpr
      }),
      doubleColon: new TokenType("::", {
        beforeExpr: beforeExpr
      }),
      dot: new TokenType("."),
      question: new TokenType("?", {
        beforeExpr: beforeExpr
      }),
      questionDot: new TokenType("?."),
      tildeDot: new TokenType("~."),
      arrow: new TokenType("=>", {
        beforeExpr: beforeExpr
      }),
      template: new TokenType("template"),
      ellipsis: new TokenType("...", {
        beforeExpr: beforeExpr
      }),
      backQuote: new TokenType("`", {
        startsExpr: startsExpr
      }),
      dollarBraceL: new TokenType("${", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      at: new TokenType("@"),
      hash: new TokenType("#", {
        startsExpr: startsExpr
      }),
      interpreterDirective: new TokenType("#!..."),
      eq: new TokenType("=", {
        beforeExpr: beforeExpr,
        isAssign: isAssign
      }),
      assign: new TokenType("_=", {
        beforeExpr: beforeExpr,
        isAssign: isAssign
      }),
      incDec: new TokenType("++/--", {
        prefix: prefix,
        postfix: postfix,
        startsExpr: startsExpr
      }),
      bang: new TokenType("!", {
        beforeExpr: beforeExpr,
        prefix: prefix,
        startsExpr: startsExpr
      }),
      tilde: new TokenType("~", {
        beforeExpr: beforeExpr,
        prefix: prefix,
        startsExpr: startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {
        beforeExpr: beforeExpr,
        binop: 9,
        prefix: prefix,
        startsExpr: startsExpr
      }),
      modulo: new TokenType("%", {
        beforeExpr: beforeExpr,
        binop: 10,
        startsExpr: startsExpr
      }),
      star: createBinop("*", 10),
      slash: createBinop("/", 10),
      exponent: new TokenType("**", {
        beforeExpr: beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr: beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr: beforeExpr
      }),
      _do: createKeyword("do", {
        isLoop: isLoop$1,
        beforeExpr: beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr: beforeExpr
      }),
      _finally: createKeyword("finally"),
      _for: createKeyword("for", {
        isLoop: isLoop$1
      }),
      _function: createKeyword("function", {
        startsExpr: startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr: beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr: beforeExpr,
        prefix: prefix,
        startsExpr: startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _while: createKeyword("while", {
        isLoop: isLoop$1
      }),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr: beforeExpr,
        startsExpr: startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr: startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr: startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr: startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr: beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr: startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr: startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr: startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr: startsExpr
      }),
      _in: createKeyword("in", {
        beforeExpr: beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr: beforeExpr,
        binop: 7
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr: beforeExpr,
        prefix: prefix,
        startsExpr: startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr: beforeExpr,
        prefix: prefix,
        startsExpr: startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr: beforeExpr,
        prefix: prefix,
        startsExpr: startsExpr
      })
    };

    var SCOPE_OTHER = 0,
        SCOPE_PROGRAM = 1,
        SCOPE_FUNCTION = 2,
        SCOPE_ARROW = 4,
        SCOPE_SIMPLE_CATCH = 8,
        SCOPE_SUPER = 16,
        SCOPE_DIRECT_SUPER = 32,
        SCOPE_CLASS = 64,
        SCOPE_TS_MODULE = 128,
        SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
    var BIND_KIND_VALUE = 1,
        BIND_KIND_TYPE = 2,
        BIND_SCOPE_VAR = 4,
        BIND_SCOPE_LEXICAL = 8,
        BIND_SCOPE_FUNCTION = 16,
        BIND_FLAGS_NONE = 64,
        BIND_FLAGS_CLASS = 128,
        BIND_FLAGS_TS_ENUM = 256,
        BIND_FLAGS_TS_CONST_ENUM = 512,
        BIND_FLAGS_TS_EXPORT_ONLY = 1024;
    var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
        BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
        BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
        BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
        BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
        BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
        BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
        BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
        BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
        BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
        BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
        BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var CLASS_ELEMENT_FLAG_STATIC = 4,
        CLASS_ELEMENT_KIND_GETTER = 2,
        CLASS_ELEMENT_KIND_SETTER = 1,
        CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
        CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
        CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
        CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
        CLASS_ELEMENT_OTHER = 0;

    var lineBreak = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;

        default:
          return false;
      }
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    function isWhitespace(code) {
      switch (code) {
        case 0x0009:
        case 0x000b:
        case 0x000c:
        case 32:
        case 160:
        case 5760:
        case 0x2000:
        case 0x2001:
        case 0x2002:
        case 0x2003:
        case 0x2004:
        case 0x2005:
        case 0x2006:
        case 0x2007:
        case 0x2008:
        case 0x2009:
        case 0x200a:
        case 0x202f:
        case 0x205f:
        case 0x3000:
        case 0xfeff:
          return true;

        default:
          return false;
      }
    }

    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };
    var SourceLocation = function SourceLocation(start, end) {
      this.start = start;
      this.end = end;
    };
    function getLineInfo(input, offset) {
      var line = 1;
      var lineStart = 0;
      var match;
      lineBreakG.lastIndex = 0;

      while ((match = lineBreakG.exec(input)) && match.index < offset) {
        line++;
        lineStart = lineBreakG.lastIndex;
      }

      return new Position(line, offset - lineStart);
    }

    var BaseParser = function () {
      function BaseParser() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }

      var _proto = BaseParser.prototype;

      _proto.hasPlugin = function hasPlugin(name) {
        return this.plugins.has(name);
      };

      _proto.getPluginOption = function getPluginOption(plugin, name) {
        if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
      };

      return BaseParser;
    }();

    function last(stack) {
      return stack[stack.length - 1];
    }

    var CommentsParser = function (_BaseParser) {
      _inheritsLoose(CommentsParser, _BaseParser);

      function CommentsParser() {
        return _BaseParser.apply(this, arguments) || this;
      }

      var _proto = CommentsParser.prototype;

      _proto.addComment = function addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        this.state.trailingComments.push(comment);
        this.state.leadingComments.push(comment);
      };

      _proto.adjustCommentsAfterTrailingComma = function adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
        if (this.state.leadingComments.length === 0) {
          return;
        }

        var lastElement = null;
        var i = elements.length;

        while (lastElement === null && i > 0) {
          lastElement = elements[--i];
        }

        if (lastElement === null) {
          return;
        }

        for (var j = 0; j < this.state.leadingComments.length; j++) {
          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
            this.state.leadingComments.splice(j, 1);
            j--;
          }
        }

        var newTrailingComments = [];

        for (var _i = 0; _i < this.state.leadingComments.length; _i++) {
          var leadingComment = this.state.leadingComments[_i];

          if (leadingComment.end < node.end) {
            newTrailingComments.push(leadingComment);

            if (!takeAllComments) {
              this.state.leadingComments.splice(_i, 1);
              _i--;
            }
          } else {
            if (node.trailingComments === undefined) {
              node.trailingComments = [];
            }

            node.trailingComments.push(leadingComment);
          }
        }

        if (takeAllComments) this.state.leadingComments = [];

        if (newTrailingComments.length > 0) {
          lastElement.trailingComments = newTrailingComments;
        } else if (lastElement.trailingComments !== undefined) {
          lastElement.trailingComments = [];
        }
      };

      _proto.processComment = function processComment(node) {
        if (node.type === "Program" && node.body.length > 0) return;
        var stack = this.state.commentStack;
        var firstChild, lastChild, trailingComments, i, j;

        if (this.state.trailingComments.length > 0) {
          if (this.state.trailingComments[0].start >= node.end) {
            trailingComments = this.state.trailingComments;
            this.state.trailingComments = [];
          } else {
            this.state.trailingComments.length = 0;
          }
        } else if (stack.length > 0) {
          var lastInStack = last(stack);

          if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
            trailingComments = lastInStack.trailingComments;
            delete lastInStack.trailingComments;
          }
        }

        if (stack.length > 0 && last(stack).start >= node.start) {
          firstChild = stack.pop();
        }

        while (stack.length > 0 && last(stack).start >= node.start) {
          lastChild = stack.pop();
        }

        if (!lastChild && firstChild) lastChild = firstChild;

        if (firstChild) {
          switch (node.type) {
            case "ObjectExpression":
              this.adjustCommentsAfterTrailingComma(node, node.properties);
              break;

            case "ObjectPattern":
              this.adjustCommentsAfterTrailingComma(node, node.properties, true);
              break;

            case "CallExpression":
              this.adjustCommentsAfterTrailingComma(node, node.arguments);
              break;

            case "ArrayExpression":
              this.adjustCommentsAfterTrailingComma(node, node.elements);
              break;

            case "ArrayPattern":
              this.adjustCommentsAfterTrailingComma(node, node.elements, true);
              break;
          }
        } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
          this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
        }

        if (lastChild) {
          if (lastChild.leadingComments) {
            if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
              node.leadingComments = lastChild.leadingComments;
              delete lastChild.leadingComments;
            } else {
              for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                if (lastChild.leadingComments[i].end <= node.start) {
                  node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                  break;
                }
              }
            }
          }
        } else if (this.state.leadingComments.length > 0) {
          if (last(this.state.leadingComments).end <= node.start) {
            if (this.state.commentPreviousNode) {
              for (j = 0; j < this.state.leadingComments.length; j++) {
                if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                  this.state.leadingComments.splice(j, 1);
                  j--;
                }
              }
            }

            if (this.state.leadingComments.length > 0) {
              node.leadingComments = this.state.leadingComments;
              this.state.leadingComments = [];
            }
          } else {
            for (i = 0; i < this.state.leadingComments.length; i++) {
              if (this.state.leadingComments[i].end > node.start) {
                break;
              }
            }

            var leadingComments = this.state.leadingComments.slice(0, i);

            if (leadingComments.length) {
              node.leadingComments = leadingComments;
            }

            trailingComments = this.state.leadingComments.slice(i);

            if (trailingComments.length === 0) {
              trailingComments = null;
            }
          }
        }

        this.state.commentPreviousNode = node;

        if (trailingComments) {
          if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
            node.innerComments = trailingComments;
          } else {
            node.trailingComments = trailingComments;
          }
        }

        stack.push(node);
      };

      return CommentsParser;
    }(BaseParser);

    var Errors = Object.freeze({
      ArgumentsDisallowedInInitializer: "'arguments' is not allowed in class field initializer",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
      AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
      AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function",
      BadGetterArity: "getter must not have any formal parameters",
      BadSetterArity: "setter must have exactly one formal parameter",
      BadSetterRestParameter: "setter function argument must not be a rest parameter",
      ConstructorClassField: "Classes may not have a field named 'constructor'",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
      ConstructorIsAccessor: "Class constructor may not be an accessor",
      ConstructorIsAsync: "Constructor can't be an async function",
      ConstructorIsGenerator: "Constructor can't be a generator",
      DeclarationMissingInitializer: "%0 require an initialization value",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon",
      DeletePrivateField: "Deleting a private field is not allowed",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
      DuplicateProto: "Redefinition of __proto__ property",
      DuplicateRegExpFlags: "Duplicate regular expression flag",
      ElementAfterRest: "Rest element must be last element",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape",
      EventualNoNew: "constructors in/after an Eventual Chain are not allowed",
      ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
      IllegalBreakContinue: "Unsyntactic %0",
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
      IllegalReturn: "'return' outside of function",
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
      ImportCallArity: "import() requires exactly one argument",
      ImportCallArityLtOne: "Dynamic imports require a parameter: import('a.js')",
      ImportCallNotNewExpression: "Cannot use new with import(...)",
      ImportCallSpreadArgument: "... is not allowed in import()",
      ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
      ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
      InvalidCodePoint: "Code point out of bounds",
      InvalidDigit: "Expected number in radix %0",
      InvalidEscapeSequence: "Bad character escape sequence",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
      InvalidEscapedReservedWord: "Escape sequence in keyword %0",
      InvalidIdentifier: "Invalid identifier %0",
      InvalidLhs: "Invalid left-hand side in %0",
      InvalidLhsBinding: "Binding invalid left-hand side in %0",
      InvalidNumber: "Invalid number",
      InvalidOrUnexpectedToken: "Unexpected character '%0'",
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
      InvalidPrivateFieldResolution: "Private name #%0 is not defined",
      InvalidPropertyBindingPattern: "Binding member expression",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument",
      LabelRedeclaration: "Label '%0' is already declared",
      LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
      MalformedRegExpFlags: "Invalid regular expression flag",
      MissingClassName: "A class name is required",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
      ModuleExportUndefined: "Export '%0' is not defined",
      MultipleDefaultsInSwitch: "Multiple default clauses",
      NewlineAfterThrow: "Illegal newline after throw",
      NoCatchOrFinally: "Missing catch or finally clause",
      NumberIdentifier: "Identifier directly after number",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
      ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
      ParamDupe: "Argument name clash",
      PatternHasAccessor: "Object pattern can't contain getter or setter",
      PatternHasMethod: "Object pattern can't contain methods",
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
      PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
      PrivateNameRedeclaration: "Duplicate private name #%0",
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
      RestTrailingComma: "Unexpected trailing comma after rest element",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
      StaticPrototype: "Classes may not have static property named prototype",
      StrictDelete: "Deleting local variable in strict mode",
      StrictEvalArguments: "Assigning to '%0' in strict mode",
      StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
      StrictWith: "'with' in strict mode",
      SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super",
      TrailingDecorator: "Decorators must be attached to a class element",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
      UnexpectedKeyword: "Unexpected keyword '%0'",
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
      UnexpectedNewTarget: "new.target can only be used in functions",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
      UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
      UnexpectedReservedWord: "Unexpected reserved word '%0'",
      UnexpectedSuper: "super is only allowed in object methods and classes",
      UnexpectedToken: "Unexpected token '%'",
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "import can only be used in import() or import.meta",
      UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
      UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
      UnterminatedComment: "Unterminated comment",
      UnterminatedRegExp: "Unterminated regular expression",
      UnterminatedString: "Unterminated string constant",
      UnterminatedTemplate: "Unterminated template",
      VarRedeclaration: "Identifier '%0' has already been declared",
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
      YieldInParameter: "yield is not allowed in generator parameters",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
    });

    var LocationParser = function (_CommentsParser) {
      _inheritsLoose(LocationParser, _CommentsParser);

      function LocationParser() {
        return _CommentsParser.apply(this, arguments) || this;
      }

      var _proto = LocationParser.prototype;

      _proto.getLocationForPosition = function getLocationForPosition(pos) {
        var loc;
        if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
        return loc;
      };

      _proto.raise = function raise(pos, errorTemplate) {
        for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          params[_key - 2] = arguments[_key];
        }

        return this.raiseWithData.apply(this, [pos, undefined, errorTemplate].concat(params));
      };

      _proto.raiseWithData = function raiseWithData(pos, data, errorTemplate) {
        for (var _len2 = arguments.length, params = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          params[_key2 - 3] = arguments[_key2];
        }

        var loc = this.getLocationForPosition(pos);
        var message = errorTemplate.replace(/%(\d+)/g, function (_, i) {
          return params[i];
        }) + (" (" + loc.line + ":" + loc.column + ")");
        return this._raise(Object.assign({
          loc: loc,
          pos: pos
        }, data), message);
      };

      _proto._raise = function _raise(errorContext, message) {
        var err = new SyntaxError(message);
        Object.assign(err, errorContext);

        if (this.options.errorRecovery) {
          if (!this.isLookahead) this.state.errors.push(err);
          return err;
        } else {
          throw err;
        }
      };

      return LocationParser;
    }(CommentsParser);

    function isSimpleProperty(node) {
      return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
    }

    var estree = (function (superClass) {
      return function (_superClass) {
        _inheritsLoose(_class, _superClass);

        function _class() {
          return _superClass.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(_ref) {
          var pattern = _ref.pattern,
              flags = _ref.flags;
          var regex = null;

          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {}

          var node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern: pattern,
            flags: flags
          };
          return node;
        };

        _proto.estreeParseBigIntLiteral = function estreeParseBigIntLiteral(value) {
          var bigInt = typeof BigInt !== "undefined" ? BigInt(value) : null;
          var node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        };

        _proto.estreeParseLiteral = function estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        };

        _proto.directiveToStmt = function directiveToStmt(directive) {
          var directiveLiteral = directive.value;
          var stmt = this.startNodeAt(directive.start, directive.loc.start);
          var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.value;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
        };

        _proto.initFunction = function initFunction(node, isAsync) {
          _superClass.prototype.initFunction.call(this, node, isAsync);

          node.expression = false;
        };

        _proto.checkDeclaration = function checkDeclaration(node) {
          if (isSimpleProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            _superClass.prototype.checkDeclaration.call(this, node);
          }
        };

        _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
          var prop = method;
          var paramCount = prop.kind === "get" ? 0 : 1;
          var start = prop.start;

          if (prop.value.params.length !== paramCount) {
            if (method.kind === "get") {
              this.raise(start, Errors.BadGetterArity);
            } else {
              this.raise(start, Errors.BadSetterArity);
            }
          } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raise(start, Errors.BadSetterRestParameter);
          }
        };

        _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding) {
          var _this = this;

          if (bindingType === void 0) {
            bindingType = BIND_NONE;
          }

          switch (expr.type) {
            case "ObjectPattern":
              expr.properties.forEach(function (prop) {
                _this.checkLVal(prop.type === "Property" ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
              });
              break;

            default:
              _superClass.prototype.checkLVal.call(this, expr, bindingType, checkClashes, contextDescription, disallowLetBinding);

          }
        };

        _proto.checkDuplicatedProto = function checkDuplicatedProto(prop, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || prop.computed || prop.method || prop.shorthand) {
            return;
          }

          var key = prop.key;
          var name = key.type === "Identifier" ? key.name : String(key.value);

          if (name === "__proto__" && prop.kind === "init") {
            if (protoRef.used) {
              if (refExpressionErrors && refExpressionErrors.doubleProto === -1) {
                refExpressionErrors.doubleProto = key.start;
              } else {
                this.raise(key.start, Errors.DuplicateProto);
              }
            }

            protoRef.used = true;
          }
        };

        _proto.isValidDirective = function isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
        };

        _proto.stmtToDirective = function stmtToDirective(stmt) {
          var directive = _superClass.prototype.stmtToDirective.call(this, stmt);

          var value = stmt.expression.value;
          directive.value.value = value;
          return directive;
        };

        _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {
          var _this2 = this;

          _superClass.prototype.parseBlockBody.call(this, node, allowDirectives, topLevel, end);

          var directiveStatements = node.directives.map(function (d) {
            return _this2.directiveToStmt(d);
          });
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        };

        _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }

          classBody.body.push(method);
        };

        _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
          switch (this.state.type) {
            case types.num:
            case types.string:
              return this.estreeParseLiteral(this.state.value);

            case types.regexp:
              return this.estreeParseRegExpLiteral(this.state.value);

            case types.bigint:
              return this.estreeParseBigIntLiteral(this.state.value);

            case types._null:
              return this.estreeParseLiteral(null);

            case types._true:
              return this.estreeParseLiteral(true);

            case types._false:
              return this.estreeParseLiteral(false);

            default:
              return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
          }
        };

        _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
          var node = _superClass.prototype.parseLiteral.call(this, value, type, startPos, startLoc);

          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        };

        _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
          if (isMethod === void 0) {
            isMethod = false;
          }

          _superClass.prototype.parseFunctionBody.call(this, node, allowExpression, isMethod);

          node.expression = node.body.type !== "BlockStatement";
        };

        _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          if (inClassScope === void 0) {
            inClassScope = false;
          }

          var funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          type = type === "ClassMethod" ? "MethodDefinition" : type;
          return this.finishNode(node, type);
        };

        _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
          var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, containsEsc);

          if (node) {
            node.type = "Property";
            if (node.kind === "method") node.kind = "init";
            node.shorthand = false;
          }

          return node;
        };

        _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

          if (node) {
            node.kind = "init";
            node.type = "Property";
          }

          return node;
        };

        _proto.toAssignable = function toAssignable(node) {
          if (isSimpleProperty(node)) {
            this.toAssignable(node.value);
            return node;
          }

          return _superClass.prototype.toAssignable.call(this, node);
        };

        _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast) {
          if (prop.kind === "get" || prop.kind === "set") {
            throw this.raise(prop.key.start, Errors.PatternHasAccessor);
          } else if (prop.method) {
            throw this.raise(prop.key.start, Errors.PatternHasMethod);
          } else {
            _superClass.prototype.toAssignableObjectExpressionProp.call(this, prop, isLast);
          }
        };

        _proto.finishCallExpression = function finishCallExpression(node, optional, eventual) {
          _superClass.prototype.finishCallExpression.call(this, node, optional, eventual);

          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];
            delete node.arguments;
            delete node.callee;
          }

          return node;
        };

        _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
          if (!exprList) {
            return;
          }

          _superClass.prototype.toReferencedListDeep.call(this, exprList, isParenthesizedExpr);
        };

        _proto.parseExport = function parseExport(node) {
          _superClass.prototype.parseExport.call(this, node);

          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;

            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }

              break;
          }

          return node;
        };

        return _class;
      }(superClass);
    });

    var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    };
    var types$1 = {
      braceStatement: new TokContext("{", false),
      braceExpression: new TokContext("{", true),
      templateQuasi: new TokContext("${", false),
      parenStatement: new TokContext("(", false),
      parenExpression: new TokContext("(", true),
      template: new TokContext("`", true, true, function (p) {
        return p.readTmplToken();
      }),
      functionExpression: new TokContext("function", true),
      functionStatement: new TokContext("function", false)
    };

    types.parenR.updateContext = types.braceR.updateContext = function () {
      if (this.state.context.length === 1) {
        this.state.exprAllowed = true;
        return;
      }

      var out = this.state.context.pop();

      if (out === types$1.braceStatement && this.curContext().token === "function") {
        out = this.state.context.pop();
      }

      this.state.exprAllowed = !out.isExpr;
    };

    types.name.updateContext = function (prevType) {
      var allowed = false;

      if (prevType !== types.dot) {
        if (this.state.value === "of" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class || this.state.value === "yield" && this.prodParam.hasYield) {
          allowed = true;
        }
      }

      this.state.exprAllowed = allowed;

      if (this.state.isIterator) {
        this.state.isIterator = false;
      }
    };

    types.braceL.updateContext = function (prevType) {
      this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
      this.state.exprAllowed = true;
    };

    types.dollarBraceL.updateContext = function () {
      this.state.context.push(types$1.templateQuasi);
      this.state.exprAllowed = true;
    };

    types.parenL.updateContext = function (prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
      this.state.exprAllowed = true;
    };

    types.incDec.updateContext = function () {};

    types._function.updateContext = types._class.updateContext = function (prevType) {
      if (prevType === types.dot || prevType === types.questionDot) ; else if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
        this.state.context.push(types$1.functionExpression);
      } else {
        this.state.context.push(types$1.functionStatement);
      }

      this.state.exprAllowed = false;
    };

    types.backQuote.updateContext = function () {
      if (this.curContext() === types$1.template) {
        this.state.context.pop();
      } else {
        this.state.context.push(types$1.template);
      }

      this.state.exprAllowed = false;
    };

    types.star.updateContext = function () {
      this.state.exprAllowed = false;
    };

    var keywordRelationalOperator = /^in(stanceof)?$/;
    function isIteratorStart(current, next) {
      return current === 64 && next === 64;
    }

    var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = Object.freeze({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
      AssignReservedType: "Cannot overwrite reserved type %0",
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
      EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
      EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
      EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
      EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
      EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
      EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
      EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
      EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
      EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
      EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
      EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
      InexactVariance: "Explicit inexact syntax cannot have variance",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment",
      OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
      SpreadVariance: "Spread properties cannot have variance",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
      UnexpectedReservedType: "Unexpected reserved type %0",
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
      UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
      UnterminatedFlowComment: "Unterminated flow-comment"
    });

    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }

    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }

    function isMaybeDefaultImport(state) {
      return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
    }

    var exportSuggestions = {
      "const": "declare export var",
      "let": "declare export var",
      type: "export type",
      "interface": "export interface"
    };

    function partition(list, test) {
      var list1 = [];
      var list2 = [];

      for (var i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }

      return [list1, list2];
    }

    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (function (superClass) {
      return function (_superClass) {
        _inheritsLoose(_class, _superClass);

        function _class(options, input) {
          var _this;

          _this = _superClass.call(this, options, input) || this;
          _this.flowPragma = undefined;
          return _this;
        }

        var _proto = _class.prototype;

        _proto.shouldParseTypes = function shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        };

        _proto.shouldParseEnums = function shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        };

        _proto.finishToken = function finishToken(type, val) {
          if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
            if (this.flowPragma === undefined) {
              this.flowPragma = null;
            }
          }

          return _superClass.prototype.finishToken.call(this, type, val);
        };

        _proto.addComment = function addComment(comment) {
          if (this.flowPragma === undefined) {
            var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

            if (!matches) ; else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }

          return _superClass.prototype.addComment.call(this, comment);
        };

        _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || types.colon);
          var type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        };

        _proto.flowParsePredicate = function flowParsePredicate() {
          var node = this.startNode();
          var moduloLoc = this.state.startLoc;
          var moduloPos = this.state.start;
          this.expect(types.modulo);
          var checksLoc = this.state.startLoc;
          this.expectContextual("checks");

          if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
            this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
          }

          if (this.eat(types.parenL)) {
            node.value = this.parseExpression();
            this.expect(types.parenR);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        };

        _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(types.colon);
          var type = null;
          var predicate = null;

          if (this.match(types.modulo)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;

            if (this.match(types.modulo)) {
              predicate = this.flowParsePredicate();
            }
          }

          return [type, predicate];
        };

        _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        };

        _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
          this.next();
          var id = node.id = this.parseIdentifier();
          var typeNode = this.startNode();
          var typeContainer = this.startNode();

          if (this.isRelational("<")) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }

          this.expect(types.parenL);
          var tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          this.expect(types.parenR);

          var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

          typeNode.returnType = _this$flowParseTypeAn[0];
          node.predicate = _this$flowParseTypeAn[1];
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          return this.finishNode(node, "DeclareFunction");
        };

        _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
          if (this.match(types._class)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(types._function)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(types._var)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual("module")) {
            if (this.match(types.dot)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
              }

              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual("type")) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual("opaque")) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual("interface")) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(types._export)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        };

        _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        };

        _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
          var _this2 = this;

          this.scope.enter(SCOPE_OTHER);

          if (this.match(types.string)) {
            node.id = this.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }

          var bodyNode = node.body = this.startNode();
          var body = bodyNode.body = [];
          this.expect(types.braceL);

          while (!this.match(types.braceR)) {
            var _bodyNode = this.startNode();

            if (this.match(types._import)) {
              this.next();

              if (!this.isContextual("type") && !this.match(types._typeof)) {
                this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
              }

              this.parseImport(_bodyNode);
            } else {
              this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
              _bodyNode = this.flowParseDeclare(_bodyNode, true);
            }

            body.push(_bodyNode);
          }

          this.scope.exit();
          this.expect(types.braceR);
          this.finishNode(bodyNode, "BlockStatement");
          var kind = null;
          var hasModuleExport = false;
          body.forEach(function (bodyElement) {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                _this2.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
              }

              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                _this2.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
              }

              if (kind === "ES") {
                _this2.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
              }

              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        };

        _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(types._export);

          if (this.eat(types._default)) {
            if (this.match(types._function) || this.match(types._class)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }

            node["default"] = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
              var label = this.state.value;
              var suggestion = exportSuggestions[label];
              throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
            }

            if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
                node.declaration = this.flowParseDeclare(this.startNode());
                node["default"] = false;
                return this.finishNode(node, "DeclareExportDeclaration");
              } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
                node = this.parseExport(node);

                if (node.type === "ExportNamedDeclaration") {
                  node.type = "ExportDeclaration";
                  node["default"] = false;
                  delete node.exportKind;
                }

                node.type = "Declare" + node.type;
                return node;
              }
          }

          throw this.unexpected();
        };

        _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual("exports");
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        };

        _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
          this.next();
          this.flowParseTypeAlias(node);
          node.type = "DeclareTypeAlias";
          return node;
        };

        _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
          this.next();
          this.flowParseOpaqueType(node, true);
          node.type = "DeclareOpaqueType";
          return node;
        };

        _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        };

        _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
          if (isClass === void 0) {
            isClass = false;
          }

          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node["extends"] = [];
          node["implements"] = [];
          node.mixins = [];

          if (this.eat(types._extends)) {
            do {
              node["extends"].push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(types.comma));
          }

          if (this.isContextual("mixins")) {
            this.next();

            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(types.comma));
          }

          if (this.isContextual("implements")) {
            this.next();

            do {
              node["implements"].push(this.flowParseInterfaceExtends());
            } while (this.eat(types.comma));
          }

          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        };

        _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
          var node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }

          return this.finishNode(node, "InterfaceExtends");
        };

        _proto.flowParseInterface = function flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        };

        _proto.checkNotUnderscore = function checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
          }
        };

        _proto.checkReservedType = function checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word)) return;
          this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
        };

        _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.start, declaration);
          return this.parseIdentifier(liberal);
        };

        _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.right = this.flowParseTypeInitialiser(types.eq);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        };

        _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
          this.expectContextual("type");
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.supertype = null;

          if (this.match(types.colon)) {
            node.supertype = this.flowParseTypeInitialiser(types.colon);
          }

          node.impltype = null;

          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(types.eq);
          }

          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        };

        _proto.flowParseTypeParameter = function flowParseTypeParameter(requireDefault) {
          if (requireDefault === void 0) {
            requireDefault = false;
          }

          var nodeStart = this.state.start;
          var node = this.startNode();
          var variance = this.flowParseVariance();
          var ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;

          if (this.match(types.eq)) {
            this.eat(types.eq);
            node["default"] = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
            }
          }

          return this.finishNode(node, "TypeParameter");
        };

        _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {
          var oldInType = this.state.inType;
          var node = this.startNode();
          node.params = [];
          this.state.inType = true;

          if (this.isRelational("<") || this.match(types.jsxTagStart)) {
            this.next();
          } else {
            this.unexpected();
          }

          var defaultRequired = false;

          do {
            var typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);

            if (typeParameter["default"]) {
              defaultRequired = true;
            }

            if (!this.isRelational(">")) {
              this.expect(types.comma);
            }
          } while (!this.isRelational(">"));

          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        };

        _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expectRelational("<");
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;

          while (!this.isRelational(">")) {
            node.params.push(this.flowParseType());

            if (!this.isRelational(">")) {
              this.expect(types.comma);
            }
          }

          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        };

        _proto.flowParseTypeParameterInstantiationCallOrNew = function flowParseTypeParameterInstantiationCallOrNew() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expectRelational("<");

          while (!this.isRelational(">")) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());

            if (!this.isRelational(">")) {
              this.expect(types.comma);
            }
          }

          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        };

        _proto.flowParseInterfaceType = function flowParseInterfaceType() {
          var node = this.startNode();
          this.expectContextual("interface");
          node["extends"] = [];

          if (this.eat(types._extends)) {
            do {
              node["extends"].push(this.flowParseInterfaceExtends());
            } while (this.eat(types.comma));
          }

          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        };

        _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
          return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
        };

        _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
          node["static"] = isStatic;

          if (this.lookahead().type === types.colon) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }

          this.expect(types.bracketR);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        };

        _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
          node["static"] = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(types.bracketR);
          this.expect(types.bracketR);

          if (this.isRelational("<") || this.match(types.parenL)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;

            if (this.eat(types.question)) {
              node.optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
          }

          return this.finishNode(node, "ObjectTypeInternalSlot");
        };

        _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          this.expect(types.parenL);

          while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
            node.params.push(this.flowParseFunctionTypeParam());

            if (!this.match(types.parenR)) {
              this.expect(types.comma);
            }
          }

          if (this.eat(types.ellipsis)) {
            node.rest = this.flowParseFunctionTypeParam();
          }

          this.expect(types.parenR);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        };

        _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
          var valueNode = this.startNode();
          node["static"] = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        };

        _proto.flowParseObjectType = function flowParseObjectType(_ref) {
          var allowStatic = _ref.allowStatic,
              allowExact = _ref.allowExact,
              allowSpread = _ref.allowSpread,
              allowProto = _ref.allowProto,
              allowInexact = _ref.allowInexact;
          var oldInType = this.state.inType;
          this.state.inType = true;
          var nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          var endDelim;
          var exact;
          var inexact = false;

          if (allowExact && this.match(types.braceBarL)) {
            this.expect(types.braceBarL);
            endDelim = types.braceBarR;
            exact = true;
          } else {
            this.expect(types.braceL);
            endDelim = types.braceR;
            exact = false;
          }

          nodeStart.exact = exact;

          while (!this.match(endDelim)) {
            var isStatic = false;
            var protoStart = null;
            var inexactStart = null;
            var node = this.startNode();

            if (allowProto && this.isContextual("proto")) {
              var lookahead = this.lookahead();

              if (lookahead.type !== types.colon && lookahead.type !== types.question) {
                this.next();
                protoStart = this.state.start;
                allowStatic = false;
              }
            }

            if (allowStatic && this.isContextual("static")) {
              var _lookahead = this.lookahead();

              if (_lookahead.type !== types.colon && _lookahead.type !== types.question) {
                this.next();
                isStatic = true;
              }
            }

            var variance = this.flowParseVariance();

            if (this.eat(types.bracketL)) {
              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (this.eat(types.bracketL)) {
                if (variance) {
                  this.unexpected(variance.start);
                }

                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(types.parenL) || this.isRelational("<")) {
              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              var kind = "init";

              if (this.isContextual("get") || this.isContextual("set")) {
                var _lookahead2 = this.lookahead();

                if (_lookahead2.type === types.name || _lookahead2.type === types.string || _lookahead2.type === types.num) {
                  kind = this.state.value;
                  this.next();
                }
              }

              var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

              if (propOrInexact === null) {
                inexact = true;
                inexactStart = this.state.lastTokStart;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }

            this.flowObjectTypeSemicolon();

            if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
              this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
            }
          }

          this.expect(endDelim);

          if (allowSpread) {
            nodeStart.inexact = inexact;
          }

          var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        };

        _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
          if (this.eat(types.ellipsis)) {
            var isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
              } else if (!allowInexact) {
                this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
              }

              if (variance) {
                this.raise(variance.start, FlowErrors.InexactVariance);
              }

              return null;
            }

            if (!allowSpread) {
              this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
            }

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.raise(variance.start, FlowErrors.SpreadVariance);
            }

            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node["static"] = isStatic;
            node.proto = protoStart != null;
            node.kind = kind;
            var optional = false;

            if (this.isRelational("<") || this.match(types.parenL)) {
              node.method = true;

              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (variance) {
                this.unexpected(variance.start);
              }

              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
            } else {
              if (kind !== "init") this.unexpected();
              node.method = false;

              if (this.eat(types.question)) {
                optional = true;
              }

              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }

            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        };

        _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
          var paramCount = property.kind === "get" ? 0 : 1;
          var start = property.start;
          var length = property.value.params.length + (property.value.rest ? 1 : 0);

          if (length !== paramCount) {
            if (property.kind === "get") {
              this.raise(start, Errors.BadGetterArity);
            } else {
              this.raise(start, Errors.BadSetterArity);
            }
          }

          if (property.kind === "set" && property.value.rest) {
            this.raise(start, Errors.BadSetterRestParameter);
          }
        };

        _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
          if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
            this.unexpected();
          }
        };

        _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          var node = id || this.flowParseRestrictedIdentifier(true);

          while (this.eat(types.dot)) {
            var node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }

          return node;
        };

        _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {
          var node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }

          return this.finishNode(node, "GenericTypeAnnotation");
        };

        _proto.flowParseTypeofType = function flowParseTypeofType() {
          var node = this.startNode();
          this.expect(types._typeof);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        };

        _proto.flowParseTupleType = function flowParseTupleType() {
          var node = this.startNode();
          node.types = [];
          this.expect(types.bracketL);

          while (this.state.pos < this.length && !this.match(types.bracketR)) {
            node.types.push(this.flowParseType());
            if (this.match(types.bracketR)) break;
            this.expect(types.comma);
          }

          this.expect(types.bracketR);
          return this.finishNode(node, "TupleTypeAnnotation");
        };

        _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {
          var name = null;
          var optional = false;
          var typeAnnotation = null;
          var node = this.startNode();
          var lh = this.lookahead();

          if (lh.type === types.colon || lh.type === types.question) {
            name = this.parseIdentifier();

            if (this.eat(types.question)) {
              optional = true;
            }

            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }

          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        };

        _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
          var node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        };

        _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
          if (params === void 0) {
            params = [];
          }

          var rest = null;

          while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
            params.push(this.flowParseFunctionTypeParam());

            if (!this.match(types.parenR)) {
              this.expect(types.comma);
            }
          }

          if (this.eat(types.ellipsis)) {
            rest = this.flowParseFunctionTypeParam();
          }

          return {
            params: params,
            rest: rest
          };
        };

        _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");

            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");

            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");

            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");

            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");

            case "string":
              return this.finishNode(node, "StringTypeAnnotation");

            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");

            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        };

        _proto.flowParsePrimaryType = function flowParsePrimaryType() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.startNode();
          var tmp;
          var type;
          var isGroupedType = false;
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;

          switch (this.state.type) {
            case types.name:
              if (this.isContextual("interface")) {
                return this.flowParseInterfaceType();
              }

              return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

            case types.braceL:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });

            case types.braceBarL:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });

            case types.bracketL:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;

            case types.relational:
              if (this.state.value === "<") {
                node.typeParameters = this.flowParseTypeParameterDeclaration();
                this.expect(types.parenL);
                tmp = this.flowParseFunctionTypeParams();
                node.params = tmp.params;
                node.rest = tmp.rest;
                this.expect(types.parenR);
                this.expect(types.arrow);
                node.returnType = this.flowParseType();
                return this.finishNode(node, "FunctionTypeAnnotation");
              }

              break;

            case types.parenL:
              this.next();

              if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
                if (this.match(types.name)) {
                  var token = this.lookahead().type;
                  isGroupedType = token !== types.question && token !== types.colon;
                } else {
                  isGroupedType = true;
                }
              }

              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;

                if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
                  this.expect(types.parenR);
                  return type;
                } else {
                  this.eat(types.comma);
                }
              }

              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }

              node.params = tmp.params;
              node.rest = tmp.rest;
              this.expect(types.parenR);
              this.expect(types.arrow);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");

            case types.string:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

            case types._true:
            case types._false:
              node.value = this.match(types._true);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");

            case types.plusMin:
              if (this.state.value === "-") {
                this.next();

                if (this.match(types.num)) {
                  return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
                }

                if (this.match(types.bigint)) {
                  return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
                }

                throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
              }

              throw this.unexpected();

            case types.num:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

            case types.bigint:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

            case types._void:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");

            case types._null:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");

            case types._this:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");

            case types.star:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");

            default:
              if (this.state.type.keyword === "typeof") {
                return this.flowParseTypeofType();
              } else if (this.state.type.keyword) {
                var label = this.state.type.label;
                this.next();
                return _superClass.prototype.createIdentifier.call(this, node, label);
              }

          }

          throw this.unexpected();
        };

        _proto.flowParsePostfixType = function flowParsePostfixType() {
          var startPos = this.state.start,
              startLoc = this.state.startLoc;
          var type = this.flowParsePrimaryType();

          while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
            var node = this.startNodeAt(startPos, startLoc);
            node.elementType = type;
            this.expect(types.bracketL);
            this.expect(types.bracketR);
            type = this.finishNode(node, "ArrayTypeAnnotation");
          }

          return type;
        };

        _proto.flowParsePrefixType = function flowParsePrefixType() {
          var node = this.startNode();

          if (this.eat(types.question)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        };

        _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
          var param = this.flowParsePrefixType();

          if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
            var node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }

          return param;
        };

        _proto.flowParseIntersectionType = function flowParseIntersectionType() {
          var node = this.startNode();
          this.eat(types.bitwiseAND);
          var type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];

          while (this.eat(types.bitwiseAND)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        };

        _proto.flowParseUnionType = function flowParseUnionType() {
          var node = this.startNode();
          this.eat(types.bitwiseOR);
          var type = this.flowParseIntersectionType();
          node.types = [type];

          while (this.eat(types.bitwiseOR)) {
            node.types.push(this.flowParseIntersectionType());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        };

        _proto.flowParseType = function flowParseType() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          var type = this.flowParseUnionType();
          this.state.inType = oldInType;
          this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
          return type;
        };

        _proto.flowParseTypeOrImplicitInstantiation = function flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === types.name && this.state.value === "_") {
            var startPos = this.state.start;
            var startLoc = this.state.startLoc;
            var node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        };

        _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
          var node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        };

        _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

          if (this.match(types.colon)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }

          return ident;
        };

        _proto.typeCastToParameter = function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
          return node.expression;
        };

        _proto.flowParseVariance = function flowParseVariance() {
          var variance = null;

          if (this.match(types.plusMin)) {
            variance = this.startNode();

            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }

            this.next();
            this.finishNode(variance, "Variance");
          }

          return variance;
        };

        _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody, isMethod) {
          var _this3 = this;

          if (isMethod === void 0) {
            isMethod = false;
          }

          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, function () {
              return _superClass.prototype.parseFunctionBody.call(_this3, node, true, isMethod);
            });
          }

          return _superClass.prototype.parseFunctionBody.call(this, node, false, isMethod);
        };

        _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
          if (isMethod === void 0) {
            isMethod = false;
          }

          if (this.match(types.colon)) {
            var typeNode = this.startNode();

            var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

            typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
            node.predicate = _this$flowParseTypeAn2[1];
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }

          _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
        };

        _proto.parseStatement = function parseStatement(context, topLevel) {
          if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
            var node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          } else if (this.shouldParseEnums() && this.isContextual("enum")) {
            var _node = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_node);
          } else {
            var stmt = _superClass.prototype.parseStatement.call(this, context, topLevel);

            if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
              this.flowPragma = null;
            }

            return stmt;
          }
        };

        _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
                return this.flowParseDeclare(node);
              }
            } else if (this.match(types.name)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }

          return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
        };

        _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
          return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _superClass.prototype.shouldParseExportDeclaration.call(this);
        };

        _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
          if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
            return false;
          }

          return _superClass.prototype.isExportDefaultSpecifier.call(this);
        };

        _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual("enum")) {
            var node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }

          return _superClass.prototype.parseExportDefaultExpression.call(this);
        };

        _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
          var _this4 = this;

          if (!this.match(types.question)) return expr;

          if (refNeedsArrowPos) {
            var result = this.tryParse(function () {
              return _superClass.prototype.parseConditional.call(_this4, expr, noIn, startPos, startLoc);
            });

            if (!result.node) {
              refNeedsArrowPos.start = result.error.pos || this.state.start;
              return expr;
            }

            if (result.error) this.state = result.failState;
            return result.node;
          }

          this.expect(types.question);
          var state = this.state.clone();
          var originalNoArrowAt = this.state.noArrowAt;
          var node = this.startNodeAt(startPos, startLoc);

          var _this$tryParseConditi = this.tryParseConditionalConsequent(),
              consequent = _this$tryParseConditi.consequent,
              failed = _this$tryParseConditi.failed;

          var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
              valid = _this$getArrowLikeExp[0],
              invalid = _this$getArrowLikeExp[1];

          if (failed || invalid.length > 0) {
            var noArrowAt = [].concat(originalNoArrowAt);

            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;

              for (var i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }

              var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi2.consequent;
              failed = _this$tryParseConditi2.failed;

              var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);

              valid = _this$getArrowLikeExp2[0];
              invalid = _this$getArrowLikeExp2[1];
            }

            if (failed && valid.length > 1) {
              this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
            }

            if (failed && valid.length === 1) {
              this.state = state;
              this.state.noArrowAt = noArrowAt.concat(valid[0].start);

              var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi3.consequent;
              failed = _this$tryParseConditi3.failed;
            }
          }

          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(types.colon);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
            return _this4.parseMaybeAssign(noIn, undefined, undefined, undefined);
          });
          return this.finishNode(node, "ConditionalExpression");
        };

        _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          var consequent = this.parseMaybeAssign();
          var failed = !this.match(types.colon);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent: consequent,
            failed: failed
          };
        };

        _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
          var _this5 = this;

          var stack = [node];
          var arrows = [];

          while (stack.length !== 0) {
            var _node2 = stack.pop();

            if (_node2.type === "ArrowFunctionExpression") {
              if (_node2.typeParameters || !_node2.returnType) {
                this.finishArrowValidation(_node2);
              } else {
                arrows.push(_node2);
              }

              stack.push(_node2.body);
            } else if (_node2.type === "ConditionalExpression") {
              stack.push(_node2.consequent);
              stack.push(_node2.alternate);
            }
          }

          if (disallowInvalid) {
            arrows.forEach(function (node) {
              return _this5.finishArrowValidation(node);
            });
            return [arrows, []];
          }

          return partition(arrows, function (node) {
            return node.params.every(function (param) {
              return _this5.isAssignable(param, true);
            });
          });
        };

        _proto.finishArrowValidation = function finishArrowValidation(node) {
          var _node$extra;

          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

          _superClass.prototype.checkParams.call(this, node, false, true);

          this.scope.exit();
        };

        _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
          var result;

          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse();
          }

          return result;
        };

        _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
          node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

          if (this.eat(types.question)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(types.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }

          return node;
        };

        _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }

          _superClass.prototype.assertModuleNodeAllowed.call(this, node);
        };

        _proto.parseExport = function parseExport(node) {
          var decl = _superClass.prototype.parseExport.call(this, node);

          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }

          return decl;
        };

        _proto.parseExportDeclaration = function parseExportDeclaration(node) {
          if (this.isContextual("type")) {
            node.exportKind = "type";
            var declarationNode = this.startNode();
            this.next();

            if (this.match(types.braceL)) {
              node.specifiers = this.parseExportSpecifiers();
              this.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual("opaque")) {
            node.exportKind = "type";

            var _declarationNode = this.startNode();

            this.next();
            return this.flowParseOpaqueType(_declarationNode, false);
          } else if (this.isContextual("interface")) {
            node.exportKind = "type";

            var _declarationNode2 = this.startNode();

            this.next();
            return this.flowParseInterface(_declarationNode2);
          } else if (this.shouldParseEnums() && this.isContextual("enum")) {
            node.exportKind = "value";

            var _declarationNode3 = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_declarationNode3);
          } else {
            return _superClass.prototype.parseExportDeclaration.call(this, node);
          }
        };

        _proto.eatExportStar = function eatExportStar(node) {
          if (_superClass.prototype.eatExportStar.apply(this, arguments)) return true;

          if (this.isContextual("type") && this.lookahead().type === types.star) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }

          return false;
        };

        _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
          var pos = this.state.start;

          var hasNamespace = _superClass.prototype.maybeParseExportNamespaceSpecifier.call(this, node);

          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(pos);
          }

          return hasNamespace;
        };

        _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
          _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        };

        _proto.parseClassMember = function parseClassMember(classBody, member, state, constructorAllowsSuper) {
          var pos = this.state.start;

          if (this.isContextual("declare")) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }

            member.declare = true;
          }

          _superClass.prototype.parseClassMember.call(this, classBody, member, state, constructorAllowsSuper);

          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty") {
              this.raise(pos, FlowErrors.DeclareClassElement);
            } else if (member.value) {
              this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
            }
          }
        };

        _proto.getTokenFromCode = function getTokenFromCode(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 123 && next === 124) {
            return this.finishOp(types.braceBarL, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types.relational, 1);
          } else if (isIteratorStart(code, next)) {
            this.state.isIterator = true;
            return _superClass.prototype.readWord.call(this);
          } else {
            return _superClass.prototype.getTokenFromCode.call(this, code);
          }
        };

        _proto.isAssignable = function isAssignable(node, isBinding) {
          var _this6 = this;

          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
              return true;

            case "ObjectExpression":
              {
                var last = node.properties.length - 1;
                return node.properties.every(function (prop, i) {
                  return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && _this6.isAssignable(prop);
                });
              }

            case "ObjectProperty":
              return this.isAssignable(node.value);

            case "SpreadElement":
              return this.isAssignable(node.argument);

            case "ArrayExpression":
              return node.elements.every(function (element) {
                return _this6.isAssignable(element);
              });

            case "AssignmentExpression":
              return node.operator === "=";

            case "ParenthesizedExpression":
            case "TypeCastExpression":
              return this.isAssignable(node.expression);

            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;

            default:
              return false;
          }
        };

        _proto.toAssignable = function toAssignable(node) {
          if (node.type === "TypeCastExpression") {
            return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node));
          } else {
            return _superClass.prototype.toAssignable.call(this, node);
          }
        };

        _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if (expr && expr.type === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }

          return _superClass.prototype.toAssignableList.call(this, exprList, trailingCommaPos);
        };

        _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if (expr && expr.type === "TypeCastExpression" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
            }
          }

          return exprList;
        };

        _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription) {
          if (bindingType === void 0) {
            bindingType = BIND_NONE;
          }

          if (expr.type !== "TypeCastExpression") {
            return _superClass.prototype.checkLVal.call(this, expr, bindingType, checkClashes, contextDescription);
          }
        };

        _proto.parseClassProperty = function parseClassProperty(node) {
          if (this.match(types.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _superClass.prototype.parseClassProperty.call(this, node);
        };

        _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
          if (this.match(types.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _superClass.prototype.parseClassPrivateProperty.call(this, node);
        };

        _proto.isClassMethod = function isClassMethod() {
          return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
        };

        _proto.isClassProperty = function isClassProperty() {
          return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
        };

        _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
          return !this.match(types.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);
        };

        _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.start);
          }

          delete method.variance;

          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        };

        _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.start);
          }

          delete method.variance;

          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
        };

        _proto.parseClassSuper = function parseClassSuper(node) {
          _superClass.prototype.parseClassSuper.call(this, node);

          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }

          if (this.isContextual("implements")) {
            this.next();
            var implemented = node["implements"] = [];

            do {
              var _node3 = this.startNode();

              _node3.id = this.flowParseRestrictedIdentifier(true);

              if (this.isRelational("<")) {
                _node3.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                _node3.typeParameters = null;
              }

              implemented.push(this.finishNode(_node3, "ClassImplements"));
            } while (this.eat(types.comma));
          }
        };

        _proto.parsePropertyName = function parsePropertyName(node, isPrivateNameAllowed) {
          var variance = this.flowParseVariance();

          var key = _superClass.prototype.parsePropertyName.call(this, node, isPrivateNameAllowed);

          node.variance = variance;
          return key;
        };

        _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
          if (prop.variance) {
            this.unexpected(prop.variance.start);
          }

          delete prop.variance;
          var typeParameters;

          if (this.isRelational("<")) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(types.parenL)) this.unexpected();
          }

          _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);

          if (typeParameters) {
            (prop.value || prop).typeParameters = typeParameters;
          }
        };

        _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
          if (this.eat(types.question)) {
            if (param.type !== "Identifier") {
              this.raise(param.start, FlowErrors.OptionalBindingPattern);
            }

            param.optional = true;
          }

          if (this.match(types.colon)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          }

          this.resetEndLocation(param);
          return param;
        };

        _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
          var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
          }

          return node;
        };

        _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return _superClass.prototype.shouldParseDefaultImport.call(this, node);
          }

          return isMaybeDefaultImport(this.state);
        };

        _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
          node.specifiers.push(this.finishNode(specifier, type));
        };

        _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          var kind = null;

          if (this.match(types._typeof)) {
            kind = "typeof";
          } else if (this.isContextual("type")) {
            kind = "type";
          }

          if (kind) {
            var lh = this.lookahead();

            if (kind === "type" && lh.type === types.star) {
              this.unexpected(lh.start);
            }

            if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
              this.next();
              node.importKind = kind;
            }
          }

          return _superClass.prototype.maybeParseDefaultImportSpecifier.call(this, node);
        };

        _proto.parseImportSpecifier = function parseImportSpecifier(node) {
          var specifier = this.startNode();
          var firstIdentLoc = this.state.start;
          var firstIdent = this.parseIdentifier(true);
          var specifierTypeKind = null;

          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }

          var isBinding = false;

          if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
            var as_ident = this.parseIdentifier(true);

            if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = as_ident.__clone();
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;

            if (this.eatContextual("as")) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = specifier.imported.__clone();
            }
          } else {
            isBinding = true;
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = specifier.imported.__clone();
          }

          var nodeIsTypeImport = hasTypeImportKind(node);
          var specifierIsTypeImport = hasTypeImportKind(specifier);

          if (nodeIsTypeImport && specifierIsTypeImport) {
            this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
          }

          if (nodeIsTypeImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.start, true);
          }

          if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.start, true, true);
          }

          this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
          node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
        };

        _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
          var kind = node.kind;

          if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
        };

        _proto.parseVarId = function parseVarId(decl, kind) {
          _superClass.prototype.parseVarId.call(this, decl, kind);

          if (this.match(types.colon)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        };

        _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(types.colon)) {
            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }

          return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
        };

        _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
          return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
        };

        _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
          var _this7 = this;

          var state = null;
          var jsx;

          if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              return _superClass.prototype.parseMaybeAssign.call(_this7, noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;

            if (context[context.length - 1] === types$1.j_oTag) {
              context.length -= 2;
            } else if (context[context.length - 1] === types$1.j_expr) {
              context.length -= 1;
            }
          }

          if (jsx && jsx.error || this.isRelational("<")) {
            state = state || this.state.clone();
            var typeParameters;
            var arrow = this.tryParse(function () {
              typeParameters = _this7.flowParseTypeParameterDeclaration();

              var arrowExpression = _this7.forwardNoArrowParamsConversionAt(typeParameters, function () {
                return _superClass.prototype.parseMaybeAssign.call(_this7, noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
              });

              arrowExpression.typeParameters = typeParameters;

              _this7.resetStartLocationFromNode(arrowExpression, typeParameters);

              return arrowExpression;
            }, state);
            var arrowExpression = arrow.node && arrow.node.type === "ArrowFunctionExpression" ? arrow.node : null;
            if (!arrow.error && arrowExpression) return arrowExpression;

            if (jsx && jsx.node) {
              this.state = jsx.failState;
              return jsx.node;
            }

            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }

            if (jsx && jsx.thrown) throw jsx.error;
            if (arrow.thrown) throw arrow.error;
            throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
          }

          return _superClass.prototype.parseMaybeAssign.call(this, noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
        };

        _proto.parseArrow = function parseArrow(node) {
          var _this8 = this;

          if (this.match(types.colon)) {
            var result = this.tryParse(function () {
              var oldNoAnonFunctionType = _this8.state.noAnonFunctionType;
              _this8.state.noAnonFunctionType = true;

              var typeNode = _this8.startNode();

              var _this8$flowParseTypeA = _this8.flowParseTypeAndPredicateInitialiser();

              typeNode.typeAnnotation = _this8$flowParseTypeA[0];
              node.predicate = _this8$flowParseTypeA[1];
              _this8.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (_this8.canInsertSemicolon()) _this8.unexpected();
              if (!_this8.match(types.arrow)) _this8.unexpected();
              return typeNode;
            });
            if (result.thrown) return null;
            if (result.error) this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }

          return _superClass.prototype.parseArrow.call(this, node);
        };

        _proto.shouldParseArrow = function shouldParseArrow() {
          return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
        };

        _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
          }
        };

        _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }

          return _superClass.prototype.checkParams.apply(this, arguments);
        };

        _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
          return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        };

        _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
          var _this9 = this;

          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = this.parseCallExpressionArguments(types.parenR, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
            var state = this.state.clone();
            var arrow = this.tryParse(function (abort) {
              return _this9.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
            }, state);
            if (!arrow.error && !arrow.aborted) return arrow.node;
            var result = this.tryParse(function () {
              return _superClass.prototype.parseSubscripts.call(_this9, base, startPos, startLoc, noCalls);
            }, state);
            if (result.node && !result.error) return result.node;

            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }

            if (result.node) {
              this.state = result.failState;
              return result.node;
            }

            throw arrow.error || result.error;
          }

          return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
        };

        _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          var _this10 = this;

          if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
            subscriptState.optionalChainMember = true;

            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }

            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(types.parenL);
            node.arguments = this.parseCallExpressionArguments(types.parenR, false);
            node.optional = true;
            return this.finishCallExpression(node, true, false);
          } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
            var _node4 = this.startNodeAt(startPos, startLoc);

            _node4.callee = base;
            var result = this.tryParse(function () {
              _node4.typeArguments = _this10.flowParseTypeParameterInstantiationCallOrNew();

              _this10.expect(types.parenL);

              _node4.arguments = _this10.parseCallExpressionArguments(types.parenR, false);
              if (subscriptState.optionalChainMember) _node4.optional = false;
              return _this10.finishCallExpression(_node4, subscriptState.optionalChainMember, subscriptState.eventualMember);
            });

            if (result.node) {
              if (result.error) this.state = result.failState;
              return result.node;
            }
          }

          return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, subscriptState);
        };

        _proto.parseNewArguments = function parseNewArguments(node) {
          var _this11 = this;

          var targs = null;

          if (this.shouldParseTypes() && this.isRelational("<")) {
            targs = this.tryParse(function () {
              return _this11.flowParseTypeParameterInstantiationCallOrNew();
            }).node;
          }

          node.typeArguments = targs;

          _superClass.prototype.parseNewArguments.call(this, node);
        };

        _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node)) return;
          return this.parseArrowExpression(node, undefined, true);
        };

        _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }

          _superClass.prototype.readToken_mult_modulo.call(this, code);
        };

        _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 124 && next === 125) {
            this.finishOp(types.braceBarR, 2);
            return;
          }

          _superClass.prototype.readToken_pipe_amp.call(this, code);
        };

        _proto.parseTopLevel = function parseTopLevel(file, program) {
          var fileNode = _superClass.prototype.parseTopLevel.call(this, file, program);

          if (this.state.hasFlowComment) {
            this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
          }

          return fileNode;
        };

        _proto.skipBlockComment = function skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              this.unexpected(null, FlowErrors.NestedFlowComment);
            }

            this.hasFlowCommentCompletion();
            this.state.pos += this.skipFlowComment();
            this.state.hasFlowComment = true;
            return;
          }

          if (this.state.hasFlowComment) {
            var end = this.input.indexOf("*-/", this.state.pos += 2);

            if (end === -1) {
              throw this.raise(this.state.pos - 2, Errors.UnterminatedComment);
            }

            this.state.pos = end + 3;
            return;
          }

          _superClass.prototype.skipBlockComment.call(this);
        };

        _proto.skipFlowComment = function skipFlowComment() {
          var pos = this.state.pos;
          var shiftToFirstNonWhiteSpace = 2;

          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }

          var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }

          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }

          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }

          return false;
        };

        _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
          var end = this.input.indexOf("*/", this.state.pos);

          if (end === -1) {
            throw this.raise(this.state.pos, Errors.UnterminatedComment);
          }
        };

        _proto.flowEnumErrorBooleanMemberNotInitialized = function flowEnumErrorBooleanMemberNotInitialized(pos, _ref2) {
          var enumName = _ref2.enumName,
              memberName = _ref2.memberName;
          this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
        };

        _proto.flowEnumErrorInvalidMemberName = function flowEnumErrorInvalidMemberName(pos, _ref3) {
          var enumName = _ref3.enumName,
              memberName = _ref3.memberName;
          var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
          this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
        };

        _proto.flowEnumErrorDuplicateMemberName = function flowEnumErrorDuplicateMemberName(pos, _ref4) {
          var enumName = _ref4.enumName,
              memberName = _ref4.memberName;
          this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
        };

        _proto.flowEnumErrorInconsistentMemberValues = function flowEnumErrorInconsistentMemberValues(pos, _ref5) {
          var enumName = _ref5.enumName;
          this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
        };

        _proto.flowEnumErrorInvalidExplicitType = function flowEnumErrorInvalidExplicitType(pos, _ref6) {
          var enumName = _ref6.enumName,
              suppliedType = _ref6.suppliedType;
          return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
        };

        _proto.flowEnumErrorInvalidMemberInitializer = function flowEnumErrorInvalidMemberInitializer(pos, _ref7) {
          var enumName = _ref7.enumName,
              explicitType = _ref7.explicitType,
              memberName = _ref7.memberName;
          var message = null;

          switch (explicitType) {
            case "boolean":
            case "number":
            case "string":
              message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
              break;

            case "symbol":
              message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
              break;

            default:
              message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
          }

          return this.raise(pos, message, enumName, memberName, explicitType);
        };

        _proto.flowEnumErrorNumberMemberNotInitialized = function flowEnumErrorNumberMemberNotInitialized(pos, _ref8) {
          var enumName = _ref8.enumName,
              memberName = _ref8.memberName;
          this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
        };

        _proto.flowEnumErrorStringMemberInconsistentlyInitailized = function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref9) {
          var enumName = _ref9.enumName;
          this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
        };

        _proto.flowEnumMemberInit = function flowEnumMemberInit() {
          var _this12 = this;

          var startPos = this.state.start;

          var endOfInit = function endOfInit() {
            return _this12.match(types.comma) || _this12.match(types.braceR);
          };

          switch (this.state.type) {
            case types.num:
              {
                var literal = this.parseLiteral(this.state.value, "NumericLiteral");

                if (endOfInit()) {
                  return {
                    type: "number",
                    pos: literal.start,
                    value: literal
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            case types.string:
              {
                var _literal = this.parseLiteral(this.state.value, "StringLiteral");

                if (endOfInit()) {
                  return {
                    type: "string",
                    pos: _literal.start,
                    value: _literal
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            case types._true:
            case types._false:
              {
                var _literal2 = this.parseBooleanLiteral();

                if (endOfInit()) {
                  return {
                    type: "boolean",
                    pos: _literal2.start,
                    value: _literal2
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            default:
              return {
                type: "invalid",
                pos: startPos
              };
          }
        };

        _proto.flowEnumMemberRaw = function flowEnumMemberRaw() {
          var pos = this.state.start;
          var id = this.parseIdentifier(true);
          var init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
            type: "none",
            pos: pos
          };
          return {
            id: id,
            init: init
          };
        };

        _proto.flowEnumCheckExplicitTypeMismatch = function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
          var explicitType = context.explicitType;

          if (explicitType === null) {
            return;
          }

          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(pos, context);
          }
        };

        _proto.flowEnumMembers = function flowEnumMembers(_ref10) {
          var enumName = _ref10.enumName,
              explicitType = _ref10.explicitType;
          var seenNames = new Set();
          var members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };

          while (!this.match(types.braceR)) {
            var memberNode = this.startNode();

            var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
                id = _this$flowEnumMemberR.id,
                init = _this$flowEnumMemberR.init;

            var memberName = id.name;

            if (memberName === "") {
              continue;
            }

            if (/^[a-z]/.test(memberName)) {
              this.flowEnumErrorInvalidMemberName(id.start, {
                enumName: enumName,
                memberName: memberName
              });
            }

            if (seenNames.has(memberName)) {
              this.flowEnumErrorDuplicateMemberName(id.start, {
                enumName: enumName,
                memberName: memberName
              });
            }

            seenNames.add(memberName);
            var context = {
              enumName: enumName,
              explicitType: explicitType,
              memberName: memberName
            };
            memberNode.id = id;

            switch (init.type) {
              case "boolean":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                  memberNode.init = init.value;
                  members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                }

              case "number":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                  memberNode.init = init.value;
                  members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                }

              case "string":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                  memberNode.init = init.value;
                  members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                }

              case "invalid":
                {
                  throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
                }

              case "none":
                {
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                      break;

                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                      break;

                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
                }
            }

            if (!this.match(types.braceR)) {
              this.expect(types.comma);
            }
          }

          return members;
        };

        _proto.flowEnumStringMembers = function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref11) {
          var enumName = _ref11.enumName;

          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (var _i2 = 0; _i2 < initializedMembers.length; _i2++) {
              var member = initializedMembers[_i2];
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
                enumName: enumName
              });
            }

            return defaultedMembers;
          } else {
            for (var _i4 = 0; _i4 < defaultedMembers.length; _i4++) {
              var _member = defaultedMembers[_i4];
              this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
                enumName: enumName
              });
            }

            return initializedMembers;
          }
        };

        _proto.flowEnumParseExplicitType = function flowEnumParseExplicitType(_ref12) {
          var enumName = _ref12.enumName;

          if (this.eatContextual("of")) {
            if (!this.match(types.name)) {
              throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: enumName,
                suppliedType: null
              });
            }

            var value = this.state.value;
            this.next();

            if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
              this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: enumName,
                suppliedType: value
              });
            }

            return value;
          }

          return null;
        };

        _proto.flowEnumBody = function flowEnumBody(node, _ref13) {
          var _this13 = this;

          var enumName = _ref13.enumName,
              nameLoc = _ref13.nameLoc;
          var explicitType = this.flowEnumParseExplicitType({
            enumName: enumName
          });
          this.expect(types.braceL);
          var members = this.flowEnumMembers({
            enumName: enumName,
            explicitType: explicitType
          });

          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(types.braceR);
              return this.finishNode(node, "EnumBooleanBody");

            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(types.braceR);
              return this.finishNode(node, "EnumNumberBody");

            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName: enumName
              });
              this.expect(types.braceR);
              return this.finishNode(node, "EnumStringBody");

            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(types.braceR);
              return this.finishNode(node, "EnumSymbolBody");

            default:
              {
                var empty = function empty() {
                  node.members = [];

                  _this13.expect(types.braceR);

                  return _this13.finishNode(node, "EnumStringBody");
                };

                node.explicitType = false;
                var boolsLen = members.booleanMembers.length;
                var numsLen = members.numberMembers.length;
                var strsLen = members.stringMembers.length;
                var defaultedLen = members.defaultedMembers.length;

                if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                  return empty();
                } else if (!boolsLen && !numsLen) {
                  node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                    enumName: enumName
                  });
                  this.expect(types.braceR);
                  return this.finishNode(node, "EnumStringBody");
                } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                  for (var _i6 = 0, _members$defaultedMem2 = members.defaultedMembers; _i6 < _members$defaultedMem2.length; _i6++) {
                    var member = _members$defaultedMem2[_i6];
                    this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                      enumName: enumName,
                      memberName: member.id.name
                    });
                  }

                  node.members = members.booleanMembers;
                  this.expect(types.braceR);
                  return this.finishNode(node, "EnumBooleanBody");
                } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                  for (var _i8 = 0, _members$defaultedMem4 = members.defaultedMembers; _i8 < _members$defaultedMem4.length; _i8++) {
                    var _member2 = _members$defaultedMem4[_i8];
                    this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                      enumName: enumName,
                      memberName: _member2.id.name
                    });
                  }

                  node.members = members.numberMembers;
                  this.expect(types.braceR);
                  return this.finishNode(node, "EnumNumberBody");
                } else {
                  this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                    enumName: enumName
                  });
                  return empty();
                }
              }
          }
        };

        _proto.flowParseEnumDeclaration = function flowParseEnumDeclaration(node) {
          var id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), {
            enumName: id.name,
            nameLoc: id.start
          });
          return this.finishNode(node, "EnumDeclaration");
        };

        _proto.updateContext = function updateContext(prevType) {
          if (this.match(types.name) && this.state.value === "of" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface") {
            this.state.exprAllowed = false;
          } else {
            _superClass.prototype.updateContext.call(this, prevType);
          }
        };

        return _class;
      }(superClass);
    });

    var entities = {
      quot: "\"",
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };

    var HEX_NUMBER = /^[\da-fA-F]+$/;
    var DECIMAL_NUMBER = /^\d+$/;
    var JsxErrors = Object.freeze({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
      MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
      UnterminatedJsxContent: "Unterminated JSX contents",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    types$1.j_oTag = new TokContext("<tag", false);
    types$1.j_cTag = new TokContext("</tag", false);
    types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
    types.jsxName = new TokenType("jsxName");
    types.jsxText = new TokenType("jsxText", {
      beforeExpr: true
    });
    types.jsxTagStart = new TokenType("jsxTagStart", {
      startsExpr: true
    });
    types.jsxTagEnd = new TokenType("jsxTagEnd");

    types.jsxTagStart.updateContext = function () {
      this.state.context.push(types$1.j_expr);
      this.state.context.push(types$1.j_oTag);
      this.state.exprAllowed = false;
    };

    types.jsxTagEnd.updateContext = function (prevType) {
      var out = this.state.context.pop();

      if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
        this.state.context.pop();
        this.state.exprAllowed = this.curContext() === types$1.j_expr;
      } else {
        this.state.exprAllowed = true;
      }
    };

    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }

    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }

      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }

      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }

      throw new Error("Node had unexpected type: " + object.type);
    }

    var jsx = (function (superClass) {
      return function (_superClass) {
        _inheritsLoose(_class, _superClass);

        function _class() {
          return _superClass.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.jsxReadToken = function jsxReadToken() {
          var out = "";
          var chunkStart = this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
            }

            var ch = this.input.charCodeAt(this.state.pos);

            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.exprAllowed) {
                    ++this.state.pos;
                    return this.finishToken(types.jsxTagStart);
                  }

                  return _superClass.prototype.getTokenFromCode.call(this, ch);
                }

                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(types.jsxText, out);

              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;

              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }

            }
          }
        };

        _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
          var ch = this.input.charCodeAt(this.state.pos);
          var out;
          ++this.state.pos;

          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        };

        _proto.jsxReadString = function jsxReadString(quote) {
          var out = "";
          var chunkStart = ++this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(this.state.start, Errors.UnterminatedString);
            }

            var ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote) break;

            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(types.string, out);
        };

        _proto.jsxReadEntity = function jsxReadEntity() {
          var str = "";
          var count = 0;
          var entity;
          var ch = this.input[this.state.pos];
          var startPos = ++this.state.pos;

          while (this.state.pos < this.length && count++ < 10) {
            ch = this.input[this.state.pos++];

            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);

                  if (HEX_NUMBER.test(str)) {
                    entity = String.fromCodePoint(parseInt(str, 16));
                  }
                } else {
                  str = str.substr(1);

                  if (DECIMAL_NUMBER.test(str)) {
                    entity = String.fromCodePoint(parseInt(str, 10));
                  }
                }
              } else {
                entity = entities[str];
              }

              break;
            }

            str += ch;
          }

          if (!entity) {
            this.state.pos = startPos;
            return "&";
          }

          return entity;
        };

        _proto.jsxReadWord = function jsxReadWord() {
          var ch;
          var start = this.state.pos;

          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);

          return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
        };

        _proto.jsxParseIdentifier = function jsxParseIdentifier() {
          var node = this.startNode();

          if (this.match(types.jsxName)) {
            node.name = this.state.value;
          } else if (this.state.type.keyword) {
            node.name = this.state.type.keyword;
          } else {
            this.unexpected();
          }

          this.next();
          return this.finishNode(node, "JSXIdentifier");
        };

        _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var name = this.jsxParseIdentifier();
          if (!this.eat(types.colon)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        };

        _proto.jsxParseElementName = function jsxParseElementName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.jsxParseNamespacedName();

          if (node.type === "JSXNamespacedName") {
            return node;
          }

          while (this.eat(types.dot)) {
            var newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }

          return node;
        };

        _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
          var node;

          switch (this.state.type) {
            case types.braceL:
              node = this.startNode();
              this.next();
              node = this.jsxParseExpressionContainer(node);

              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(node.start, JsxErrors.AttributeIsEmpty);
              }

              return node;

            case types.jsxTagStart:
            case types.string:
              return this.parseExprAtom();

            default:
              throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
          }
        };

        _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
          var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
        };

        _proto.jsxParseSpreadChild = function jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.expect(types.braceR);
          return this.finishNode(node, "JSXSpreadChild");
        };

        _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer(node) {
          if (this.match(types.braceR)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            node.expression = this.parseExpression();
          }

          this.expect(types.braceR);
          return this.finishNode(node, "JSXExpressionContainer");
        };

        _proto.jsxParseAttribute = function jsxParseAttribute() {
          var node = this.startNode();

          if (this.eat(types.braceL)) {
            this.expect(types.ellipsis);
            node.argument = this.parseMaybeAssign();
            this.expect(types.braceR);
            return this.finishNode(node, "JSXSpreadAttribute");
          }

          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        };

        _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.match(types.jsxTagEnd)) {
            this.expect(types.jsxTagEnd);
            return this.finishNode(node, "JSXOpeningFragment");
          }

          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        };

        _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
          var attributes = [];

          while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
            attributes.push(this.jsxParseAttribute());
          }

          node.attributes = attributes;
          node.selfClosing = this.eat(types.slash);
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningElement");
        };

        _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.match(types.jsxTagEnd)) {
            this.expect(types.jsxTagEnd);
            return this.finishNode(node, "JSXClosingFragment");
          }

          node.name = this.jsxParseElementName();
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXClosingElement");
        };

        _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          var children = [];
          var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          var closingElement = null;

          if (!openingElement.selfClosing) {
            contents: for (;;) {
              switch (this.state.type) {
                case types.jsxTagStart:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();

                  if (this.eat(types.slash)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }

                  children.push(this.jsxParseElementAt(startPos, startLoc));
                  break;

                case types.jsxText:
                  children.push(this.parseExprAtom());
                  break;

                case types.braceL:
                  {
                    var _node = this.startNode();

                    this.next();

                    if (this.match(types.ellipsis)) {
                      children.push(this.jsxParseSpreadChild(_node));
                    } else {
                      children.push(this.jsxParseExpressionContainer(_node));
                    }

                    break;
                  }

                default:
                  throw this.unexpected();
              }
            }

            if (isFragment(openingElement) && !isFragment(closingElement)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
              }
            }
          }

          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }

          node.children = children;

          if (this.isRelational("<")) {
            throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
          }

          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        };

        _proto.jsxParseElement = function jsxParseElement() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        };

        _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
          if (this.match(types.jsxText)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(types.jsxTagStart)) {
            return this.jsxParseElement();
          } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
            this.finishToken(types.jsxTagStart);
            return this.jsxParseElement();
          } else {
            return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
          }
        };

        _proto.getTokenFromCode = function getTokenFromCode(code) {
          if (this.state.inPropertyName) return _superClass.prototype.getTokenFromCode.call(this, code);
          var context = this.curContext();

          if (context === types$1.j_expr) {
            return this.jsxReadToken();
          }

          if (context === types$1.j_oTag || context === types$1.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }

            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(types.jsxTagEnd);
            }

            if ((code === 34 || code === 39) && context === types$1.j_oTag) {
              return this.jsxReadString(code);
            }
          }

          if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }

          return _superClass.prototype.getTokenFromCode.call(this, code);
        };

        _proto.updateContext = function updateContext(prevType) {
          if (this.match(types.braceL)) {
            var curContext = this.curContext();

            if (curContext === types$1.j_oTag) {
              this.state.context.push(types$1.braceExpression);
            } else if (curContext === types$1.j_expr) {
              this.state.context.push(types$1.templateQuasi);
            } else {
              _superClass.prototype.updateContext.call(this, prevType);
            }

            this.state.exprAllowed = true;
          } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
            this.state.context.length -= 2;
            this.state.context.push(types$1.j_cTag);
            this.state.exprAllowed = false;
          } else {
            return _superClass.prototype.updateContext.call(this, prevType);
          }
        };

        return _class;
      }(superClass);
    });

    var Scope$2 = function Scope(flags) {
      this["var"] = [];
      this.lexical = [];
      this.functions = [];
      this.flags = flags;
    };

    var ScopeHandler = function () {
      function ScopeHandler(raise, inModule) {
        this.scopeStack = [];
        this.undefinedExports = new Map();
        this.undefinedPrivateNames = new Map();
        this.raise = raise;
        this.inModule = inModule;
      }

      var _proto = ScopeHandler.prototype;

      _proto.createScope = function createScope(flags) {
        return new Scope$2(flags);
      };

      _proto.enter = function enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      };

      _proto.exit = function exit() {
        this.scopeStack.pop();
      };

      _proto.treatFunctionsAsVarInScope = function treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
      };

      _proto.declareName = function declareName(name, bindingType, pos) {
        var scope = this.currentScope();

        if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);

          if (bindingType & BIND_SCOPE_FUNCTION) {
            scope.functions.push(name);
          } else {
            scope.lexical.push(name);
          }

          if (bindingType & BIND_SCOPE_LEXICAL) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & BIND_SCOPE_VAR) {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, pos);
            scope["var"].push(name);
            this.maybeExportDefined(scope, name);
            if (scope.flags & SCOPE_VAR) break;
          }
        }

        if (this.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports["delete"](name);
        }
      };

      _proto.maybeExportDefined = function maybeExportDefined(scope, name) {
        if (this.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports["delete"](name);
        }
      };

      _proto.checkRedeclarationInScope = function checkRedeclarationInScope(scope, name, bindingType, pos) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.raise(pos, Errors.VarRedeclaration, name);
        }
      };

      _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & BIND_KIND_VALUE)) return false;

        if (bindingType & BIND_SCOPE_LEXICAL) {
          return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope["var"].indexOf(name) > -1;
        }

        if (bindingType & BIND_SCOPE_FUNCTION) {
          return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope["var"].indexOf(name) > -1;
        }

        return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
      };

      _proto.checkLocalExport = function checkLocalExport(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0]["var"].indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
          this.undefinedExports.set(id.name, id.start);
        }
      };

      _proto.currentScope = function currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      };

      _proto.currentVarScope = function currentVarScope() {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];

          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };

      _proto.currentThisScope = function currentThisScope() {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];

          if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };

      _createClass(ScopeHandler, [{
        key: "inFunction",
        get: function get() {
          return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
        }
      }, {
        key: "allowSuper",
        get: function get() {
          return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
        }
      }, {
        key: "allowDirectSuper",
        get: function get() {
          return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
        }
      }, {
        key: "inClass",
        get: function get() {
          return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
        }
      }, {
        key: "inNonArrowFunction",
        get: function get() {
          return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
        }
      }, {
        key: "treatFunctionsAsVar",
        get: function get() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
      }]);

      return ScopeHandler;
    }();

    var TypeScriptScope = function (_Scope) {
      _inheritsLoose(TypeScriptScope, _Scope);

      function TypeScriptScope() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
        _this.types = [];
        _this.enums = [];
        _this.constEnums = [];
        _this.classes = [];
        _this.exportOnlyBindings = [];
        return _this;
      }

      return TypeScriptScope;
    }(Scope$2);

    var TypeScriptScopeHandler = function (_ScopeHandler) {
      _inheritsLoose(TypeScriptScopeHandler, _ScopeHandler);

      function TypeScriptScopeHandler() {
        return _ScopeHandler.apply(this, arguments) || this;
      }

      var _proto = TypeScriptScopeHandler.prototype;

      _proto.createScope = function createScope(flags) {
        return new TypeScriptScope(flags);
      };

      _proto.declareName = function declareName(name, bindingType, pos) {
        var scope = this.currentScope();

        if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.push(name);
          return;
        }

        _ScopeHandler.prototype.declareName.apply(this, arguments);

        if (bindingType & BIND_KIND_TYPE) {
          if (!(bindingType & BIND_KIND_VALUE)) {
            this.checkRedeclarationInScope(scope, name, bindingType, pos);
            this.maybeExportDefined(scope, name);
          }

          scope.types.push(name);
        }

        if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
        if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
        if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
      };

      _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
        if (scope.enums.indexOf(name) > -1) {
          if (bindingType & BIND_FLAGS_TS_ENUM) {
            var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
            var wasConst = scope.constEnums.indexOf(name) > -1;
            return isConst !== wasConst;
          }

          return true;
        }

        if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
          if (scope.lexical.indexOf(name) > -1) {
            return !!(bindingType & BIND_KIND_VALUE);
          } else {
            return false;
          }
        }

        if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
          return true;
        }

        return _ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments);
      };

      _proto.checkLocalExport = function checkLocalExport(id) {
        if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
          _ScopeHandler.prototype.checkLocalExport.call(this, id);
        }
      };

      return TypeScriptScopeHandler;
    }(ScopeHandler);

    var PARAM = 0,
        PARAM_YIELD = 1,
        PARAM_AWAIT = 2,
        PARAM_RETURN = 4;

    var ProductionParameterHandler = function () {
      function ProductionParameterHandler() {
        this.stacks = [];
      }

      var _proto = ProductionParameterHandler.prototype;

      _proto.enter = function enter(flags) {
        this.stacks.push(flags);
      };

      _proto.exit = function exit() {
        this.stacks.pop();
      };

      _proto.currentFlags = function currentFlags() {
        return this.stacks[this.stacks.length - 1];
      };

      _createClass(ProductionParameterHandler, [{
        key: "hasAwait",
        get: function get() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
      }, {
        key: "hasYield",
        get: function get() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
      }, {
        key: "hasReturn",
        get: function get() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
      }]);

      return ProductionParameterHandler;
    }();
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
    }

    function nonNull(x) {
      if (x == null) {
        throw new Error("Unexpected " + x + " value.");
      }

      return x;
    }

    function assert$1(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }

    var TSErrors = Object.freeze({
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
      DeclareClassFieldHasInitializer: "'declare' class fields cannot have an initializer",
      DuplicateModifier: "Duplicate modifier: '%0'",
      EmptyHeritageClauseType: "'%0' list cannot be empty.",
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
      IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
      TemplateTypeHasSubstitution: "Template literal types cannot have any substitution",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
    });

    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";

        case "boolean":
          return "TSBooleanKeyword";

        case "bigint":
          return "TSBigIntKeyword";

        case "never":
          return "TSNeverKeyword";

        case "number":
          return "TSNumberKeyword";

        case "object":
          return "TSObjectKeyword";

        case "string":
          return "TSStringKeyword";

        case "symbol":
          return "TSSymbolKeyword";

        case "undefined":
          return "TSUndefinedKeyword";

        case "unknown":
          return "TSUnknownKeyword";

        default:
          return undefined;
      }
    }

    var typescript = (function (superClass) {
      return function (_superClass) {
        _inheritsLoose(_class, _superClass);

        function _class() {
          return _superClass.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.getScopeHandler = function getScopeHandler() {
          return TypeScriptScopeHandler;
        };

        _proto.tsIsIdentifier = function tsIsIdentifier() {
          return this.match(types.name);
        };

        _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
          this.next();
          return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);
        };

        _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {
          if (!this.match(types.name)) {
            return undefined;
          }

          var modifier = this.state.value;

          if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }

          return undefined;
        };

        _proto.tsParseModifiers = function tsParseModifiers(modified, allowedModifiers) {
          for (;;) {
            var startPos = this.state.start;
            var modifier = this.tsParseModifier(allowedModifiers);
            if (!modifier) break;

            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(startPos, TSErrors.DuplicateModifier, modifier);
            }

            modified[modifier] = true;
          }
        };

        _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(types.braceR);

            case "HeritageClauseElement":
              return this.match(types.braceL);

            case "TupleElementTypes":
              return this.match(types.bracketR);

            case "TypeParametersOrArguments":
              return this.isRelational(">");
          }

          throw new Error("Unreachable");
        };

        _proto.tsParseList = function tsParseList(kind, parseElement) {
          var result = [];

          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }

          return result;
        };

        _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
        };

        _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
          var result = [];

          for (;;) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }

            var element = parseElement();

            if (element == null) {
              return undefined;
            }

            result.push(element);

            if (this.eat(types.comma)) {
              continue;
            }

            if (this.tsIsListTerminator(kind)) {
              break;
            }

            if (expectSuccess) {
              this.expect(types.comma);
            }

            return undefined;
          }

          return result;
        };

        _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(types.bracketL);
            } else {
              this.expectRelational("<");
            }
          }

          var result = this.tsParseDelimitedList(kind, parseElement);

          if (bracket) {
            this.expect(types.bracketR);
          } else {
            this.expectRelational(">");
          }

          return result;
        };

        _proto.tsParseImportType = function tsParseImportType() {
          var node = this.startNode();
          this.expect(types._import);
          this.expect(types.parenL);

          if (!this.match(types.string)) {
            this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
          }

          node.argument = this.parseExprAtom();
          this.expect(types.parenR);

          if (this.eat(types.dot)) {
            node.qualifier = this.tsParseEntityName(true);
          }

          if (this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSImportType");
        };

        _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {
          var entity = this.parseIdentifier();

          while (this.eat(types.dot)) {
            var node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }

          return entity;
        };

        _proto.tsParseTypeReference = function tsParseTypeReference() {
          var node = this.startNode();
          node.typeName = this.tsParseEntityName(false);

          if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSTypeReference");
        };

        _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
          this.next();
          var node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          return this.finishNode(node, "TSTypePredicate");
        };

        _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
          var node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        };

        _proto.tsParseTypeQuery = function tsParseTypeQuery() {
          var node = this.startNode();
          this.expect(types._typeof);

          if (this.match(types._import)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName(true);
          }

          return this.finishNode(node, "TSTypeQuery");
        };

        _proto.tsParseTypeParameter = function tsParseTypeParameter() {
          var node = this.startNode();
          node.name = this.parseIdentifierName(node.start);
          node.constraint = this.tsEatThenParseType(types._extends);
          node["default"] = this.tsEatThenParseType(types.eq);
          return this.finishNode(node, "TSTypeParameter");
        };

        _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
          if (this.isRelational("<")) {
            return this.tsParseTypeParameters();
          }
        };

        _proto.tsParseTypeParameters = function tsParseTypeParameters() {
          var node = this.startNode();

          if (this.isRelational("<") || this.match(types.jsxTagStart)) {
            this.next();
          } else {
            this.unexpected();
          }

          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
          return this.finishNode(node, "TSTypeParameterDeclaration");
        };

        _proto.tsTryNextParseConstantContext = function tsTryNextParseConstantContext() {
          if (this.lookahead().type === types._const) {
            this.next();
            return this.tsParseTypeReference();
          }

          return null;
        };

        _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
          var returnTokenRequired = returnToken === types.arrow;
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(types.parenL);
          signature.parameters = this.tsParseBindingListForSignature();

          if (returnTokenRequired) {
            signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        };

        _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
          var _this = this;

          return this.parseBindingList(types.parenR, 41).map(function (pattern) {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              _this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
            }

            return pattern;
          });
        };

        _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
          if (!this.eat(types.comma)) {
            this.semicolon();
          }
        };

        _proto.tsParseSignatureMember = function tsParseSignatureMember(kind, node) {
          this.tsFillSignature(types.colon, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        };

        _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
          this.next();
          return this.eat(types.name) && this.match(types.colon);
        };

        _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
          if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return undefined;
          }

          this.expect(types.bracketL);
          var id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(types.bracketR);
          node.parameters = [id];
          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        };

        _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(types.question)) node.optional = true;
          var nodeAny = node;

          if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
            var method = nodeAny;
            this.tsFillSignature(types.colon, method);
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(method, "TSMethodSignature");
          } else {
            var property = nodeAny;
            if (readonly) property.readonly = true;
            var type = this.tsTryParseTypeAnnotation();
            if (type) property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        };

        _proto.tsParseTypeMember = function tsParseTypeMember() {
          var node = this.startNode();

          if (this.match(types.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }

          if (this.match(types._new)) {
            var id = this.startNode();
            this.next();

            if (this.match(types.parenL) || this.isRelational("<")) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }

          var readonly = !!this.tsParseModifier(["readonly"]);
          var idx = this.tsTryParseIndexSignature(node);

          if (idx) {
            if (readonly) node.readonly = true;
            return idx;
          }

          this.parsePropertyName(node, false);
          return this.tsParsePropertyOrMethodSignature(node, readonly);
        };

        _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
          var node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        };

        _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
          this.expect(types.braceL);
          var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(types.braceR);
          return members;
        };

        _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
          this.next();

          if (this.eat(types.plusMin)) {
            return this.isContextual("readonly");
          }

          if (this.isContextual("readonly")) {
            this.next();
          }

          if (!this.match(types.bracketL)) {
            return false;
          }

          this.next();

          if (!this.tsIsIdentifier()) {
            return false;
          }

          this.next();
          return this.match(types._in);
        };

        _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
          var node = this.startNode();
          node.name = this.parseIdentifierName(node.start);
          node.constraint = this.tsExpectThenParseType(types._in);
          return this.finishNode(node, "TSTypeParameter");
        };

        _proto.tsParseMappedType = function tsParseMappedType() {
          var node = this.startNode();
          this.expect(types.braceL);

          if (this.match(types.plusMin)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual("readonly");
          } else if (this.eatContextual("readonly")) {
            node.readonly = true;
          }

          this.expect(types.bracketL);
          node.typeParameter = this.tsParseMappedTypeParameter();
          this.expect(types.bracketR);

          if (this.match(types.plusMin)) {
            node.optional = this.state.value;
            this.next();
            this.expect(types.question);
          } else if (this.eat(types.question)) {
            node.optional = true;
          }

          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(types.braceR);
          return this.finishNode(node, "TSMappedType");
        };

        _proto.tsParseTupleType = function tsParseTupleType() {
          var _this2 = this;

          var node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          var seenOptionalElement = false;
          node.elementTypes.forEach(function (elementNode) {
            if (elementNode.type === "TSOptionalType") {
              seenOptionalElement = true;
            } else if (seenOptionalElement && elementNode.type !== "TSRestType") {
              _this2.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
            }
          });
          return this.finishNode(node, "TSTupleType");
        };

        _proto.tsParseTupleElementType = function tsParseTupleElementType() {
          if (this.match(types.ellipsis)) {
            var restNode = this.startNode();
            this.next();
            restNode.typeAnnotation = this.tsParseType();

            if (this.match(types.comma) && this.lookaheadCharCode() !== 93) {
              this.raiseRestNotLast(this.state.start);
            }

            return this.finishNode(restNode, "TSRestType");
          }

          var type = this.tsParseType();

          if (this.eat(types.question)) {
            var optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            return this.finishNode(optionalTypeNode, "TSOptionalType");
          }

          return type;
        };

        _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
          var node = this.startNode();
          this.expect(types.parenL);
          node.typeAnnotation = this.tsParseType();
          this.expect(types.parenR);
          return this.finishNode(node, "TSParenthesizedType");
        };

        _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type) {
          var node = this.startNode();

          if (type === "TSConstructorType") {
            this.expect(types._new);
          }

          this.tsFillSignature(types.arrow, node);
          return this.finishNode(node, type);
        };

        _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
          var _this3 = this;

          var node = this.startNode();

          node.literal = function () {
            switch (_this3.state.type) {
              case types.num:
              case types.string:
              case types._true:
              case types._false:
                return _this3.parseExprAtom();

              default:
                throw _this3.unexpected();
            }
          }();

          return this.finishNode(node, "TSLiteralType");
        };

        _proto.tsParseTemplateLiteralType = function tsParseTemplateLiteralType() {
          var node = this.startNode();
          var templateNode = this.parseTemplate(false);

          if (templateNode.expressions.length > 0) {
            this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution);
          }

          node.literal = templateNode;
          return this.finishNode(node, "TSLiteralType");
        };

        _proto.tsParseThisTypeOrThisTypePredicate = function tsParseThisTypeOrThisTypePredicate() {
          var thisKeyword = this.tsParseThisTypeNode();

          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        };

        _proto.tsParseNonArrayType = function tsParseNonArrayType() {
          switch (this.state.type) {
            case types.name:
            case types._void:
            case types._null:
              {
                var type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

                if (type !== undefined && this.lookaheadCharCode() !== 46) {
                  var node = this.startNode();
                  this.next();
                  return this.finishNode(node, type);
                }

                return this.tsParseTypeReference();
              }

            case types.string:
            case types.num:
            case types._true:
            case types._false:
              return this.tsParseLiteralTypeNode();

            case types.plusMin:
              if (this.state.value === "-") {
                var _node = this.startNode();

                if (this.lookahead().type !== types.num) {
                  throw this.unexpected();
                }

                _node.literal = this.parseMaybeUnary();
                return this.finishNode(_node, "TSLiteralType");
              }

              break;

            case types._this:
              return this.tsParseThisTypeOrThisTypePredicate();

            case types._typeof:
              return this.tsParseTypeQuery();

            case types._import:
              return this.tsParseImportType();

            case types.braceL:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

            case types.bracketL:
              return this.tsParseTupleType();

            case types.parenL:
              return this.tsParseParenthesizedType();

            case types.backQuote:
              return this.tsParseTemplateLiteralType();
          }

          throw this.unexpected();
        };

        _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
          var type = this.tsParseNonArrayType();

          while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
            if (this.match(types.bracketR)) {
              var node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(types.bracketR);
              type = this.finishNode(node, "TSArrayType");
            } else {
              var _node2 = this.startNodeAtNode(type);

              _node2.objectType = type;
              _node2.indexType = this.tsParseType();
              this.expect(types.bracketR);
              type = this.finishNode(_node2, "TSIndexedAccessType");
            }
          }

          return type;
        };

        _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {
          var node = this.startNode();
          this.expectContextual(operator);
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }

          return this.finishNode(node, "TSTypeOperator");
        };

        _proto.tsCheckTypeAnnotationForReadOnly = function tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;

            default:
              this.raise(node.start, TSErrors.UnexpectedReadonly);
          }
        };

        _proto.tsParseInferType = function tsParseInferType() {
          var node = this.startNode();
          this.expectContextual("infer");
          var typeParameter = this.startNode();
          typeParameter.name = this.parseIdentifierName(typeParameter.start);
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        };

        _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
          var _this4 = this;

          var operator = ["keyof", "unique", "readonly"].find(function (kw) {
            return _this4.isContextual(kw);
          });
          return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
        };

        _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          this.eat(operator);
          var type = parseConstituentType();

          if (this.match(operator)) {
            var types = [type];

            while (this.eat(operator)) {
              types.push(parseConstituentType());
            }

            var node = this.startNodeAtNode(type);
            node.types = types;
            type = this.finishNode(node, kind);
          }

          return type;
        };

        _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
        };

        _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
        };

        _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
          if (this.isRelational("<")) {
            return true;
          }

          return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        };

        _proto.tsSkipParameterStart = function tsSkipParameterStart() {
          if (this.match(types.name) || this.match(types._this)) {
            this.next();
            return true;
          }

          if (this.match(types.braceL)) {
            var braceStackCounter = 1;
            this.next();

            while (braceStackCounter > 0) {
              if (this.match(types.braceL)) {
                ++braceStackCounter;
              } else if (this.match(types.braceR)) {
                --braceStackCounter;
              }

              this.next();
            }

            return true;
          }

          if (this.match(types.bracketL)) {
            var _braceStackCounter = 1;
            this.next();

            while (_braceStackCounter > 0) {
              if (this.match(types.bracketL)) {
                ++_braceStackCounter;
              } else if (this.match(types.bracketR)) {
                --_braceStackCounter;
              }

              this.next();
            }

            return true;
          }

          return false;
        };

        _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
          this.next();

          if (this.match(types.parenR) || this.match(types.ellipsis)) {
            return true;
          }

          if (this.tsSkipParameterStart()) {
            if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
              return true;
            }

            if (this.match(types.parenR)) {
              this.next();

              if (this.match(types.arrow)) {
                return true;
              }
            }
          }

          return false;
        };

        _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
          var _this5 = this;

          return this.tsInType(function () {
            var t = _this5.startNode();

            _this5.expect(returnToken);

            var asserts = _this5.tsTryParse(_this5.tsParseTypePredicateAsserts.bind(_this5));

            if (asserts && _this5.match(types._this)) {
              var thisTypePredicate = _this5.tsParseThisTypeOrThisTypePredicate();

              if (thisTypePredicate.type === "TSThisType") {
                var _node3 = _this5.startNodeAtNode(t);

                _node3.parameterName = thisTypePredicate;
                _node3.asserts = true;
                thisTypePredicate = _this5.finishNode(_node3, "TSTypePredicate");
              } else {
                thisTypePredicate.asserts = true;
              }

              t.typeAnnotation = thisTypePredicate;
              return _this5.finishNode(t, "TSTypeAnnotation");
            }

            var typePredicateVariable = _this5.tsIsIdentifier() && _this5.tsTryParse(_this5.tsParseTypePredicatePrefix.bind(_this5));

            if (!typePredicateVariable) {
              if (!asserts) {
                return _this5.tsParseTypeAnnotation(false, t);
              }

              var _node4 = _this5.startNodeAtNode(t);

              _node4.parameterName = _this5.parseIdentifier();
              _node4.asserts = asserts;
              t.typeAnnotation = _this5.finishNode(_node4, "TSTypePredicate");
              return _this5.finishNode(t, "TSTypeAnnotation");
            }

            var type = _this5.tsParseTypeAnnotation(false);

            var node = _this5.startNodeAtNode(t);

            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = _this5.finishNode(node, "TSTypePredicate");
            return _this5.finishNode(t, "TSTypeAnnotation");
          });
        };

        _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
        };

        _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
          return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
        };

        _proto.tsTryParseType = function tsTryParseType() {
          return this.tsEatThenParseType(types.colon);
        };

        _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
          var id = this.parseIdentifier();

          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        };

        _proto.tsParseTypePredicateAsserts = function tsParseTypePredicateAsserts() {
          if (!this.match(types.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
            return false;
          }

          var containsEsc = this.state.containsEsc;
          this.next();

          if (!this.match(types.name) && !this.match(types._this)) {
            return false;
          }

          if (containsEsc) {
            this.raise(this.state.lastTokStart, Errors.InvalidEscapedReservedWord, "asserts");
          }

          return true;
        };

        _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
          var _this6 = this;

          if (eatColon === void 0) {
            eatColon = true;
          }

          if (t === void 0) {
            t = this.startNode();
          }

          this.tsInType(function () {
            if (eatColon) _this6.expect(types.colon);
            t.typeAnnotation = _this6.tsParseType();
          });
          return this.finishNode(t, "TSTypeAnnotation");
        };

        _proto.tsParseType = function tsParseType() {
          assert$1(this.state.inType);
          var type = this.tsParseNonConditionalType();

          if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
            return type;
          }

          var node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsParseNonConditionalType();
          this.expect(types.question);
          node.trueType = this.tsParseType();
          this.expect(types.colon);
          node.falseType = this.tsParseType();
          return this.finishNode(node, "TSConditionalType");
        };

        _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }

          if (this.match(types._new)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          }

          return this.tsParseUnionTypeOrHigher();
        };

        _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
          var node = this.startNode();

          var _const = this.tsTryNextParseConstantContext();

          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expectRelational(">");
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        };

        _proto.tsParseHeritageClause = function tsParseHeritageClause(descriptor) {
          var originalStart = this.state.start;
          var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

          if (!delimitedList.length) {
            this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
          }

          return delimitedList;
        };

        _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
          var node = this.startNode();
          node.expression = this.tsParseEntityName(false);

          if (this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSExpressionWithTypeArguments");
        };

        _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, "typescript interface declaration");
          node.typeParameters = this.tsTryParseTypeParameters();

          if (this.eat(types._extends)) {
            node["extends"] = this.tsParseHeritageClause("extends");
          }

          var body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        };

        _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, BIND_TS_TYPE, undefined, "typescript type alias");
          node.typeParameters = this.tsTryParseTypeParameters();
          node.typeAnnotation = this.tsExpectThenParseType(types.eq);
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        };

        _proto.tsInNoContext = function tsInNoContext(cb) {
          var oldContext = this.state.context;
          this.state.context = [oldContext[0]];

          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        };

        _proto.tsInType = function tsInType(cb) {
          var oldInType = this.state.inType;
          this.state.inType = true;

          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        };

        _proto.tsEatThenParseType = function tsEatThenParseType(token) {
          return !this.match(token) ? undefined : this.tsNextThenParseType();
        };

        _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
          var _this7 = this;

          return this.tsDoThenParseType(function () {
            return _this7.expect(token);
          });
        };

        _proto.tsNextThenParseType = function tsNextThenParseType() {
          var _this8 = this;

          return this.tsDoThenParseType(function () {
            return _this8.next();
          });
        };

        _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
          var _this9 = this;

          return this.tsInType(function () {
            cb();
            return _this9.tsParseType();
          });
        };

        _proto.tsParseEnumMember = function tsParseEnumMember() {
          var node = this.startNode();
          node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

          if (this.eat(types.eq)) {
            node.initializer = this.parseMaybeAssign();
          }

          return this.finishNode(node, "TSEnumMember");
        };

        _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {
          if (isConst) node["const"] = true;
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, "typescript enum declaration");
          this.expect(types.braceL);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(types.braceR);
          return this.finishNode(node, "TSEnumDeclaration");
        };

        _proto.tsParseModuleBlock = function tsParseModuleBlock() {
          var node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(types.braceL);
          this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        };

        _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node, nested) {
          if (nested === void 0) {
            nested = false;
          }

          node.id = this.parseIdentifier();

          if (!nested) {
            this.checkLVal(node.id, BIND_TS_NAMESPACE, null, "module or namespace declaration");
          }

          if (this.eat(types.dot)) {
            var inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        };

        _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual("global")) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(types.string)) {
            node.id = this.parseExprAtom();
          } else {
            this.unexpected();
          }

          if (this.match(types.braceL)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        };

        _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, BIND_LEXICAL, undefined, "import equals declaration");
          this.expect(types.eq);
          node.moduleReference = this.tsParseModuleReference();
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        };

        _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
          return this.isContextual("require") && this.lookaheadCharCode() === 40;
        };

        _proto.tsParseModuleReference = function tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        };

        _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
          var node = this.startNode();
          this.expectContextual("require");
          this.expect(types.parenL);

          if (!this.match(types.string)) {
            throw this.unexpected();
          }

          node.expression = this.parseExprAtom();
          this.expect(types.parenR);
          return this.finishNode(node, "TSExternalModuleReference");
        };

        _proto.tsLookAhead = function tsLookAhead(f) {
          var state = this.state.clone();
          var res = f();
          this.state = state;
          return res;
        };

        _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
          var result = this.tryParse(function (abort) {
            return f() || abort();
          });
          if (result.aborted || !result.node) return undefined;
          if (result.error) this.state = result.failState;
          return result.node;
        };

        _proto.tsTryParse = function tsTryParse(f) {
          var state = this.state.clone();
          var result = f();

          if (result !== undefined && result !== false) {
            return result;
          } else {
            this.state = state;
            return undefined;
          }
        };

        _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }

          var starttype = this.state.type;
          var kind;

          if (this.isContextual("let")) {
            starttype = types._var;
            kind = "let";
          }

          switch (starttype) {
            case types._function:
              return this.parseFunctionStatement(nany, false, true);

            case types._class:
              nany.declare = true;
              return this.parseClass(nany, true, false);

            case types._const:
              if (this.match(types._const) && this.isLookaheadContextual("enum")) {
                this.expect(types._const);
                this.expectContextual("enum");
                return this.tsParseEnumDeclaration(nany, true);
              }

            case types._var:
              kind = kind || this.state.value;
              return this.parseVarStatement(nany, kind);

            case types.name:
              {
                var value = this.state.value;

                if (value === "global") {
                  return this.tsParseAmbientExternalModuleDeclaration(nany);
                } else {
                  return this.tsParseDeclaration(nany, value, true);
                }
              }
          }
        };

        _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        };

        _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare":
              {
                var declaration = this.tsTryParseDeclare(node);

                if (declaration) {
                  declaration.declare = true;
                  return declaration;
                }

                break;
              }

            case "global":
              if (this.match(types.braceL)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                var mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }

              break;

            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        };

        _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
                var cls = node;
                cls["abstract"] = true;

                if (next) {
                  this.next();

                  if (!this.match(types._class)) {
                    this.unexpected(null, types._class);
                  }
                }

                return this.parseClass(cls, true, false);
              }

              break;

            case "enum":
              if (next || this.match(types.name)) {
                if (next) this.next();
                return this.tsParseEnumDeclaration(node, false);
              }

              break;

            case "interface":
              if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                if (next) this.next();
                return this.tsParseInterfaceDeclaration(node);
              }

              break;

            case "module":
              if (next) this.next();

              if (this.match(types.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }

              break;

            case "namespace":
              if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                if (next) this.next();
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }

              break;

            case "type":
              if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
                if (next) this.next();
                return this.tsParseTypeAliasDeclaration(node);
              }

              break;
          }
        };

        _proto.tsCheckLineTerminatorAndMatch = function tsCheckLineTerminatorAndMatch(tokenType, next) {
          return (next || this.match(tokenType)) && !this.isLineTerminator();
        };

        _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          var _this10 = this;

          if (!this.isRelational("<")) {
            return undefined;
          }

          var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          var oldYieldPos = this.state.yieldPos;
          var oldAwaitPos = this.state.awaitPos;
          this.state.maybeInArrowParameters = true;
          this.state.yieldPos = -1;
          this.state.awaitPos = -1;
          var res = this.tsTryParseAndCatch(function () {
            var node = _this10.startNodeAt(startPos, startLoc);

            node.typeParameters = _this10.tsParseTypeParameters();

            _superClass.prototype.parseFunctionParams.call(_this10, node);

            node.returnType = _this10.tsTryParseTypeOrTypePredicateAnnotation();

            _this10.expect(types.arrow);

            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.yieldPos = oldYieldPos;
          this.state.awaitPos = oldAwaitPos;

          if (!res) {
            return undefined;
          }

          return this.parseArrowExpression(res, null, true);
        };

        _proto.tsParseTypeArguments = function tsParseTypeArguments() {
          var _this11 = this;

          var node = this.startNode();
          node.params = this.tsInType(function () {
            return _this11.tsInNoContext(function () {
              _this11.expectRelational("<");

              return _this11.tsParseDelimitedList("TypeParametersOrArguments", _this11.tsParseType.bind(_this11));
            });
          });
          this.state.exprAllowed = false;
          this.expectRelational(">");
          return this.finishNode(node, "TSTypeParameterInstantiation");
        };

        _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
          if (this.match(types.name)) {
            switch (this.state.value) {
              case "abstract":
              case "declare":
              case "enum":
              case "interface":
              case "module":
              case "namespace":
              case "type":
                return true;
            }
          }

          return false;
        };

        _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart()) return false;
          return _superClass.prototype.isExportDefaultSpecifier.call(this);
        };

        _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var accessibility;
          var readonly = false;

          if (allowModifiers) {
            accessibility = this.parseAccessModifier();
            readonly = !!this.tsParseModifier(["readonly"]);
          }

          var left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

          if (accessibility || readonly) {
            var pp = this.startNodeAt(startPos, startLoc);

            if (decorators.length) {
              pp.decorators = decorators;
            }

            if (accessibility) pp.accessibility = accessibility;
            if (readonly) pp.readonly = readonly;

            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
            }

            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }

          if (decorators.length) {
            left.decorators = decorators;
          }

          return elt;
        };

        _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
          if (isMethod === void 0) {
            isMethod = false;
          }

          if (this.match(types.colon)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
          }

          var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

          if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
            this.finishNode(node, bodilessType);
            return;
          }

          _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
        };

        _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkLVal(node.id, BIND_TS_AMBIENT, null, "function name");
          } else {
            _superClass.prototype.registerFunctionStatementId.apply(this, arguments);
          }
        };

        _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
          var _this12 = this;

          if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
            this.state.exprAllowed = false;
            this.next();
            var nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }

          if (this.isRelational("<")) {
            var result = this.tsTryParseAndCatch(function () {
              if (!noCalls && _this12.atPossibleAsyncArrow(base)) {
                var asyncArrowFn = _this12.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }

              var node = _this12.startNodeAt(startPos, startLoc);

              node.callee = base;

              var typeArguments = _this12.tsParseTypeArguments();

              if (typeArguments) {
                if (!noCalls && _this12.eat(types.parenL)) {
                  node.arguments = _this12.parseCallExpressionArguments(types.parenR, false);
                  node.typeParameters = typeArguments;
                  return _this12.finishCallExpression(node, state.optionalChainMember, state.eventualMember);
                } else if (_this12.match(types.backQuote)) {
                  return _this12.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
                }
              }

              _this12.unexpected();
            });
            if (result) return result;
          }

          return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);
        };

        _proto.parseNewArguments = function parseNewArguments(node) {
          var _this13 = this;

          if (this.isRelational("<")) {
            var typeParameters = this.tsTryParseAndCatch(function () {
              var args = _this13.tsParseTypeArguments();

              if (!_this13.match(types.parenL)) _this13.unexpected();
              return args;
            });

            if (typeParameters) {
              node.typeParameters = typeParameters;
            }
          }

          _superClass.prototype.parseNewArguments.call(this, node);
        };

        _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
          if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
            var node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;

            var _const = this.tsTryNextParseConstantContext();

            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }

            this.finishNode(node, "TSAsExpression");
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
          }

          return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);
        };

        _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};

        _proto.checkDuplicateExports = function checkDuplicateExports() {};

        _proto.parseImport = function parseImport(node) {
          if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {
            var ahead = this.lookahead();

            if (this.match(types.name) && ahead.type === types.eq) {
              return this.tsParseImportEqualsDeclaration(node);
            }

            if (this.isContextual("type") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === "from")) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }
          }

          var importNode = _superClass.prototype.parseImport.call(this, node);

          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(importNode.start, "A type-only import can specify a default import or named bindings, but not both.");
          }

          return importNode;
        };

        _proto.parseExport = function parseExport(node) {
          if (this.match(types._import)) {
            this.expect(types._import);
            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(types.eq)) {
            var assign = node;
            assign.expression = this.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual("as")) {
            var decl = node;
            this.expectContextual("namespace");
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual("type") && this.lookahead().type === types.braceL) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }

            return _superClass.prototype.parseExport.call(this, node);
          }
        };

        _proto.isAbstractClass = function isAbstractClass() {
          return this.isContextual("abstract") && this.lookahead().type === types._class;
        };

        _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            var cls = this.startNode();
            this.next();
            this.parseClass(cls, true, true);
            cls["abstract"] = true;
            return cls;
          }

          if (this.state.value === "interface") {
            var result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
            if (result) return result;
          }

          return _superClass.prototype.parseExportDefaultExpression.call(this);
        };

        _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
          if (this.state.type === types._const) {
            var ahead = this.lookahead();

            if (ahead.type === types.name && ahead.value === "enum") {
              var node = this.startNode();
              this.expect(types._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(node, true);
            }
          }

          return _superClass.prototype.parseStatementContent.call(this, context, topLevel);
        };

        _proto.parseAccessModifier = function parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        };

        _proto.parseClassMember = function parseClassMember(classBody, member, state, constructorAllowsSuper) {
          this.tsParseModifiers(member, ["declare"]);
          var accessibility = this.parseAccessModifier();
          if (accessibility) member.accessibility = accessibility;
          this.tsParseModifiers(member, ["declare"]);

          _superClass.prototype.parseClassMember.call(this, classBody, member, state, constructorAllowsSuper);
        };

        _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
          this.tsParseModifiers(member, ["abstract", "readonly", "declare"]);
          var idx = this.tsTryParseIndexSignature(member);

          if (idx) {
            classBody.body.push(idx);

            if (member["abstract"]) {
              this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
            }

            if (isStatic) {
              this.raise(member.start, TSErrors.IndexSignatureHasStatic);
            }

            if (member.accessibility) {
              this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
            }

            return;
          }

          _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic, constructorAllowsSuper);
        };

        _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
          var optional = this.eat(types.question);
          if (optional) methodOrProp.optional = true;

          if (methodOrProp.readonly && this.match(types.parenL)) {
            this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
          }

          if (methodOrProp.declare && this.match(types.parenL)) {
            this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
          }
        };

        _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
          var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
          return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);
        };

        _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart()) return true;
          return _superClass.prototype.shouldParseExportDeclaration.call(this);
        };

        _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
          var _this14 = this;

          if (!refNeedsArrowPos || !this.match(types.question)) {
            return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);
          }

          var result = this.tryParse(function () {
            return _superClass.prototype.parseConditional.call(_this14, expr, noIn, startPos, startLoc);
          });

          if (!result.node) {
            refNeedsArrowPos.start = result.error.pos || this.state.start;
            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        };

        _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
          node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

          if (this.eat(types.question)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(types.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }

          return node;
        };

        _proto.parseExportDeclaration = function parseExportDeclaration(node) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var isDeclare = this.eatContextual("declare");
          var declaration;

          if (this.match(types.name)) {
            declaration = this.tsTryParseExportDeclaration();
          }

          if (!declaration) {
            declaration = _superClass.prototype.parseExportDeclaration.call(this, node);
          }

          if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
            node.exportKind = "type";
          }

          if (declaration && isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }

          return declaration;
        };

        _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
          if ((!isStatement || optionalId) && this.isContextual("implements")) {
            return;
          }

          _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;
        };

        _proto.parseClassPropertyAnnotation = function parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(types.bang)) {
            node.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
        };

        _proto.parseClassProperty = function parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);

          if (node.declare && this.match(types.equal)) {
            this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
          }

          return _superClass.prototype.parseClassProperty.call(this, node);
        };

        _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
          if (node["abstract"]) {
            this.raise(node.start, TSErrors.PrivateElementHasAbstract);
          }

          if (node.accessibility) {
            this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
          }

          this.parseClassPropertyAnnotation(node);
          return _superClass.prototype.parseClassPrivateProperty.call(this, node);
        };

        _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;

          _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        };

        _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;

          _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
        };

        _proto.parseClassSuper = function parseClassSuper(node) {
          _superClass.prototype.parseClassSuper.call(this, node);

          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.tsParseTypeArguments();
          }

          if (this.eatContextual("implements")) {
            node["implements"] = this.tsParseHeritageClause("implements");
          }
        };

        _proto.parseObjPropValue = function parseObjPropValue(prop) {
          var _superClass$prototype;

          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) prop.typeParameters = typeParameters;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          (_superClass$prototype = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype, [this, prop].concat(args));
        };

        _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;

          _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
        };

        _proto.parseVarId = function parseVarId(decl, kind) {
          _superClass.prototype.parseVarId.call(this, decl, kind);

          if (decl.id.type === "Identifier" && this.eat(types.bang)) {
            decl.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();

          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        };

        _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(types.colon)) {
            node.returnType = this.tsParseTypeAnnotation();
          }

          return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
        };

        _proto.parseMaybeAssign = function parseMaybeAssign() {
          var _this15 = this;

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var state;
          var jsx;
          var typeCast;

          if (this.match(types.jsxTagStart)) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              var _superClass$prototype2;

              return (_superClass$prototype2 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype2, [_this15].concat(args));
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;

            if (context[context.length - 1] === types$1.j_oTag) {
              context.length -= 2;
            } else if (context[context.length - 1] === types$1.j_expr) {
              context.length -= 1;
            }
          }

          if (!(jsx && jsx.error) && !this.isRelational("<")) {
            var _superClass$prototype3;

            return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [this].concat(args));
          }

          var typeParameters;
          state = state || this.state.clone();
          var arrow = this.tryParse(function (abort) {
            var _superClass$prototype4;

            typeParameters = _this15.tsParseTypeParameters();

            var expr = (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [_this15].concat(args));

            if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
              abort();
            }

            if (typeParameters && typeParameters.params.length !== 0) {
              _this15.resetStartLocationFromNode(expr, typeParameters);
            }

            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;

          if (!jsx) {
            assert$1(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(function () {
              var _superClass$prototype5;

              return (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [_this15].concat(args));
            }, state);
            if (!typeCast.error) return typeCast.node;
          }

          if (jsx && jsx.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (typeCast && typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }

          if (jsx && jsx.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          if (typeCast && typeCast.thrown) throw typeCast.error;
          throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;
        };

        _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
          if (!this.hasPlugin("jsx") && this.isRelational("<")) {
            return this.tsParseTypeAssertion();
          } else {
            return _superClass.prototype.parseMaybeUnary.call(this, refExpressionErrors);
          }
        };

        _proto.parseArrow = function parseArrow(node) {
          var _this16 = this;

          if (this.match(types.colon)) {
            var result = this.tryParse(function (abort) {
              var returnType = _this16.tsParseTypeOrTypePredicateAnnotation(types.colon);

              if (_this16.canInsertSemicolon() || !_this16.match(types.arrow)) abort();
              return returnType;
            });
            if (result.aborted) return;

            if (!result.thrown) {
              if (result.error) this.state = result.failState;
              node.returnType = result.node;
            }
          }

          return _superClass.prototype.parseArrow.call(this, node);
        };

        _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
          if (this.eat(types.question)) {
            if (param.type !== "Identifier") {
              this.raise(param.start, TSErrors.PatternIsOptional);
            }

            param.optional = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        };

        _proto.toAssignable = function toAssignable(node) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node));

            case "TSParameterProperty":
              return _superClass.prototype.toAssignable.call(this, node);

            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              node.expression = this.toAssignable(node.expression);
              return node;

            default:
              return _superClass.prototype.toAssignable.call(this, node);
          }
        };

        _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription) {
          if (bindingType === void 0) {
            bindingType = BIND_NONE;
          }

          switch (expr.type) {
            case "TSTypeCastExpression":
              return;

            case "TSParameterProperty":
              this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");
              return;

            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);
              return;

            default:
              _superClass.prototype.checkLVal.call(this, expr, bindingType, checkClashes, contextDescription);

              return;
          }
        };

        _proto.parseBindingAtom = function parseBindingAtom() {
          switch (this.state.type) {
            case types._this:
              return this.parseIdentifier(true);

            default:
              return _superClass.prototype.parseBindingAtom.call(this);
          }
        };

        _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
          if (this.isRelational("<")) {
            var typeArguments = this.tsParseTypeArguments();

            if (this.match(types.parenL)) {
              var call = _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);

              call.typeParameters = typeArguments;
              return call;
            }

            this.unexpected(this.state.start, types.parenL);
          }

          return _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);
        };

        _proto.isClassMethod = function isClassMethod() {
          return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
        };

        _proto.isClassProperty = function isClassProperty() {
          return this.match(types.bang) || this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
        };

        _proto.parseMaybeDefault = function parseMaybeDefault() {
          var _superClass$prototype6;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          var node = (_superClass$prototype6 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype6, [this].concat(args));

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
          }

          return node;
        };

        _proto.getTokenFromCode = function getTokenFromCode(code) {
          if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types.relational, 1);
          } else {
            return _superClass.prototype.getTokenFromCode.call(this, code);
          }
        };

        _proto.toAssignableList = function toAssignableList(exprList) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];
            if (!expr) continue;

            switch (expr.type) {
              case "TSTypeCastExpression":
                exprList[i] = this.typeCastToParameter(expr);
                break;

              case "TSAsExpression":
              case "TSTypeAssertion":
                if (!this.state.maybeInArrowParameters) {
                  exprList[i] = this.typeCastToParameter(expr);
                } else {
                  this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
                }

                break;
            }
          }

          return _superClass.prototype.toAssignableList.apply(this, arguments);
        };

        _proto.typeCastToParameter = function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
          return node.expression;
        };

        _proto.toReferencedList = function toReferencedList(exprList, isInParens) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if (expr && expr.type === "TSTypeCastExpression") {
              this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);
            }
          }

          return exprList;
        };

        _proto.shouldParseArrow = function shouldParseArrow() {
          return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
        };

        _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
          return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
        };

        _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
          return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
        };

        _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
          var _this17 = this;

          if (this.isRelational("<")) {
            var typeArguments = this.tsTryParseAndCatch(function () {
              return _this17.tsParseTypeArguments();
            });
            if (typeArguments) node.typeParameters = typeArguments;
          }

          return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
        };

        _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
          var baseCount = _superClass.prototype.getGetterSetterExpectedParamCount.call(this, method);

          var firstParam = method.params[0];
          var hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
          return hasContextParam ? baseCount + 1 : baseCount;
        };

        return _class;
      }(superClass);
    });

    types.placeholder = new TokenType("%%", {
      startsExpr: true
    });
    var placeholders = (function (superClass) {
      return function (_superClass) {
        _inheritsLoose(_class, _superClass);

        function _class() {
          return _superClass.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.parsePlaceholder = function parsePlaceholder(expectedNode) {
          if (this.match(types.placeholder)) {
            var node = this.startNode();
            this.next();
            this.assertNoSpace("Unexpected space in placeholder.");
            node.name = _superClass.prototype.parseIdentifier.call(this, true);
            this.assertNoSpace("Unexpected space in placeholder.");
            this.expect(types.placeholder);
            return this.finishPlaceholder(node, expectedNode);
          }
        };

        _proto.finishPlaceholder = function finishPlaceholder(node, expectedNode) {
          var isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        };

        _proto.getTokenFromCode = function getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(types.placeholder, 2);
          }

          return _superClass.prototype.getTokenFromCode.apply(this, arguments);
        };

        _proto.parseExprAtom = function parseExprAtom() {
          return this.parsePlaceholder("Expression") || _superClass.prototype.parseExprAtom.apply(this, arguments);
        };

        _proto.parseIdentifier = function parseIdentifier() {
          return this.parsePlaceholder("Identifier") || _superClass.prototype.parseIdentifier.apply(this, arguments);
        };

        _proto.checkReservedWord = function checkReservedWord(word) {
          if (word !== undefined) _superClass.prototype.checkReservedWord.apply(this, arguments);
        };

        _proto.parseBindingAtom = function parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || _superClass.prototype.parseBindingAtom.apply(this, arguments);
        };

        _proto.checkLVal = function checkLVal(expr) {
          if (expr.type !== "Placeholder") _superClass.prototype.checkLVal.apply(this, arguments);
        };

        _proto.toAssignable = function toAssignable(node) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
            return node;
          }

          return _superClass.prototype.toAssignable.apply(this, arguments);
        };

        _proto.verifyBreakContinue = function verifyBreakContinue(node) {
          if (node.label && node.label.type === "Placeholder") return;

          _superClass.prototype.verifyBreakContinue.apply(this, arguments);
        };

        _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return _superClass.prototype.parseExpressionStatement.apply(this, arguments);
          }

          if (this.match(types.colon)) {
            var stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = this.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }

          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        };

        _proto.parseBlock = function parseBlock() {
          return this.parsePlaceholder("BlockStatement") || _superClass.prototype.parseBlock.apply(this, arguments);
        };

        _proto.parseFunctionId = function parseFunctionId() {
          return this.parsePlaceholder("Identifier") || _superClass.prototype.parseFunctionId.apply(this, arguments);
        };

        _proto.parseClass = function parseClass(node, isStatement, optionalId) {
          var type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          var placeholder = this.parsePlaceholder("Identifier");

          if (placeholder) {
            if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              this.unexpected(null, "A class name is required");
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }

          this.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass);
          return this.finishNode(node, type);
        };

        _proto.parseExport = function parseExport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _superClass.prototype.parseExport.apply(this, arguments);

          if (!this.isContextual("from") && !this.match(types.comma)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }

          this.expectPlugin("exportDefaultFrom");
          var specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return _superClass.prototype.parseExport.call(this, node);
        };

        _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }

          return _superClass.prototype.maybeParseExportDefaultSpecifier.apply(this, arguments);
        };

        _proto.checkExport = function checkExport(node) {
          var specifiers = node.specifiers;

          if (specifiers && specifiers.length) {
            node.specifiers = specifiers.filter(function (node) {
              return node.exported.type === "Placeholder";
            });
          }

          _superClass.prototype.checkExport.call(this, node);

          node.specifiers = specifiers;
        };

        _proto.parseImport = function parseImport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _superClass.prototype.parseImport.apply(this, arguments);
          node.specifiers = [];

          if (!this.isContextual("from") && !this.match(types.comma)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }

          var specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          this.finishNode(specifier, "ImportDefaultSpecifier");
          node.specifiers.push(specifier);

          if (this.eat(types.comma)) {
            var hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport) this.parseNamedImportSpecifiers(node);
          }

          this.expectContextual("from");
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        };

        _proto.parseImportSource = function parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || _superClass.prototype.parseImportSource.apply(this, arguments);
        };

        return _class;
      }(superClass);
    });

    var v8intrinsic = (function (superClass) {
      return function (_superClass) {
        _inheritsLoose(_class, _superClass);

        function _class() {
          return _superClass.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.parseV8Intrinsic = function parseV8Intrinsic() {
          if (this.match(types.modulo)) {
            var v8IntrinsicStart = this.state.start;
            var node = this.startNode();
            this.eat(types.modulo);

            if (this.match(types.name)) {
              var name = this.parseIdentifierName(this.state.start);
              var identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";

              if (this.match(types.parenL)) {
                return identifier;
              }
            }

            this.unexpected(v8IntrinsicStart);
          }
        };

        _proto.parseExprAtom = function parseExprAtom() {
          return this.parseV8Intrinsic() || _superClass.prototype.parseExprAtom.apply(this, arguments);
        };

        return _class;
      }(superClass);
    });

    function hasPlugin(plugins, name) {
      return plugins.some(function (plugin) {
        if (Array.isArray(plugin)) {
          return plugin[0] === name;
        } else {
          return plugin === name;
        }
      });
    }
    function getPluginOption(plugins, name, option) {
      var plugin = plugins.find(function (plugin) {
        if (Array.isArray(plugin)) {
          return plugin[0] === name;
        } else {
          return plugin === name;
        }
      });

      if (plugin && Array.isArray(plugin)) {
        return plugin[1][option];
      }

      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
    var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }

        var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

        if (decoratorsBeforeExport == null) {
          throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
        } else if (typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
        }
      }

      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }

      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }

      if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
        throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(function (p) {
          return "'" + p + "'";
        }).join(", "));
      }

      if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
        throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
          return "'" + p + "'";
        }).join(", "));
      }
    }
    var mixinPlugins = {
      estree: estree,
      jsx: jsx,
      flow: flow,
      typescript: typescript,
      v8intrinsic: v8intrinsic,
      placeholders: placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);

    var defaultOptions = {
      sourceType: "script",
      sourceFilename: undefined,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createParenthesizedExpressions: false,
      errorRecovery: false
    };
    function getOptions(opts) {
      var options = {};

      for (var _i2 = 0, _Object$keys2 = Object.keys(defaultOptions); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];
        options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
      }

      return options;
    }

    var State = function () {
      function State() {
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.inParameters = false;
        this.maybeInArrowParameters = false;
        this.maybeInAsyncArrowHead = false;
        this.inPipeline = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.inPropertyName = false;
        this.hasFlowComment = false;
        this.isIterator = false;
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.decoratorStack = [[]];
        this.yieldPos = -1;
        this.awaitPos = -1;
        this.comments = [];
        this.trailingComments = [];
        this.leadingComments = [];
        this.commentStack = [];
        this.commentPreviousNode = null;
        this.pos = 0;
        this.lineStart = 0;
        this.type = types.eof;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.lastTokEnd = 0;
        this.context = [types$1.braceStatement];
        this.exprAllowed = true;
        this.containsEsc = false;
        this.octalPositions = [];
        this.exportedIdentifiers = [];
        this.tokensLength = 0;
      }

      var _proto = State.prototype;

      _proto.init = function init(options) {
        this.strict = options.strictMode === false ? false : options.sourceType === "module";
        this.curLine = options.startLine;
        this.startLoc = this.endLoc = this.curPosition();
      };

      _proto.curPosition = function curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart);
      };

      _proto.clone = function clone(skipArrays) {
        var state = new State();
        var keys = Object.keys(this);

        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var val = this[key];

          if (!skipArrays && Array.isArray(val)) {
            val = val.slice();
          }

          state[key] = val;
        }

        return state;
      };

      return State;
    }();

    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
      hex: [46, 88, 95, 120]
    };
    var allowedNumericSeparatorSiblings = {};
    allowedNumericSeparatorSiblings.bin = [48, 49];
    allowedNumericSeparatorSiblings.oct = [].concat(allowedNumericSeparatorSiblings.bin, [50, 51, 52, 53, 54, 55]);
    allowedNumericSeparatorSiblings.dec = [].concat(allowedNumericSeparatorSiblings.oct, [56, 57]);
    allowedNumericSeparatorSiblings.hex = [].concat(allowedNumericSeparatorSiblings.dec, [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);
    var Token = function Token(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    };

    var Tokenizer = function (_LocationParser) {
      _inheritsLoose(Tokenizer, _LocationParser);

      function Tokenizer(options, input) {
        var _this;

        _this = _LocationParser.call(this) || this;
        _this.tokens = [];
        _this.state = new State();

        _this.state.init(options);

        _this.input = input;
        _this.length = input.length;
        _this.isLookahead = false;
        return _this;
      }

      var _proto = Tokenizer.prototype;

      _proto.pushToken = function pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      };

      _proto.next = function next() {
        if (!this.isLookahead) {
          this.checkKeywordEscapes();

          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
        }

        this.state.lastTokEnd = this.state.end;
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      };

      _proto.eat = function eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      };

      _proto.match = function match(type) {
        return this.state.type === type;
      };

      _proto.lookahead = function lookahead() {
        var old = this.state;
        this.state = old.clone(true);
        this.isLookahead = true;
        this.next();
        this.isLookahead = false;
        var curr = this.state;
        this.state = old;
        return curr;
      };

      _proto.nextTokenStart = function nextTokenStart() {
        var thisTokEnd = this.state.pos;
        skipWhiteSpace.lastIndex = thisTokEnd;
        var skip = skipWhiteSpace.exec(this.input);
        return thisTokEnd + skip[0].length;
      };

      _proto.lookaheadCharCode = function lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      };

      _proto.setStrict = function setStrict(strict) {
        this.state.strict = strict;
        if (!this.match(types.num) && !this.match(types.string)) return;
        this.state.pos = this.state.start;

        while (this.state.pos < this.state.lineStart) {
          this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
          --this.state.curLine;
        }

        this.nextToken();
      };

      _proto.curContext = function curContext() {
        return this.state.context[this.state.context.length - 1];
      };

      _proto.nextToken = function nextToken() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) this.skipSpace();
        this.state.octalPositions = [];
        this.state.start = this.state.pos;
        this.state.startLoc = this.state.curPosition();

        if (this.state.pos >= this.length) {
          this.finishToken(types.eof);
          return;
        }

        var override = curContext == null ? void 0 : curContext.override;

        if (override) {
          override(this);
        } else {
          this.getTokenFromCode(this.input.codePointAt(this.state.pos));
        }
      };

      _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "CommentBlock" : "CommentLine",
          value: text,
          start: start,
          end: end,
          loc: new SourceLocation(startLoc, endLoc)
        };
        if (this.options.tokens) this.pushToken(comment);
        this.state.comments.push(comment);
        this.addComment(comment);
      };

      _proto.skipBlockComment = function skipBlockComment() {
        var startLoc = this.state.curPosition();
        var start = this.state.pos;
        var end = this.input.indexOf("*/", this.state.pos + 2);
        if (end === -1) throw this.raise(start, Errors.UnterminatedComment);
        this.state.pos = end + 2;
        lineBreakG.lastIndex = start;
        var match;

        while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
          ++this.state.curLine;
          this.state.lineStart = match.index + match[0].length;
        }

        if (this.isLookahead) return;
        this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
      };

      _proto.skipLineComment = function skipLineComment(startSkip) {
        var start = this.state.pos;
        var startLoc = this.state.curPosition();
        var ch = this.input.charCodeAt(this.state.pos += startSkip);

        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }

        if (this.isLookahead) return;
        this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
      };

      _proto.skipSpace = function skipSpace() {
        loop: while (this.state.pos < this.length) {
          var ch = this.input.charCodeAt(this.state.pos);

          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;

            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }

            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;

            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;

                case 47:
                  this.skipLineComment(2);
                  break;

                default:
                  break loop;
              }

              break;

            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else {
                break loop;
              }

          }
        }
      };

      _proto.finishToken = function finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        var prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) this.updateContext(prevType);
      };

      _proto.readToken_numberSign = function readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }

        var nextPos = this.state.pos + 1;
        var next = this.input.charCodeAt(nextPos);

        if (next >= 48 && next <= 57) {
          throw this.raise(this.state.pos, Errors.UnexpectedDigitAfterHash);
        }

        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");

          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
            throw this.raise(this.state.pos, next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType);
          }

          if (next === 123) {
            this.finishToken(types.braceHashL);
          } else {
            this.finishToken(types.bracketHashL);
          }

          this.state.pos += 2;
        } else {
          this.finishOp(types.hash, 1);
        }
      };

      _proto.readToken_dot = function readToken_dot() {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }

        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(types.ellipsis);
        } else {
          ++this.state.pos;
          this.finishToken(types.dot);
        }
      };

      _proto.readToken_slash = function readToken_slash() {
        if (this.state.exprAllowed && !this.state.inType) {
          ++this.state.pos;
          this.readRegexp();
          return;
        }

        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next === 61) {
          this.finishOp(types.assign, 2);
        } else {
          this.finishOp(types.slash, 1);
        }
      };

      _proto.readToken_interpreter = function readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        var ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        var start = this.state.pos;
        this.state.pos += 1;

        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }

        var value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(types.interpreterDirective, value);
        return true;
      };

      _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
        var type = code === 42 ? types.star : types.modulo;
        var width = 1;
        var next = this.input.charCodeAt(this.state.pos + 1);
        var exprAllowed = this.state.exprAllowed;

        if (code === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = types.exponent;
        }

        if (next === 61 && !exprAllowed) {
          width++;
          type = types.assign;
        }

        this.finishOp(type, width);
      };

      _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next === code) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(types.assign, 3);
          } else {
            this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
          }

          return;
        }

        if (code === 124) {
          if (next === 62) {
            this.finishOp(types.pipeline, 2);
            return;
          }

          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectEndSyntaxType);
            }

            this.finishOp(types.braceBarR, 2);
            return;
          }

          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectEndSyntaxType);
            }

            this.finishOp(types.bracketBarR, 2);
            return;
          }
        }

        if (next === 61) {
          this.finishOp(types.assign, 2);
          return;
        }

        this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
      };

      _proto.readToken_caret = function readToken_caret() {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next === 61) {
          this.finishOp(types.assign, 2);
        } else {
          this.finishOp(types.bitwiseXOR, 1);
        }
      };

      _proto.readToken_plus_min = function readToken_plus_min(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            this.nextToken();
            return;
          }

          this.finishOp(types.incDec, 2);
          return;
        }

        if (next === 61) {
          this.finishOp(types.assign, 2);
        } else {
          this.finishOp(types.plusMin, 1);
        }
      };

      _proto.readToken_lt_gt = function readToken_lt_gt(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        var size = 1;

        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

          if (this.input.charCodeAt(this.state.pos + size) === 61) {
            this.finishOp(types.assign, size + 1);
            return;
          }

          this.finishOp(types.bitShift, size);
          return;
        }

        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          this.nextToken();
          return;
        }

        if (next === 61) {
          size = 2;
        }

        this.finishOp(types.relational, size);
      };

      _proto.readToken_eq_excl = function readToken_eq_excl(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next === 61) {
          this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }

        if (code === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(types.arrow);
          return;
        }

        this.finishOp(code === 61 ? types.eq : types.bang, 1);
      };

      _proto.readToken_question = function readToken_question() {
        var next = this.input.charCodeAt(this.state.pos + 1);
        var next2 = this.input.charCodeAt(this.state.pos + 2);

        if (next === 63 && !this.state.inType) {
          if (next2 === 61) {
            this.finishOp(types.assign, 3);
          } else {
            this.finishOp(types.nullishCoalescing, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(types.questionDot);
        } else {
          ++this.state.pos;
          this.finishToken(types.question);
        }
      };

      _proto.readToken_tilde = function readToken_tilde() {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (next === 46) {
          var next2 = this.input.charCodeAt(this.state.pos + 2);

          if (!(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(types.tildeDot);
            return;
          }
        }

        this.finishOp(types.tilde, 1);
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        switch (code) {
          case 46:
            this.readToken_dot();
            return;

          case 40:
            ++this.state.pos;
            this.finishToken(types.parenL);
            return;

          case 41:
            ++this.state.pos;
            this.finishToken(types.parenR);
            return;

          case 59:
            ++this.state.pos;
            this.finishToken(types.semi);
            return;

          case 44:
            ++this.state.pos;
            this.finishToken(types.comma);
            return;

          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectStartSyntaxType);
              }

              this.finishToken(types.bracketBarL);
              this.state.pos += 2;
            } else {
              ++this.state.pos;
              this.finishToken(types.bracketL);
            }

            return;

          case 93:
            ++this.state.pos;
            this.finishToken(types.bracketR);
            return;

          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectStartSyntaxType);
              }

              this.finishToken(types.braceBarL);
              this.state.pos += 2;
            } else {
              ++this.state.pos;
              this.finishToken(types.braceL);
            }

            return;

          case 125:
            ++this.state.pos;
            this.finishToken(types.braceR);
            return;

          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(types.doubleColon, 2);
            } else {
              ++this.state.pos;
              this.finishToken(types.colon);
            }

            return;

          case 63:
            this.readToken_question();
            return;

          case 96:
            ++this.state.pos;
            this.finishToken(types.backQuote);
            return;

          case 48:
            {
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
              }

              if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
              }

              if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
              }
            }

          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;

          case 34:
          case 39:
            this.readString(code);
            return;

          case 47:
            this.readToken_slash();
            return;

          case 37:
          case 42:
            this.readToken_mult_modulo(code);
            return;

          case 124:
          case 38:
            this.readToken_pipe_amp(code);
            return;

          case 94:
            this.readToken_caret();
            return;

          case 43:
          case 45:
            this.readToken_plus_min(code);
            return;

          case 60:
          case 62:
            this.readToken_lt_gt(code);
            return;

          case 61:
          case 33:
            this.readToken_eq_excl(code);
            return;

          case 126:
            this.readToken_tilde();
            return;

          case 64:
            ++this.state.pos;
            this.finishToken(types.at);
            return;

          case 35:
            this.readToken_numberSign();
            return;

          case 92:
            this.readWord();
            return;

          default:
            if (isIdentifierStart(code)) {
              this.readWord();
              return;
            }

        }

        throw this.raise(this.state.pos, Errors.InvalidOrUnexpectedToken, String.fromCodePoint(code));
      };

      _proto.finishOp = function finishOp(type, size) {
        var str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      };

      _proto.readRegexp = function readRegexp() {
        var start = this.state.pos;
        var escaped, inClass;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(start, Errors.UnterminatedRegExp);
          }

          var ch = this.input.charAt(this.state.pos);

          if (lineBreak.test(ch)) {
            throw this.raise(start, Errors.UnterminatedRegExp);
          }

          if (escaped) {
            escaped = false;
          } else {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }

            escaped = ch === "\\";
          }

          ++this.state.pos;
        }

        var content = this.input.slice(start, this.state.pos);
        ++this.state.pos;
        var mods = "";

        while (this.state.pos < this.length) {
          var _char = this.input[this.state.pos];
          var charCode = this.input.codePointAt(this.state.pos);

          if (VALID_REGEX_FLAGS.has(_char)) {
            if (mods.indexOf(_char) > -1) {
              this.raise(this.state.pos + 1, Errors.DuplicateRegExpFlags);
            }
          } else if (isIdentifierChar(charCode) || charCode === 92) {
            this.raise(this.state.pos + 1, Errors.MalformedRegExpFlags);
          } else {
            break;
          }

          ++this.state.pos;
          mods += _char;
        }

        this.finishToken(types.regexp, {
          pattern: content,
          flags: mods
        });
      };

      _proto.readInt = function readInt(radix, len, forceLen, allowNumSeparator) {
        if (allowNumSeparator === void 0) {
          allowNumSeparator = true;
        }

        var start = this.state.pos;
        var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
        var invalid = false;
        var total = 0;

        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = this.input.charCodeAt(this.state.pos);
          var val = void 0;

          if (this.hasPlugin("numericSeparator")) {
            if (code === 95) {
              var prev = this.input.charCodeAt(this.state.pos - 1);
              var next = this.input.charCodeAt(this.state.pos + 1);

              if (allowedSiblings.indexOf(next) === -1) {
                this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);
              } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
                this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);
              }

              if (!allowNumSeparator) {
                this.raise(this.state.pos, Errors.NumericSeparatorInEscapeSequence);
              }

              ++this.state.pos;
              continue;
            }
          }

          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }

          if (val >= radix) {
            if (this.options.errorRecovery && val <= 9) {
              val = 0;
              this.raise(this.state.start + i + 2, Errors.InvalidDigit, radix);
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }

          ++this.state.pos;
          total = total * radix + val;
        }

        if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
          return null;
        }

        return total;
      };

      _proto.readRadixNumber = function readRadixNumber(radix) {
        var start = this.state.pos;
        var isBigInt = false;
        this.state.pos += 2;
        var val = this.readInt(radix);

        if (val == null) {
          this.raise(this.state.start + 2, Errors.InvalidDigit, radix);
        }

        var next = this.input.charCodeAt(this.state.pos);

        if (next === 95) {
          this.expectPlugin("numericSeparator", this.state.pos);
        }

        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        }

        if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
          throw this.raise(this.state.pos, Errors.NumberIdentifier);
        }

        if (isBigInt) {
          var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(types.bigint, str);
          return;
        }

        this.finishToken(types.num, val);
      };

      _proto.readNumber = function readNumber(startsWithDot) {
        var start = this.state.pos;
        var isFloat = false;
        var isBigInt = false;
        var isNonOctalDecimalInt = false;

        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(start, Errors.InvalidNumber);
        }

        var octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

        if (octal) {
          if (this.state.strict) {
            this.raise(start, Errors.StrictOctalLiteral);
          }

          if (/[89]/.test(this.input.slice(start, this.state.pos))) {
            octal = false;
            isNonOctalDecimalInt = true;
          }
        }

        var next = this.input.charCodeAt(this.state.pos);

        if (next === 46 && !octal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }

        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.state.pos);

          if (next === 43 || next === 45) {
            ++this.state.pos;
          }

          if (this.readInt(10) === null) this.raise(start, "Invalid number");
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }

        if (this.hasPlugin("numericSeparator") && (octal || isNonOctalDecimalInt)) {
          var underscorePos = this.input.slice(start, this.state.pos).indexOf("_");

          if (underscorePos > 0) {
            this.raise(underscorePos + start, Errors.ZeroDigitNumericSeparator);
          }
        }

        if (next === 95) {
          this.expectPlugin("numericSeparator", this.state.pos);
        }

        if (next === 110) {
          if (isFloat || octal || isNonOctalDecimalInt) {
            this.raise(start, "Invalid BigIntLiteral");
          }

          ++this.state.pos;
          isBigInt = true;
        }

        if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
          throw this.raise(this.state.pos, Errors.NumberIdentifier);
        }

        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");

        if (isBigInt) {
          this.finishToken(types.bigint, str);
          return;
        }

        var val = octal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(types.num, val);
      };

      _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
        var ch = this.input.charCodeAt(this.state.pos);
        var code;

        if (ch === 123) {
          var codePos = ++this.state.pos;
          code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
          ++this.state.pos;

          if (code !== null && code > 0x10ffff) {
            if (throwOnInvalid) {
              this.raise(codePos, Errors.InvalidCodePoint);
            } else {
              return null;
            }
          }
        } else {
          code = this.readHexChar(4, false, throwOnInvalid);
        }

        return code;
      };

      _proto.readString = function readString(quote) {
        var out = "",
            chunkStart = ++this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, Errors.UnterminatedString);
          }

          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;

          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.state.pos;
          } else if (ch === 8232 || ch === 8233) {
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
          } else if (isNewLine(ch)) {
            throw this.raise(this.state.start, Errors.UnterminatedString);
          } else {
            ++this.state.pos;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(types.string, out);
      };

      _proto.readTmplToken = function readTmplToken() {
        var out = "",
            chunkStart = this.state.pos,
            containsInvalid = false;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, Errors.UnterminatedTemplate);
          }

          var ch = this.input.charCodeAt(this.state.pos);

          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
            if (this.state.pos === this.state.start && this.match(types.template)) {
              if (ch === 36) {
                this.state.pos += 2;
                this.finishToken(types.dollarBraceL);
                return;
              } else {
                ++this.state.pos;
                this.finishToken(types.backQuote);
                return;
              }
            }

            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(types.template, containsInvalid ? null : out);
            return;
          }

          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            var escaped = this.readEscapedChar(true);

            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }

            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            ++this.state.pos;

            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.state.pos) === 10) {
                  ++this.state.pos;
                }

              case 10:
                out += "\n";
                break;

              default:
                out += String.fromCharCode(ch);
                break;
            }

            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
      };

      _proto.readEscapedChar = function readEscapedChar(inTemplate) {
        var throwOnInvalid = !inTemplate;
        var ch = this.input.charCodeAt(++this.state.pos);
        ++this.state.pos;

        switch (ch) {
          case 110:
            return "\n";

          case 114:
            return "\r";

          case 120:
            {
              var code = this.readHexChar(2, false, throwOnInvalid);
              return code === null ? null : String.fromCharCode(code);
            }

          case 117:
            {
              var _code = this.readCodePoint(throwOnInvalid);

              return _code === null ? null : String.fromCodePoint(_code);
            }

          case 116:
            return "\t";

          case 98:
            return "\b";

          case 118:
            return "\x0B";

          case 102:
            return "\f";

          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
            }

          case 10:
            this.state.lineStart = this.state.pos;
            ++this.state.curLine;

          case 8232:
          case 8233:
            return "";

          case 56:
          case 57:
            if (inTemplate) {
              return null;
            }

          default:
            if (ch >= 48 && ch <= 55) {
              var codePos = this.state.pos - 1;
              var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);

              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }

              this.state.pos += octalStr.length - 1;
              var next = this.input.charCodeAt(this.state.pos);

              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return null;
                } else if (this.state.strict) {
                  this.raise(codePos, Errors.StrictOctalLiteral);
                } else {
                  this.state.octalPositions.push(codePos);
                }
              }

              return String.fromCharCode(octal);
            }

            return String.fromCharCode(ch);
        }
      };

      _proto.readHexChar = function readHexChar(len, forceLen, throwOnInvalid) {
        var codePos = this.state.pos;
        var n = this.readInt(16, len, forceLen, false);

        if (n === null) {
          if (throwOnInvalid) {
            this.raise(codePos, Errors.InvalidEscapeSequence);
          } else {
            this.state.pos = codePos - 1;
          }
        }

        return n;
      };

      _proto.readWord1 = function readWord1() {
        var word = "";
        this.state.containsEsc = false;
        var start = this.state.pos;
        var chunkStart = this.state.pos;

        while (this.state.pos < this.length) {
          var ch = this.input.codePointAt(this.state.pos);

          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 0xffff ? 1 : 2;
          } else if (this.state.isIterator && ch === 64) {
            ++this.state.pos;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            var escStart = this.state.pos;
            var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(this.state.pos, Errors.MissingUnicodeEscape);
              continue;
            }

            ++this.state.pos;
            var esc = this.readCodePoint(true);

            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(escStart, Errors.EscapedCharNotAnIdentifier);
              }

              word += String.fromCodePoint(esc);
            }

            chunkStart = this.state.pos;
          } else {
            break;
          }
        }

        return word + this.input.slice(chunkStart, this.state.pos);
      };

      _proto.isIterator = function isIterator(word) {
        return word === "@@iterator" || word === "@@asyncIterator";
      };

      _proto.readWord = function readWord() {
        var word = this.readWord1();
        var type = keywords$1.get(word) || types.name;

        if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
          this.raise(this.state.pos, Errors.InvalidIdentifier, word);
        }

        this.finishToken(type, word);
      };

      _proto.checkKeywordEscapes = function checkKeywordEscapes() {
        var kw = this.state.type.keyword;

        if (kw && this.state.containsEsc) {
          this.raise(this.state.start, Errors.InvalidEscapedReservedWord, kw);
        }
      };

      _proto.braceIsBlock = function braceIsBlock(prevType) {
        var parent = this.curContext();

        if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
          return true;
        }

        if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
          return !parent.isExpr;
        }

        if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
          return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
        }

        if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
          return true;
        }

        if (prevType === types.braceL) {
          return parent === types$1.braceStatement;
        }

        if (prevType === types._var || prevType === types._const || prevType === types.name) {
          return false;
        }

        if (prevType === types.relational) {
          return true;
        }

        return !this.state.exprAllowed;
      };

      _proto.updateContext = function updateContext(prevType) {
        var type = this.state.type;
        var update;

        if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
          this.state.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.state.exprAllowed = type.beforeExpr;
        }
      };

      return Tokenizer;
    }(LocationParser);

    var UtilParser = function (_Tokenizer) {
      _inheritsLoose(UtilParser, _Tokenizer);

      function UtilParser() {
        return _Tokenizer.apply(this, arguments) || this;
      }

      var _proto = UtilParser.prototype;

      _proto.addExtra = function addExtra(node, key, val) {
        if (!node) return;
        var extra = node.extra = node.extra || {};
        extra[key] = val;
      };

      _proto.isRelational = function isRelational(op) {
        return this.match(types.relational) && this.state.value === op;
      };

      _proto.isLookaheadRelational = function isLookaheadRelational(op) {
        var next = this.nextTokenStart();

        if (this.input.charAt(next) === op) {
          if (next + 1 === this.input.length) {
            return true;
          }

          var afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== op.charCodeAt(0) && afterNext !== 61;
        }

        return false;
      };

      _proto.expectRelational = function expectRelational(op) {
        if (this.isRelational(op)) {
          this.next();
        } else {
          this.unexpected(null, types.relational);
        }
      };

      _proto.isContextual = function isContextual(name) {
        return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
      };

      _proto.isUnparsedContextual = function isUnparsedContextual(nameStart, name) {
        var nameEnd = nameStart + name.length;
        return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
      };

      _proto.isLookaheadContextual = function isLookaheadContextual(name) {
        var next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      };

      _proto.eatContextual = function eatContextual(name) {
        return this.isContextual(name) && this.eat(types.name);
      };

      _proto.expectContextual = function expectContextual(name, message) {
        if (!this.eatContextual(name)) this.unexpected(null, message);
      };

      _proto.canInsertSemicolon = function canInsertSemicolon() {
        return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
      };

      _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
      };

      _proto.isLineTerminator = function isLineTerminator() {
        return this.eat(types.semi) || this.canInsertSemicolon();
      };

      _proto.semicolon = function semicolon() {
        if (!this.isLineTerminator()) this.unexpected(null, types.semi);
      };

      _proto.expect = function expect(type, pos) {
        this.eat(type) || this.unexpected(pos, type);
      };

      _proto.assertNoSpace = function assertNoSpace(message) {
        if (message === void 0) {
          message = "Unexpected space.";
        }

        if (this.state.start > this.state.lastTokEnd) {
          this.raise(this.state.lastTokEnd, message);
        }
      };

      _proto.unexpected = function unexpected(pos, messageOrType) {
        if (messageOrType === void 0) {
          messageOrType = "Unexpected token";
        }

        if (typeof messageOrType !== "string") {
          messageOrType = "Unexpected token, expected \"" + messageOrType.label + "\"";
        }

        throw this.raise(pos != null ? pos : this.state.start, messageOrType);
      };

      _proto.expectPlugin = function expectPlugin(name, pos) {
        if (!this.hasPlugin(name)) {
          throw this.raiseWithData(pos != null ? pos : this.state.start, {
            missingPlugin: [name]
          }, "This experimental syntax requires enabling the parser plugin: '" + name + "'");
        }

        return true;
      };

      _proto.expectOnePlugin = function expectOnePlugin(names, pos) {
        var _this = this;

        if (!names.some(function (n) {
          return _this.hasPlugin(n);
        })) {
          throw this.raiseWithData(pos != null ? pos : this.state.start, {
            missingPlugin: names
          }, "This experimental syntax requires enabling one of the following parser plugin(s): '" + names.join(", ") + "'");
        }
      };

      _proto.checkYieldAwaitInDefaultParams = function checkYieldAwaitInDefaultParams() {
        if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {
          this.raise(this.state.yieldPos, "Yield cannot be used as name inside a generator function");
        }

        if (this.state.awaitPos !== -1) {
          this.raise(this.state.awaitPos, "Await cannot be used as name inside an async function");
        }
      };

      _proto.tryParse = function tryParse(fn, oldState) {
        if (oldState === void 0) {
          oldState = this.state.clone();
        }

        var abortSignal = {
          node: null
        };

        try {
          var _node = fn(function (node) {
            if (node === void 0) {
              node = null;
            }

            abortSignal.node = node;
            throw abortSignal;
          });

          if (this.state.errors.length > oldState.errors.length) {
            var failState = this.state;
            this.state = oldState;
            return {
              node: _node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState: failState
            };
          }

          return {
            node: _node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          var _failState = this.state;
          this.state = oldState;

          if (error instanceof SyntaxError) {
            return {
              node: null,
              error: error,
              thrown: true,
              aborted: false,
              failState: _failState
            };
          }

          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState: _failState
            };
          }

          throw error;
        }
      };

      _proto.checkExpressionErrors = function checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        var shorthandAssign = refExpressionErrors.shorthandAssign,
            doubleProto = refExpressionErrors.doubleProto;
        if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

        if (shorthandAssign >= 0) {
          this.unexpected(shorthandAssign);
        }

        if (doubleProto >= 0) {
          this.raise(doubleProto, Errors.DuplicateProto);
        }
      };

      return UtilParser;
    }(Tokenizer);
    var ExpressionErrors = function ExpressionErrors() {
      this.shorthandAssign = -1;
      this.doubleProto = -1;
    };

    var Node = function () {
      function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser && parser.options.ranges) this.range = [pos, 0];
        if (parser && parser.filename) this.loc.filename = parser.filename;
      }

      var _proto = Node.prototype;

      _proto.__clone = function __clone() {
        var newNode = new Node();
        var keys = Object.keys(this);

        for (var i = 0, length = keys.length; i < length; i++) {
          var _key = keys[i];

          if (_key !== "leadingComments" && _key !== "trailingComments" && _key !== "innerComments") {
            newNode[_key] = this[_key];
          }
        }

        return newNode;
      };

      return Node;
    }();

    var NodeUtils = function (_UtilParser) {
      _inheritsLoose(NodeUtils, _UtilParser);

      function NodeUtils() {
        return _UtilParser.apply(this, arguments) || this;
      }

      var _proto2 = NodeUtils.prototype;

      _proto2.startNode = function startNode() {
        return new Node(this, this.state.start, this.state.startLoc);
      };

      _proto2.startNodeAt = function startNodeAt(pos, loc) {
        return new Node(this, pos, loc);
      };

      _proto2.startNodeAtNode = function startNodeAtNode(type) {
        return this.startNodeAt(type.start, type.loc.start);
      };

      _proto2.finishNode = function finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
      };

      _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
        if ( node.end > 0) {
          throw new Error("Do not call finishNode*() twice on the same node." + " Instead use resetEndLocation() or change type directly.");
        }

        node.type = type;
        node.end = pos;
        node.loc.end = loc;
        if (this.options.ranges) node.range[1] = pos;
        this.processComment(node);
        return node;
      };

      _proto2.resetStartLocation = function resetStartLocation(node, start, startLoc) {
        node.start = start;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = start;
      };

      _proto2.resetEndLocation = function resetEndLocation(node, end, endLoc) {
        if (end === void 0) {
          end = this.state.lastTokEnd;
        }

        if (endLoc === void 0) {
          endLoc = this.state.lastTokEndLoc;
        }

        node.end = end;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = end;
      };

      _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      };

      return NodeUtils;
    }(UtilParser);

    var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };

    var LValParser = function (_NodeUtils) {
      _inheritsLoose(LValParser, _NodeUtils);

      function LValParser() {
        return _NodeUtils.apply(this, arguments) || this;
      }

      var _proto = LValParser.prototype;

      _proto.toAssignable = function toAssignable(node) {
        var _node$extra, _node$extra3;

        var parenthesized = undefined;

        if (node.type === "ParenthesizedExpression" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {
          parenthesized = unwrapParenthesizedExpression(node);

          if (parenthesized.type !== "Identifier" && parenthesized.type !== "MemberExpression") {
            this.raise(node.start, Errors.InvalidParenthesizedAssignment);
          }
        }

        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            break;

          case "ObjectExpression":
            node.type = "ObjectPattern";

            for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;

              var prop = node.properties[i];
              var isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast);

              if (isLast && prop.type === "RestElement" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {
                this.raiseRestNotLast(node.extra.trailingComma);
              }
            }

            break;

          case "ObjectProperty":
            this.toAssignable(node.value);
            break;

          case "SpreadElement":
            {
              this.checkToRestConversion(node);
              node.type = "RestElement";
              var arg = node.argument;
              this.toAssignable(arg);
              break;
            }

          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);
            break;

          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, Errors.MissingEqInAssignment);
            }

            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left);
            break;

          case "ParenthesizedExpression":
            this.toAssignable(parenthesized);
            break;
        }

        return node;
      };

      _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast) {
        if (prop.type === "ObjectMethod") {
          var error = prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod;
          this.raise(prop.key.start, error);
        } else if (prop.type === "SpreadElement" && !isLast) {
          this.raiseRestNotLast(prop.start);
        } else {
          this.toAssignable(prop);
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos) {
        var end = exprList.length;

        if (end) {
          var last = exprList[end - 1];

          if (last && last.type === "RestElement") {
            --end;
          } else if (last && last.type === "SpreadElement") {
            last.type = "RestElement";
            var arg = last.argument;
            this.toAssignable(arg);

            if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
              this.unexpected(arg.start);
            }

            if (trailingCommaPos) {
              this.raiseTrailingCommaAfterRest(trailingCommaPos);
            }

            --end;
          }
        }

        for (var i = 0; i < end; i++) {
          var elt = exprList[i];

          if (elt) {
            this.toAssignable(elt);

            if (elt.type === "RestElement") {
              this.raiseRestNotLast(elt.start);
            }
          }
        }

        return exprList;
      };

      _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      };

      _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);

        for (var _i2 = 0; _i2 < exprList.length; _i2++) {
          var expr = exprList[_i2];

          if (expr && expr.type === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      };

      _proto.parseSpread = function parseSpread(refExpressionErrors, refNeedsArrowPos) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refExpressionErrors, undefined, refNeedsArrowPos);
        return this.finishNode(node, "SpreadElement");
      };

      _proto.parseRestBinding = function parseRestBinding() {
        var node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        switch (this.state.type) {
          case types.bracketL:
            {
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types.bracketR, 93, true);
              return this.finishNode(node, "ArrayPattern");
            }

          case types.braceL:
            return this.parseObj(types.braceR, true);
        }

        return this.parseIdentifier();
      };

      _proto.parseBindingList = function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
        var elts = [];
        var first = true;

        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);
          }

          if (allowEmpty && this.match(types.comma)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(types.ellipsis)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
            this.checkCommaAfterRest(closeCharCode);
            this.expect(close);
            break;
          } else {
            var decorators = [];

            if (this.match(types.at) && this.hasPlugin("decorators")) {
              this.raise(this.state.start, Errors.UnsupportedParameterDecorator);
            }

            while (this.match(types.at)) {
              decorators.push(this.parseDecorator());
            }

            elts.push(this.parseAssignableListItem(allowModifiers, decorators));
          }
        }

        return elts;
      };

      _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
        var left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

        if (decorators.length) {
          left.decorators = decorators;
        }

        return elt;
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        return param;
      };

      _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
        startLoc = startLoc || this.state.startLoc;
        startPos = startPos || this.state.start;
        left = left || this.parseBindingAtom();
        if (!this.eat(types.eq)) return left;
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };

      _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding, strictModeChanged) {
        if (bindingType === void 0) {
          bindingType = BIND_NONE;
        }

        if (strictModeChanged === void 0) {
          strictModeChanged = false;
        }

        switch (expr.type) {
          case "Identifier":
            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {
              this.raise(expr.start, bindingType === BIND_NONE ? Errors.StrictEvalArguments : Errors.StrictEvalArgumentsBinding, expr.name);
            }

            if (checkClashes) {
              var _key = "_" + expr.name;

              if (checkClashes[_key]) {
                this.raise(expr.start, Errors.ParamDupe);
              } else {
                checkClashes[_key] = true;
              }
            }

            if (disallowLetBinding && expr.name === "let") {
              this.raise(expr.start, Errors.LetInLexicalBinding);
            }

            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(expr.name, bindingType, expr.start);
            }

            break;

          case "MemberExpression":
            if (bindingType !== BIND_NONE) {
              this.raise(expr.start, Errors.InvalidPropertyBindingPattern);
            }

            break;

          case "ObjectPattern":
            for (var _i4 = 0, _expr$properties2 = expr.properties; _i4 < _expr$properties2.length; _i4++) {
              var prop = _expr$properties2[_i4];
              if (prop.type === "ObjectProperty") prop = prop.value;else if (prop.type === "ObjectMethod") continue;
              this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
            }

            break;

          case "ArrayPattern":
            for (var _i6 = 0, _expr$elements2 = expr.elements; _i6 < _expr$elements2.length; _i6++) {
              var elem = _expr$elements2[_i6];

              if (elem) {
                this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
              }
            }

            break;

          case "AssignmentPattern":
            this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
            break;

          case "RestElement":
            this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
            break;

          case "ParenthesizedExpression":
            this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
            break;

          default:
            {
              this.raise(expr.start, bindingType === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding, contextDescription);
            }
        }
      };

      _proto.checkToRestConversion = function checkToRestConversion(node) {
        if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
          this.raise(node.argument.start, Errors.InvalidRestAssignmentPattern);
        }
      };

      _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
        if (this.match(types.comma)) {
          if (this.lookaheadCharCode() === close) {
            this.raiseTrailingCommaAfterRest(this.state.start);
          } else {
            this.raiseRestNotLast(this.state.start);
          }
        }
      };

      _proto.raiseRestNotLast = function raiseRestNotLast(pos) {
        throw this.raise(pos, Errors.ElementAfterRest);
      };

      _proto.raiseTrailingCommaAfterRest = function raiseTrailingCommaAfterRest(pos) {
        this.raise(pos, Errors.RestTrailingComma);
      };

      return LValParser;
    }(NodeUtils);

    var ExpressionParser = function (_LValParser) {
      _inheritsLoose(ExpressionParser, _LValParser);

      function ExpressionParser() {
        return _LValParser.apply(this, arguments) || this;
      }

      var _proto = ExpressionParser.prototype;

      _proto.checkDuplicatedProto = function checkDuplicatedProto(prop, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || prop.computed || prop.kind || prop.shorthand) {
          return;
        }

        var key = prop.key;
        var name = key.type === "Identifier" ? key.name : String(key.value);

        if (name === "__proto__") {
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProto === -1) {
                refExpressionErrors.doubleProto = key.start;
              }
            } else {
              this.raise(key.start, Errors.DuplicateProto);
            }
          }

          protoRef.used = true;
        }
      };

      _proto.getExpression = function getExpression() {
        var paramFlags = PARAM;

        if (this.hasPlugin("topLevelAwait") && this.inModule) {
          paramFlags |= PARAM_AWAIT;
        }

        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
        this.nextToken();
        var expr = this.parseExpression();

        if (!this.match(types.eof)) {
          this.unexpected();
        }

        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        return expr;
      };

      _proto.parseExpression = function parseExpression(noIn, refExpressionErrors) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr = this.parseMaybeAssign(noIn, refExpressionErrors);

        if (this.match(types.comma)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];

          while (this.eat(types.comma)) {
            node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));
          }

          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }

        return expr;
      };

      _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;

        if (this.isContextual("yield")) {
          if (this.prodParam.hasYield) {
            var _left = this.parseYield(noIn);

            if (afterLeftParse) {
              _left = afterLeftParse.call(this, _left, startPos, startLoc);
            }

            return _left;
          } else {
            this.state.exprAllowed = false;
          }
        }

        var ownExpressionErrors;

        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }

        if (this.match(types.parenL) || this.match(types.name)) {
          this.state.potentialArrowAt = this.state.start;
        }

        var left = this.parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos);

        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }

        if (this.state.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          var operator = this.state.value;
          node.operator = operator;

          if (operator === "??=") {
            this.expectPlugin("logicalAssignment");
          }

          if (operator === "||=" || operator === "&&=") {
            this.expectPlugin("logicalAssignment");
          }

          if (this.match(types.eq)) {
            node.left = this.toAssignable(left);
            refExpressionErrors.doubleProto = -1;
          } else {
            node.left = left;
          }

          if (refExpressionErrors.shorthandAssign >= node.left.start) {
            refExpressionErrors.shorthandAssign = -1;
          }

          this.checkLVal(left, undefined, undefined, "assignment expression");
          this.next();
          node.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "AssignmentExpression");
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }

        return left;
      };

      _proto.parseMaybeConditional = function parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var potentialArrowAt = this.state.potentialArrowAt;
        var expr = this.parseExprOps(noIn, refExpressionErrors);

        if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
          return expr;
        }

        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
      };

      _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        if (this.eat(types.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types.colon);
          node.alternate = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "ConditionalExpression");
        }

        return expr;
      };

      _proto.parseExprOps = function parseExprOps(noIn, refExpressionErrors) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var potentialArrowAt = this.state.potentialArrowAt;
        var expr = this.parseMaybeUnary(refExpressionErrors);

        if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
          return expr;
        }

        if (this.checkExpressionErrors(refExpressionErrors, false)) {
          return expr;
        }

        return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
      };

      _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        var prec = this.state.type.binop;

        if (prec != null && (!noIn || !this.match(types._in))) {
          if (prec > minPrec) {
            var operator = this.state.value;

            if (operator === "|>" && this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            var node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.left = left;
            node.operator = operator;

            if (operator === "**" && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
              this.raise(left.argument.start, Errors.UnexpectedTokenUnaryExponentiation);
            }

            var op = this.state.type;
            var logical = op === types.logicalOR || op === types.logicalAND;
            var coalesce = op === types.nullishCoalescing;

            if (op === types.pipeline) {
              this.expectPlugin("pipelineOperator");
              this.state.inPipeline = true;
              this.checkPipelineAtInfixOperator(left, leftStartPos);
            } else if (coalesce) {
              prec = types.logicalAND.binop;
            }

            this.next();

            if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
              if (this.match(types.name) && this.state.value === "await" && this.prodParam.hasAwait) {
                throw this.raise(this.state.start, Errors.UnexpectedAwaitAfterPipelineBody);
              }
            }

            node.right = this.parseExprOpRightExpr(op, prec, noIn);
            this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            var nextOp = this.state.type;

            if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {
              throw this.raise(this.state.start, Errors.MixingCoalesceWithLogical);
            }

            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
          }
        }

        return left;
      };

      _proto.parseExprOpRightExpr = function parseExprOpRightExpr(op, prec, noIn) {
        var _this = this;

        var startPos = this.state.start;
        var startLoc = this.state.startLoc;

        switch (op) {
          case types.pipeline:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "smart":
                return this.withTopicPermittingContext(function () {
                  return _this.parseSmartPipelineBody(_this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);
                });

              case "fsharp":
                return this.withSoloAwaitPermittingContext(function () {
                  return _this.parseFSharpPipelineBody(prec, noIn);
                });
            }

          default:
            return this.parseExprOpBaseRightExpr(op, prec, noIn);
        }
      };

      _proto.parseExprOpBaseRightExpr = function parseExprOpBaseRightExpr(op, prec, noIn) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
      };

      _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
        if (this.isContextual("await") && this.isAwaitAllowed()) {
          return this.parseAwait();
        } else if (this.state.type.prefix) {
          var node = this.startNode();
          var update = this.match(types.incDec);
          node.operator = this.state.value;
          node.prefix = true;

          if (node.operator === "throw") {
            this.expectPlugin("throwExpressions");
          }

          this.next();
          node.argument = this.parseMaybeUnary();
          this.checkExpressionErrors(refExpressionErrors, true);

          if (update) {
            this.checkLVal(node.argument, undefined, undefined, "prefix operation");
          } else if (this.state.strict && node.operator === "delete") {
            var arg = node.argument;

            if (arg.type === "Identifier") {
              this.raise(node.start, Errors.StrictDelete);
            } else if (arg.type === "MemberExpression" && arg.property.type === "PrivateName") {
              this.raise(node.start, Errors.DeletePrivateField);
            }
          }

          return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        }

        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

        while (this.state.type.postfix && !this.canInsertSemicolon()) {
          var _node = this.startNodeAt(startPos, startLoc);

          _node.operator = this.state.value;
          _node.prefix = false;
          _node.argument = expr;
          this.checkLVal(expr, undefined, undefined, "postfix operation");
          this.next();
          expr = this.finishNode(_node, "UpdateExpression");
        }

        return expr;
      };

      _proto.parseExprSubscripts = function parseExprSubscripts(refExpressionErrors) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var potentialArrowAt = this.state.potentialArrowAt;
        var expr = this.parseExprAtom(refExpressionErrors);

        if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
          return expr;
        }

        return this.parseSubscripts(expr, startPos, startLoc);
      };

      _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
        var state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };

        do {
          var oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;

          if (state.maybeAsyncArrow) {
            this.state.maybeInAsyncArrowHead = true;
          }

          base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
          this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
        } while (!state.stop);

        return base;
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
        if (!noCalls && this.eat(types.doubleColon)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
        }

        var optional = false;
        var eventual = false;

        if (this.match(types.questionDot)) {
          state.optionalChainMember = optional = true;

          if (noCalls && this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }

          this.next();
        } else if (this.match(types.tildeDot)) {
          this.expectPlugin("eventualSend");
          eventual = true;

          if (noCalls && this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }

          this.next();
        }

        var computed = this.eat(types.bracketL);

        if ((optional || eventual) && !this.match(types.parenL) && !this.match(types.backQuote) || computed || this.eat(types.dot)) {
          var _node2 = this.startNodeAt(startPos, startLoc);

          _node2.object = base;
          _node2.property = computed ? this.parseExpression() : optional || eventual ? this.parseIdentifier(true) : this.parseMaybePrivateName(true);
          _node2.computed = computed;

          if (_node2.property.type === "PrivateName") {
            if (_node2.object.type === "Super") {
              this.raise(startPos, Errors.SuperPrivateField);
            }

            this.classScope.usePrivateName(_node2.property.id.name, _node2.property.start);
          }

          if (computed) {
            this.expect(types.bracketR);
          }

          if (state.optionalChainMember) {
            _node2.optional = optional;
            return this.finishNode(_node2, "OptionalMemberExpression");
          } else if (eventual) {
            base = this.finishNode(_node2, "EventualMemberExpression");

            if (noCalls || !this.match(types.parenL)) {
              return base;
            }
          } else {
            return this.finishNode(_node2, "MemberExpression");
          }
        }

        if (!noCalls && this.match(types.parenL)) {
          var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          var oldYieldPos = this.state.yieldPos;
          var oldAwaitPos = this.state.awaitPos;
          this.state.maybeInArrowParameters = true;
          this.state.yieldPos = -1;
          this.state.awaitPos = -1;
          this.next();

          var _node3 = this.startNodeAt(startPos, startLoc);

          _node3.callee = base;

          if (optional) {
            _node3.optional = true;
            _node3.arguments = this.parseCallExpressionArguments(types.parenR, false);
          } else {
            _node3.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", _node3);
          }

          this.finishCallExpression(_node3, state.optionalChainMember, eventual);

          if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !(optional || eventual)) {
            state.stop = true;
            _node3 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node3);
            this.checkYieldAwaitInDefaultParams();
            this.state.yieldPos = oldYieldPos;
            this.state.awaitPos = oldAwaitPos;
          } else {
            this.toReferencedListDeep(_node3.arguments);
            if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;

            if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {
              this.state.awaitPos = oldAwaitPos;
            }
          }

          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return _node3;
        } else if (this.match(types.backQuote)) {
          return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
        } else {
          state.stop = true;
          return base;
        }
      };

      _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
        var node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (typeArguments) node.typeParameters = typeArguments;

        if (state.optionalChainMember) {
          this.raise(startPos, Errors.OptionalChainingNoTemplate);
        }

        return this.finishNode(node, "TaggedTemplateExpression");
      };

      _proto.atPossibleAsyncArrow = function atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      };

      _proto.finishCallExpression = function finishCallExpression(node, optional, eventual) {
        if (node.callee.type === "Import") {
          if (node.arguments.length !== 1) {
            this.raise(node.start, Errors.ImportCallArity);
          } else {
            var importArg = node.arguments[0];

            if (importArg && importArg.type === "SpreadElement") {
              this.raise(importArg.start, Errors.ImportCallSpreadArgument);
            }
          }
        }

        if (eventual) {
          if (node.callee.type === "EventualMemberExpression") {
            var base = node.callee;
            node.callee = base.object;
            node.property = base.property;
            node.computed = base.computed;
            return this.finishNode(node, "EventualMemberCallExpression");
          }

          return this.finishNode(node, "EventualCallExpression");
        }

        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      };

      _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
        var elts = [];
        var innerParenStart;
        var first = true;
        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;

        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);

            if (this.match(close)) {
              if (dynamicImport) {
                this.raise(this.state.lastTokStart, Errors.ImportCallArgumentTrailingComma);
              }

              if (nodeForExtra) {
                this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
              }

              this.next();
              break;
            }
          }

          if (this.match(types.parenL) && !innerParenStart) {
            innerParenStart = this.state.start;
          }

          elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {
            start: 0
          } : undefined, allowPlaceholder));
        }

        if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
          this.unexpected();
        }

        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types.arrow) && !this.canInsertSemicolon();
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;

        this.expect(types.arrow);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
        return node;
      };

      _proto.parseNoCallExpr = function parseNoCallExpr() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      };

      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        if (this.state.type === types.slash) this.readRegexp();
        var canBeArrow = this.state.potentialArrowAt === this.state.start;
        var node;

        switch (this.state.type) {
          case types._super:
            node = this.startNode();
            this.next();

            if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
              this.raise(node.start, Errors.SuperNotAllowed);
            } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
              this.raise(node.start, Errors.UnexpectedSuper);
            }

            if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
              this.raise(node.start, Errors.UnsupportedSuper);
            }

            return this.finishNode(node, "Super");

          case types._import:
            node = this.startNode();
            this.next();

            if (this.match(types.dot)) {
              return this.parseImportMetaProperty(node);
            }

            if (!this.match(types.parenL)) {
              this.raise(this.state.lastTokStart, Errors.UnsupportedImport);
            }

            return this.finishNode(node, "Import");

          case types._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");

          case types.name:
            {
              node = this.startNode();
              var containsEsc = this.state.containsEsc;
              var id = this.parseIdentifier();

              if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
                var last = this.state.context.length - 1;

                if (this.state.context[last] !== types$1.functionStatement) {
                  throw new Error("Internal error");
                }

                this.state.context[last] = types$1.functionExpression;
                this.next();
                return this.parseFunction(node, undefined, true);
              } else if (canBeArrow && !containsEsc && id.name === "async" && this.match(types.name) && !this.canInsertSemicolon()) {
                var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                var oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;
                var oldYieldPos = this.state.yieldPos;
                var oldAwaitPos = this.state.awaitPos;
                this.state.maybeInArrowParameters = true;
                this.state.maybeInAsyncArrowHead = true;
                this.state.yieldPos = -1;
                this.state.awaitPos = -1;
                var params = [this.parseIdentifier()];
                this.expect(types.arrow);
                this.checkYieldAwaitInDefaultParams();
                this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
                this.state.yieldPos = oldYieldPos;
                this.state.awaitPos = oldAwaitPos;
                this.parseArrowExpression(node, params, true);
                return node;
              }

              if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
                this.next();
                this.parseArrowExpression(node, [id], false);
                return node;
              }

              return id;
            }

          case types._do:
            {
              this.expectPlugin("doExpressions");

              var _node4 = this.startNode();

              this.next();
              var oldLabels = this.state.labels;
              this.state.labels = [];
              _node4.body = this.parseBlock();
              this.state.labels = oldLabels;
              return this.finishNode(_node4, "DoExpression");
            }

          case types.regexp:
            {
              var value = this.state.value;
              node = this.parseLiteral(value.value, "RegExpLiteral");
              node.pattern = value.pattern;
              node.flags = value.flags;
              return node;
            }

          case types.num:
            return this.parseLiteral(this.state.value, "NumericLiteral");

          case types.bigint:
            return this.parseLiteral(this.state.value, "BigIntLiteral");

          case types.string:
            return this.parseLiteral(this.state.value, "StringLiteral");

          case types._null:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "NullLiteral");

          case types._true:
          case types._false:
            return this.parseBooleanLiteral();

          case types.parenL:
            return this.parseParenAndDistinguishExpression(canBeArrow);

          case types.bracketBarL:
          case types.bracketHashL:
            {
              this.expectPlugin("recordAndTuple");
              var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              var close = this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR;
              this.state.inFSharpPipelineDirectBody = false;
              node = this.startNode();
              this.next();
              node.elements = this.parseExprList(close, true, refExpressionErrors, node);
              this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
              return this.finishNode(node, "TupleExpression");
            }

          case types.bracketL:
            {
              var _oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              node = this.startNode();
              this.next();
              node.elements = this.parseExprList(types.bracketR, true, refExpressionErrors, node);

              if (!this.state.maybeInArrowParameters) {
                this.toReferencedList(node.elements);
              }

              this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody;
              return this.finishNode(node, "ArrayExpression");
            }

          case types.braceBarL:
          case types.braceHashL:
            {
              this.expectPlugin("recordAndTuple");
              var _oldInFSharpPipelineDirectBody2 = this.state.inFSharpPipelineDirectBody;

              var _close = this.state.type === types.braceBarL ? types.braceBarR : types.braceR;

              this.state.inFSharpPipelineDirectBody = false;
              var ret = this.parseObj(_close, false, true, refExpressionErrors);
              this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody2;
              return ret;
            }

          case types.braceL:
            {
              var _oldInFSharpPipelineDirectBody3 = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;

              var _ret = this.parseObj(types.braceR, false, false, refExpressionErrors);

              this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody3;
              return _ret;
            }

          case types._function:
            return this.parseFunctionExpression();

          case types.at:
            this.parseDecorators();

          case types._class:
            node = this.startNode();
            this.takeDecorators(node);
            return this.parseClass(node, false);

          case types._new:
            return this.parseNew();

          case types.backQuote:
            return this.parseTemplate(false);

          case types.doubleColon:
            {
              node = this.startNode();
              this.next();
              node.object = null;
              var callee = node.callee = this.parseNoCallExpr();

              if (callee.type === "MemberExpression") {
                return this.finishNode(node, "BindExpression");
              } else {
                throw this.raise(callee.start, Errors.UnsupportedBind);
              }
            }

          case types.hash:
            {
              if (this.state.inPipeline) {
                node = this.startNode();

                if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                  this.raise(node.start, Errors.PrimaryTopicRequiresSmartPipeline);
                }

                this.next();

                if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                  this.raise(node.start, Errors.PrimaryTopicNotAllowed);
                }

                this.registerTopicReference();
                return this.finishNode(node, "PipelinePrimaryTopicReference");
              }
            }

          default:
            throw this.unexpected();
        }
      };

      _proto.parseBooleanLiteral = function parseBooleanLiteral() {
        var node = this.startNode();
        node.value = this.match(types._true);
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      };

      _proto.parseMaybePrivateName = function parseMaybePrivateName(isPrivateNameAllowed) {
        var isPrivate = this.match(types.hash);

        if (isPrivate) {
          this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);

          if (!isPrivateNameAllowed) {
            this.raise(this.state.pos, Errors.UnexpectedPrivateField);
          }

          var node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space between # and identifier");
          node.id = this.parseIdentifier(true);
          return this.finishNode(node, "PrivateName");
        } else {
          return this.parseIdentifier(true);
        }
      };

      _proto.parseFunctionExpression = function parseFunctionExpression() {
        var node = this.startNode();
        var meta = this.startNode();
        this.next();
        meta = this.createIdentifier(meta, "function");

        if (this.prodParam.hasYield && this.eat(types.dot)) {
          return this.parseMetaProperty(node, meta, "sent");
        }

        return this.parseFunction(node);
      };

      _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;

        if (meta.name === "function" && propertyName === "sent") {
          if (this.isContextual(propertyName)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
        }

        var containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);

        if (node.property.name !== propertyName || containsEsc) {
          this.raise(node.property.start, Errors.UnsupportedMetaProperty, meta.name, propertyName);
        }

        return this.finishNode(node, "MetaProperty");
      };

      _proto.parseImportMetaProperty = function parseImportMetaProperty(node) {
        var id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.expect(types.dot);

        if (this.isContextual("meta")) {
          this.expectPlugin("importMeta");

          if (!this.inModule) {
            this.raiseWithData(id.start, {
              code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
            }, Errors.ImportMetaOutsideModule);
          }

          this.sawUnambiguousESM = true;
        } else if (!this.hasPlugin("importMeta")) {
          this.raise(id.start, Errors.ImportCallArityLtOne);
        }

        return this.parseMetaProperty(node, id, "meta");
      };

      _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        var node = this.startNodeAt(startPos, startLoc);
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      };

      _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var val;
        this.expect(types.parenL);
        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.state.inFSharpPipelineDirectBody = false;
        var innerStartPos = this.state.start;
        var innerStartLoc = this.state.startLoc;
        var exprList = [];
        var refExpressionErrors = new ExpressionErrors();
        var refNeedsArrowPos = {
          start: 0
        };
        var first = true;
        var spreadStart;
        var optionalCommaStart;

        while (!this.match(types.parenR)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma, refNeedsArrowPos.start || null);

            if (this.match(types.parenR)) {
              optionalCommaStart = this.state.start;
              break;
            }
          }

          if (this.match(types.ellipsis)) {
            var spreadNodeStartPos = this.state.start;
            var spreadNodeStartLoc = this.state.startLoc;
            spreadStart = this.state.start;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
            this.checkCommaAfterRest(41);
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
          }
        }

        var innerEndPos = this.state.start;
        var innerEndLoc = this.state.startLoc;
        this.expect(types.parenR);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        var arrowNode = this.startNodeAt(startPos, startLoc);

        if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
          if (!this.isAwaitAllowed() && !this.state.maybeInAsyncArrowHead) {
            this.state.awaitPos = oldAwaitPos;
          }

          this.checkYieldAwaitInDefaultParams();
          this.state.yieldPos = oldYieldPos;
          this.state.awaitPos = oldAwaitPos;

          for (var _i2 = 0; _i2 < exprList.length; _i2++) {
            var param = exprList[_i2];

            if (param.extra && param.extra.parenthesized) {
              this.unexpected(param.extra.parenStart);
            }
          }

          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }

        if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;
        if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;

        if (!exprList.length) {
          this.unexpected(this.state.lastTokStart);
        }

        if (optionalCommaStart) this.unexpected(optionalCommaStart);
        if (spreadStart) this.unexpected(spreadStart);
        this.checkExpressionErrors(refExpressionErrors, true);
        if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
        this.toReferencedListDeep(exprList, true);

        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }

        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(val, "parenthesized", true);
          this.addExtra(val, "parenStart", startPos);
          return val;
        }

        var parenExpression = this.startNodeAt(startPos, startLoc);
        parenExpression.expression = val;
        this.finishNode(parenExpression, "ParenthesizedExpression");
        return parenExpression;
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return !this.canInsertSemicolon();
      };

      _proto.parseArrow = function parseArrow(node) {
        if (this.eat(types.arrow)) {
          return node;
        }
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        return node;
      };

      _proto.parseNew = function parseNew() {
        var node = this.startNode();
        var meta = this.startNode();
        this.next();
        meta = this.createIdentifier(meta, "new");

        if (this.eat(types.dot)) {
          var metaProp = this.parseMetaProperty(node, meta, "target");

          if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
            var error = Errors.UnexpectedNewTarget;

            if (this.hasPlugin("classProperties")) {
              error += " or class properties";
            }

            this.raise(metaProp.start, error);
          }

          return metaProp;
        }

        node.callee = this.parseNoCallExpr();

        if (node.callee.type === "Import") {
          this.raise(node.callee.start, Errors.ImportCallNotNewExpression);
        } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
          this.raise(this.state.lastTokEnd, Errors.OptionalChainingNoNew);
        } else if (node.callee.type === "EventualMemberExpression" || node.callee.type === "EventualCallExpression") {
          this.raise(this.state.lastTokEnd, Errors.EventualNoNew);
        } else if (this.eat(types.questionDot)) {
          this.raise(this.state.start, Errors.OptionalChainingNoNew);
        } else if (this.eat(types.tildeDot)) {
          this.expectPlugin("eventualSend");
          this.raise(this.state.start, Errors.EventualNoNew);
        }

        this.parseNewArguments(node);
        return this.finishNode(node, "NewExpression");
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        if (this.eat(types.parenL)) {
          var args = this.parseExprList(types.parenR);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
      };

      _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
        var elem = this.startNode();

        if (this.state.value === null) {
          if (!isTagged) {
            this.raise(this.state.start + 1, Errors.InvalidEscapeSequenceTemplate);
          }
        }

        elem.value = {
          raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
          cooked: this.state.value
        };
        this.next();
        elem.tail = this.match(types.backQuote);
        return this.finishNode(elem, "TemplateElement");
      };

      _proto.parseTemplate = function parseTemplate(isTagged) {
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement(isTagged);
        node.quasis = [curElt];

        while (!curElt.tail) {
          this.expect(types.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types.braceR);
          node.quasis.push(curElt = this.parseTemplateElement(isTagged));
        }

        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };

      _proto.parseObj = function parseObj(close, isPattern, isRecord, refExpressionErrors) {
        var propHash = Object.create(null);
        var first = true;
        var node = this.startNode();
        node.properties = [];
        this.next();

        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);

            if (this.match(close)) {
              this.addExtra(node, "trailingComma", this.state.lastTokStart);
              this.next();
              break;
            }
          }

          var prop = this.parseObjectMember(isPattern, refExpressionErrors);

          if (!isPattern) {
            this.checkDuplicatedProto(prop, propHash, refExpressionErrors);
          }

          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }

          node.properties.push(prop);
        }

        var type = "ObjectExpression";

        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }

        return this.finishNode(node, type);
      };

      _proto.isAsyncProp = function isAsyncProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();
      };

      _proto.parseObjectMember = function parseObjectMember(isPattern, refExpressionErrors) {
        var decorators = [];

        if (this.match(types.at)) {
          if (this.hasPlugin("decorators")) {
            this.raise(this.state.start, Errors.UnsupportedPropertyDecorator);
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }
        }

        var prop = this.startNode();
        var isGenerator = false;
        var isAsync = false;
        var startPos;
        var startLoc;

        if (this.match(types.ellipsis)) {
          if (decorators.length) this.unexpected();

          if (isPattern) {
            this.next();
            prop.argument = this.parseIdentifier();
            this.checkCommaAfterRest(125);
            return this.finishNode(prop, "RestElement");
          }

          return this.parseSpread();
        }

        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }

        prop.method = false;

        if (isPattern || refExpressionErrors) {
          startPos = this.state.start;
          startLoc = this.state.startLoc;
        }

        if (!isPattern) {
          isGenerator = this.eat(types.star);
        }

        var containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, false);

        if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.eat(types.star);
          this.parsePropertyName(prop, false);
        } else {
          isAsync = false;
        }

        this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);
        return prop;
      };

      _proto.isGetterOrSetterMethod = function isGetterOrSetterMethod(prop, isPattern) {
        return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);
      };

      _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      };

      _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
        var paramCount = this.getGetterSetterExpectedParamCount(method);
        var start = method.start;

        if (method.params.length !== paramCount) {
          if (method.kind === "get") {
            this.raise(start, Errors.BadGetterArity);
          } else {
            this.raise(start, Errors.BadSetterArity);
          }
        }

        if (method.kind === "set" && method.params[method.params.length - 1].type === "RestElement") {
          this.raise(start, Errors.BadSetterRestParameter);
        }
      };

      _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
        if (isAsync || isGenerator || this.match(types.parenL)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }

        if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
          if (isGenerator || isAsync) this.unexpected();
          prop.kind = prop.key.name;
          this.parsePropertyName(prop, false);
          this.parseMethod(prop, false, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(prop);
          return prop;
        }
      };

      _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;

        if (this.eat(types.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }

        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.start, true, true);

          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
          } else if (this.match(types.eq) && refExpressionErrors) {
            if (refExpressionErrors.shorthandAssign === -1) {
              refExpressionErrors.shorthandAssign = this.state.start;
            }

            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
          } else {
            prop.value = prop.key.__clone();
          }

          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
        var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
      };

      _proto.parsePropertyName = function parsePropertyName(prop, isPrivateNameAllowed) {
        if (this.eat(types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types.bracketR);
        } else {
          var oldInPropertyName = this.state.inPropertyName;
          this.state.inPropertyName = true;
          prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

          if (prop.key.type !== "PrivateName") {
            prop.computed = false;
          }

          this.state.inPropertyName = oldInPropertyName;
        }

        return prop.key;
      };

      _proto.initFunction = function initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = !!isAsync;
      };

      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        if (inClassScope === void 0) {
          inClassScope = false;
        }

        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.initFunction(node, isAsync);
        node.generator = !!isGenerator;
        var allowModifiers = isConstructor;
        this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, allowModifiers);
        this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;
        return node;
      };

      _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        this.prodParam.enter(functionFlags(isAsync, false));
        this.initFunction(node, isAsync);
        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;

        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaPos);
        }

        this.state.maybeInArrowParameters = false;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };

      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaPos) {
        node.params = this.toAssignableList(params, trailingCommaPos);
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        this.parseFunctionBody(node, false, isMethod);
        this.finishNode(node, type);
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
        var _this2 = this;

        if (isMethod === void 0) {
          isMethod = false;
        }

        var isExpression = allowExpression && !this.match(types.braceL);
        var oldInParameters = this.state.inParameters;
        this.state.inParameters = false;

        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          var oldStrict = this.state.strict;
          var oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
          node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
            var nonSimple = !_this2.isSimpleParamList(node.params);

            if (hasStrictModeDirective && nonSimple) {
              var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;

              _this2.raise(errorPos, Errors.IllegalLanguageModeDirective);
            }

            var strictModeChanged = !oldStrict && _this2.state.strict;

            _this2.checkParams(node, !_this2.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

            if (_this2.state.strict && node.id) {
              _this2.checkLVal(node.id, BIND_OUTSIDE, undefined, "function name", undefined, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }

        this.state.inParameters = oldInParameters;
      };

      _proto.isSimpleParamList = function isSimpleParamList(params) {
        for (var i = 0, len = params.length; i < len; i++) {
          if (params[i].type !== "Identifier") return false;
        }

        return true;
      };

      _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
        if (strictModeChanged === void 0) {
          strictModeChanged = true;
        }

        var nameHash = Object.create(null);

        for (var i = 0; i < node.params.length; i++) {
          this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, "function parameter list", undefined, strictModeChanged);
        }
      };

      _proto.parseExprList = function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        var elts = [];
        var first = true;

        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);

            if (this.match(close)) {
              if (nodeForExtra) {
                this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
              }

              this.next();
              break;
            }
          }

          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }

        return elts;
      };

      _proto.parseExprListItem = function parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
        var elt;

        if (allowEmpty && this.match(types.comma)) {
          elt = null;
        } else if (this.match(types.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
        } else if (this.match(types.question)) {
          this.expectPlugin("partialApplication");

          if (!allowPlaceholder) {
            this.raise(this.state.start, Errors.UnexpectedArgumentPlaceholder);
          }

          var node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
        }

        return elt;
      };

      _proto.parseIdentifier = function parseIdentifier(liberal) {
        var node = this.startNode();
        var name = this.parseIdentifierName(node.start, liberal);
        return this.createIdentifier(node, name);
      };

      _proto.createIdentifier = function createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      };

      _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {
        var name;

        if (this.match(types.name)) {
          name = this.state.value;
        } else if (this.state.type.keyword) {
          name = this.state.type.keyword;
          var context = this.state.context;

          if ((name === "class" || name === "function") && context[context.length - 1].token === "function") {
            context.pop();
          }
        } else {
          throw this.unexpected();
        }

        if (liberal) {
          this.state.type = types.name;
        } else {
          this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);
        }

        this.next();
        return name;
      };

      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (this.prodParam.hasYield && word === "yield") {
          this.raise(startLoc, Errors.YieldBindingIdentifier);
          return;
        }

        if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(startLoc, Errors.AwaitBindingIdentifier);
            return;
          }

          if (this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed())) {
            this.state.awaitPos = this.state.start;
          }
        }

        if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
          this.raise(startLoc, Errors.ArgumentsDisallowedInInitializer);
          return;
        }

        if (checkKeywords && isKeyword(word)) {
          this.raise(startLoc, Errors.UnexpectedKeyword, word);
          return;
        }

        var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

        if (reservedTest(word, this.inModule)) {
          if (!this.prodParam.hasAwait && word === "await") {
            this.raise(startLoc, Errors.AwaitNotInAsyncFunction);
          } else {
            this.raise(startLoc, Errors.UnexpectedReservedWord, word);
          }
        }
      };

      _proto.isAwaitAllowed = function isAwaitAllowed() {
        if (this.scope.inFunction) return this.prodParam.hasAwait;
        if (this.options.allowAwaitOutsideFunction) return true;

        if (this.hasPlugin("topLevelAwait")) {
          return this.inModule && this.prodParam.hasAwait;
        }

        return false;
      };

      _proto.parseAwait = function parseAwait() {
        var node = this.startNode();
        this.next();

        if (this.state.inParameters) {
          this.raise(node.start, Errors.AwaitExpressionFormalParameter);
        } else if (this.state.awaitPos === -1) {
          this.state.awaitPos = node.start;
        }

        if (this.eat(types.star)) {
          this.raise(node.start, Errors.ObsoleteAwaitStar);
        }

        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }

        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary();
        }

        return this.finishNode(node, "AwaitExpression");
      };

      _proto.parseYield = function parseYield(noIn) {
        var node = this.startNode();

        if (this.state.inParameters) {
          this.raise(node.start, Errors.YieldInParameter);
        } else if (this.state.yieldPos === -1) {
          this.state.yieldPos = node.start;
        }

        this.next();

        if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types.star);
          node.argument = this.parseMaybeAssign(noIn);
        }

        return this.finishNode(node, "YieldExpression");
      };

      _proto.checkPipelineAtInfixOperator = function checkPipelineAtInfixOperator(left, leftStartPos) {
        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
          if (left.type === "SequenceExpression") {
            this.raise(leftStartPos, Errors.PipelineHeadSequenceExpression);
          }
        }
      };

      _proto.parseSmartPipelineBody = function parseSmartPipelineBody(childExpression, startPos, startLoc) {
        var pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
        this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);
        return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
      };

      _proto.checkSmartPipelineBodyEarlyErrors = function checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
        if (this.match(types.arrow)) {
          throw this.raise(this.state.start, Errors.PipelineBodyNoArrow);
        } else if (pipelineStyle === "PipelineTopicExpression" && childExpression.type === "SequenceExpression") {
          this.raise(startPos, Errors.PipelineBodySequenceExpression);
        }
      };

      _proto.parseSmartPipelineBodyInStyle = function parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
        var bodyNode = this.startNodeAt(startPos, startLoc);

        switch (pipelineStyle) {
          case "PipelineBareFunction":
            bodyNode.callee = childExpression;
            break;

          case "PipelineBareConstructor":
            bodyNode.callee = childExpression.callee;
            break;

          case "PipelineBareAwaitedFunction":
            bodyNode.callee = childExpression.argument;
            break;

          case "PipelineTopicExpression":
            if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
              this.raise(startPos, Errors.PipelineTopicUnused);
            }

            bodyNode.expression = childExpression;
            break;

          default:
            throw new Error("Internal @babel/parser error: Unknown pipeline style (" + pipelineStyle + ")");
        }

        return this.finishNode(bodyNode, pipelineStyle);
      };

      _proto.checkSmartPipelineBodyStyle = function checkSmartPipelineBodyStyle(expression) {
        switch (expression.type) {
          default:
            return this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
        }
      };

      _proto.isSimpleReference = function isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);

          case "Identifier":
            return true;

          default:
            return false;
        }
      };

      _proto.withTopicPermittingContext = function withTopicPermittingContext(callback) {
        var outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };

        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      };

      _proto.withTopicForbiddingContext = function withTopicForbiddingContext(callback) {
        var outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };

        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      };

      _proto.withSoloAwaitPermittingContext = function withSoloAwaitPermittingContext(callback) {
        var outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;

        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      };

      _proto.registerTopicReference = function registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      };

      _proto.primaryTopicReferenceIsAllowedInCurrentTopicContext = function primaryTopicReferenceIsAllowedInCurrentTopicContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      };

      _proto.topicReferenceWasUsedInCurrentTopicContext = function topicReferenceWasUsedInCurrentTopicContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      };

      _proto.parseFSharpPipelineBody = function parseFSharpPipelineBody(prec, noIn) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      };

      return ExpressionParser;
    }(LValParser);

    var loopLabel = {
      kind: "loop"
    },
        switchLabel = {
      kind: "switch"
    };
    var FUNC_NO_FLAGS = 0,
        FUNC_STATEMENT = 1,
        FUNC_HANGING_STATEMENT = 2,
        FUNC_NULLABLE_ID = 4;

    var StatementParser = function (_ExpressionParser) {
      _inheritsLoose(StatementParser, _ExpressionParser);

      function StatementParser() {
        return _ExpressionParser.apply(this, arguments) || this;
      }

      var _proto = StatementParser.prototype;

      _proto.parseTopLevel = function parseTopLevel(file, program) {
        program.sourceType = this.options.sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, types.eof);

        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (var _i2 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i2 < _Array$from2.length; _i2++) {
            var _Array$from2$_i = _Array$from2[_i2],
                name = _Array$from2$_i[0];
            var pos = this.scope.undefinedExports.get(name);
            this.raise(pos, Errors.ModuleExportUndefined, name);
          }
        }

        file.program = this.finishNode(program, "Program");
        file.comments = this.state.comments;
        if (this.options.tokens) file.tokens = this.tokens;
        return this.finishNode(file, "File");
      };

      _proto.stmtToDirective = function stmtToDirective(stmt) {
        var expr = stmt.expression;
        var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
        var directive = this.startNodeAt(stmt.start, stmt.loc.start);
        var raw = this.input.slice(expr.start, expr.end);
        var val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
        return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
      };

      _proto.parseInterpreterDirective = function parseInterpreterDirective() {
        if (!this.match(types.interpreterDirective)) {
          return null;
        }

        var node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      };

      _proto.isLet = function isLet(context) {
        if (!this.isContextual("let")) {
          return false;
        }

        var next = this.nextTokenStart();
        var nextCh = this.input.charCodeAt(next);
        if (nextCh === 91) return true;
        if (context) return false;
        if (nextCh === 123) return true;

        if (isIdentifierStart(nextCh)) {
          var pos = next + 1;

          while (isIdentifierChar(this.input.charCodeAt(pos))) {
            ++pos;
          }

          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) return true;
        }

        return false;
      };

      _proto.parseStatement = function parseStatement(context, topLevel) {
        if (this.match(types.at)) {
          this.parseDecorators(true);
        }

        return this.parseStatementContent(context, topLevel);
      };

      _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
        var starttype = this.state.type;
        var node = this.startNode();
        var kind;

        if (this.isLet(context)) {
          starttype = types._var;
          kind = "let";
        }

        switch (starttype) {
          case types._break:
          case types._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);

          case types._debugger:
            return this.parseDebuggerStatement(node);

          case types._do:
            return this.parseDoStatement(node);

          case types._for:
            return this.parseForStatement(node);

          case types._function:
            if (this.lookaheadCharCode() === 46) break;

            if (context) {
              if (this.state.strict) {
                this.raise(this.state.start, Errors.StrictFunction);
              } else if (context !== "if" && context !== "label") {
                this.raise(this.state.start, Errors.SloppyFunction);
              }
            }

            return this.parseFunctionStatement(node, false, !context);

          case types._class:
            if (context) this.unexpected();
            return this.parseClass(node, true);

          case types._if:
            return this.parseIfStatement(node);

          case types._return:
            return this.parseReturnStatement(node);

          case types._switch:
            return this.parseSwitchStatement(node);

          case types._throw:
            return this.parseThrowStatement(node);

          case types._try:
            return this.parseTryStatement(node);

          case types._const:
          case types._var:
            kind = kind || this.state.value;

            if (context && kind !== "var") {
              this.raise(this.state.start, Errors.UnexpectedLexicalDeclaration);
            }

            return this.parseVarStatement(node, kind);

          case types._while:
            return this.parseWhileStatement(node);

          case types._with:
            return this.parseWithStatement(node);

          case types.braceL:
            return this.parseBlock();

          case types.semi:
            return this.parseEmptyStatement(node);

          case types._export:
          case types._import:
            {
              var nextTokenCharCode = this.lookaheadCharCode();

              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }

              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(this.state.start, Errors.UnexpectedImportExport);
              }

              this.next();
              var result;

              if (starttype === types._import) {
                result = this.parseImport(node);

                if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result = this.parseExport(node);

                if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }

              this.assertModuleNodeAllowed(node);
              return result;
            }

          default:
            {
              if (this.isAsyncFunction()) {
                if (context) {
                  this.raise(this.state.start, Errors.AsyncFunctionInSingleStatementContext);
                }

                this.next();
                return this.parseFunctionStatement(node, true, !context);
              }
            }
        }

        var maybeName = this.state.value;
        var expr = this.parseExpression();

        if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
          return this.parseLabeledStatement(node, maybeName, expr, context);
        } else {
          return this.parseExpressionStatement(node, expr);
        }
      };

      _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raiseWithData(node.start, {
            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
          }, Errors.ImportOutsideModule);
        }
      };

      _proto.takeDecorators = function takeDecorators(node) {
        var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

        if (decorators.length) {
          node.decorators = decorators;
          this.resetStartLocationFromNode(node, decorators[0]);
          this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
        }
      };

      _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
        return this.match(types._class);
      };

      _proto.parseDecorators = function parseDecorators(allowExport) {
        var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

        while (this.match(types.at)) {
          var decorator = this.parseDecorator();
          currentContextDecorators.push(decorator);
        }

        if (this.match(types._export)) {
          if (!allowExport) {
            this.unexpected();
          }

          if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(this.state.start, Errors.DecoratorExportClass);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(this.state.start, Errors.UnexpectedLeadingDecorator);
        }
      };

      _proto.parseDecorator = function parseDecorator() {
        this.expectOnePlugin(["decorators-legacy", "decorators"]);
        var node = this.startNode();
        this.next();

        if (this.hasPlugin("decorators")) {
          this.state.decoratorStack.push([]);
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var expr;

          if (this.eat(types.parenL)) {
            expr = this.parseExpression();
            this.expect(types.parenR);
          } else {
            expr = this.parseIdentifier(false);

            while (this.eat(types.dot)) {
              var _node = this.startNodeAt(startPos, startLoc);

              _node.object = expr;
              _node.property = this.parseIdentifier(true);
              _node.computed = false;
              expr = this.finishNode(_node, "MemberExpression");
            }
          }

          node.expression = this.parseMaybeDecoratorArguments(expr);
          this.state.decoratorStack.pop();
        } else {
          node.expression = this.parseExprSubscripts();
        }

        return this.finishNode(node, "Decorator");
      };

      _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
        if (this.eat(types.parenL)) {
          var node = this.startNodeAtNode(expr);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }

        return expr;
      };

      _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {
        var isBreak = keyword === "break";
        this.next();

        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }

        this.verifyBreakContinue(node, keyword);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };

      _proto.verifyBreakContinue = function verifyBreakContinue(node, keyword) {
        var isBreak = keyword === "break";
        var i;

        for (i = 0; i < this.state.labels.length; ++i) {
          var lab = this.state.labels[i];

          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
            if (node.label && isBreak) break;
          }
        }

        if (i === this.state.labels.length) {
          this.raise(node.start, Errors.IllegalBreakContinue, keyword);
        }
      };

      _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };

      _proto.parseHeaderExpression = function parseHeaderExpression() {
        this.expect(types.parenL);
        var val = this.parseExpression();
        this.expect(types.parenR);
        return val;
      };

      _proto.parseDoStatement = function parseDoStatement(node) {
        var _this = this;

        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withTopicForbiddingContext(function () {
          return _this.parseStatement("do");
        });
        this.state.labels.pop();
        this.expect(types._while);
        node.test = this.parseHeaderExpression();
        this.eat(types.semi);
        return this.finishNode(node, "DoWhileStatement");
      };

      _proto.parseForStatement = function parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        var awaitAt = -1;

        if (this.isAwaitAllowed() && this.eatContextual("await")) {
          awaitAt = this.state.lastTokStart;
        }

        this.scope.enter(SCOPE_OTHER);
        this.expect(types.parenL);

        if (this.match(types.semi)) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }

          return this.parseFor(node, null);
        }

        var isLet = this.isLet();

        if (this.match(types._var) || this.match(types._const) || isLet) {
          var _init = this.startNode();

          var kind = isLet ? "let" : this.state.value;
          this.next();
          this.parseVar(_init, true, kind);
          this.finishNode(_init, "VariableDeclaration");

          if ((this.match(types._in) || this.isContextual("of")) && _init.declarations.length === 1) {
            return this.parseForIn(node, _init, awaitAt);
          }

          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }

          return this.parseFor(node, _init);
        }

        var refExpressionErrors = new ExpressionErrors();
        var init = this.parseExpression(true, refExpressionErrors);

        if (this.match(types._in) || this.isContextual("of")) {
          this.toAssignable(init);
          var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
          this.checkLVal(init, undefined, undefined, description);
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, init);
      };

      _proto.parseFunctionStatement = function parseFunctionStatement(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
      };

      _proto.parseIfStatement = function parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };

      _proto.parseReturnStatement = function parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(this.state.start, Errors.IllegalReturn);
        }

        this.next();

        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }

        return this.finishNode(node, "ReturnStatement");
      };

      _proto.parseSwitchStatement = function parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        var cases = node.cases = [];
        this.expect(types.braceL);
        this.state.labels.push(switchLabel);
        this.scope.enter(SCOPE_OTHER);
        var cur;

        for (var sawDefault; !this.match(types.braceR);) {
          if (this.match(types._case) || this.match(types._default)) {
            var isCase = this.match(types._case);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();

            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(this.state.lastTokStart, Errors.MultipleDefaultsInSwitch);
              }

              sawDefault = true;
              cur.test = null;
            }

            this.expect(types.colon);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatement(null));
            } else {
              this.unexpected();
            }
          }
        }

        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };

      _proto.parseThrowStatement = function parseThrowStatement(node) {
        this.next();

        if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
          this.raise(this.state.lastTokEnd, Errors.NewlineAfterThrow);
        }

        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };

      _proto.parseTryStatement = function parseTryStatement(node) {
        var _this2 = this;

        this.next();
        node.block = this.parseBlock();
        node.handler = null;

        if (this.match(types._catch)) {
          var clause = this.startNode();
          this.next();

          if (this.match(types.parenL)) {
            this.expect(types.parenL);
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLVal(clause.param, BIND_LEXICAL, null, "catch clause");
            this.expect(types.parenR);
          } else {
            clause.param = null;
            this.scope.enter(SCOPE_OTHER);
          }

          clause.body = this.withTopicForbiddingContext(function () {
            return _this2.parseBlock(false, false);
          });
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }

        node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

        if (!node.handler && !node.finalizer) {
          this.raise(node.start, Errors.NoCatchOrFinally);
        }

        return this.finishNode(node, "TryStatement");
      };

      _proto.parseVarStatement = function parseVarStatement(node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };

      _proto.parseWhileStatement = function parseWhileStatement(node) {
        var _this3 = this;

        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withTopicForbiddingContext(function () {
          return _this3.parseStatement("while");
        });
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };

      _proto.parseWithStatement = function parseWithStatement(node) {
        var _this4 = this;

        if (this.state.strict) {
          this.raise(this.state.start, Errors.StrictWith);
        }

        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withTopicForbiddingContext(function () {
          return _this4.parseStatement("with");
        });
        return this.finishNode(node, "WithStatement");
      };

      _proto.parseEmptyStatement = function parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };

      _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr, context) {
        for (var _i4 = 0, _this$state$labels2 = this.state.labels; _i4 < _this$state$labels2.length; _i4++) {
          var label = _this$state$labels2[_i4];

          if (label.name === maybeName) {
            this.raise(expr.start, Errors.LabelRedeclaration, maybeName);
          }
        }

        var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

        for (var i = this.state.labels.length - 1; i >= 0; i--) {
          var _label = this.state.labels[i];

          if (_label.statementStart === node.start) {
            _label.statementStart = this.state.start;
            _label.kind = kind;
          } else {
            break;
          }
        }

        this.state.labels.push({
          name: maybeName,
          kind: kind,
          statementStart: this.state.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };

      _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        if (allowDirectives === void 0) {
          allowDirectives = false;
        }

        if (createNewLexicalScope === void 0) {
          createNewLexicalScope = true;
        }

        var node = this.startNode();
        this.expect(types.braceL);

        if (createNewLexicalScope) {
          this.scope.enter(SCOPE_OTHER);
        }

        this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);

        if (createNewLexicalScope) {
          this.scope.exit();
        }

        return this.finishNode(node, "BlockStatement");
      };

      _proto.isValidDirective = function isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      };

      _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        var body = node.body = [];
        var directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
      };

      _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        var octalPositions = [];
        var oldStrict = this.state.strict;
        var hasStrictModeDirective = false;
        var parsedNonDirective = false;

        while (!this.match(end)) {
          if (!parsedNonDirective && this.state.octalPositions.length) {
            octalPositions.push.apply(octalPositions, this.state.octalPositions);
          }

          var stmt = this.parseStatement(null, topLevel);

          if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
            var directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          body.push(stmt);
        }

        if (this.state.strict && octalPositions.length) {
          for (var _i6 = 0; _i6 < octalPositions.length; _i6++) {
            var pos = octalPositions[_i6];
            this.raise(pos, Errors.StrictOctalLiteral);
          }
        }

        if (afterBlockParse) {
          afterBlockParse.call(this, hasStrictModeDirective);
        }

        if (!oldStrict) {
          this.setStrict(false);
        }

        this.next();
      };

      _proto.parseFor = function parseFor(node, init) {
        var _this5 = this;

        node.init = init;
        this.expect(types.semi);
        node.test = this.match(types.semi) ? null : this.parseExpression();
        this.expect(types.semi);
        node.update = this.match(types.parenR) ? null : this.parseExpression();
        this.expect(types.parenR);
        node.body = this.withTopicForbiddingContext(function () {
          return _this5.parseStatement("for");
        });
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      };

      _proto.parseForIn = function parseForIn(node, init, awaitAt) {
        var _this6 = this;

        var isForIn = this.match(types._in);
        this.next();

        if (isForIn) {
          if (awaitAt > -1) this.unexpected(awaitAt);
        } else {
          node["await"] = awaitAt > -1;
        }

        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, Errors.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
        } else if (init.type === "AssignmentPattern") {
          this.raise(init.start, Errors.InvalidLhs, "for-loop");
        }

        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types.parenR);
        node.body = this.withTopicForbiddingContext(function () {
          return _this6.parseStatement("for");
        });
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };

      _proto.parseVar = function parseVar(node, isFor, kind) {
        var declarations = node.declarations = [];
        var isTypescript = this.hasPlugin("typescript");
        node.kind = kind;

        for (;;) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);

          if (this.eat(types.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else {
            if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
              if (!isTypescript) {
                this.unexpected();
              }
            } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
              this.raise(this.state.lastTokEnd, Errors.DeclarationMissingInitializer, "Complex binding patterns");
            }

            decl.init = null;
          }

          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types.comma)) break;
        }

        return node;
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, "variable declaration", kind !== "var");
      };

      _proto.parseFunction = function parseFunction(node, statement, isAsync) {
        var _this7 = this;

        if (statement === void 0) {
          statement = FUNC_NO_FLAGS;
        }

        if (isAsync === void 0) {
          isAsync = false;
        }

        var isStatement = statement & FUNC_STATEMENT;
        var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
        var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
        this.initFunction(node, isAsync);

        if (this.match(types.star) && isHangingStatement) {
          this.raise(this.state.start, Errors.GeneratorInSingleStatementContext);
        }

        node.generator = this.eat(types.star);

        if (isStatement) {
          node.id = this.parseFunctionId(requireId);
        }

        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = false;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.scope.enter(SCOPE_FUNCTION);
        this.prodParam.enter(functionFlags(isAsync, node.generator));

        if (!isStatement) {
          node.id = this.parseFunctionId();
        }

        this.parseFunctionParams(node);
        this.withTopicForbiddingContext(function () {
          _this7.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();

        if (isStatement && !isHangingStatement) {
          this.registerFunctionStatementId(node);
        }

        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;
        return node;
      };

      _proto.parseFunctionId = function parseFunctionId(requireId) {
        return requireId || this.match(types.name) ? this.parseIdentifier() : null;
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var oldInParameters = this.state.inParameters;
        this.state.inParameters = true;
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
        this.state.inParameters = oldInParameters;
        this.checkYieldAwaitInDefaultParams();
      };

      _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
      };

      _proto.parseClass = function parseClass(node, isStatement, optionalId) {
        this.next();
        this.takeDecorators(node);
        var oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        this.state.strict = oldStrict;
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.match(types.parenL);
      };

      _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
        return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
      };

      _proto.parseClassBody = function parseClassBody(constructorAllowsSuper, oldStrict) {
        var _this8 = this;

        this.classScope.enter();
        var state = {
          hadConstructor: false
        };
        var decorators = [];
        var classBody = this.startNode();
        classBody.body = [];
        this.expect(types.braceL);
        this.withTopicForbiddingContext(function () {
          while (!_this8.match(types.braceR)) {
            if (_this8.eat(types.semi)) {
              if (decorators.length > 0) {
                throw _this8.raise(_this8.state.lastTokEnd, Errors.DecoratorSemicolon);
              }

              continue;
            }

            if (_this8.match(types.at)) {
              decorators.push(_this8.parseDecorator());
              continue;
            }

            var member = _this8.startNode();

            if (decorators.length) {
              member.decorators = decorators;

              _this8.resetStartLocationFromNode(member, decorators[0]);

              decorators = [];
            }

            _this8.parseClassMember(classBody, member, state, constructorAllowsSuper);

            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              _this8.raise(member.start, Errors.DecoratorConstructor);
            }
          }
        });

        if (!oldStrict) {
          this.state.strict = false;
        }

        this.next();

        if (decorators.length) {
          throw this.raise(this.state.start, Errors.TrailingDecorator);
        }

        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      };

      _proto.parseClassMemberFromModifier = function parseClassMemberFromModifier(classBody, member) {
        var containsEsc = this.state.containsEsc;
        var key = this.parseIdentifier(true);

        if (this.isClassMethod()) {
          var method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method["static"] = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          var prop = member;
          prop.computed = false;
          prop.key = key;
          prop["static"] = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        } else if (containsEsc) {
          throw this.unexpected();
        }

        return false;
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state, constructorAllowsSuper) {
        var isStatic = this.isContextual("static");

        if (isStatic && this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
      };

      _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
        var publicMethod = member;
        var privateMethod = member;
        var publicProp = member;
        var privateProp = member;
        var method = publicMethod;
        var publicMember = publicMethod;
        member["static"] = isStatic;

        if (this.eat(types.star)) {
          method.kind = "method";
          this.parseClassPropertyName(method);

          if (method.key.type === "PrivateName") {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }

          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, Errors.ConstructorIsGenerator);
          }

          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }

        var containsEsc = this.state.containsEsc;
        var key = this.parseClassPropertyName(member);
        var isPrivate = key.type === "PrivateName";
        var isSimple = key.type === "Identifier";
        var maybeQuestionTokenStart = this.state.start;
        this.parsePostMemberNameModifiers(publicMember);

        if (this.isClassMethod()) {
          method.kind = "method";

          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }

          var isConstructor = this.isNonstaticConstructor(publicMethod);
          var allowsDirectSuper = false;

          if (isConstructor) {
            publicMethod.kind = "constructor";

            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(key.start, Errors.DuplicateConstructor);
            }

            state.hadConstructor = true;
            allowsDirectSuper = constructorAllowsSuper;
          }

          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
          var isGenerator = this.eat(types.star);

          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStart);
          }

          method.kind = "method";
          this.parseClassPropertyName(method);
          this.parsePostMemberNameModifiers(publicMember);

          if (method.key.type === "PrivateName") {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(publicMethod.key.start, Errors.ConstructorIsAsync);
            }

            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
          method.kind = key.name;
          this.parseClassPropertyName(publicMethod);

          if (method.key.type === "PrivateName") {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(publicMethod.key.start, Errors.ConstructorIsAccessor);
            }

            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }

          this.checkGetterSetterParams(publicMethod);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      };

      _proto.parseClassPropertyName = function parseClassPropertyName(member) {
        var key = this.parsePropertyName(member, true);

        if (!member.computed && member["static"] && (key.name === "prototype" || key.value === "prototype")) {
          this.raise(key.start, Errors.StaticPrototype);
        }

        if (key.type === "PrivateName" && key.id.name === "constructor") {
          this.raise(key.start, Errors.ConstructorClassPrivateField);
        }

        return key;
      };

      _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
        if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
          this.raise(prop.key.start, Errors.ConstructorClassField);
        }

        classBody.body.push(this.parseClassProperty(prop));
      };

      _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
        this.expectPlugin("classPrivateProperties", prop.key.start);
        var node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(node.key.id.name, CLASS_ELEMENT_OTHER, node.key.start);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        this.expectPlugin("classPrivateMethods", method.key.start);
        var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
        this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);
      };

      _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};

      _proto.parseAccessModifier = function parseAccessModifier() {
        return undefined;
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.prodParam.enter(PARAM);
        node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
        this.semicolon();
        this.prodParam.exit();
        this.scope.exit();
        return this.finishNode(node, "ClassPrivateProperty");
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        if (!node.typeAnnotation) {
          this.expectPlugin("classProperties");
        }

        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.prodParam.enter(PARAM);

        if (this.match(types.eq)) {
          this.expectPlugin("classProperties");
          this.next();
          node.value = this.parseMaybeAssign();
        } else {
          node.value = null;
        }

        this.semicolon();
        this.prodParam.exit();
        this.scope.exit();
        return this.finishNode(node, "ClassProperty");
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
        if (bindingType === void 0) {
          bindingType = BIND_CLASS;
        }

        if (this.match(types.name)) {
          node.id = this.parseIdentifier();

          if (isStatement) {
            this.checkLVal(node.id, bindingType, undefined, "class name");
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            this.unexpected(null, Errors.MissingClassName);
          }
        }
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
      };

      _proto.parseExport = function parseExport(node) {
        var hasDefault = this.maybeParseExportDefaultSpecifier(node);
        var parseAfterDefault = !hasDefault || this.eat(types.comma);
        var hasStar = parseAfterDefault && this.eatExportStar(node);
        var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
        var isFromRequired = hasDefault || hasStar;

        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }

        var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
          throw this.unexpected(null, types.braceL);
        }

        var hasDeclaration;

        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }

        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          this.checkExport(node, true, false, !!node.source);
          return this.finishNode(node, "ExportNamedDeclaration");
        }

        if (this.eat(types._default)) {
          node.declaration = this.parseExportDefaultExpression();
          this.checkExport(node, true, true);
          return this.finishNode(node, "ExportDefaultDeclaration");
        }

        throw this.unexpected(null, types.braceL);
      };

      _proto.eatExportStar = function eatExportStar(node) {
        return this.eat(types.star);
      };

      _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
        if (this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom");
          var specifier = this.startNode();
          specifier.exported = this.parseIdentifier(true);
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }

        return false;
      };

      _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual("as")) {
          if (!node.specifiers) node.specifiers = [];
          var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseIdentifier(true);
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }

        return false;
      };

      _proto.maybeParseExportNamedSpecifiers = function maybeParseExportNamedSpecifiers(node) {
        if (this.match(types.braceL)) {
          var _node$specifiers;

          if (!node.specifiers) node.specifiers = [];

          (_node$specifiers = node.specifiers).push.apply(_node$specifiers, this.parseExportSpecifiers());

          node.source = null;
          node.declaration = null;
          return true;
        }

        return false;
      };

      _proto.maybeParseExportDeclaration = function maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          if (this.isContextual("async")) {
            var next = this.nextTokenStart();

            if (!this.isUnparsedContextual(next, "function")) {
              this.unexpected(next, types._function);
            }
          }

          node.specifiers = [];
          node.source = null;
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }

        return false;
      };

      _proto.isAsyncFunction = function isAsyncFunction() {
        if (!this.isContextual("async")) return false;
        var next = this.nextTokenStart();
        return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        var expr = this.startNode();
        var isAsync = this.isAsyncFunction();

        if (this.match(types._function) || isAsync) {
          this.next();

          if (isAsync) {
            this.next();
          }

          return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
        } else if (this.match(types._class)) {
          return this.parseClass(expr, true, true);
        } else if (this.match(types.at)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(this.state.start, Errors.DecoratorBeforeExport);
          }

          this.parseDecorators(false);
          return this.parseClass(expr, true, true);
        } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
          throw this.raise(this.state.start, Errors.UnsupportedDefaultExport);
        } else {
          var res = this.parseMaybeAssign();
          this.semicolon();
          return res;
        }
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        return this.parseStatement(null);
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(types.name)) {
          var value = this.state.value;

          if (value === "async" || value === "let") {
            return false;
          }

          if ((value === "type" || value === "interface") && !this.state.containsEsc) {
            var l = this.lookahead();

            if (l.type === types.name && l.value !== "from" || l.type === types.braceL) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(types._default)) {
          return false;
        }

        var next = this.nextTokenStart();
        return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, "from");
      };

      _proto.parseExportFrom = function parseExportFrom(node, expect) {
        if (this.eatContextual("from")) {
          node.source = this.parseImportSource();
          this.checkExport(node);
        } else {
          if (expect) {
            this.unexpected();
          } else {
            node.source = null;
          }
        }

        this.semicolon();
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        if (this.match(types.at)) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);

          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.unexpected(this.state.start, Errors.DecoratorBeforeExport);
            } else {
              return true;
            }
          }
        }

        return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
      };

      _proto.checkExport = function checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
          } else if (node.specifiers && node.specifiers.length) {
            for (var _i8 = 0, _node$specifiers3 = node.specifiers; _i8 < _node$specifiers3.length; _i8++) {
              var specifier = _node$specifiers3[_i8];
              this.checkDuplicateExports(specifier, specifier.exported.name);

              if (!isFrom && specifier.local) {
                this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);
                this.scope.checkLocalExport(specifier.local);
              }
            }
          } else if (node.declaration) {
            if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
              var id = node.declaration.id;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (node.declaration.type === "VariableDeclaration") {
              for (var _i10 = 0, _node$declaration$dec2 = node.declaration.declarations; _i10 < _node$declaration$dec2.length; _i10++) {
                var declaration = _node$declaration$dec2[_i10];
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }

        var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

        if (currentContextDecorators.length) {
          var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

          if (!node.declaration || !isClass) {
            throw this.raise(node.start, Errors.UnsupportedDecoratorExport);
          }

          this.takeDecorators(node.declaration);
        }
      };

      _proto.checkDeclaration = function checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (var _i12 = 0, _node$properties2 = node.properties; _i12 < _node$properties2.length; _i12++) {
            var prop = _node$properties2[_i12];
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (var _i14 = 0, _node$elements2 = node.elements; _i14 < _node$elements2.length; _i14++) {
            var elem = _node$elements2[_i14];

            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      };

      _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {
        if (this.state.exportedIdentifiers.indexOf(name) > -1) {
          this.raise(node.start, name === "default" ? Errors.DuplicateDefaultExport : Errors.DuplicateExport, name);
        }

        this.state.exportedIdentifiers.push(name);
      };

      _proto.parseExportSpecifiers = function parseExportSpecifiers() {
        var nodes = [];
        var first = true;
        this.expect(types.braceL);

        while (!this.eat(types.braceR)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);
            if (this.eat(types.braceR)) break;
          }

          var node = this.startNode();
          node.local = this.parseIdentifier(true);
          node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }

        return nodes;
      };

      _proto.parseImport = function parseImport(node) {
        node.specifiers = [];

        if (!this.match(types.string)) {
          var hasDefault = this.maybeParseDefaultImportSpecifier(node);
          var parseNext = !hasDefault || this.eat(types.comma);
          var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
          if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
          this.expectContextual("from");
        }

        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };

      _proto.parseImportSource = function parseImportSource() {
        if (!this.match(types.string)) this.unexpected();
        return this.parseExprAtom();
      };

      _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
        return this.match(types.name);
      };

      _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = this.parseIdentifier();
        this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
        node.specifiers.push(this.finishNode(specifier, type));
      };

      _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
        if (this.shouldParseDefaultImport(node)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
          return true;
        }

        return false;
      };

      _proto.maybeParseStarImportSpecifier = function maybeParseStarImportSpecifier(node) {
        if (this.match(types.star)) {
          var specifier = this.startNode();
          this.next();
          this.expectContextual("as");
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
          return true;
        }

        return false;
      };

      _proto.parseNamedImportSpecifiers = function parseNamedImportSpecifiers(node) {
        var first = true;
        this.expect(types.braceL);

        while (!this.eat(types.braceR)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(types.colon)) {
              throw this.raise(this.state.start, Errors.DestructureNamedImport);
            }

            this.expect(types.comma);
            if (this.eat(types.braceR)) break;
          }

          this.parseImportSpecifier(node);
        }
      };

      _proto.parseImportSpecifier = function parseImportSpecifier(node) {
        var specifier = this.startNode();
        specifier.imported = this.parseIdentifier(true);

        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
          specifier.local = specifier.imported.__clone();
        }

        this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      };

      return StatementParser;
    }(ExpressionParser);

    var ClassScope = function ClassScope() {
      this.privateNames = new Set();
      this.loneAccessors = new Map();
      this.undefinedPrivateNames = new Map();
    };

    var ClassScopeHandler = function () {
      function ClassScopeHandler(raise) {
        this.stack = [];
        this.undefinedPrivateNames = new Map();
        this.raise = raise;
      }

      var _proto = ClassScopeHandler.prototype;

      _proto.current = function current() {
        return this.stack[this.stack.length - 1];
      };

      _proto.enter = function enter() {
        this.stack.push(new ClassScope());
      };

      _proto.exit = function exit() {
        var oldClassScope = this.stack.pop();
        var current = this.current();

        for (var _i2 = 0, _Array$from2 = Array.from(oldClassScope.undefinedPrivateNames); _i2 < _Array$from2.length; _i2++) {
          var _Array$from2$_i = _Array$from2[_i2],
              name = _Array$from2$_i[0],
              pos = _Array$from2$_i[1];

          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, pos);
            }
          } else {
            this.raise(pos, Errors.InvalidPrivateFieldResolution, name);
          }
        }
      };

      _proto.declarePrivateName = function declarePrivateName(name, elementType, pos) {
        var classScope = this.current();
        var redefined = classScope.privateNames.has(name);

        if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
          var accessor = redefined && classScope.loneAccessors.get(name);

          if (accessor) {
            var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
            var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
            var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
            var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) classScope.loneAccessors["delete"](name);
          } else if (!redefined) {
            classScope.loneAccessors.set(name, elementType);
          }
        }

        if (redefined) {
          this.raise(pos, Errors.PrivateNameRedeclaration, name);
        }

        classScope.privateNames.add(name);
        classScope.undefinedPrivateNames["delete"](name);
      };

      _proto.usePrivateName = function usePrivateName(name, pos) {
        var classScope;

        for (var _i4 = 0, _this$stack2 = this.stack; _i4 < _this$stack2.length; _i4++) {
          classScope = _this$stack2[_i4];
          if (classScope.privateNames.has(name)) return;
        }

        if (classScope) {
          classScope.undefinedPrivateNames.set(name, pos);
        } else {
          this.raise(pos, Errors.InvalidPrivateFieldResolution, name);
        }
      };

      return ClassScopeHandler;
    }();

    var Parser = function (_StatementParser) {
      _inheritsLoose(Parser, _StatementParser);

      function Parser(options, input) {
        var _this;

        options = getOptions(options);
        _this = _StatementParser.call(this, options, input) || this;

        var ScopeHandler = _this.getScopeHandler();

        _this.options = options;
        _this.inModule = _this.options.sourceType === "module";
        _this.scope = new ScopeHandler(_this.raise.bind(_assertThisInitialized(_this)), _this.inModule);
        _this.prodParam = new ProductionParameterHandler();
        _this.classScope = new ClassScopeHandler(_this.raise.bind(_assertThisInitialized(_this)));
        _this.plugins = pluginsMap(_this.options.plugins);
        _this.filename = options.sourceFilename;
        return _this;
      }

      var _proto = Parser.prototype;

      _proto.getScopeHandler = function getScopeHandler() {
        return ScopeHandler;
      };

      _proto.parse = function parse() {
        var paramFlags = PARAM;

        if (this.hasPlugin("topLevelAwait") && this.inModule) {
          paramFlags |= PARAM_AWAIT;
        }

        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
        var file = this.startNode();
        var program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        return file;
      };

      return Parser;
    }(StatementParser);

    function pluginsMap(plugins) {
      var pluginMap = new Map();

      for (var _i2 = 0; _i2 < plugins.length; _i2++) {
        var plugin = plugins[_i2];

        var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
            name = _ref[0],
            options = _ref[1];

        if (!pluginMap.has(name)) pluginMap.set(name, options || {});
      }

      return pluginMap;
    }

    function parse$1(input, options) {
      if (options && options.sourceType === "unambiguous") {
        options = Object.assign({}, options);

        try {
          options.sourceType = "module";
          var parser = getParser(options, input);
          var ast = parser.parse();

          if (parser.sawUnambiguousESM) {
            return ast;
          }

          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {}
          } else {
            ast.program.sourceType = "script";
          }

          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {}

          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }

    function getParser(options, input) {
      var cls = Parser;

      if (options && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
      }

      return new cls(options, input);
    }

    var parserClassCache = {};

    function getParserClass(pluginsFromOptions) {
      var pluginList = mixinPluginNames.filter(function (name) {
        return hasPlugin(pluginsFromOptions, name);
      });
      var key = pluginList.join("/");
      var cls = parserClassCache[key];

      if (!cls) {
        cls = Parser;

        for (var _i2 = 0; _i2 < pluginList.length; _i2++) {
          var plugin = pluginList[_i2];
          cls = mixinPlugins[plugin](cls);
        }

        parserClassCache[key] = cls;
      }

      return cls;
    }

    var hoistVariablesVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      VariableDeclaration: function VariableDeclaration(path) {
        if (path.node.kind !== "var") return;
        var bindings = path.getBindingIdentifiers();

        for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          path.scope.push({
            id: bindings[key]
          });
        }

        var exprs = [];

        for (var _i2 = 0, _arr = path.node.declarations; _i2 < _arr.length; _i2++) {
          var declar = _arr[_i2];

          if (declar.init) {
            exprs.push(ExpressionStatement(AssignmentExpression("=", declar.id, declar.init)));
          }
        }

        path.replaceWithMultiple(exprs);
      }
    };
    function replaceWithMultiple(nodes) {
      this.resync();
      nodes = this._verifyNodeList(nodes);
      inheritLeadingComments(nodes[0], this.node);
      inheritTrailingComments(nodes[nodes.length - 1], this.node);
      this.node = this.container[this.key] = null;
      var paths = this.insertAfter(nodes);

      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }

      return paths;
    }
    function replaceWithSourceString(replacement) {
      this.resync();

      try {
        replacement = "(" + replacement + ")";
        replacement = parse$1(replacement);
      } catch (err) {
        var loc = err.loc;

        if (loc) {
          err.message += " - make sure this is an expression.\n" + codeFrameColumns(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }

        throw err;
      }

      replacement = replacement.program.body[0].expression;
      traverse$1.removeProperties(replacement);
      return this.replaceWith(replacement);
    }
    function replaceWith(replacement) {
      this.resync();

      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }

      if (replacement instanceof NodePath) {
        replacement = replacement.node;
      }

      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }

      if (this.node === replacement) {
        return [this];
      }

      if (this.isProgram() && !isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }

      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }

      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }

      var nodePath = "";

      if (this.isNodeType("Statement") && isExpression(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = ExpressionStatement(replacement);
          nodePath = "expression";
        }
      }

      if (this.isNodeType("Expression") && isStatement(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }

      var oldNode = this.node;

      if (oldNode) {
        inheritsComments(replacement, oldNode);
        removeComments(oldNode);
      }

      this._replaceWith(replacement);

      this.type = replacement.type;
      this.setScope();
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }

      if (this.inList) {
        validate(this.parent, this.key, [node]);
      } else {
        validate(this.parent, this.key, node);
      }

      this.debug("Replace with " + (node && node.type));
      this.node = this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      this.resync();
      var toSequenceExpression$1 = toSequenceExpression(nodes, this.scope);

      if (toSequenceExpression$1) {
        return this.replaceWith(toSequenceExpression$1)[0].get("expressions");
      }

      var functionParent = this.getFunctionParent();
      var isParentAsync = functionParent && functionParent.is("async");
      var container = ArrowFunctionExpression([], BlockStatement(nodes));
      this.replaceWith(CallExpression(container, []));
      this.traverse(hoistVariablesVisitor);
      var completionRecords = this.get("callee").getCompletionRecords();

      for (var _iterator = _createForOfIteratorHelperLoose(completionRecords), _step; !(_step = _iterator()).done;) {
        var path = _step.value;
        if (!path.isExpressionStatement()) continue;
        var loop = path.findParent(function (path) {
          return path.isLoop();
        });

        if (loop) {
          var uid = loop.getData("expressionReplacementReturnUid");

          if (!uid) {
            var _callee = this.get("callee");

            uid = _callee.scope.generateDeclaredUidIdentifier("ret");

            _callee.get("body").pushContainer("body", ReturnStatement(cloneNode(uid)));

            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = Identifier(uid.name);
          }

          path.get("expression").replaceWith(AssignmentExpression("=", cloneNode(uid), path.node.expression));
        } else {
          path.replaceWith(ReturnStatement(path.node.expression));
        }
      }

      var callee = this.get("callee");
      callee.arrowFunctionToExpression();

      if (isParentAsync && traverse$1.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES)) {
        callee.set("async", true);
        this.replaceWith(AwaitExpression(this.node));
      }

      return callee.get("body.body");
    }
    function replaceInline(nodes) {
      this.resync();

      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = this._verifyNodeList(nodes);

          var paths = this._containerInsertAfter(nodes);

          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }

    var NodePath_replacement = /*#__PURE__*/Object.freeze({
      __proto__: null,
      replaceWithMultiple: replaceWithMultiple,
      replaceWithSourceString: replaceWithSourceString,
      replaceWith: replaceWith,
      _replaceWith: _replaceWith,
      replaceExpressionWithStatements: replaceExpressionWithStatements,
      replaceInline: replaceInline
    });

    var VALID_CALLEES = ["String", "Number", "Math"];
    var INVALID_METHODS = ["random"];
    function evaluateTruthy() {
      var res = this.evaluate();
      if (res.confident) return !!res.value;
    }

    function deopt(path, state) {
      if (!state.confident) return;
      state.deoptPath = path;
      state.confident = false;
    }

    function evaluateCached(path, state) {
      var node = path.node;
      var seen = state.seen;

      if (seen.has(node)) {
        var existing = seen.get(node);

        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path, state);
          return;
        }
      } else {
        var item = {
          resolved: false
        };
        seen.set(node, item);

        var val = _evaluate(path, state);

        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }

        return val;
      }
    }

    function _evaluate(path, state) {
      if (!state.confident) return;
      var node = path.node;

      if (path.isSequenceExpression()) {
        var exprs = path.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }

      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return node.value;
      }

      if (path.isNullLiteral()) {
        return null;
      }

      if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, node.quasis, state);
      }

      if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
        var object = path.get("tag.object");
        var name = object.node.name;
        var property = path.get("tag.property");

        if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === "raw") {
          return evaluateQuasis(path, node.quasi.quasis, state, true);
        }
      }

      if (path.isConditionalExpression()) {
        var testResult = evaluateCached(path.get("test"), state);
        if (!state.confident) return;

        if (testResult) {
          return evaluateCached(path.get("consequent"), state);
        } else {
          return evaluateCached(path.get("alternate"), state);
        }
      }

      if (path.isExpressionWrapper()) {
        return evaluateCached(path.get("expression"), state);
      }

      if (path.isMemberExpression() && !path.parentPath.isCallExpression({
        callee: node
      })) {
        var _property = path.get("property");

        var _object = path.get("object");

        if (_object.isLiteral() && _property.isIdentifier()) {
          var value = _object.node.value;
          var type = typeof value;

          if (type === "number" || type === "string") {
            return value[_property.node.name];
          }
        }
      }

      if (path.isReferencedIdentifier()) {
        var binding = path.scope.getBinding(node.name);

        if (binding && binding.constantViolations.length > 0) {
          return deopt(binding.path, state);
        }

        if (binding && path.node.start < binding.path.node.end) {
          return deopt(binding.path, state);
        }

        if (binding && binding.hasValue) {
          return binding.value;
        } else {
          if (node.name === "undefined") {
            return binding ? deopt(binding.path, state) : undefined;
          } else if (node.name === "Infinity") {
            return binding ? deopt(binding.path, state) : Infinity;
          } else if (node.name === "NaN") {
            return binding ? deopt(binding.path, state) : NaN;
          }

          var resolved = path.resolve();

          if (resolved === path) {
            return deopt(path, state);
          } else {
            return evaluateCached(resolved, state);
          }
        }
      }

      if (path.isUnaryExpression({
        prefix: true
      })) {
        if (node.operator === "void") {
          return undefined;
        }

        var argument = path.get("argument");

        if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }

        var arg = evaluateCached(argument, state);
        if (!state.confident) return;

        switch (node.operator) {
          case "!":
            return !arg;

          case "+":
            return +arg;

          case "-":
            return -arg;

          case "~":
            return ~arg;

          case "typeof":
            return typeof arg;
        }
      }

      if (path.isArrayExpression()) {
        var arr = [];
        var elems = path.get("elements");

        for (var _iterator = _createForOfIteratorHelperLoose(elems), _step; !(_step = _iterator()).done;) {
          var elem = _step.value;
          var elemValue = elem.evaluate();

          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            return deopt(elem, state);
          }
        }

        return arr;
      }

      if (path.isObjectExpression()) {
        var obj = {};
        var props = path.get("properties");

        for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
          var prop = _step2.value;

          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            return deopt(prop, state);
          }

          var keyPath = prop.get("key");
          var key = keyPath;

          if (prop.node.computed) {
            key = key.evaluate();

            if (!key.confident) {
              return deopt(keyPath, state);
            }

            key = key.value;
          } else if (key.isIdentifier()) {
            key = key.node.name;
          } else {
            key = key.node.value;
          }

          var valuePath = prop.get("value");

          var _value = valuePath.evaluate();

          if (!_value.confident) {
            return deopt(valuePath, state);
          }

          _value = _value.value;
          obj[key] = _value;
        }

        return obj;
      }

      if (path.isLogicalExpression()) {
        var wasConfident = state.confident;
        var left = evaluateCached(path.get("left"), state);
        var leftConfident = state.confident;
        state.confident = wasConfident;
        var right = evaluateCached(path.get("right"), state);
        var rightConfident = state.confident;

        switch (node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident) return;
            return left || right;

          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident) return;
            return left && right;
        }
      }

      if (path.isBinaryExpression()) {
        var _left = evaluateCached(path.get("left"), state);

        if (!state.confident) return;

        var _right = evaluateCached(path.get("right"), state);

        if (!state.confident) return;

        switch (node.operator) {
          case "-":
            return _left - _right;

          case "+":
            return _left + _right;

          case "/":
            return _left / _right;

          case "*":
            return _left * _right;

          case "%":
            return _left % _right;

          case "**":
            return Math.pow(_left, _right);

          case "<":
            return _left < _right;

          case ">":
            return _left > _right;

          case "<=":
            return _left <= _right;

          case ">=":
            return _left >= _right;

          case "==":
            return _left == _right;

          case "!=":
            return _left != _right;

          case "===":
            return _left === _right;

          case "!==":
            return _left !== _right;

          case "|":
            return _left | _right;

          case "&":
            return _left & _right;

          case "^":
            return _left ^ _right;

          case "<<":
            return _left << _right;

          case ">>":
            return _left >> _right;

          case ">>>":
            return _left >>> _right;
        }
      }

      if (path.isCallExpression()) {
        var callee = path.get("callee");
        var context;
        var func;

        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
          func = global$1[node.callee.name];
        }

        if (callee.isMemberExpression()) {
          var _object2 = callee.get("object");

          var _property2 = callee.get("property");

          if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {
            context = global$1[_object2.node.name];
            func = context[_property2.node.name];
          }

          if (_object2.isLiteral() && _property2.isIdentifier()) {
            var _type = typeof _object2.node.value;

            if (_type === "string" || _type === "number") {
              context = _object2.node.value;
              func = context[_property2.node.name];
            }
          }
        }

        if (func) {
          var args = path.get("arguments").map(function (arg) {
            return evaluateCached(arg, state);
          });
          if (!state.confident) return;
          return func.apply(context, args);
        }
      }

      deopt(path, state);
    }

    function evaluateQuasis(path, quasis, state, raw) {
      if (raw === void 0) {
        raw = false;
      }

      var str = "";
      var i = 0;
      var exprs = path.get("expressions");

      for (var _iterator3 = _createForOfIteratorHelperLoose(quasis), _step3; !(_step3 = _iterator3()).done;) {
        var elem = _step3.value;
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        var expr = exprs[i++];
        if (expr) str += String(evaluateCached(expr, state));
      }

      if (!state.confident) return;
      return str;
    }

    function evaluate() {
      var state = {
        confident: true,
        deoptPath: null,
        seen: new Map()
      };
      var value = evaluateCached(this, state);
      if (!state.confident) value = undefined;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value: value
      };
    }

    var NodePath_evaluation = /*#__PURE__*/Object.freeze({
      __proto__: null,
      evaluateTruthy: evaluateTruthy,
      evaluate: evaluate
    });

    function getFunctionArity (node) {
      var params = node.params;

      for (var i = 0; i < params.length; i++) {
        var param = params[i];

        if (isAssignmentPattern(param) || isRestElement(param)) {
          return i;
        }
      }

      return params.length;
    }

    function makeStatementFormatter(fn) {
      return {
        code: function code(str) {
          return "/* @babel/template */;\n" + str;
        },
        validate: function validate() {},
        unwrap: function unwrap(ast) {
          return fn(ast.program.body.slice(1));
        }
      };
    }

    var smart = makeStatementFormatter(function (body) {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    var statements = makeStatementFormatter(function (body) {
      return body;
    });
    var statement = makeStatementFormatter(function (body) {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }

      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }

      return body[0];
    });
    var expression = {
      code: function code(str) {
        return "(\n" + str + "\n)";
      },
      validate: function validate(_ref) {
        var program = _ref.program;

        if (program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }

        var expression = program.body[0].expression;

        if (expression.start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: function unwrap(ast) {
        return ast.program.body[0].expression;
      }
    };
    var program = {
      code: function code(str) {
        return str;
      },
      validate: function validate() {},
      unwrap: function unwrap(ast) {
        return ast.program;
      }
    };

    function merge(a, b) {
      var _b$placeholderWhiteli = b.placeholderWhitelist,
          placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
          _b$placeholderPattern = b.placeholderPattern,
          placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
          _b$preserveComments = b.preserveComments,
          preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
          _b$syntacticPlacehold = b.syntacticPlaceholders,
          syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
      return {
        parser: Object.assign({}, a.parser, {}, b.parser),
        placeholderWhitelist: placeholderWhitelist,
        placeholderPattern: placeholderPattern,
        preserveComments: preserveComments,
        syntacticPlaceholders: syntacticPlaceholders
      };
    }
    function validate$2(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }

      var _ref = opts || {},
          placeholderWhitelist = _ref.placeholderWhitelist,
          placeholderPattern = _ref.placeholderPattern,
          preserveComments = _ref.preserveComments,
          syntacticPlaceholders = _ref.syntacticPlaceholders,
          parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);

      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }

      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }

      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }

      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }

      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
      }

      return {
        parser: parser,
        placeholderWhitelist: placeholderWhitelist || undefined,
        placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
        preserveComments: preserveComments == null ? undefined : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce(function (acc, replacement, i) {
          acc["$" + i] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || undefined;
      }

      throw new Error("Template replacements must be an array, object, null, or undefined");
    }

    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code, opts) {
      var ast = parseWithCodeFrame(code, opts.parser);
      var placeholderWhitelist = opts.placeholderWhitelist,
          placeholderPattern = opts.placeholderPattern,
          preserveComments = opts.preserveComments,
          syntacticPlaceholders = opts.syntacticPlaceholders;
      removePropertiesDeep(ast, {
        preserveComments: preserveComments
      });
      formatter.validate(ast);
      var syntactic = {
        placeholders: [],
        placeholderNames: new Set()
      };
      var legacy = {
        placeholders: [],
        placeholderNames: new Set()
      };
      var isLegacyRef = {
        value: undefined
      };
      traverse(ast, placeholderVisitorHandler, {
        syntactic: syntactic,
        legacy: legacy,
        isLegacyRef: isLegacyRef,
        placeholderWhitelist: placeholderWhitelist,
        placeholderPattern: placeholderPattern,
        syntacticPlaceholders: syntacticPlaceholders
      });
      return Object.assign({
        ast: ast
      }, isLegacyRef.value ? legacy : syntactic);
    }

    function placeholderVisitorHandler(node, ancestors, state) {
      var name;

      if (isPlaceholder(node)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
        } else {
          name = node.name.name;
          state.isLegacyRef.value = false;
        }
      } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
        return;
      } else if (isIdentifier(node) || isJSXIdentifier(node)) {
        name = node.name;
        state.isLegacyRef.value = true;
      } else if (isStringLiteral(node)) {
        name = node.value;
        state.isLegacyRef.value = true;
      } else {
        return;
      }

      if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
      }

      if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))) {
        return;
      }

      ancestors = ancestors.slice();
      var _ancestors = ancestors[ancestors.length - 1],
          parent = _ancestors.node,
          key = _ancestors.key;
      var type;

      if (isStringLiteral(node) || isPlaceholder(node, {
        expectedNode: "StringLiteral"
      })) {
        type = "string";
      } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
        type = "param";
      } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (isStatement(node) && isPlaceholder(node)) {
        type = "statement";
      } else {
        type = "other";
      }

      var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,
          placeholders = _ref.placeholders,
          placeholderNames = _ref.placeholderNames;

      placeholders.push({
        name: name,
        type: type,
        resolve: function resolve(ast) {
          return resolveAncestors(ast, ancestors);
        },
        isDuplicate: placeholderNames.has(name)
      });
      placeholderNames.add(name);
    }

    function resolveAncestors(ast, ancestors) {
      var parent = ast;

      for (var i = 0; i < ancestors.length - 1; i++) {
        var _ancestors$i = ancestors[i],
            _key = _ancestors$i.key,
            _index = _ancestors$i.index;

        if (_index === undefined) {
          parent = parent[_key];
        } else {
          parent = parent[_key][_index];
        }
      }

      var _ancestors2 = ancestors[ancestors.length - 1],
          key = _ancestors2.key,
          index = _ancestors2.index;
      return {
        parent: parent,
        key: key,
        index: index
      };
    }

    function parseWithCodeFrame(code, parserOpts) {
      parserOpts = Object.assign({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: "module"
      }, parserOpts, {
        plugins: (parserOpts.plugins || []).concat("placeholders")
      });

      try {
        return parse$1(code, parserOpts);
      } catch (err) {
        var loc = err.loc;

        if (loc) {
          err.message += "\n" + codeFrameColumns(code, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }

        throw err;
      }
    }

    function populatePlaceholders(metadata, replacements) {
      var ast = cloneNode(metadata.ast);

      if (replacements) {
        metadata.placeholders.forEach(function (placeholder) {
          if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
            var placeholderName = placeholder.name;
            throw new Error("Error: No substitution given for \"" + placeholderName + "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" + placeholderName + "'])}\n            - { placeholderPattern: /^" + placeholderName + "$/ }");
          }
        });
        Object.keys(replacements).forEach(function (key) {
          if (!metadata.placeholderNames.has(key)) {
            throw new Error("Unknown substitution \"" + key + "\" given");
          }
        });
      }

      metadata.placeholders.slice().reverse().forEach(function (placeholder) {
        try {
          applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
        } catch (e) {
          e.message = "@babel/template placeholder \"" + placeholder.name + "\": " + e.message;
          throw e;
        }
      });
      return ast;
    }

    function applyReplacement(placeholder, ast, replacement) {
      if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map(function (node) {
            return cloneNode(node);
          });
        } else if (typeof replacement === "object") {
          replacement = cloneNode(replacement);
        }
      }

      var _placeholder$resolve = placeholder.resolve(ast),
          parent = _placeholder$resolve.parent,
          key = _placeholder$resolve.key,
          index = _placeholder$resolve.index;

      if (placeholder.type === "string") {
        if (typeof replacement === "string") {
          replacement = StringLiteral(replacement);
        }

        if (!replacement || !isStringLiteral(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder.type === "statement") {
        if (index === undefined) {
          if (!replacement) {
            replacement = EmptyStatement();
          } else if (Array.isArray(replacement)) {
            replacement = BlockStatement(replacement);
          } else if (typeof replacement === "string") {
            replacement = ExpressionStatement(Identifier(replacement));
          } else if (!isStatement(replacement)) {
            replacement = ExpressionStatement(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = Identifier(replacement);
            }

            if (!isStatement(replacement)) {
              replacement = ExpressionStatement(replacement);
            }
          }
        }
      } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
          replacement = Identifier(replacement);
        }

        if (index === undefined) throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = Identifier(replacement);
        }

        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }

      if (index === undefined) {
        validate(parent, key, replacement);
        parent[key] = replacement;
      } else {
        var items = parent[key].slice();

        if (placeholder.type === "statement" || placeholder.type === "param") {
          if (replacement == null) {
            items.splice(index, 1);
          } else if (Array.isArray(replacement)) {
            items.splice.apply(items, [index, 1].concat(replacement));
          } else {
            items[index] = replacement;
          }
        } else {
          items[index] = replacement;
        }

        validate(parent, key, items);
        parent[key] = items;
      }
    }

    function stringTemplate(formatter, code, opts) {
      code = formatter.code(code);
      var metadata;
      return function (arg) {
        var replacements = normalizeReplacements(arg);
        if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
        return formatter.unwrap(populatePlaceholders(metadata, replacements));
      };
    }

    function literalTemplate(formatter, tpl, opts) {
      var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
          metadata = _buildLiteralData.metadata,
          names = _buildLiteralData.names;

      return function (arg) {
        var defaultReplacements = arg.reduce(function (acc, replacement, i) {
          acc[names[i]] = replacement;
          return acc;
        }, {});
        return function (arg) {
          var replacements = normalizeReplacements(arg);

          if (replacements) {
            Object.keys(replacements).forEach(function (key) {
              if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }

          return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }

    function buildLiteralData(formatter, tpl, opts) {
      var names;
      var nameSet;
      var metadata;
      var prefix = "";

      do {
        prefix += "$";
        var result = buildTemplateCode(tpl, prefix);
        names = result.names;
        nameSet = new Set(names);
        metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {
          parser: opts.parser,
          placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
          placeholderPattern: opts.placeholderPattern,
          preserveComments: opts.preserveComments,
          syntacticPlaceholders: opts.syntacticPlaceholders
        });
      } while (metadata.placeholders.some(function (placeholder) {
        return placeholder.isDuplicate && nameSet.has(placeholder.name);
      }));

      return {
        metadata: metadata,
        names: names
      };
    }

    function buildTemplateCode(tpl, prefix) {
      var names = [];
      var code = tpl[0];

      for (var i = 1; i < tpl.length; i++) {
        var value = "" + prefix + (i - 1);
        names.push(value);
        code += value + tpl[i];
      }

      return {
        names: names,
        code: code
      };
    }

    var NO_PLACEHOLDER = validate$2({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      var templateFnCache = new WeakMap();
      var templateAstCache = new WeakMap();
      var cachedOpts = defaultOpts || validate$2(null);
      return Object.assign(function (tpl) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return extendedTrace(stringTemplate(formatter, tpl, merge(cachedOpts, validate$2(args[0]))));
        } else if (Array.isArray(tpl)) {
          var builder = templateFnCache.get(tpl);

          if (!builder) {
            builder = literalTemplate(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }

          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0) throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, merge(cachedOpts, validate$2(tpl)));
        }

        throw new Error("Unexpected template param " + typeof tpl);
      }, {
        ast: function ast(tpl) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          if (typeof tpl === "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return stringTemplate(formatter, tpl, merge(merge(cachedOpts, validate$2(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            var builder = templateAstCache.get(tpl);

            if (!builder) {
              builder = literalTemplate(formatter, tpl, merge(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }

            return builder(args)();
          }

          throw new Error("Unexpected template param " + typeof tpl);
        }
      });
    }

    function extendedTrace(fn) {
      var rootStack = "";

      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }

      return function (arg) {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += "\n    =============\n" + rootStack;
          throw err;
        }
      };
    }

    var smart$1 = createTemplateBuilder(smart);
    var statement$1 = createTemplateBuilder(statement);
    var statements$1 = createTemplateBuilder(statements);
    var expression$1 = createTemplateBuilder(expression);
    var program$1 = createTemplateBuilder(program);
    var template = Object.assign(smart$1.bind(undefined), {
      smart: smart$1,
      statement: statement$1,
      statements: statements$1,
      expression: expression$1,
      program: program$1,
      ast: smart$1.ast
    });

    var buildPropertyMethodAssignmentWrapper = template("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
    var buildGeneratorPropertyMethodAssignmentWrapper = template("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
    var visitor = {
      "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
        if (path.node.name !== state.name) return;
        var localDeclar = path.scope.getBindingIdentifier(state.name);
        if (localDeclar !== state.outerDeclar) return;
        state.selfReference = true;
        path.stop();
      }
    };

    function getNameFromLiteralId(id) {
      if (isNullLiteral(id)) {
        return "null";
      }

      if (isRegExpLiteral(id)) {
        return "_" + id.pattern + "_" + id.flags;
      }

      if (isTemplateLiteral(id)) {
        return id.quasis.map(function (quasi) {
          return quasi.value.raw;
        }).join("");
      }

      if (id.value !== undefined) {
        return id.value + "";
      }

      return "";
    }

    function wrap(state, method, id, scope) {
      if (state.selfReference) {
        if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
          scope.rename(id.name);
        } else {
          if (!isFunction(method)) return;
          var build = buildPropertyMethodAssignmentWrapper;

          if (method.generator) {
            build = buildGeneratorPropertyMethodAssignmentWrapper;
          }

          var _template = build({
            FUNCTION: method,
            FUNCTION_ID: id,
            FUNCTION_KEY: scope.generateUidIdentifier(id.name)
          }).expression;
          var params = _template.callee.body.body[0].params;

          for (var i = 0, len = getFunctionArity(method); i < len; i++) {
            params.push(scope.generateUidIdentifier("x"));
          }

          return _template;
        }
      }

      method.id = id;
      scope.getProgramParent().references[id.name] = true;
    }

    function visit(node, name, scope) {
      var state = {
        selfAssignment: false,
        selfReference: false,
        outerDeclar: scope.getBindingIdentifier(name),
        references: [],
        name: name
      };
      var binding = scope.getOwnBinding(name);

      if (binding) {
        if (binding.kind === "param") {
          state.selfReference = true;
        }
      } else if (state.outerDeclar || scope.hasGlobal(name)) {
        scope.traverse(node, visitor, state);
      }

      return state;
    }

    function nameFunction (_ref, localBinding) {
      var node = _ref.node,
          parent = _ref.parent,
          scope = _ref.scope,
          id = _ref.id;

      if (localBinding === void 0) {
        localBinding = false;
      }

      if (node.id) return;

      if ((isObjectProperty(parent) || isObjectMethod(parent, {
        kind: "method"
      })) && (!parent.computed || isLiteral(parent.key))) {
        id = parent.key;
      } else if (isVariableDeclarator(parent)) {
        id = parent.id;

        if (isIdentifier(id) && !localBinding) {
          var binding = scope.parent.getBinding(id.name);

          if (binding && binding.constant && scope.getBinding(id.name) === binding) {
            node.id = cloneNode(id);
            node.id[NOT_LOCAL_BINDING] = true;
            return;
          }
        }
      } else if (isAssignmentExpression(parent, {
        operator: "="
      })) {
        id = parent.left;
      } else if (!id) {
        return;
      }

      var name;

      if (id && isLiteral(id)) {
        name = getNameFromLiteralId(id);
      } else if (id && isIdentifier(id)) {
        name = id.name;
      }

      if (name === undefined) {
        return;
      }

      name = toBindingIdentifierName(name);
      id = Identifier(name);
      id[NOT_LOCAL_BINDING] = true;
      var state = visit(node, name, scope);
      return wrap(state, node, id, scope) || node;
    }

    function toComputedKey$1() {
      var node = this.node;
      var key;

      if (this.isMemberExpression()) {
        key = node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = node.key;
      } else {
        throw new ReferenceError("todo");
      }

      if (!node.computed) {
        if (isIdentifier(key)) key = StringLiteral(key.name);
      }

      return key;
    }
    function ensureBlock$1() {
      var body = this.get("body");
      var bodyNode = body.node;

      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }

      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }

      if (body.isBlockStatement()) {
        return bodyNode;
      }

      var statements = [];
      var stringPath = "body";
      var key;
      var listKey;

      if (body.isStatement()) {
        listKey = "body";
        key = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";

        if (this.isFunction()) {
          key = "argument";
          statements.push(ReturnStatement(body.node));
        } else {
          key = "expression";
          statements.push(ExpressionStatement(body.node));
        }
      }

      this.node.body = BlockStatement(statements);
      var parentPath = this.get(stringPath);
      body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
      return this.node;
    }
    function arrowFunctionToShadowed() {
      if (!this.isArrowFunctionExpression()) return;
      this.arrowFunctionToExpression();
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }

      hoistFunctionEnvironment(this);
    }
    function arrowFunctionToExpression(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$allowInsertArrow = _ref.allowInsertArrow,
          allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
          _ref$specCompliant = _ref.specCompliant,
          specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant;

      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }

      var thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);
      this.ensureBlock();
      this.node.type = "FunctionExpression";

      if (specCompliant) {
        var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

        if (checkBinding) {
          this.parentPath.scope.push({
            id: checkBinding,
            init: ObjectExpression([])
          });
        }

        this.get("body").unshiftContainer("body", ExpressionStatement(CallExpression(this.hub.addHelper("newArrowCheck"), [ThisExpression(), checkBinding ? Identifier(checkBinding.name) : Identifier(thisBinding)])));
        this.replaceWith(CallExpression(MemberExpression(nameFunction(this, true) || this.node, Identifier("bind")), [checkBinding ? Identifier(checkBinding.name) : ThisExpression()]));
      }
    }

    function hoistFunctionEnvironment(fnPath, specCompliant, allowInsertArrow) {
      if (specCompliant === void 0) {
        specCompliant = false;
      }

      if (allowInsertArrow === void 0) {
        allowInsertArrow = true;
      }

      var thisEnvFn = fnPath.findParent(function (p) {
        return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
          "static": false
        });
      });
      var inConstructor = thisEnvFn && thisEnvFn.node.kind === "constructor";

      if (thisEnvFn.isClassProperty()) {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }

      var _getScopeInformation = getScopeInformation(fnPath),
          thisPaths = _getScopeInformation.thisPaths,
          argumentsPaths = _getScopeInformation.argumentsPaths,
          newTargetPaths = _getScopeInformation.newTargetPaths,
          superProps = _getScopeInformation.superProps,
          superCalls = _getScopeInformation.superCalls;

      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
        }

        var allSuperCalls = [];
        thisEnvFn.traverse({
          Function: function Function(child) {
            if (child.isArrowFunctionExpression()) return;
            child.skip();
          },
          ClassProperty: function ClassProperty(child) {
            child.skip();
          },
          CallExpression: function CallExpression(child) {
            if (!child.get("callee").isSuper()) return;
            allSuperCalls.push(child);
          }
        });
        var superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach(function (superCall) {
          var callee = Identifier(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }

      if (argumentsPaths.length > 0) {
        var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
          return Identifier("arguments");
        });
        argumentsPaths.forEach(function (argumentsChild) {
          var argsRef = Identifier(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }

      if (newTargetPaths.length > 0) {
        var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
          return MetaProperty(Identifier("new"), Identifier("target"));
        });
        newTargetPaths.forEach(function (targetChild) {
          var targetRef = Identifier(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }

      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
        }

        var flatSuperProps = superProps.reduce(function (acc, superProp) {
          return acc.concat(standardizeSuperProperty(superProp));
        }, []);
        flatSuperProps.forEach(function (superProp) {
          var key = superProp.node.computed ? "" : superProp.get("property").node.name;
          var isAssignment = superProp.parentPath.isAssignmentExpression({
            left: superProp.node
          });
          var isCall = superProp.parentPath.isCallExpression({
            callee: superProp.node
          });
          var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
          var args = [];

          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }

          if (isAssignment) {
            var value = superProp.parentPath.node.right;
            args.push(value);
          }

          var call = CallExpression(Identifier(superBinding), args);

          if (isCall) {
            superProp.parentPath.unshiftContainer("arguments", ThisExpression());
            superProp.replaceWith(MemberExpression(call, Identifier("call")));
            thisPaths.push(superProp.parentPath.get("arguments.0"));
          } else if (isAssignment) {
            superProp.parentPath.replaceWith(call);
          } else {
            superProp.replaceWith(call);
          }
        });
      }

      var thisBinding;

      if (thisPaths.length > 0 || specCompliant) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);

        if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach(function (thisChild) {
            var thisRef = thisChild.isJSX() ? JSXIdentifier(thisBinding) : Identifier(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (specCompliant) thisBinding = null;
        }
      }

      return thisBinding;
    }

    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        var assignmentPath = superProp.parentPath;
        var op = assignmentPath.node.operator.slice(0, -1);
        var value = assignmentPath.node.right;
        assignmentPath.node.operator = "=";

        if (superProp.node.computed) {
          var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          assignmentPath.get("left").replaceWith(MemberExpression(superProp.node.object, AssignmentExpression("=", tmp, superProp.node.property), true));
          assignmentPath.get("right").replaceWith(BinaryExpression(op, MemberExpression(superProp.node.object, Identifier(tmp.name), true), value));
        } else {
          assignmentPath.get("left").replaceWith(MemberExpression(superProp.node.object, superProp.node.property));
          assignmentPath.get("right").replaceWith(BinaryExpression(op, MemberExpression(superProp.node.object, Identifier(superProp.node.property.name)), value));
        }

        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        var updateExpr = superProp.parentPath;

        var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

        var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        var parts = [AssignmentExpression("=", _tmp, MemberExpression(superProp.node.object, computedKey ? AssignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), AssignmentExpression("=", MemberExpression(superProp.node.object, computedKey ? Identifier(computedKey.name) : superProp.node.property, superProp.node.computed), BinaryExpression("+", Identifier(_tmp.name), NumericLiteral(1)))];

        if (!superProp.parentPath.node.prefix) {
          parts.push(Identifier(_tmp.name));
        }

        updateExpr.replaceWith(SequenceExpression(parts));
        var left = updateExpr.get("expressions.0.right");
        var right = updateExpr.get("expressions.1.left");
        return [left, right];
      }

      return [superProp];
    }

    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }

    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", function (thisBinding) {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return ThisExpression();
        var supers = new WeakSet();
        thisEnvFn.traverse({
          Function: function Function(child) {
            if (child.isArrowFunctionExpression()) return;
            child.skip();
          },
          ClassProperty: function ClassProperty(child) {
            child.skip();
          },
          CallExpression: function CallExpression(child) {
            if (!child.get("callee").isSuper()) return;
            if (supers.has(child.node)) return;
            supers.add(child.node);
            child.replaceWithMultiple([child.node, AssignmentExpression("=", Identifier(thisBinding), Identifier("this"))]);
          }
        });
      });
    }

    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", function () {
        var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return ArrowFunctionExpression([RestElement(argsBinding)], CallExpression(Super(), [SpreadElement(Identifier(argsBinding.name))]));
      });
    }

    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      var op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, "superprop_" + op + ":" + (propName || ""), function () {
        var argsList = [];
        var fnBody;

        if (propName) {
          fnBody = MemberExpression(Super(), Identifier(propName));
        } else {
          var method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = MemberExpression(Super(), Identifier(method.name), true);
        }

        if (isAssignment) {
          var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = AssignmentExpression("=", fnBody, Identifier(valueIdent.name));
        }

        return ArrowFunctionExpression(argsList, fnBody);
      });
    }

    function getBinding(thisEnvFn, key, init) {
      var cacheKey = "binding:" + key;
      var data = thisEnvFn.getData(cacheKey);

      if (!data) {
        var id = thisEnvFn.scope.generateUidIdentifier(key);
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id: id,
          init: init(data)
        });
      }

      return data;
    }

    function getScopeInformation(fnPath) {
      var thisPaths = [];
      var argumentsPaths = [];
      var newTargetPaths = [];
      var superProps = [];
      var superCalls = [];
      fnPath.traverse({
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ThisExpression: function ThisExpression(child) {
          thisPaths.push(child);
        },
        JSXIdentifier: function JSXIdentifier(child) {
          if (child.node.name !== "this") return;

          if (!child.parentPath.isJSXMemberExpression({
            object: child.node
          }) && !child.parentPath.isJSXOpeningElement({
            name: child.node
          })) {
            return;
          }

          thisPaths.push(child);
        },
        CallExpression: function CallExpression(child) {
          if (child.get("callee").isSuper()) superCalls.push(child);
        },
        MemberExpression: function MemberExpression(child) {
          if (child.get("object").isSuper()) superProps.push(child);
        },
        ReferencedIdentifier: function ReferencedIdentifier(child) {
          if (child.node.name !== "arguments") return;
          argumentsPaths.push(child);
        },
        MetaProperty: function MetaProperty(child) {
          if (!child.get("meta").isIdentifier({
            name: "new"
          })) return;
          if (!child.get("property").isIdentifier({
            name: "target"
          })) return;
          newTargetPaths.push(child);
        }
      });
      return {
        thisPaths: thisPaths,
        argumentsPaths: argumentsPaths,
        newTargetPaths: newTargetPaths,
        superProps: superProps,
        superCalls: superCalls
      };
    }

    var NodePath_conversion = /*#__PURE__*/Object.freeze({
      __proto__: null,
      toComputedKey: toComputedKey$1,
      ensureBlock: ensureBlock$1,
      arrowFunctionToShadowed: arrowFunctionToShadowed,
      unwrapFunctionEnvironment: unwrapFunctionEnvironment,
      arrowFunctionToExpression: arrowFunctionToExpression
    });

    function matchesPattern$1(pattern, allowPartial) {
      return matchesPattern(this.node, pattern, allowPartial);
    }
    function has$2(key) {
      var val = this.node && this.node[key];

      if (val && Array.isArray(val)) {
        return !!val.length;
      } else {
        return !!val;
      }
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    var is$1 = has$2;
    function isnt(key) {
      return !this.has(key);
    }
    function equals(key, value) {
      return this.node[key] === value;
    }
    function isNodeType(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }

      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement);
      }

      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      var path = this;
      var first = true;

      do {
        var container = path.container;

        if (path.isFunction() && !first) {
          return !!allowInsideFunction;
        }

        first = false;

        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram());

      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return includes_1(STATEMENT_OR_BLOCK_KEYS, this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) return false;
      var binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      var path = binding.path;
      var parent = path.parentPath;
      if (!parent.isImportDeclaration()) return false;

      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }

      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }

      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }

      if (path.isImportSpecifier() && path.node.imported.name === importName) {
        return true;
      }

      return false;
    }
    function getSource() {
      var node = this.node;

      if (node.end) {
        var code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }

      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }

    function getOuterFunction(path) {
      return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
    }

    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";

        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";

        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";

        case "ForStatement":
          return key === "body" || key === "update";

        case "SwitchStatement":
          return key === "cases";

        case "TryStatement":
          return key === "handler";

        case "AssignmentPattern":
          return key === "right";

        case "OptionalMemberExpression":
          return key === "property";

        case "OptionalCallExpression":
          return key === "arguments";

        default:
          return false;
      }
    }

    function isExecutionUncertainInList(paths, maxIndex) {
      for (var i = 0; i < maxIndex; i++) {
        var path = paths[i];

        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }

      return false;
    }

    function _guessExecutionStatusRelativeTo(target) {
      var funcParent = {
        "this": getOuterFunction(this),
        target: getOuterFunction(target)
      };

      if (funcParent.target.node !== funcParent["this"].node) {
        return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
      }

      var paths = {
        target: target.getAncestry(),
        "this": this.getAncestry()
      };
      if (paths.target.indexOf(this) >= 0) return "after";
      if (paths["this"].indexOf(target) >= 0) return "before";
      var commonPath;
      var commonIndex = {
        target: 0,
        "this": 0
      };

      while (!commonPath && commonIndex["this"] < paths["this"].length) {
        var path = paths["this"][commonIndex["this"]];
        commonIndex.target = paths.target.indexOf(path);

        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex["this"]++;
        }
      }

      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
      }

      if (isExecutionUncertainInList(paths["this"], commonIndex["this"] - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }

      var divergence = {
        "this": paths["this"][commonIndex["this"] - 1],
        target: paths.target[commonIndex.target - 1]
      };

      if (divergence.target.listKey && divergence["this"].listKey && divergence.target.container === divergence["this"].container) {
        return divergence.target.key > divergence["this"].key ? "before" : "after";
      }

      var keys = VISITOR_KEYS[commonPath.type];
      var keyPosition = {
        "this": keys.indexOf(divergence["this"].parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition["this"] ? "before" : "after";
    }
    var executionOrderCheckedNodes = new WeakSet();
    function _guessExecutionStatusRelativeToDifferentFunctions(target) {
      if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
        return "unknown";
      }

      var binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      var referencePaths = binding.referencePaths;
      var allStatus;

      for (var _iterator = _createForOfIteratorHelperLoose(referencePaths), _step; !(_step = _iterator()).done;) {
        var path = _step.value;
        var childOfFunction = !!path.find(function (path) {
          return path.node === target.node;
        });
        if (childOfFunction) continue;

        if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
          return "unknown";
        }

        if (executionOrderCheckedNodes.has(path.node)) continue;
        executionOrderCheckedNodes.add(path.node);

        var status = this._guessExecutionStatusRelativeTo(path);

        executionOrderCheckedNodes["delete"](path.node);

        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }

      return allStatus;
    }
    function resolve(dangerous, resolved) {
      return this._resolve(dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      if (resolved && resolved.indexOf(this) >= 0) return;
      resolved = resolved || [];
      resolved.push(this);

      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        }
      } else if (this.isReferencedIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;

        if (binding.path !== this) {
          var ret = binding.path.resolve(dangerous, resolved);
          if (this.find(function (parent) {
            return parent.node === ret.node;
          })) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        var targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        var targetName = targetKey.value;
        var target = this.get("object").resolve(dangerous, resolved);

        if (target.isObjectExpression()) {
          var props = target.get("properties");

          for (var _i = 0, _arr = props; _i < _arr.length; _i++) {
            var prop = _arr[_i];
            if (!prop.isProperty()) continue;
            var key = prop.get("key");
            var match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match = match || key.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          var elems = target.get("elements");
          var elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }

      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }

        if (this.isTemplateLiteral()) {
          return this.get("expressions").every(function (expression) {
            return expression.isConstantExpression();
          });
        }

        return true;
      }

      if (this.isUnaryExpression()) {
        if (this.get("operator").node !== "void") {
          return false;
        }

        return this.get("argument").isConstantExpression();
      }

      if (this.isBinaryExpression()) {
        return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }

      return false;
    }
    function isInStrictMode() {
      var start = this.isProgram() ? this : this.parentPath;
      var strictParent = start.find(function (path) {
        if (path.isProgram({
          sourceType: "module"
        })) return true;
        if (path.isClass()) return true;
        if (!path.isProgram() && !path.isFunction()) return false;

        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }

        var node = path.node;
        if (path.isFunction()) node = node.body;

        for (var _iterator2 = _createForOfIteratorHelperLoose(node.directives), _step2; !(_step2 = _iterator2()).done;) {
          var directive = _step2.value;

          if (directive.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }

    var NodePath_introspection = /*#__PURE__*/Object.freeze({
      __proto__: null,
      matchesPattern: matchesPattern$1,
      has: has$2,
      isStatic: isStatic,
      is: is$1,
      isnt: isnt,
      equals: equals,
      isNodeType: isNodeType,
      canHaveVariableDeclarationOrExpression: canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: canSwapBetweenExpressionAndStatement,
      isCompletionRecord: isCompletionRecord,
      isStatementOrBlock: isStatementOrBlock,
      referencesImport: referencesImport,
      getSource: getSource,
      willIMaybeExecuteBefore: willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: _guessExecutionStatusRelativeTo,
      _guessExecutionStatusRelativeToDifferentFunctions: _guessExecutionStatusRelativeToDifferentFunctions,
      resolve: resolve,
      _resolve: _resolve,
      isConstantExpression: isConstantExpression,
      isInStrictMode: isInStrictMode
    });

    function call(key) {
      var opts = this.opts;
      this.debug(key);

      if (this.node) {
        if (this._call(opts[key])) return true;
      }

      if (this.node) {
        return this._call(opts[this.node.type] && opts[this.node.type][key]);
      }

      return false;
    }
    function _call(fns) {
      if (!fns) return false;

      for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
        var fn = _step.value;
        if (!fn) continue;
        var node = this.node;
        if (!node) return true;
        var ret = fn.call(this.state, this, this.state);

        if (ret && typeof ret === "object" && typeof ret.then === "function") {
          throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
        }

        if (ret) {
          throw new Error("Unexpected return value from visitor method " + fn);
        }

        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }

      return false;
    }
    function isBlacklisted() {
      var blacklist = this.opts.blacklist;
      return blacklist && blacklist.indexOf(this.node.type) > -1;
    }
    function visit$1() {
      if (!this.node) {
        return false;
      }

      if (this.isBlacklisted()) {
        return false;
      }

      if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
        return false;
      }

      if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
        this.debug("Skip...");
        return this.shouldStop;
      }

      this.debug("Recursing into...");
      traverse$1.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      this.call("exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }

      this.skipKeys[key] = true;
    }
    function stop() {
      this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
    }
    function setScope() {
      if (this.opts && this.opts.noScope) return;
      var path = this.parentPath;
      var target;

      while (path && !target) {
        if (path.opts && path.opts.noScope) return;
        target = path.scope;
        path = path.parentPath;
      }

      this.scope = this.getScope(target);
      if (this.scope) this.scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }

      this._traverseFlags = 0;

      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }

      this.setScope();
      return this;
    }
    function resync() {
      if (this.removed) return;

      this._resyncParent();

      this._resyncList();

      this._resyncKey();
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) return;

      if (Array.isArray(this.container)) {
        for (var i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            return this.setKey(i);
          }
        }
      } else {
        for (var _i = 0, _Object$keys = Object.keys(this.container); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (this.container[key] === this.node) {
            return this.setKey(key);
          }
        }
      }

      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      var newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        this._markRemoved();
      }
    }
    function popContext() {
      this.contexts.pop();

      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(undefined);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup$1(parentPath, container, listKey, key) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      this.setKey(key);
    }
    function setKey(key) {
      this.key = key;
      this.node = this.container[this.key];
      this.type = this.node && this.node.type;
    }
    function requeue(pathToQueue) {
      if (pathToQueue === void 0) {
        pathToQueue = this;
      }

      if (pathToQueue.removed) return;
      var contexts = this.contexts;

      for (var _iterator2 = _createForOfIteratorHelperLoose(contexts), _step2; !(_step2 = _iterator2()).done;) {
        var context = _step2.value;
        context.maybeQueue(pathToQueue);
      }
    }
    function _getQueueContexts() {
      var path = this;
      var contexts = this.contexts;

      while (!contexts.length) {
        path = path.parentPath;
        if (!path) break;
        contexts = path.contexts;
      }

      return contexts;
    }

    var NodePath_context = /*#__PURE__*/Object.freeze({
      __proto__: null,
      call: call,
      _call: _call,
      isBlacklisted: isBlacklisted,
      visit: visit$1,
      skip: skip,
      skipKey: skipKey,
      stop: stop,
      setScope: setScope,
      setContext: setContext,
      resync: resync,
      _resyncParent: _resyncParent,
      _resyncKey: _resyncKey,
      _resyncList: _resyncList,
      _resyncRemoved: _resyncRemoved,
      popContext: popContext,
      pushContext: pushContext,
      setup: setup$1,
      setKey: setKey,
      requeue: requeue,
      _getQueueContexts: _getQueueContexts
    });

    var hooks = [function (self, parent) {
      var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function (self, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function (self, parent) {
      if (parent.isBinary()) {
        if (self.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }

        return true;
      }
    }, function (self, parent) {
      if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];

    function remove() {
      this._assertUnremoved();

      this.resync();

      if (!this.opts || !this.opts.noScope) {
        this._removeFromScope();
      }

      if (this._callRemovalHooks()) {
        this._markRemoved();

        return;
      }

      this.shareCommentsWithSiblings();

      this._remove();

      this._markRemoved();
    }
    function _removeFromScope() {
      var _this = this;

      var bindings = this.getBindingIdentifiers();
      Object.keys(bindings).forEach(function (name) {
        return _this.scope.removeBinding(name);
      });
    }
    function _callRemovalHooks() {
      for (var _i = 0, _arr = hooks; _i < _arr.length; _i++) {
        var fn = _arr[_i];
        if (fn(this, this.parentPath)) return true;
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        this.updateSiblingKeys(this.key, -1);
      } else {
        this._replaceWith(null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= SHOULD_SKIP | REMOVED;
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }

    var NodePath_removal = /*#__PURE__*/Object.freeze({
      __proto__: null,
      remove: remove,
      _removeFromScope: _removeFromScope,
      _callRemovalHooks: _callRemovalHooks,
      _remove: _remove,
      _markRemoved: _markRemoved,
      _assertUnremoved: _assertUnremoved
    });

    var referenceVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
          return;
        }

        if (path.node.name === "this") {
          var scope = path.scope;

          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);

          if (scope) state.breakOnScopePaths.push(scope.path);
        }

        var binding = path.scope.getBinding(path.node.name);
        if (!binding) return;

        for (var _iterator = _createForOfIteratorHelperLoose(binding.constantViolations), _step; !(_step = _iterator()).done;) {
          var violation = _step.value;

          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }

        if (binding !== state.scope.getBinding(path.node.name)) return;
        state.bindings[path.node.name] = binding;
      }
    };

    var PathHoister = function () {
      function PathHoister(path, scope) {
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path;
        this.attachAfter = false;
      }

      var _proto = PathHoister.prototype;

      _proto.isCompatibleScope = function isCompatibleScope(scope) {
        for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          var binding = this.bindings[key];

          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }

        return true;
      };

      _proto.getCompatibleScopes = function getCompatibleScopes() {
        var scope = this.path.scope;

        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }

          if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
            break;
          }
        } while (scope = scope.parent);
      };

      _proto.getAttachmentPath = function getAttachmentPath() {
        var path = this._getAttachmentPath();

        if (!path) return;
        var targetScope = path.scope;

        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }

        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {
            var name = _Object$keys2[_i2];
            if (!targetScope.hasOwnBinding(name)) continue;
            var binding = this.bindings[name];

            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }

            var bindingParentPath = this.getAttachmentParentForPath(binding.path);

            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;

              for (var _i3 = 0, _arr = binding.constantViolations; _i3 < _arr.length; _i3++) {
                var violationPath = _arr[_i3];

                if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                  path = violationPath;
                }
              }
            }
          }
        }

        return path;
      };

      _proto._getAttachmentPath = function _getAttachmentPath() {
        var scopes = this.scopes;
        var scope = scopes.pop();
        if (!scope) return;

        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            var bodies = scope.path.get("body").get("body");

            for (var i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      };

      _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
        var scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      };

      _proto.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            return path;
          }
        } while (path = path.parentPath);
      };

      _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {
        for (var _i4 = 0, _Object$keys3 = Object.keys(this.bindings); _i4 < _Object$keys3.length; _i4++) {
          var name = _Object$keys3[_i4];
          if (!scope.hasOwnBinding(name)) continue;
          var binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant) return true;
        }

        return false;
      };

      _proto.run = function run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        var attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        var uid = attachTo.scope.generateUidIdentifier("ref");
        var declarator = VariableDeclarator(uid, this.path.node);
        var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

        var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : VariableDeclaration("var", [declarator])]),
            attached = _attachTo$insertFn[0];

        var parent = this.path.parentPath;

        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = JSXExpressionContainer(uid);
        }

        this.path.replaceWith(cloneNode(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      };

      return PathHoister;
    }();

    function insertBefore(nodes) {
      this._assertUnremoved();

      nodes = this._verifyNodeList(nodes);
      var parentPath = this.parentPath;

      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return this._containerInsertBefore(nodes);
      } else if (this.isStatementOrBlock()) {
        var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
        this.replaceWith(BlockStatement(shouldInsertCurrentNode ? [this.node] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      var _this$container;

      this.updateSiblingKeys(from, nodes.length);
      var paths = [];

      (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(nodes));

      for (var i = 0; i < nodes.length; i++) {
        var to = from + i;
        var path = this.getSibling(to);
        paths.push(path);

        if (this.context && this.context.queue) {
          path.pushContext(this.context);
        }
      }

      var contexts = this._getQueueContexts();

      for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
        var _path = _paths[_i];

        _path.setScope();

        _path.debug("Inserted.");

        for (var _iterator = _createForOfIteratorHelperLoose(contexts), _step; !(_step = _iterator()).done;) {
          var context = _step.value;
          context.maybeQueue(_path, true);
        }
      }

      return paths;
    }
    function _containerInsertBefore(nodes) {
      return this._containerInsert(this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return this._containerInsert(this.key + 1, nodes);
    }
    function insertAfter(nodes) {
      this._assertUnremoved();

      nodes = this._verifyNodeList(nodes);
      var parentPath = this.parentPath;

      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map(function (node) {
          return isExpression(node) ? ExpressionStatement(node) : node;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) {
          var scope = this.scope;

          if (parentPath.isMethod({
            computed: true,
            key: this.node
          })) {
            scope = scope.parent;
          }

          var temp = scope.generateDeclaredUidIdentifier();
          nodes.unshift(ExpressionStatement(AssignmentExpression("=", cloneNode(temp), this.node)));
          nodes.push(ExpressionStatement(cloneNode(temp)));
        }

        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return this._containerInsertAfter(nodes);
      } else if (this.isStatementOrBlock()) {
        var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
        this.replaceWith(BlockStatement(shouldInsertCurrentNode ? [this.node] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      var paths = path.get(this.parent);

      for (var i = 0; i < paths.length; i++) {
        var path$1 = paths[i];

        if (path$1.key >= fromIndex) {
          path$1.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }

      if (nodes.constructor !== Array) {
        nodes = [nodes];
      }

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var msg = void 0;

        if (!node) {
          msg = "has falsy node";
        } else if (typeof node !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof NodePath) {
          msg = "has a NodePath when it expected a raw object";
        }

        if (msg) {
          var type = Array.isArray(node) ? "array" : typeof node;
          throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
        }
      }

      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      this._assertUnremoved();

      nodes = this._verifyNodeList(nodes);
      var path = NodePath.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey: listKey,
        key: 0
      });
      return path._containerInsertBefore(nodes);
    }
    function pushContainer(listKey, nodes) {
      this._assertUnremoved();

      nodes = this._verifyNodeList(nodes);
      var container = this.node[listKey];
      var path = NodePath.get({
        parentPath: this,
        parent: this.node,
        container: container,
        listKey: listKey,
        key: container.length
      });
      return path.replaceWithMultiple(nodes);
    }
    function hoist(scope) {
      if (scope === void 0) {
        scope = this.scope;
      }

      var hoister = new PathHoister(this, scope);
      return hoister.run();
    }

    var NodePath_modification = /*#__PURE__*/Object.freeze({
      __proto__: null,
      insertBefore: insertBefore,
      _containerInsert: _containerInsert,
      _containerInsertBefore: _containerInsertBefore,
      _containerInsertAfter: _containerInsertAfter,
      insertAfter: insertAfter,
      updateSiblingKeys: updateSiblingKeys,
      _verifyNodeList: _verifyNodeList,
      unshiftContainer: unshiftContainer,
      pushContainer: pushContainer,
      hoist: hoist
    });

    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
    }

    function addCompletionRecords(path, paths) {
      if (path) return paths.concat(path.getCompletionRecords());
      return paths;
    }

    function completionRecordForSwitch(cases, paths) {
      var isLastCaseWithConsequent = true;

      for (var i = cases.length - 1; i >= 0; i--) {
        var switchCase = cases[i];
        var consequent = switchCase.get("consequent");
        var breakStatement = void 0;

        findBreak: for (var _iterator = _createForOfIteratorHelperLoose(consequent), _step; !(_step = _iterator()).done;) {
          var statement = _step.value;

          if (statement.isBlockStatement()) {
            for (var _iterator2 = _createForOfIteratorHelperLoose(statement.get("body")), _step2; !(_step2 = _iterator2()).done;) {
              var statementInBlock = _step2.value;

              if (statementInBlock.isBreakStatement()) {
                breakStatement = statementInBlock;
                break findBreak;
              }
            }
          } else if (statement.isBreakStatement()) {
            breakStatement = statement;
            break;
          }
        }

        if (breakStatement) {
          while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {
            breakStatement = breakStatement.parentPath;
          }

          var prevSibling = breakStatement.getPrevSibling();

          if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {
            paths = addCompletionRecords(prevSibling, paths);
            breakStatement.remove();
          } else {
            breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());
            paths = addCompletionRecords(breakStatement, paths);
          }
        } else if (isLastCaseWithConsequent) {
          (function () {
            var statementFinder = function statementFinder(statement) {
              return !statement.isBlockStatement() || statement.get("body").some(statementFinder);
            };

            var hasConsequent = consequent.some(statementFinder);

            if (hasConsequent) {
              paths = addCompletionRecords(consequent[consequent.length - 1], paths);
              isLastCaseWithConsequent = false;
            }
          })();
        }
      }

      return paths;
    }

    function getCompletionRecords() {
      var paths = [];

      if (this.isIfStatement()) {
        paths = addCompletionRecords(this.get("consequent"), paths);
        paths = addCompletionRecords(this.get("alternate"), paths);
      } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
        paths = addCompletionRecords(this.get("body"), paths);
      } else if (this.isProgram() || this.isBlockStatement()) {
        paths = addCompletionRecords(this.get("body").pop(), paths);
      } else if (this.isFunction()) {
        return this.get("body").getCompletionRecords();
      } else if (this.isTryStatement()) {
        paths = addCompletionRecords(this.get("block"), paths);
        paths = addCompletionRecords(this.get("handler"), paths);
      } else if (this.isCatchClause()) {
        paths = addCompletionRecords(this.get("body"), paths);
      } else if (this.isSwitchStatement()) {
        paths = completionRecordForSwitch(this.get("cases"), paths);
      } else {
        paths.push(this);
      }

      return paths;
    }
    function getSibling(key) {
      return NodePath.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: key
      });
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      var _key = this.key;
      var sibling = this.getSibling(++_key);
      var siblings = [];

      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }

      return siblings;
    }
    function getAllPrevSiblings() {
      var _key = this.key;
      var sibling = this.getSibling(--_key);
      var siblings = [];

      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }

      return siblings;
    }
    function get(key, context) {
      if (context === true) context = this.context;
      var parts = key.split(".");

      if (parts.length === 1) {
        return this._getKey(key, context);
      } else {
        return this._getPattern(parts, context);
      }
    }
    function _getKey(key, context) {
      var _this = this;

      var node = this.node;
      var container = node[key];

      if (Array.isArray(container)) {
        return container.map(function (_, i) {
          return NodePath.get({
            listKey: key,
            parentPath: _this,
            parent: node,
            container: container,
            key: i
          }).setContext(context);
        });
      } else {
        return NodePath.get({
          parentPath: this,
          parent: node,
          container: node,
          key: key
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      var path = this;

      for (var _iterator3 = _createForOfIteratorHelperLoose(parts), _step3; !(_step3 = _iterator3()).done;) {
        var part = _step3.value;

        if (part === ".") {
          path = path.parentPath;
        } else {
          if (Array.isArray(path)) {
            path = path[part];
          } else {
            path = path.get(part, context);
          }
        }
      }

      return path;
    }
    function getBindingIdentifiers$1(duplicates) {
      return getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers$1(duplicates) {
      return getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates, outerOnly) {
      if (duplicates === void 0) {
        duplicates = false;
      }

      if (outerOnly === void 0) {
        outerOnly = false;
      }

      var path = this;
      var search = [].concat(path);
      var ids = Object.create(null);

      while (search.length) {
        var id = search.shift();
        if (!id) continue;
        if (!id.node) continue;
        var keys = getBindingIdentifiers.keys[id.node.type];

        if (id.isIdentifier()) {
          if (duplicates) {
            var _ids = ids[id.node.name] = ids[id.node.name] || [];

            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }

          continue;
        }

        if (id.isExportDeclaration()) {
          var declaration = id.get("declaration");

          if (declaration.isDeclaration()) {
            search.push(declaration);
          }

          continue;
        }

        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }

          if (id.isFunctionExpression()) {
            continue;
          }
        }

        if (keys) {
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var child = id.get(key);

            if (Array.isArray(child) || child.node) {
              search = search.concat(child);
            }
          }
        }
      }

      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }

    var NodePath_family = /*#__PURE__*/Object.freeze({
      __proto__: null,
      getOpposite: getOpposite,
      getCompletionRecords: getCompletionRecords,
      getSibling: getSibling,
      getPrevSibling: getPrevSibling,
      getNextSibling: getNextSibling,
      getAllNextSiblings: getAllNextSiblings,
      getAllPrevSiblings: getAllPrevSiblings,
      get: get,
      _getKey: _getKey,
      _getPattern: _getPattern,
      getBindingIdentifiers: getBindingIdentifiers$1,
      getOuterBindingIdentifiers: getOuterBindingIdentifiers$1,
      getBindingIdentifierPaths: getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: getOuterBindingIdentifierPaths
    });

    function shareCommentsWithSiblings() {
      if (typeof this.key === "string") return;
      var node = this.node;
      if (!node) return;
      var trailing = node.trailingComments;
      var leading = node.leadingComments;
      if (!trailing && !leading) return;
      var prev = this.getSibling(this.key - 1);
      var next = this.getSibling(this.key + 1);
      var hasPrev = Boolean(prev.node);
      var hasNext = Boolean(next.node);

      if (hasPrev && !hasNext) {
        prev.addComments("trailing", trailing);
      } else if (hasNext && !hasPrev) {
        next.addComments("leading", leading);
      }
    }
    function addComment$1(type, content, line) {
      addComment(this.node, type, content, line);
    }
    function addComments$1(type, comments) {
      addComments(this.node, type, comments);
    }

    var NodePath_comments = /*#__PURE__*/Object.freeze({
      __proto__: null,
      shareCommentsWithSiblings: shareCommentsWithSiblings,
      addComment: addComment$1,
      addComments: addComments$1
    });

    var _debug = browser$1("babel");

    var REMOVED = 1 << 0;
    var SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = 1 << 2;

    var NodePath = function () {
      function NodePath(hub, parent) {
        this.parent = parent;
        this.hub = hub;
        this.contexts = [];
        this.data = null;
        this._traverseFlags = 0;
        this.state = null;
        this.opts = null;
        this.skipKeys = null;
        this.parentPath = null;
        this.context = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.scope = null;
        this.type = null;
      }

      NodePath.get = function get(_ref) {
        var hub = _ref.hub,
            parentPath = _ref.parentPath,
            parent = _ref.parent,
            container = _ref.container,
            listKey = _ref.listKey,
            key = _ref.key;

        if (!hub && parentPath) {
          hub = parentPath.hub;
        }

        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }

        var targetNode = container[key];
        var paths = path.get(parent) || [];

        if (!path.has(parent)) {
          path.set(parent, paths);
        }

        var path$1;

        for (var i = 0; i < paths.length; i++) {
          var pathCheck = paths[i];

          if (pathCheck.node === targetNode) {
            path$1 = pathCheck;
            break;
          }
        }

        if (!path$1) {
          path$1 = new NodePath(hub, parent);
          paths.push(path$1);
        }

        path$1.setup(parentPath, container, listKey, key);
        return path$1;
      };

      var _proto = NodePath.prototype;

      _proto.getScope = function getScope(scope) {
        return this.isScope() ? new Scope$1(this) : scope;
      };

      _proto.setData = function setData(key, val) {
        if (this.data == null) {
          this.data = Object.create(null);
        }

        return this.data[key] = val;
      };

      _proto.getData = function getData(key, def) {
        if (this.data == null) {
          this.data = Object.create(null);
        }

        var val = this.data[key];
        if (val === undefined && def !== undefined) val = this.data[key] = def;
        return val;
      };

      _proto.buildCodeFrameError = function buildCodeFrameError(msg, Error) {
        if (Error === void 0) {
          Error = SyntaxError;
        }

        return this.hub.buildError(this.node, msg, Error);
      };

      _proto.traverse = function traverse(visitor, state) {
        traverse$1(this.node, visitor, this.scope, state, this);
      };

      _proto.set = function set(key, node) {
        validate(this.node, key, node);
        this.node[key] = node;
      };

      _proto.getPathLocation = function getPathLocation() {
        var parts = [];
        var path = this;

        do {
          var key = path.key;
          if (path.inList) key = path.listKey + "[" + key + "]";
          parts.unshift(key);
        } while (path = path.parentPath);

        return parts.join(".");
      };

      _proto.debug = function debug(message) {
        if (!_debug.enabled) return;

        _debug(this.getPathLocation() + " " + this.type + ": " + message);
      };

      _proto.toString = function toString() {
        return generateCode(this.node).code;
      };

      _createClass(NodePath, [{
        key: "inList",
        get: function get() {
          return !!this.listKey;
        },
        set: function set(inList) {
          if (!inList) {
            this.listKey = null;
          }
        }
      }, {
        key: "parentKey",
        get: function get() {
          return this.listKey || this.key;
        }
      }, {
        key: "shouldSkip",
        get: function get() {
          return !!(this._traverseFlags & SHOULD_SKIP);
        },
        set: function set(v) {
          if (v) {
            this._traverseFlags |= SHOULD_SKIP;
          } else {
            this._traverseFlags &= ~SHOULD_SKIP;
          }
        }
      }, {
        key: "shouldStop",
        get: function get() {
          return !!(this._traverseFlags & SHOULD_STOP);
        },
        set: function set(v) {
          if (v) {
            this._traverseFlags |= SHOULD_STOP;
          } else {
            this._traverseFlags &= ~SHOULD_STOP;
          }
        }
      }, {
        key: "removed",
        get: function get() {
          return !!(this._traverseFlags & REMOVED);
        },
        set: function set(v) {
          if (v) {
            this._traverseFlags |= REMOVED;
          } else {
            this._traverseFlags &= ~REMOVED;
          }
        }
      }]);

      return NodePath;
    }();
    Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

    var _loop = function _loop() {
      var type = _arr[_i$2];
      var typeKey = "is" + type;
      var fn = t[typeKey];

      NodePath.prototype[typeKey] = function (opts) {
        return fn(this.node, opts);
      };

      NodePath.prototype["assert" + type] = function (opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError("Expected node path of type " + type);
        }
      };
    };

    for (var _i$2 = 0, _arr = TYPES; _i$2 < _arr.length; _i$2++) {
      _loop();
    }

    var _loop2 = function _loop2() {
      var type = _Object$keys[_i2];
      if (type[0] === "_") return "continue";
      if (TYPES.indexOf(type) < 0) TYPES.push(type);
      var virtualType = virtualTypes[type];

      NodePath.prototype["is" + type] = function (opts) {
        return virtualType.checkPath(this, opts);
      };
    };

    for (var _i2 = 0, _Object$keys = Object.keys(virtualTypes); _i2 < _Object$keys.length; _i2++) {
      var _ret = _loop2();

      if (_ret === "continue") continue;
    }

    var TraversalContext = function () {
      function TraversalContext(scope, opts, state, parentPath) {
        this.queue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }

      var _proto = TraversalContext.prototype;

      _proto.shouldVisit = function shouldVisit(node) {
        var opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        var keys = VISITOR_KEYS[node.type];
        if (!keys || !keys.length) return false;

        for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
          var key = _step.value;
          if (node[key]) return true;
        }

        return false;
      };

      _proto.create = function create(node, obj, key, listKey) {
        return NodePath.get({
          parentPath: this.parentPath,
          parent: node,
          container: obj,
          key: key,
          listKey: listKey
        });
      };

      _proto.maybeQueue = function maybeQueue(path, notPriority) {
        if (this.trap) {
          throw new Error("Infinite cycle detected");
        }

        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      };

      _proto.visitMultiple = function visitMultiple(container, parent, listKey) {
        if (container.length === 0) return false;
        var queue = [];

        for (var key = 0; key < container.length; key++) {
          var node = container[key];

          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }

        return this.visitQueue(queue);
      };

      _proto.visitSingle = function visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      };

      _proto.visitQueue = function visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        var visited = [];
        var stop = false;

        for (var _iterator2 = _createForOfIteratorHelperLoose(queue), _step2; !(_step2 = _iterator2()).done;) {
          var path = _step2.value;
          path.resync();

          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            path.pushContext(this);
          }

          if (path.key === null) continue;

          if (visited.indexOf(path.node) >= 0) continue;
          visited.push(path.node);

          if (path.visit()) {
            stop = true;
            break;
          }

          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }

        for (var _iterator3 = _createForOfIteratorHelperLoose(queue), _step3; !(_step3 = _iterator3()).done;) {
          var _path = _step3.value;

          _path.popContext();
        }

        this.queue = null;
        return stop;
      };

      _proto.visit = function visit(node, key) {
        var nodes = node[key];
        if (!nodes) return false;

        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      };

      return TraversalContext;
    }();

    function explode(visitor) {
      if (visitor._exploded) return visitor;
      visitor._exploded = true;

      for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
        var nodeType = _Object$keys[_i];
        if (shouldIgnoreKey(nodeType)) continue;
        var parts = nodeType.split("|");
        if (parts.length === 1) continue;
        var fns = visitor[nodeType];
        delete visitor[nodeType];

        for (var _iterator = _createForOfIteratorHelperLoose(parts), _step; !(_step = _iterator()).done;) {
          var part = _step.value;
          visitor[part] = fns;
        }
      }

      verify(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);

      for (var _i2 = 0, _arr = Object.keys(visitor); _i2 < _arr.length; _i2++) {
        var _nodeType = _arr[_i2];
        if (shouldIgnoreKey(_nodeType)) continue;
        var wrapper = virtualTypes[_nodeType];
        if (!wrapper) continue;
        var _fns = visitor[_nodeType];

        for (var _i3 = 0, _Object$keys2 = Object.keys(_fns); _i3 < _Object$keys2.length; _i3++) {
          var type = _Object$keys2[_i3];
          _fns[type] = wrapCheck(wrapper, _fns[type]);
        }

        delete visitor[_nodeType];

        if (wrapper.types) {
          for (var _i4 = 0, _arr2 = wrapper.types; _i4 < _arr2.length; _i4++) {
            var _type = _arr2[_i4];

            if (visitor[_type]) {
              mergePair(visitor[_type], _fns);
            } else {
              visitor[_type] = _fns;
            }
          }
        } else {
          mergePair(visitor, _fns);
        }
      }

      for (var _i5 = 0, _Object$keys3 = Object.keys(visitor); _i5 < _Object$keys3.length; _i5++) {
        var _nodeType2 = _Object$keys3[_i5];
        if (shouldIgnoreKey(_nodeType2)) continue;
        var _fns2 = visitor[_nodeType2];
        var aliases = FLIPPED_ALIAS_KEYS[_nodeType2];
        var deprecratedKey = DEPRECATED_KEYS[_nodeType2];

        if (deprecratedKey) {
          console.trace("Visitor defined for " + _nodeType2 + " but it has been renamed to " + deprecratedKey);
          aliases = [deprecratedKey];
        }

        if (!aliases) continue;
        delete visitor[_nodeType2];

        for (var _iterator2 = _createForOfIteratorHelperLoose(aliases), _step2; !(_step2 = _iterator2()).done;) {
          var alias = _step2.value;
          var existing = visitor[alias];

          if (existing) {
            mergePair(existing, _fns2);
          } else {
            visitor[alias] = clone_1(_fns2);
          }
        }
      }

      for (var _i6 = 0, _Object$keys4 = Object.keys(visitor); _i6 < _Object$keys4.length; _i6++) {
        var _nodeType3 = _Object$keys4[_i6];
        if (shouldIgnoreKey(_nodeType3)) continue;
        ensureCallbackArrays(visitor[_nodeType3]);
      }

      return visitor;
    }
    function verify(visitor) {
      if (visitor._verified) return;

      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
      }

      for (var _i7 = 0, _Object$keys5 = Object.keys(visitor); _i7 < _Object$keys5.length; _i7++) {
        var nodeType = _Object$keys5[_i7];

        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }

        if (shouldIgnoreKey(nodeType)) continue;

        if (TYPES.indexOf(nodeType) < 0) {
          throw new Error("You gave us a visitor for the node type " + nodeType + " but it's not a valid type");
        }

        var visitors = visitor[nodeType];

        if (typeof visitors === "object") {
          for (var _i8 = 0, _Object$keys6 = Object.keys(visitors); _i8 < _Object$keys6.length; _i8++) {
            var visitorKey = _Object$keys6[_i8];

            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
            } else {
              throw new Error("You passed `traverse()` a visitor object with the property " + (nodeType + " that has the invalid property " + visitorKey));
            }
          }
        }
      }

      visitor._verified = true;
    }

    function validateVisitorMethods(path, val) {
      var fns = [].concat(val);

      for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
        var fn = _step3.value;

        if (typeof fn !== "function") {
          throw new TypeError("Non-function found defined in " + path + " with type " + typeof fn);
        }
      }
    }

    function merge$1(visitors, states, wrapper) {
      if (states === void 0) {
        states = [];
      }

      var rootVisitor = {};

      for (var i = 0; i < visitors.length; i++) {
        var visitor = visitors[i];
        var state = states[i];
        explode(visitor);

        for (var _i9 = 0, _Object$keys7 = Object.keys(visitor); _i9 < _Object$keys7.length; _i9++) {
          var type = _Object$keys7[_i9];
          var visitorType = visitor[type];

          if (state || wrapper) {
            visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
          }

          var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
          mergePair(nodeVisitor, visitorType);
        }
      }

      return rootVisitor;
    }

    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      var newVisitor = {};

      var _loop = function _loop() {
        var key = _Object$keys8[_i10];
        var fns = oldVisitor[key];
        if (!Array.isArray(fns)) return "continue";
        fns = fns.map(function (fn) {
          var newFn = fn;

          if (state) {
            newFn = function newFn(path) {
              return fn.call(state, path, state);
            };
          }

          if (wrapper) {
            newFn = wrapper(state.key, key, newFn);
          }

          if (newFn !== fn) {
            newFn.toString = function () {
              return fn.toString();
            };
          }

          return newFn;
        });
        newVisitor[key] = fns;
      };

      for (var _i10 = 0, _Object$keys8 = Object.keys(oldVisitor); _i10 < _Object$keys8.length; _i10++) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return newVisitor;
    }

    function ensureEntranceObjects(obj) {
      for (var _i11 = 0, _Object$keys9 = Object.keys(obj); _i11 < _Object$keys9.length; _i11++) {
        var key = _Object$keys9[_i11];
        if (shouldIgnoreKey(key)) continue;
        var fns = obj[key];

        if (typeof fns === "function") {
          obj[key] = {
            enter: fns
          };
        }
      }
    }

    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
    }

    function wrapCheck(wrapper, fn) {
      var newFn = function newFn(path) {
        if (wrapper.checkPath(path)) {
          return fn.apply(this, arguments);
        }
      };

      newFn.toString = function () {
        return fn.toString();
      };

      return newFn;
    }

    function shouldIgnoreKey(key) {
      if (key[0] === "_") return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

      if (key === "blacklist" || key === "noScope" || key === "skipKeys") {
        return true;
      }

      return false;
    }

    function mergePair(dest, src) {
      for (var _i12 = 0, _Object$keys10 = Object.keys(src); _i12 < _Object$keys10.length; _i12++) {
        var key = _Object$keys10[_i12];
        dest[key] = [].concat(dest[key] || [], src[key]);
      }
    }

    var visitors = /*#__PURE__*/Object.freeze({
      __proto__: null,
      explode: explode,
      verify: verify,
      merge: merge$1
    });

    function traverse$1(parent, opts, scope, state, parentPath) {
      if (!parent) return;
      if (!opts) opts = {};

      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + ("Instead of that you tried to traverse a " + parent.type + " node without ") + "passing scope and parentPath.");
        }
      }

      if (!VISITOR_KEYS[parent.type]) {
        return;
      }

      explode(opts);
      traverse$1.node(parent, opts, scope, state, parentPath);
    }
    traverse$1.visitors = visitors;
    traverse$1.verify = verify;
    traverse$1.explode = explode;

    traverse$1.cheap = function (node, enter) {
      return traverseFast(node, enter);
    };

    traverse$1.node = function (node, opts, scope, state, parentPath, skipKeys) {
      var keys = VISITOR_KEYS[node.type];
      if (!keys) return;
      var context = new TraversalContext(scope, opts, state, parentPath);

      for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        if (skipKeys && skipKeys[key]) continue;
        if (context.visit(node, key)) return;
      }
    };

    traverse$1.clearNode = function (node, opts) {
      removeProperties(node, opts);
      path["delete"](node);
    };

    traverse$1.removeProperties = function (tree, opts) {
      traverseFast(tree, traverse$1.clearNode, opts);
      return tree;
    };

    function hasBlacklistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }

    traverse$1.hasType = function (tree, type, blacklistTypes) {
      if (includes_1(blacklistTypes, tree.type)) return false;
      if (tree.type === type) return true;
      var state = {
        has: false,
        type: type
      };
      traverse$1(tree, {
        noScope: true,
        blacklist: blacklistTypes,
        enter: hasBlacklistedType
      }, null, state);
      return state.has;
    };

    traverse$1.cache = cache;

    function _templateObject79() {
      var data = _taggedTemplateLiteralLoose(["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"], ["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"]);

      _templateObject79 = function _templateObject79() {
        return data;
      };

      return data;
    }

    function _templateObject78() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodSet() {\n    throw new TypeError(\"attempted to reassign private method\");\n  }\n"]);

      _templateObject78 = function _templateObject78() {
        return data;
      };

      return data;
    }

    function _templateObject77() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n"]);

      _templateObject77 = function _templateObject77() {
        return data;
      };

      return data;
    }

    function _templateObject76() {
      var data = _taggedTemplateLiteralLoose(["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"], ["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"]);

      _templateObject76 = function _templateObject76() {
        return data;
      };

      return data;
    }

    function _templateObject75() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n"]);

      _templateObject75 = function _templateObject75() {
        return data;
      };

      return data;
    }

    function _templateObject74() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    return method;\n  }\n"]);

      _templateObject74 = function _templateObject74() {
        return data;
      };

      return data;
    }

    function _templateObject73() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

      _templateObject73 = function _templateObject73() {
        return data;
      };

      return data;
    }

    function _templateObject72() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

      _templateObject72 = function _templateObject72() {
        return data;
      };

      return data;
    }

    function _templateObject71() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    var descriptor = privateMap.get(receiver);\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n"]);

      _templateObject71 = function _templateObject71() {
        return data;
      };

      return data;
    }

    function _templateObject70() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

      _templateObject70 = function _templateObject70() {
        return data;
      };

      return data;
    }

    function _templateObject69() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

      _templateObject69 = function _templateObject69() {
        return data;
      };

      return data;
    }

    function _templateObject68() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n"]);

      _templateObject68 = function _templateObject68() {
        return data;
      };

      return data;
    }

    function _templateObject67() {
      var data = _taggedTemplateLiteralLoose(["\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n"]);

      _templateObject67 = function _templateObject67() {
        return data;
      };

      return data;
    }

    function _templateObject66() {
      var data = _taggedTemplateLiteralLoose(["\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            // This is a hack to avoid this being processed by 'transform-runtime'.\n            // See issue #9.\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n"]);

      _templateObject66 = function _templateObject66() {
        return data;
      };

      return data;
    }

    function _templateObject65() {
      var data = _taggedTemplateLiteralLoose(["\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"]);

      _templateObject65 = function _templateObject65() {
        return data;
      };

      return data;
    }

    function _templateObject64() {
      var data = _taggedTemplateLiteralLoose(["\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n"]);

      _templateObject64 = function _templateObject64() {
        return data;
      };

      return data;
    }

    function _templateObject63() {
      var data = _taggedTemplateLiteralLoose(["\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n"]);

      _templateObject63 = function _templateObject63() {
        return data;
      };

      return data;
    }

    function _templateObject62() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n"]);

      _templateObject62 = function _templateObject62() {
        return data;
      };

      return data;
    }

    function _templateObject61() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n"]);

      _templateObject61 = function _templateObject61() {
        return data;
      };

      return data;
    }

    function _templateObject60() {
      var data = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o) {\n    var i = 0;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o)))\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    i = o[Symbol.iterator]();\n    return i.next.bind(i);\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o) {\n    var i = 0;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o)))\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    i = o[Symbol.iterator]();\n    return i.next.bind(i);\n  }\n"]);

      _templateObject60 = function _templateObject60() {
        return data;
      };

      return data;
    }

    function _templateObject59() {
      var data = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o) {\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var it, normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o) {\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var it, normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"]);

      _templateObject59 = function _templateObject59() {
        return data;
      };

      return data;
    }

    function _templateObject58() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"]);

      _templateObject58 = function _templateObject58() {
        return data;
      };

      return data;
    }

    function _templateObject57() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"]);

      _templateObject57 = function _templateObject57() {
        return data;
      };

      return data;
    }

    function _templateObject56() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n"]);

      _templateObject56 = function _templateObject56() {
        return data;
      };

      return data;
    }

    function _templateObject55() {
      var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return arrayLikeToArray(o, minLen);\n  }\n"]);

      _templateObject55 = function _templateObject55() {
        return data;
      };

      return data;
    }

    function _templateObject54() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n"]);

      _templateObject54 = function _templateObject54() {
        return data;
      };

      return data;
    }

    function _templateObject53() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"], ["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"]);

      _templateObject53 = function _templateObject53() {
        return data;
      };

      return data;
    }

    function _templateObject52() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n"]);

      _templateObject52 = function _templateObject52() {
        return data;
      };

      return data;
    }

    function _templateObject51() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n"]);

      _templateObject51 = function _templateObject51() {
        return data;
      };

      return data;
    }

    function _templateObject50() {
      var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\n  }\n"]);

      _templateObject50 = function _templateObject50() {
        return data;
      };

      return data;
    }

    function _templateObject49() {
      var data = _taggedTemplateLiteralLoose(["\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return (\n      arrayWithoutHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableSpread()\n    );\n  }\n"]);

      _templateObject49 = function _templateObject49() {
        return data;
      };

      return data;
    }

    function _templateObject48() {
      var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableRest()\n    );\n  }\n"]);

      _templateObject48 = function _templateObject48() {
        return data;
      };

      return data;
    }

    function _templateObject47() {
      var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimitLoose(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"]);

      _templateObject47 = function _templateObject47() {
        return data;
      };

      return data;
    }

    function _templateObject46() {
      var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimit(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"]);

      _templateObject46 = function _templateObject46() {
        return data;
      };

      return data;
    }

    function _templateObject45() {
      var data = _taggedTemplateLiteralLoose(["\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n"]);

      _templateObject45 = function _templateObject45() {
        return data;
      };

      return data;
    }

    function _templateObject44() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n"]);

      _templateObject44 = function _templateObject44() {
        return data;
      };

      return data;
    }

    function _templateObject43() {
      var data = _taggedTemplateLiteralLoose(["\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n"]);

      _templateObject43 = function _templateObject43() {
        return data;
      };

      return data;
    }

    function _templateObject42() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n  }\n"], ["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n"]);

      _templateObject42 = function _templateObject42() {
        return data;
      };

      return data;
    }

    function _templateObject41() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n  }\n"], ["\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n"]);

      _templateObject41 = function _templateObject41() {
        return data;
      };

      return data;
    }

    function _templateObject40() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n"]);

      _templateObject40 = function _templateObject40() {
        return data;
      };

      return data;
    }

    function _templateObject39() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n"]);

      _templateObject39 = function _templateObject39() {
        return data;
      };

      return data;
    }

    function _templateObject38() {
      var data = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n"]);

      _templateObject38 = function _templateObject38() {
        return data;
      };

      return data;
    }

    function _templateObject37() {
      var data = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n"]);

      _templateObject37 = function _templateObject37() {
        return data;
      };

      return data;
    }

    function _templateObject36() {
      var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n"]);

      _templateObject36 = function _templateObject36() {
        return data;
      };

      return data;
    }

    function _templateObject35() {
      var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n\n  export default function _createSuper(Derived) {\n    var hasNativeReflectConstruct = isNativeReflectConstruct();\n\n    return function () {\n      var Super = getPrototypeOf(Derived), result;\n      if (hasNativeReflectConstruct) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn(this, result);\n    }\n  }\n "]);

      _templateObject35 = function _templateObject35() {
        return data;
      };

      return data;
    }

    function _templateObject34() {
      var data = _taggedTemplateLiteralLoose(["\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n"]);

      _templateObject34 = function _templateObject34() {
        return data;
      };

      return data;
    }

    function _templateObject33() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n"]);

      _templateObject33 = function _templateObject33() {
        return data;
      };

      return data;
    }

    function _templateObject32() {
      var data = _taggedTemplateLiteralLoose(["\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n"]);

      _templateObject32 = function _templateObject32() {
        return data;
      };

      return data;
    }

    function _templateObject31() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n"]);

      _templateObject31 = function _templateObject31() {
        return data;
      };

      return data;
    }

    function _templateObject30() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n"]);

      _templateObject30 = function _templateObject30() {
        return data;
      };

      return data;
    }

    function _templateObject29() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n"]);

      _templateObject29 = function _templateObject29() {
        return data;
      };

      return data;
    }

    function _templateObject28() {
      var data = _taggedTemplateLiteralLoose(["\n  function _getRequireWildcardCache() {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cache = new WeakMap();\n    _getRequireWildcardCache = function () { return cache; };\n    return cache;\n  }\n\n  export default function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache();\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n"]);

      _templateObject28 = function _templateObject28() {
        return data;
      };

      return data;
    }

    function _templateObject27() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n"]);

      _templateObject27 = function _templateObject27() {
        return data;
      };

      return data;
    }

    function _templateObject26() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n"]);

      _templateObject26 = function _templateObject26() {
        return data;
      };

      return data;
    }

    function _templateObject25() {
      var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n"]);

      _templateObject25 = function _templateObject25() {
        return data;
      };

      return data;
    }

    function _templateObject24() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n"]);

      _templateObject24 = function _templateObject24() {
        return data;
      };

      return data;
    }

    function _templateObject23() {
      var data = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n"]);

      _templateObject23 = function _templateObject23() {
        return data;
      };

      return data;
    }

    function _templateObject22() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Date object.\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n"]);

      _templateObject22 = function _templateObject22() {
        return data;
      };

      return data;
    }

    function _templateObject21() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n"]);

      _templateObject21 = function _templateObject21() {
        return data;
      };

      return data;
    }

    function _templateObject20() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n"]);

      _templateObject20 = function _templateObject20() {
        return data;
      };

      return data;
    }

    function _templateObject19() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n"]);

      _templateObject19 = function _templateObject19() {
        return data;
      };

      return data;
    }

    function _templateObject18() {
      var data = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n"]);

      _templateObject18 = function _templateObject18() {
        return data;
      };

      return data;
    }

    function _templateObject17() {
      var data = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  // This function is different to \"Reflect.ownKeys\". The enumerableOnly\n  // filters on symbol properties only. Returned string properties are always\n  // enumerable. It is good to use in objectSpread.\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n\n  export default function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n    return target;\n  }\n"]);

      _templateObject17 = function _templateObject17() {
        return data;
      };

      return data;
    }

    function _templateObject16() {
      var data = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n"]);

      _templateObject16 = function _templateObject16() {
        return data;
      };

      return data;
    }

    function _templateObject15() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n"]);

      _templateObject15 = function _templateObject15() {
        return data;
      };

      return data;
    }

    function _templateObject14() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n"]);

      _templateObject14 = function _templateObject14() {
        return data;
      };

      return data;
    }

    function _templateObject13() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n"]);

      _templateObject13 = function _templateObject13() {
        return data;
      };

      return data;
    }

    function _templateObject12() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n"]);

      _templateObject12 = function _templateObject12() {
        return data;
      };

      return data;
    }

    function _templateObject11() {
      var data = _taggedTemplateLiteralLoose(["\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n"]);

      _templateObject11 = function _templateObject11() {
        return data;
      };

      return data;
    }

    function _templateObject10() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n"]);

      _templateObject10 = function _templateObject10() {
        return data;
      };

      return data;
    }

    function _templateObject9() {
      var data = _taggedTemplateLiteralLoose(["\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n"]);

      _templateObject9 = function _templateObject9() {
        return data;
      };

      return data;
    }

    function _templateObject8() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n"]);

      _templateObject8 = function _templateObject8() {
        return data;
      };

      return data;
    }

    function _templateObject7() {
      var data = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n"]);

      _templateObject7 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6() {
      var data = _taggedTemplateLiteralLoose(["\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n"]);

      _templateObject6 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5() {
      var data = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n"]);

      _templateObject5 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n"]);

      _templateObject4 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _asyncIterator(iterable) {\n    var method\n    if (typeof Symbol !== \"undefined\") {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator]\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator]\n        if (method != null) return method.call(iterable);\n      }\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n"]);

      _templateObject3 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2() {
      var data = _taggedTemplateLiteralLoose(["\n  var REACT_ELEMENT_TYPE;\n\n  export default function _createRawReactElement(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE = (\n        typeof Symbol === \"function\" && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\")\n      ) || 0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      // If we're going to assign props.children, we create a new object now\n      // to avoid mutating defaultProps.\n      props = {\n        children: void 0,\n      };\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n      props.children = childArray;\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null,\n    };\n  }\n"]);

      _templateObject2 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject() {
      var data = _taggedTemplateLiteralLoose(["\n  export default function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) { return typeof obj; };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? \"symbol\"\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n"]);

      _templateObject = function _templateObject() {
        return data;
      };

      return data;
    }
    var helpers = Object.create(null);

    var helper = function helper(minVersion) {
      return function (tpl) {
        return {
          minVersion: minVersion,
          ast: function ast() {
            return template.program.ast(tpl);
          }
        };
      };
    };

    helpers["typeof"] = helper("7.0.0-beta.0")(_templateObject());
    helpers.jsx = helper("7.0.0-beta.0")(_templateObject2());
    helpers.asyncIterator = helper("7.0.0-beta.0")(_templateObject3());
    helpers.AwaitValue = helper("7.0.0-beta.0")(_templateObject4());
    helpers.AsyncGenerator = helper("7.0.0-beta.0")(_templateObject5());
    helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")(_templateObject6());
    helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")(_templateObject7());
    helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")(_templateObject8());
    helpers.asyncToGenerator = helper("7.0.0-beta.0")(_templateObject9());
    helpers.classCallCheck = helper("7.0.0-beta.0")(_templateObject10());
    helpers.createClass = helper("7.0.0-beta.0")(_templateObject11());
    helpers.defineEnumerableProperties = helper("7.0.0-beta.0")(_templateObject12());
    helpers.defaults = helper("7.0.0-beta.0")(_templateObject13());
    helpers.defineProperty = helper("7.0.0-beta.0")(_templateObject14());
    helpers["extends"] = helper("7.0.0-beta.0")(_templateObject15());
    helpers.objectSpread = helper("7.0.0-beta.0")(_templateObject16());
    helpers.objectSpread2 = helper("7.5.0")(_templateObject17());
    helpers.inherits = helper("7.0.0-beta.0")(_templateObject18());
    helpers.inheritsLoose = helper("7.0.0-beta.0")(_templateObject19());
    helpers.getPrototypeOf = helper("7.0.0-beta.0")(_templateObject20());
    helpers.setPrototypeOf = helper("7.0.0-beta.0")(_templateObject21());
    helpers.isNativeReflectConstruct = helper("7.9.0")(_templateObject22());
    helpers.construct = helper("7.0.0-beta.0")(_templateObject23());
    helpers.isNativeFunction = helper("7.0.0-beta.0")(_templateObject24());
    helpers.wrapNativeSuper = helper("7.0.0-beta.0")(_templateObject25());
    helpers["instanceof"] = helper("7.0.0-beta.0")(_templateObject26());
    helpers.interopRequireDefault = helper("7.0.0-beta.0")(_templateObject27());
    helpers.interopRequireWildcard = helper("7.0.0-beta.0")(_templateObject28());
    helpers.newArrowCheck = helper("7.0.0-beta.0")(_templateObject29());
    helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")(_templateObject30());
    helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")(_templateObject31());
    helpers.objectWithoutProperties = helper("7.0.0-beta.0")(_templateObject32());
    helpers.assertThisInitialized = helper("7.0.0-beta.0")(_templateObject33());
    helpers.possibleConstructorReturn = helper("7.0.0-beta.0")(_templateObject34());
    helpers.createSuper = helper("7.9.0")(_templateObject35());
    helpers.superPropBase = helper("7.0.0-beta.0")(_templateObject36());
    helpers.get = helper("7.0.0-beta.0")(_templateObject37());
    helpers.set = helper("7.0.0-beta.0")(_templateObject38());
    helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")(_templateObject39());
    helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")(_templateObject40());
    helpers.readOnlyError = helper("7.0.0-beta.0")(_templateObject41());
    helpers.classNameTDZError = helper("7.0.0-beta.0")(_templateObject42());
    helpers.temporalUndefined = helper("7.0.0-beta.0")(_templateObject43());
    helpers.tdz = helper("7.5.5")(_templateObject44());
    helpers.temporalRef = helper("7.0.0-beta.0")(_templateObject45());
    helpers.slicedToArray = helper("7.0.0-beta.0")(_templateObject46());
    helpers.slicedToArrayLoose = helper("7.0.0-beta.0")(_templateObject47());
    helpers.toArray = helper("7.0.0-beta.0")(_templateObject48());
    helpers.toConsumableArray = helper("7.0.0-beta.0")(_templateObject49());
    helpers.arrayWithoutHoles = helper("7.0.0-beta.0")(_templateObject50());
    helpers.arrayWithHoles = helper("7.0.0-beta.0")(_templateObject51());
    helpers.iterableToArray = helper("7.0.0-beta.0")(_templateObject52());
    helpers.iterableToArrayLimit = helper("7.0.0-beta.0")(_templateObject53());
    helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")(_templateObject54());
    helpers.unsupportedIterableToArray = helper("7.9.0")(_templateObject55());
    helpers.arrayLikeToArray = helper("7.9.0")(_templateObject56());
    helpers.nonIterableSpread = helper("7.0.0-beta.0")(_templateObject57());
    helpers.nonIterableRest = helper("7.0.0-beta.0")(_templateObject58());
    helpers.createForOfIteratorHelper = helper("7.9.0")(_templateObject59());
    helpers.createForOfIteratorHelperLoose = helper("7.9.0")(_templateObject60());
    helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")(_templateObject61());
    helpers.toPrimitive = helper("7.1.5")(_templateObject62());
    helpers.toPropertyKey = helper("7.1.5")(_templateObject63());
    helpers.initializerWarningHelper = helper("7.0.0-beta.0")(_templateObject64());
    helpers.initializerDefineProperty = helper("7.0.0-beta.0")(_templateObject65());
    helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")(_templateObject66());
    helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")(_templateObject67());
    helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")(_templateObject68());
    helpers.classPrivateFieldGet = helper("7.0.0-beta.0")(_templateObject69());
    helpers.classPrivateFieldSet = helper("7.0.0-beta.0")(_templateObject70());
    helpers.classPrivateFieldDestructureSet = helper("7.4.4")(_templateObject71());
    helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")(_templateObject72());
    helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")(_templateObject73());
    helpers.classStaticPrivateMethodGet = helper("7.3.2")(_templateObject74());
    helpers.classStaticPrivateMethodSet = helper("7.3.2")(_templateObject75());
    helpers.decorate = helper("7.1.5")(_templateObject76());
    helpers.classPrivateMethodGet = helper("7.1.6")(_templateObject77());
    helpers.classPrivateMethodSet = helper("7.1.6")(_templateObject78());
    helpers.wrapRegExp = helper("7.2.6")(_templateObject79());

    function makePath(path) {
      var parts = [];

      for (; path.parentPath; path = path.parentPath) {
        parts.push(path.key);
        if (path.inList) parts.push(path.listKey);
      }

      return parts.reverse().join(".");
    }

    var fileClass = undefined;

    function getHelperMetadata(file) {
      var globals = new Set();
      var localBindingNames = new Set();
      var dependencies = new Map();
      var exportName;
      var exportPath;
      var exportBindingAssignments = [];
      var importPaths = [];
      var importBindingsReferences = [];
      var dependencyVisitor = {
        ImportDeclaration: function ImportDeclaration(child) {
          var name = child.node.source.value;

          if (!helpers[name]) {
            throw child.buildCodeFrameError("Unknown helper " + name);
          }

          if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
            throw child.buildCodeFrameError("Helpers can only import a default value");
          }

          var bindingIdentifier = child.node.specifiers[0].local;
          dependencies.set(bindingIdentifier, name);
          importPaths.push(makePath(child));
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
          var decl = child.get("declaration");

          if (decl.isFunctionDeclaration()) {
            if (!decl.node.id) {
              throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
            }

            exportName = decl.node.id.name;
          }

          exportPath = makePath(child);
        },
        ExportAllDeclaration: function ExportAllDeclaration(child) {
          throw child.buildCodeFrameError("Helpers can only export default");
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(child) {
          throw child.buildCodeFrameError("Helpers can only export default");
        },
        Statement: function Statement(child) {
          if (child.isModuleDeclaration()) return;
          child.skip();
        }
      };
      var referenceVisitor = {
        Program: function Program(path) {
          var bindings = path.scope.getAllBindings();
          Object.keys(bindings).forEach(function (name) {
            if (name === exportName) return;
            if (dependencies.has(bindings[name].identifier)) return;
            localBindingNames.add(name);
          });
        },
        ReferencedIdentifier: function ReferencedIdentifier(child) {
          var name = child.node.name;
          var binding = child.scope.getBinding(name, true);

          if (!binding) {
            globals.add(name);
          } else if (dependencies.has(binding.identifier)) {
            importBindingsReferences.push(makePath(child));
          }
        },
        AssignmentExpression: function AssignmentExpression(child) {
          var left = child.get("left");
          if (!(exportName in left.getBindingIdentifiers())) return;

          if (!left.isIdentifier()) {
            throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
          }

          var binding = child.scope.getBinding(exportName);

          if (binding && binding.scope.path.isProgram()) {
            exportBindingAssignments.push(makePath(child));
          }
        }
      };
      traverse$1(file.ast, dependencyVisitor, file.scope);
      traverse$1(file.ast, referenceVisitor, file.scope);
      if (!exportPath) throw new Error("Helpers must default-export something.");
      exportBindingAssignments.reverse();
      return {
        globals: Array.from(globals),
        localBindingNames: Array.from(localBindingNames),
        dependencies: dependencies,
        exportBindingAssignments: exportBindingAssignments,
        exportPath: exportPath,
        exportName: exportName,
        importBindingsReferences: importBindingsReferences,
        importPaths: importPaths
      };
    }

    function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
      if (localBindings && !id) {
        throw new Error("Unexpected local bindings for module-based helpers.");
      }

      if (!id) return;
      var localBindingNames = metadata.localBindingNames,
          dependencies = metadata.dependencies,
          exportBindingAssignments = metadata.exportBindingAssignments,
          exportPath = metadata.exportPath,
          exportName = metadata.exportName,
          importBindingsReferences = metadata.importBindingsReferences,
          importPaths = metadata.importPaths;
      var dependenciesRefs = {};
      dependencies.forEach(function (name, id) {
        dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
      });
      var toRename = {};
      var bindings = new Set(localBindings || []);
      localBindingNames.forEach(function (name) {
        var newName = name;

        while (bindings.has(newName)) {
          newName = "_" + newName;
        }

        if (newName !== name) toRename[name] = newName;
      });

      if (id.type === "Identifier" && exportName !== id.name) {
        toRename[exportName] = id.name;
      }

      var visitor = {
        Program: function Program(path) {
          var exp = path.get(exportPath);
          var imps = importPaths.map(function (p) {
            return path.get(p);
          });
          var impsBindingRefs = importBindingsReferences.map(function (p) {
            return path.get(p);
          });
          var decl = exp.get("declaration");

          if (id.type === "Identifier") {
            if (decl.isFunctionDeclaration()) {
              exp.replaceWith(decl);
            } else {
              exp.replaceWith(VariableDeclaration("var", [VariableDeclarator(id, decl.node)]));
            }
          } else if (id.type === "MemberExpression") {
            if (decl.isFunctionDeclaration()) {
              exportBindingAssignments.forEach(function (assignPath) {
                var assign = path.get(assignPath);
                assign.replaceWith(AssignmentExpression("=", id, assign.node));
              });
              exp.replaceWith(decl);
              path.pushContainer("body", ExpressionStatement(AssignmentExpression("=", id, Identifier(exportName))));
            } else {
              exp.replaceWith(ExpressionStatement(AssignmentExpression("=", id, decl.node)));
            }
          } else {
            throw new Error("Unexpected helper format.");
          }

          Object.keys(toRename).forEach(function (name) {
            path.scope.rename(name, toRename[name]);
          });

          for (var _iterator = _createForOfIteratorHelperLoose(imps), _step; !(_step = _iterator()).done;) {
            var _path = _step.value;

            _path.remove();
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(impsBindingRefs), _step2; !(_step2 = _iterator2()).done;) {
            var _path2 = _step2.value;
            var node = cloneNode(dependenciesRefs[_path2.node.name]);

            _path2.replaceWith(node);
          }

          path.stop();
        }
      };
      traverse$1(file.ast, visitor, file.scope);
    }

    var helperData = Object.create(null);

    function loadHelper(name) {
      if (!helperData[name]) {
        var helper = helpers[name];

        if (!helper) {
          throw Object.assign(new ReferenceError("Unknown helper " + name), {
            code: "BABEL_HELPER_UNKNOWN",
            helper: name
          });
        }

        var fn = function fn() {
          var file = {
            ast: File(helper.ast())
          };

          if (fileClass) {
            return new fileClass({
              filename: "babel-helper://" + name
            }, file);
          }

          return file;
        };

        var metadata = getHelperMetadata(fn());
        helperData[name] = {
          build: function build(getDependency, id, localBindings) {
            var file = fn();
            permuteHelperAST(file, metadata, id, localBindings, getDependency);
            return {
              nodes: file.ast.program.body,
              globals: metadata.globals
            };
          },
          minVersion: function minVersion() {
            return helper.minVersion;
          },
          dependencies: metadata.dependencies
        };
      }

      return helperData[name];
    }

    function get$1(name, getDependency, id, localBindings) {
      return loadHelper(name).build(getDependency, id, localBindings);
    }
    function minVersion(name) {
      return loadHelper(name).minVersion();
    }
    function getDependencies(name) {
      return Array.from(loadHelper(name).dependencies.values());
    }
    function ensure(name, newFileClass) {
      if (!fileClass) {
        fileClass = newFileClass;
      }

      loadHelper(name);
    }
    var list$1 = Object.keys(helpers).map(function (name) {
      return name.replace(/^_/, "");
    }).filter(function (name) {
      return name !== "__esModule";
    });

    var inherits$1;

    if (typeof Object.create === 'function') {
      inherits$1 = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits$1 = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }

    var inherits$2 = inherits$1;

    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];

      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        _extend(ctx, opts);
      }

      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };

    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction$3(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);

        if (!isString$2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }

        return ret;
      }

      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      }

      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      if (keys.length === 0) {
        if (isFunction$3(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp$1(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}'];

      if (isArray$3(value)) {
        array = true;
        braces = ['[', ']'];
      }

      if (isFunction$3(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      if (isRegExp$1(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp$1(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString$2(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }

      if (isNumber$1(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty$d(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty$d(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function (prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isArray$3(ar) {
      return Array.isArray(ar);
    }
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNumber$1(arg) {
      return typeof arg === 'number';
    }
    function isString$2(arg) {
      return typeof arg === 'string';
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
    function isRegExp$1(re) {
      return isObject$2(re) && objectToString$1(re) === '[object RegExp]';
    }
    function isObject$2(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    function isDate(d) {
      return isObject$2(d) && objectToString$1(d) === '[object Date]';
    }
    function isError(e) {
      return isObject$2(e) && (objectToString$1(e) === '[object Error]' || e instanceof Error);
    }
    function isFunction$3(arg) {
      return typeof arg === 'function';
    }
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }

    function objectToString$1(o) {
      return Object.prototype.toString.call(o);
    }
    function _extend(origin, add) {
      if (!add || !isObject$2(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;

      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }

      return origin;
    }

    function hasOwnProperty$d(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    function compare(a, b) {
      if (a === b) {
        return 0;
      }

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) {
        return -1;
      }

      if (y < x) {
        return 1;
      }

      return 0;
    }

    var hasOwn = Object.prototype.hasOwnProperty;

    var objectKeys = Object.keys || function (obj) {
      var keys = [];

      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }

      return keys;
    };
    var pSlice = Array.prototype.slice;

    var _functionsHaveNames;

    function functionsHaveNames() {
      if (typeof _functionsHaveNames !== 'undefined') {
        return _functionsHaveNames;
      }

      return _functionsHaveNames = function () {
        return function foo() {}.name === 'foo';
      }();
    }

    function pToString(obj) {
      return Object.prototype.toString.call(obj);
    }

    function isView(arrbuf) {
      if (isBuffer(arrbuf)) {
        return false;
      }

      if (typeof global$1.ArrayBuffer !== 'function') {
        return false;
      }

      if (typeof ArrayBuffer.isView === 'function') {
        return ArrayBuffer.isView(arrbuf);
      }

      if (!arrbuf) {
        return false;
      }

      if (arrbuf instanceof DataView) {
        return true;
      }

      if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
        return true;
      }

      return false;
    }

    function assert$2(value, message) {
      if (!value) fail(value, true, message, '==', ok);
    }
    var regex = /\s*function\s+([^\(\s]*)\s*/;

    function getName(func) {
      if (!isFunction$3(func)) {
        return;
      }

      if (functionsHaveNames()) {
        return func.name;
      }

      var str = func.toString();
      var match = str.match(regex);
      return match && match[1];
    }

    assert$2.AssertionError = AssertionError;
    function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;

      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }

      var stackStartFunction = options.stackStartFunction || fail;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      } else {
        var err = new Error();

        if (err.stack) {
          var out = err.stack;
          var fn_name = getName(stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);

          if (idx >= 0) {
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }

          this.stack = out;
        }
      }
    }
    inherits$2(AssertionError, Error);

    function truncate(s, n) {
      if (typeof s === 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }

    function inspect$1(something) {
      if (functionsHaveNames() || !isFunction$3(something)) {
        return inspect(something);
      }

      var rawname = getName(something);
      var name = rawname ? ': ' + rawname : '';
      return '[Function' + name + ']';
    }

    function getMessage(self) {
      return truncate(inspect$1(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect$1(self.expected), 128);
    }

    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    assert$2.fail = fail;
    function ok(value, message) {
      if (!value) fail(value, true, message, '==', ok);
    }
    assert$2.ok = ok;
    assert$2.equal = equal;
    function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', equal);
    }
    assert$2.notEqual = notEqual;
    function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', notEqual);
      }
    }
    assert$2.deepEqual = deepEqual;
    function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'deepEqual', deepEqual);
      }
    }
    assert$2.deepStrictEqual = deepStrictEqual;
    function deepStrictEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
      }
    }

    function _deepEqual(actual, expected, strict, memos) {
      if (actual === expected) {
        return true;
      } else if (isBuffer(actual) && isBuffer(expected)) {
        return compare(actual, expected) === 0;
      } else if (isDate(actual) && isDate(expected)) {
        return actual.getTime() === expected.getTime();
      } else if (isRegExp$1(actual) && isRegExp$1(expected)) {
        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
      } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
        return strict ? actual === expected : actual == expected;
      } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
        return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
      } else if (isBuffer(actual) !== isBuffer(expected)) {
        return false;
      } else {
        memos = memos || {
          actual: [],
          expected: []
        };
        var actualIndex = memos.actual.indexOf(actual);

        if (actualIndex !== -1) {
          if (actualIndex === memos.expected.indexOf(expected)) {
            return true;
          }
        }

        memos.actual.push(actual);
        memos.expected.push(expected);
        return objEquiv(actual, expected, strict, memos);
      }
    }

    function isArguments$1(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }

    function objEquiv(a, b, strict, actualVisitedObjects) {
      if (a === null || a === undefined || b === null || b === undefined) return false;
      if (isPrimitive(a) || isPrimitive(b)) return a === b;
      if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
      var aIsArgs = isArguments$1(a);
      var bIsArgs = isArguments$1(b);
      if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, strict);
      }

      var ka = objectKeys(a);
      var kb = objectKeys(b);
      var key, i;
      if (ka.length !== kb.length) return false;
      ka.sort();
      kb.sort();

      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) return false;
      }

      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
      }

      return true;
    }

    assert$2.notDeepEqual = notDeepEqual;
    function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
      }
    }
    assert$2.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
      }
    }
    assert$2.strictEqual = strictEqual;
    function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', strictEqual);
      }
    }
    assert$2.notStrictEqual = notStrictEqual;
    function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', notStrictEqual);
      }
    }

    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }

      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      }

      try {
        if (actual instanceof expected) {
          return true;
        }
      } catch (e) {}

      if (Error.isPrototypeOf(expected)) {
        return false;
      }

      return expected.call({}, actual) === true;
    }

    function _tryBlock(block) {
      var error;

      try {
        block();
      } catch (e) {
        error = e;
      }

      return error;
    }

    function _throws(shouldThrow, block, expected, message) {
      var actual;

      if (typeof block !== 'function') {
        throw new TypeError('"block" argument must be a function');
      }

      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }

      actual = _tryBlock(block);
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }

      var userProvidedMessage = typeof message === 'string';
      var isUnwantedException = !shouldThrow && isError(actual);
      var isUnexpectedException = !shouldThrow && actual && !expected;

      if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }

      if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
        throw actual;
      }
    }

    assert$2["throws"] = _throws2;

    function _throws2(block, error, message) {
      _throws(true, block, error, message);
    }
    assert$2.doesNotThrow = doesNotThrow;
    function doesNotThrow(block, error, message) {
      _throws(false, block, error, message);
    }
    assert$2.ifError = ifError;
    function ifError(err) {
      if (err) throw err;
    }

    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }

      end = end > length ? length : end;

      if (end < 0) {
        end += length;
      }

      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);

      while (++index < length) {
        result[index] = array[index + start];
      }

      return result;
    }

    var _baseSlice = baseSlice;

    var nativeCeil = Math.ceil,
        nativeMax$2 = Math.max;

    function chunk(array, size, guard) {
      if (guard ? _isIterateeCall(array, size, guard) : size === undefined) {
        size = 1;
      } else {
        size = nativeMax$2(toInteger_1(size), 0);
      }

      var length = array == null ? 0 : array.length;

      if (!length || size < 1) {
        return [];
      }

      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = _baseSlice(array, index, index += size);
      }

      return result;
    }

    var chunk_1 = chunk;

    var ImportBuilder = function () {
      function ImportBuilder(importedSource, scope, hub) {
        this._statements = [];
        this._resultName = null;
        this._scope = null;
        this._hub = null;
        this._scope = scope;
        this._hub = hub;
        this._importedSource = importedSource;
      }

      var _proto = ImportBuilder.prototype;

      _proto.done = function done() {
        return {
          statements: this._statements,
          resultName: this._resultName
        };
      };

      _proto["import"] = function _import() {
        this._statements.push(ImportDeclaration([], StringLiteral(this._importedSource)));

        return this;
      };

      _proto.require = function require() {
        this._statements.push(ExpressionStatement(CallExpression(Identifier("require"), [StringLiteral(this._importedSource)])));

        return this;
      };

      _proto.namespace = function namespace(name) {
        if (name === void 0) {
          name = "namespace";
        }

        name = this._scope.generateUidIdentifier(name);
        var statement = this._statements[this._statements.length - 1];
        assert$2(statement.type === "ImportDeclaration");
        assert$2(statement.specifiers.length === 0);
        statement.specifiers = [ImportNamespaceSpecifier(name)];
        this._resultName = cloneNode(name);
        return this;
      };

      _proto["default"] = function _default(name) {
        name = this._scope.generateUidIdentifier(name);
        var statement = this._statements[this._statements.length - 1];
        assert$2(statement.type === "ImportDeclaration");
        assert$2(statement.specifiers.length === 0);
        statement.specifiers = [ImportDefaultSpecifier(name)];
        this._resultName = cloneNode(name);
        return this;
      };

      _proto.named = function named(name, importName) {
        if (importName === "default") return this["default"](name);
        name = this._scope.generateUidIdentifier(name);
        var statement = this._statements[this._statements.length - 1];
        assert$2(statement.type === "ImportDeclaration");
        assert$2(statement.specifiers.length === 0);
        statement.specifiers = [ImportSpecifier(name, Identifier(importName))];
        this._resultName = cloneNode(name);
        return this;
      };

      _proto["var"] = function _var(name) {
        name = this._scope.generateUidIdentifier(name);
        var statement = this._statements[this._statements.length - 1];

        if (statement.type !== "ExpressionStatement") {
          assert$2(this._resultName);
          statement = ExpressionStatement(this._resultName);

          this._statements.push(statement);
        }

        this._statements[this._statements.length - 1] = VariableDeclaration("var", [VariableDeclarator(name, statement.expression)]);
        this._resultName = cloneNode(name);
        return this;
      };

      _proto.defaultInterop = function defaultInterop() {
        return this._interop(this._hub.addHelper("interopRequireDefault"));
      };

      _proto.wildcardInterop = function wildcardInterop() {
        return this._interop(this._hub.addHelper("interopRequireWildcard"));
      };

      _proto._interop = function _interop(callee) {
        var statement = this._statements[this._statements.length - 1];

        if (statement.type === "ExpressionStatement") {
          statement.expression = CallExpression(callee, [statement.expression]);
        } else if (statement.type === "VariableDeclaration") {
          assert$2(statement.declarations.length === 1);
          statement.declarations[0].init = CallExpression(callee, [statement.declarations[0].init]);
        } else {
          assert$2.fail("Unexpected type.");
        }

        return this;
      };

      _proto.prop = function prop(name) {
        var statement = this._statements[this._statements.length - 1];

        if (statement.type === "ExpressionStatement") {
          statement.expression = MemberExpression(statement.expression, Identifier(name));
        } else if (statement.type === "VariableDeclaration") {
          assert$2(statement.declarations.length === 1);
          statement.declarations[0].init = MemberExpression(statement.declarations[0].init, Identifier(name));
        } else {
          assert$2.fail("Unexpected type:" + statement.type);
        }

        return this;
      };

      _proto.read = function read(name) {
        this._resultName = MemberExpression(this._resultName, Identifier(name));
      };

      return ImportBuilder;
    }();

    function isModule(path) {
      var sourceType = path.node.sourceType;

      if (sourceType !== "module" && sourceType !== "script") {
        throw path.buildCodeFrameError("Unknown sourceType \"" + sourceType + "\", cannot transform.");
      }

      return path.node.sourceType === "module";
    }

    var ImportInjector = function () {
      function ImportInjector(path, importedSource, opts) {
        this._defaultOpts = {
          importedSource: null,
          importedType: "commonjs",
          importedInterop: "babel",
          importingInterop: "babel",
          ensureLiveReference: false,
          ensureNoContext: false
        };
        var programPath = path.find(function (p) {
          return p.isProgram();
        });
        this._programPath = programPath;
        this._programScope = programPath.scope;
        this._hub = programPath.hub;
        this._defaultOpts = this._applyDefaults(importedSource, opts, true);
      }

      var _proto = ImportInjector.prototype;

      _proto.addDefault = function addDefault(importedSourceIn, opts) {
        return this.addNamed("default", importedSourceIn, opts);
      };

      _proto.addNamed = function addNamed(importName, importedSourceIn, opts) {
        assert$2(typeof importName === "string");
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
      };

      _proto.addNamespace = function addNamespace(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
      };

      _proto.addSideEffect = function addSideEffect(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
      };

      _proto._applyDefaults = function _applyDefaults(importedSource, opts, isInit) {
        if (isInit === void 0) {
          isInit = false;
        }

        var optsList = [];

        if (typeof importedSource === "string") {
          optsList.push({
            importedSource: importedSource
          });
          optsList.push(opts);
        } else {
          assert$2(!opts, "Unexpected secondary arguments.");
          optsList.push(importedSource);
        }

        var newOpts = Object.assign({}, this._defaultOpts);

        var _loop = function _loop() {
          var opts = _optsList[_i];
          if (!opts) return "continue";
          Object.keys(newOpts).forEach(function (key) {
            if (opts[key] !== undefined) newOpts[key] = opts[key];
          });

          if (!isInit) {
            if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
            if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
          }
        };

        for (var _i = 0, _optsList = optsList; _i < _optsList.length; _i++) {
          var _ret = _loop();

          if (_ret === "continue") continue;
        }

        return newOpts;
      };

      _proto._generateImport = function _generateImport(opts, importName) {
        var isDefault = importName === "default";
        var isNamed = !!importName && !isDefault;
        var isNamespace = importName === null;
        var importedSource = opts.importedSource,
            importedType = opts.importedType,
            importedInterop = opts.importedInterop,
            importingInterop = opts.importingInterop,
            ensureLiveReference = opts.ensureLiveReference,
            ensureNoContext = opts.ensureNoContext,
            nameHint = opts.nameHint,
            blockHoist = opts.blockHoist;
        var name = nameHint || importName;
        var isMod = isModule(this._programPath);
        var isModuleForNode = isMod && importingInterop === "node";
        var isModuleForBabel = isMod && importingInterop === "babel";
        var builder = new ImportBuilder(importedSource, this._programScope, this._hub);

        if (importedType === "es6") {
          if (!isModuleForNode && !isModuleForBabel) {
            throw new Error("Cannot import an ES6 module from CommonJS");
          }

          builder["import"]();

          if (isNamespace) {
            builder.namespace(nameHint || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else if (importedType !== "commonjs") {
          throw new Error("Unexpected interopType \"" + importedType + "\"");
        } else if (importedInterop === "babel") {
          if (isModuleForNode) {
            name = name !== "default" ? name : importedSource;
            var es6Default = importedSource + "$es6Default";
            builder["import"]();

            if (isNamespace) {
              builder["default"](es6Default)["var"](name || importedSource).wildcardInterop();
            } else if (isDefault) {
              if (ensureLiveReference) {
                builder["default"](es6Default)["var"](name || importedSource).defaultInterop().read("default");
              } else {
                builder["default"](es6Default)["var"](name).defaultInterop().prop(importName);
              }
            } else if (isNamed) {
              builder["default"](es6Default).read(importName);
            }
          } else if (isModuleForBabel) {
            builder["import"]();

            if (isNamespace) {
              builder.namespace(name || importedSource);
            } else if (isDefault || isNamed) {
              builder.named(name, importName);
            }
          } else {
            builder.require();

            if (isNamespace) {
              builder["var"](name || importedSource).wildcardInterop();
            } else if ((isDefault || isNamed) && ensureLiveReference) {
              if (isDefault) {
                name = name !== "default" ? name : importedSource;
                builder["var"](name).read(importName);
                builder.defaultInterop();
              } else {
                builder["var"](importedSource).read(importName);
              }
            } else if (isDefault) {
              builder["var"](name).defaultInterop().prop(importName);
            } else if (isNamed) {
              builder["var"](name).prop(importName);
            }
          }
        } else if (importedInterop === "compiled") {
          if (isModuleForNode) {
            builder["import"]();

            if (isNamespace) {
              builder["default"](name || importedSource);
            } else if (isDefault || isNamed) {
              builder["default"](importedSource).read(name);
            }
          } else if (isModuleForBabel) {
            builder["import"]();

            if (isNamespace) {
              builder.namespace(name || importedSource);
            } else if (isDefault || isNamed) {
              builder.named(name, importName);
            }
          } else {
            builder.require();

            if (isNamespace) {
              builder["var"](name || importedSource);
            } else if (isDefault || isNamed) {
              if (ensureLiveReference) {
                builder["var"](importedSource).read(name);
              } else {
                builder.prop(importName)["var"](name);
              }
            }
          }
        } else if (importedInterop === "uncompiled") {
          if (isDefault && ensureLiveReference) {
            throw new Error("No live reference for commonjs default");
          }

          if (isModuleForNode) {
            builder["import"]();

            if (isNamespace) {
              builder["default"](name || importedSource);
            } else if (isDefault) {
              builder["default"](name);
            } else if (isNamed) {
              builder["default"](importedSource).read(name);
            }
          } else if (isModuleForBabel) {
            builder["import"]();

            if (isNamespace) {
              builder["default"](name || importedSource);
            } else if (isDefault) {
              builder["default"](name);
            } else if (isNamed) {
              builder.named(name, importName);
            }
          } else {
            builder.require();

            if (isNamespace) {
              builder["var"](name || importedSource);
            } else if (isDefault) {
              builder["var"](name);
            } else if (isNamed) {
              if (ensureLiveReference) {
                builder["var"](importedSource).read(name);
              } else {
                builder["var"](name).prop(importName);
              }
            }
          }
        } else {
          throw new Error("Unknown importedInterop \"" + importedInterop + "\".");
        }

        var _builder$done = builder.done(),
            statements = _builder$done.statements,
            resultName = _builder$done.resultName;

        this._insertStatements(statements, blockHoist);

        if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
          return SequenceExpression([NumericLiteral(0), resultName]);
        }

        return resultName;
      };

      _proto._insertStatements = function _insertStatements(statements, blockHoist) {
        if (blockHoist === void 0) {
          blockHoist = 3;
        }

        statements.forEach(function (node) {
          node._blockHoist = blockHoist;
        });

        var targetPath = this._programPath.get("body").find(function (p) {
          var val = p.node._blockHoist;
          return Number.isFinite(val) && val < 4;
        });

        if (targetPath) {
          targetPath.insertBefore(statements);
        } else {
          this._programPath.unshiftContainer("body", statements);
        }
      };

      return ImportInjector;
    }();

    function addDefault(path, importedSource, opts) {
      return new ImportInjector(path).addDefault(importedSource, opts);
    }
    function addNamed(path, name, importedSource, opts) {
      return new ImportInjector(path).addNamed(name, importedSource, opts);
    }
    function addNamespace(path, importedSource, opts) {
      return new ImportInjector(path).addNamespace(importedSource, opts);
    }
    function addSideEffect(path, importedSource, opts) {
      return new ImportInjector(path).addSideEffect(importedSource, opts);
    }

    var AssignmentMemoiser = function () {
      function AssignmentMemoiser() {
        this._map = new WeakMap();
      }

      var _proto = AssignmentMemoiser.prototype;

      _proto.has = function has(key) {
        return this._map.has(key);
      };

      _proto.get = function get(key) {
        if (!this.has(key)) return;

        var record = this._map.get(key);

        var value = record.value;
        record.count--;

        if (record.count === 0) {
          return AssignmentExpression("=", value, key);
        }

        return value;
      };

      _proto.set = function set(key, value, count) {
        return this._map.set(key, {
          count: count,
          value: value
        });
      };

      return AssignmentMemoiser;
    }();

    var handle = {
      memoise: function memoise() {},
      handle: function handle(member) {
        var node = member.node,
            parent = member.parent,
            parentPath = member.parentPath;

        if (parentPath.isUpdateExpression({
          argument: node
        })) {
          var operator = parent.operator,
              prefix = parent.prefix;
          this.memoise(member, 2);
          var value = BinaryExpression(operator[0], UnaryExpression("+", this.get(member)), NumericLiteral(1));

          if (prefix) {
            parentPath.replaceWith(this.set(member, value));
          } else {
            var scope = member.scope;
            var ref = scope.generateUidIdentifierBasedOnNode(node);
            scope.push({
              id: ref
            });
            value.left = AssignmentExpression("=", cloneNode(ref), value.left);
            parentPath.replaceWith(SequenceExpression([this.set(member, value), cloneNode(ref)]));
          }

          return;
        }

        if (parentPath.isAssignmentExpression({
          left: node
        })) {
          var _operator = parent.operator,
              right = parent.right;
          var _value = right;

          if (_operator !== "=") {
            this.memoise(member, 2);
            _value = BinaryExpression(_operator.slice(0, -1), this.get(member), _value);
          }

          parentPath.replaceWith(this.set(member, _value));
          return;
        }

        if (parentPath.isCallExpression({
          callee: node
        })) {
          var args = parent.arguments;
          parentPath.replaceWith(this.call(member, args));
          return;
        }

        if (parentPath.isObjectProperty({
          value: node
        }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
          left: node
        }) && parentPath.parentPath.isObjectProperty({
          value: parent
        }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
          left: node
        }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
          member.replaceWith(this.destructureSet(member));
          return;
        }

        member.replaceWith(this.get(member));
      }
    };
    function memberExpressionToFunctions(path, visitor, state) {
      path.traverse(visitor, Object.assign({}, handle, {}, state, {
        memoiser: new AssignmentMemoiser()
      }));
    }

    function optimiseCall (callee, thisNode, args) {
      if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
        name: "arguments"
      })) {
        return CallExpression(MemberExpression(callee, Identifier("apply")), [thisNode, args[0].argument]);
      } else {
        return CallExpression(MemberExpression(callee, Identifier("call")), [thisNode].concat(args));
      }
    }

    function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
      objectRef = cloneNode(objectRef);
      var targetRef = isStatic || isPrivateMethod ? objectRef : MemberExpression(objectRef, Identifier("prototype"));
      return CallExpression(file.addHelper("getPrototypeOf"), [targetRef]);
    }

    function skipAllButComputedKey(path) {
      if (!path.node.computed) {
        path.skip();
        return;
      }

      var keys = VISITOR_KEYS[path.type];

      for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        if (key !== "key") path.skipKey(key);
      }
    }
    var environmentVisitor = {
      TypeAnnotation: function TypeAnnotation(path) {
        path.skip();
      },
      Function: function Function(path) {
        if (path.isMethod()) return;
        if (path.isArrowFunctionExpression()) return;
        path.skip();
      },
      "Method|ClassProperty|ClassPrivateProperty": function MethodClassPropertyClassPrivateProperty(path) {
        skipAllButComputedKey(path);
      }
    };
    var visitor$1 = traverse$1.visitors.merge([environmentVisitor, {
      Super: function Super(path, state) {
        var node = path.node,
            parentPath = path.parentPath;
        if (!parentPath.isMemberExpression({
          object: node
        })) return;
        state.handle(parentPath);
      }
    }]);
    var specHandlers = {
      memoise: function memoise(superMember, count) {
        var scope = superMember.scope,
            node = superMember.node;
        var computed = node.computed,
            property = node.property;

        if (!computed) {
          return;
        }

        var memo = scope.maybeGenerateMemoised(property);

        if (!memo) {
          return;
        }

        this.memoiser.set(property, memo, count);
      },
      prop: function prop(superMember) {
        var _superMember$node = superMember.node,
            computed = _superMember$node.computed,
            property = _superMember$node.property;

        if (this.memoiser.has(property)) {
          return cloneNode(this.memoiser.get(property));
        }

        if (computed) {
          return cloneNode(property);
        }

        return StringLiteral(property.name);
      },
      get: function get(superMember) {
        return this._get(superMember, this._getThisRefs());
      },
      _get: function _get(superMember, thisRefs) {
        var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
        return CallExpression(this.file.addHelper("get"), [thisRefs.memo ? SequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs["this"]]);
      },
      _getThisRefs: function _getThisRefs() {
        if (!this.isDerivedConstructor) {
          return {
            "this": ThisExpression()
          };
        }

        var thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
        return {
          memo: AssignmentExpression("=", thisRef, ThisExpression()),
          "this": cloneNode(thisRef)
        };
      },
      set: function set(superMember, value) {
        var thisRefs = this._getThisRefs();

        var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
        return CallExpression(this.file.addHelper("set"), [thisRefs.memo ? SequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs["this"], BooleanLiteral(superMember.isInStrictMode())]);
      },
      destructureSet: function destructureSet(superMember) {
        throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
      },
      call: function call(superMember, args) {
        var thisRefs = this._getThisRefs();

        return optimiseCall(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args);
      }
    };
    var looseHandlers = Object.assign({}, specHandlers, {
      prop: function prop(superMember) {
        var property = superMember.node.property;

        if (this.memoiser.has(property)) {
          return cloneNode(this.memoiser.get(property));
        }

        return cloneNode(property);
      },
      get: function get(superMember) {
        var isStatic = this.isStatic,
            superRef = this.superRef;
        var computed = superMember.node.computed;
        var prop = this.prop(superMember);
        var object;

        if (isStatic) {
          object = superRef ? cloneNode(superRef) : MemberExpression(Identifier("Function"), Identifier("prototype"));
        } else {
          object = superRef ? MemberExpression(cloneNode(superRef), Identifier("prototype")) : MemberExpression(Identifier("Object"), Identifier("prototype"));
        }

        return MemberExpression(object, prop, computed);
      },
      set: function set(superMember, value) {
        var computed = superMember.node.computed;
        var prop = this.prop(superMember);
        return AssignmentExpression("=", MemberExpression(ThisExpression(), prop, computed), value);
      },
      destructureSet: function destructureSet(superMember) {
        var computed = superMember.node.computed;
        var prop = this.prop(superMember);
        return MemberExpression(ThisExpression(), prop, computed);
      },
      call: function call(superMember, args) {
        return optimiseCall(this.get(superMember), ThisExpression(), args);
      }
    });

    var ReplaceSupers = function () {
      function ReplaceSupers(opts) {
        var path = opts.methodPath;
        this.methodPath = path;
        this.isDerivedConstructor = path.isClassMethod({
          kind: "constructor"
        }) && !!opts.superRef;
        this.isStatic = path.isObjectMethod() || path.node["static"];
        this.isPrivateMethod = path.isPrivate() && path.isMethod();
        this.file = opts.file;
        this.superRef = opts.superRef;
        this.isLoose = opts.isLoose;
        this.opts = opts;
      }

      var _proto = ReplaceSupers.prototype;

      _proto.getObjectRef = function getObjectRef() {
        return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
      };

      _proto.replace = function replace() {
        var handler = this.isLoose ? looseHandlers : specHandlers;
        memberExpressionToFunctions(this.methodPath, visitor$1, Object.assign({
          file: this.file,
          scope: this.methodPath.scope,
          isDerivedConstructor: this.isDerivedConstructor,
          isStatic: this.isStatic,
          isPrivateMethod: this.isPrivateMethod,
          getObjectRef: this.getObjectRef.bind(this),
          superRef: this.superRef
        }, handler));
      };

      return ReplaceSupers;
    }();

    function rewriteThis(programPath) {
      programPath.traverse(rewriteThisVisitor);
    }
    var rewriteThisVisitor = {
      ThisExpression: function ThisExpression(path) {
        path.replaceWith(path.scope.buildUndefinedNode());
      },
      Function: function Function(path) {
        if (path.isMethod()) skipAllButComputedKey(path);else if (!path.isArrowFunctionExpression()) path.skip();
      },
      ClassProperty: function ClassProperty(path) {
        skipAllButComputedKey(path);
      },
      ClassPrivateProperty: function ClassPrivateProperty(path) {
        path.skip();
      }
    };

    function simplifyAccess(path, bindingNames) {
      path.traverse(simpleAssignmentVisitor, {
        scope: path.scope,
        bindingNames: bindingNames,
        seen: new WeakSet()
      });
    }
    var simpleAssignmentVisitor = {
      UpdateExpression: {
        exit: function exit(path) {
          var scope = this.scope,
              bindingNames = this.bindingNames;
          var arg = path.get("argument");
          if (!arg.isIdentifier()) return;
          var localName = arg.node.name;
          if (!bindingNames.has(localName)) return;

          if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
            return;
          }

          if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
            var operator = path.node.operator == "++" ? "+=" : "-=";
            path.replaceWith(AssignmentExpression(operator, arg.node, NumericLiteral(1)));
          } else if (path.node.prefix) {
            path.replaceWith(AssignmentExpression("=", Identifier(localName), BinaryExpression(path.node.operator[0], UnaryExpression("+", arg.node), NumericLiteral(1))));
          } else {
            var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
            var varName = old.name;
            path.scope.push({
              id: old
            });
            var binary = BinaryExpression(path.node.operator[0], Identifier(varName), NumericLiteral(1));
            path.replaceWith(SequenceExpression([AssignmentExpression("=", Identifier(varName), UnaryExpression("+", arg.node)), AssignmentExpression("=", cloneNode(arg.node), binary), Identifier(varName)]));
          }
        }
      },
      AssignmentExpression: {
        exit: function exit(path) {
          var scope = this.scope,
              seen = this.seen,
              bindingNames = this.bindingNames;
          if (path.node.operator === "=") return;
          if (seen.has(path.node)) return;
          seen.add(path.node);
          var left = path.get("left");
          if (!left.isIdentifier()) return;
          var localName = left.node.name;
          if (!bindingNames.has(localName)) return;

          if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
            return;
          }

          path.node.right = BinaryExpression(path.node.operator.slice(0, -1), cloneNode(path.node.left), path.node.right);
          path.node.operator = "=";
        }
      }
    };

    function _templateObject$1() {
      var data = _taggedTemplateLiteralLoose(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "]);

      _templateObject$1 = function _templateObject() {
        return data;
      };

      return data;
    }
    function rewriteLiveReferences(programPath, metadata) {
      var imported = new Map();
      var exported = new Map();

      var requeueInParent = function requeueInParent(path) {
        programPath.requeue(path);
      };

      for (var _iterator = _createForOfIteratorHelperLoose(metadata.source), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            source = _step$value[0],
            data = _step$value[1];

        for (var _iterator3 = _createForOfIteratorHelperLoose(data.imports), _step3; !(_step3 = _iterator3()).done;) {
          var _step3$value = _step3.value,
              localName = _step3$value[0],
              importName = _step3$value[1];
          imported.set(localName, [source, importName, null]);
        }

        for (var _iterator4 = _createForOfIteratorHelperLoose(data.importsNamespace), _step4; !(_step4 = _iterator4()).done;) {
          var _localName = _step4.value;
          imported.set(_localName, [source, null, _localName]);
        }
      }

      for (var _iterator2 = _createForOfIteratorHelperLoose(metadata.local), _step2; !(_step2 = _iterator2()).done;) {
        var _exportMeta;

        var _step2$value = _step2.value,
            local = _step2$value[0],
            _data = _step2$value[1];
        var exportMeta = exported.get(local);

        if (!exportMeta) {
          exportMeta = [];
          exported.set(local, exportMeta);
        }

        (_exportMeta = exportMeta).push.apply(_exportMeta, _data.names);
      }

      programPath.traverse(rewriteBindingInitVisitor, {
        metadata: metadata,
        requeueInParent: requeueInParent,
        scope: programPath.scope,
        exported: exported
      });
      simplifyAccess(programPath, new Set([].concat(Array.from(imported.keys()), Array.from(exported.keys()))));
      programPath.traverse(rewriteReferencesVisitor, {
        seen: new WeakSet(),
        metadata: metadata,
        requeueInParent: requeueInParent,
        scope: programPath.scope,
        imported: imported,
        exported: exported,
        buildImportReference: function buildImportReference(_ref, identNode) {
          var source = _ref[0],
              importName = _ref[1],
              localName = _ref[2];
          var meta = metadata.source.get(source);

          if (localName) {
            if (meta.lazy) identNode = CallExpression(identNode, []);
            return identNode;
          }

          var namespace = Identifier(meta.name);
          if (meta.lazy) namespace = CallExpression(namespace, []);
          return MemberExpression(namespace, Identifier(importName));
        }
      });
    }
    var rewriteBindingInitVisitor = {
      Scope: function Scope(path) {
        path.skip();
      },
      ClassDeclaration: function ClassDeclaration(path) {
        var requeueInParent = this.requeueInParent,
            exported = this.exported,
            metadata = this.metadata;
        var id = path.node.id;
        if (!id) throw new Error("Expected class to have a name");
        var localName = id.name;
        var exportNames = exported.get(localName) || [];

        if (exportNames.length > 0) {
          var statement = ExpressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, Identifier(localName)));
          statement._blockHoist = path.node._blockHoist;
          requeueInParent(path.insertAfter(statement)[0]);
        }
      },
      VariableDeclaration: function VariableDeclaration(path) {
        var requeueInParent = this.requeueInParent,
            exported = this.exported,
            metadata = this.metadata;
        Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
          var exportNames = exported.get(localName) || [];

          if (exportNames.length > 0) {
            var statement = ExpressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, Identifier(localName)));
            statement._blockHoist = path.node._blockHoist;
            requeueInParent(path.insertAfter(statement)[0]);
          }
        });
      }
    };

    var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {
      return (exportNames || []).reduce(function (expr, exportName) {
        return AssignmentExpression("=", MemberExpression(Identifier(metadata.exportName), Identifier(exportName)), expr);
      }, localExpr);
    };

    var buildImportThrow = function buildImportThrow(localName) {
      return template.expression.ast(_templateObject$1(), localName);
    };

    var rewriteReferencesVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var seen = this.seen,
            buildImportReference = this.buildImportReference,
            scope = this.scope,
            imported = this.imported,
            requeueInParent = this.requeueInParent;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var localName = path.node.name;
        var localBinding = path.scope.getBinding(localName);
        var rootBinding = scope.getBinding(localName);
        if (rootBinding !== localBinding) return;
        var importData = imported.get(localName);

        if (importData) {
          var ref = buildImportReference(importData, path.node);
          ref.loc = path.node.loc;

          if ((path.parentPath.isCallExpression({
            callee: path.node
          }) || path.parentPath.isOptionalCallExpression({
            callee: path.node
          }) || path.parentPath.isTaggedTemplateExpression({
            tag: path.node
          })) && isMemberExpression(ref)) {
            path.replaceWith(SequenceExpression([NumericLiteral(0), ref]));
          } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
            var object = ref.object,
                property = ref.property;
            path.replaceWith(JSXMemberExpression(JSXIdentifier(object.name), JSXIdentifier(property.name)));
          } else {
            path.replaceWith(ref);
          }

          requeueInParent(path);
          path.skip();
        }
      },
      AssignmentExpression: {
        exit: function exit(path) {
          var _this = this;

          var scope = this.scope,
              seen = this.seen,
              imported = this.imported,
              exported = this.exported,
              requeueInParent = this.requeueInParent,
              buildImportReference = this.buildImportReference;
          if (seen.has(path.node)) return;
          seen.add(path.node);
          var left = path.get("left");
          if (left.isMemberExpression()) return;

          if (left.isIdentifier()) {
            var localName = left.node.name;

            if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
              return;
            }

            var exportedNames = exported.get(localName);
            var importData = imported.get(localName);

            if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
              assert$2(path.node.operator === "=", "Path was not simplified");
              var assignment = path.node;

              if (importData) {
                assignment.left = buildImportReference(importData, assignment.left);
                assignment.right = SequenceExpression([assignment.right, buildImportThrow(localName)]);
              }

              path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));
              requeueInParent(path);
            }
          } else {
            var ids = left.getOuterBindingIdentifiers();
            var programScopeIds = Object.keys(ids).filter(function (localName) {
              return scope.getBinding(localName) === path.scope.getBinding(localName);
            });
            var id = programScopeIds.find(function (localName) {
              return imported.has(localName);
            });

            if (id) {
              path.node.right = SequenceExpression([path.node.right, buildImportThrow(id)]);
            }

            var items = [];
            programScopeIds.forEach(function (localName) {
              var exportedNames = exported.get(localName) || [];

              if (exportedNames.length > 0) {
                items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, Identifier(localName)));
              }
            });

            if (items.length > 0) {
              var node = SequenceExpression(items);

              if (path.parentPath.isExpressionStatement()) {
                node = ExpressionStatement(node);
                node._blockHoist = path.parentPath.node._blockHoist;
              }

              var statement = path.insertAfter(node)[0];
              requeueInParent(statement);
            }
          }
        }
      },
      "ForOfStatement|ForInStatement": function ForOfStatementForInStatement(path) {
        var scope = path.scope,
            node = path.node;
        var left = node.left;
        var exported = this.exported,
            programScope = this.scope;

        if (!isVariableDeclaration(left)) {
          var didTransform = false;
          var bodyPath = path.get("body");
          var loopBodyScope = bodyPath.scope;

          for (var _i = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i < _Object$keys.length; _i++) {
            var name = _Object$keys[_i];

            if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {
              didTransform = true;

              if (loopBodyScope.hasOwnBinding(name)) {
                loopBodyScope.rename(name);
              }
            }
          }

          if (!didTransform) {
            return;
          }

          var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
          bodyPath.unshiftContainer("body", ExpressionStatement(AssignmentExpression("=", left, newLoopId)));
          path.get("left").replaceWith(VariableDeclaration("let", [VariableDeclarator(newLoopId)]));
          scope.registerDeclaration(path.get("left"));
        }
      }
    };

    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;

      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];

        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }

      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    }

    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

    var splitPath = function splitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    };

    function resolve$1() {
      var resolvedPath = '',
          resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : '/';

        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }

      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
    }
    function normalize(path) {
      var isPathAbsolute = isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
      path = normalizeArray(filter(path.split('/'), function (p) {
        return !!p;
      }), !isPathAbsolute).join('/');

      if (!path && !isPathAbsolute) {
        path = '.';
      }

      if (path && trailingSlash) {
        path += '/';
      }

      return (isPathAbsolute ? '/' : '') + path;
    }
    function isAbsolute(path) {
      return path.charAt(0) === '/';
    }
    function join() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return normalize(filter(paths, function (p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }

        return p;
      }).join('/'));
    }
    function relative(from, to) {
      from = resolve$1(from).substr(1);
      to = resolve$1(to).substr(1);

      function trim(arr) {
        var start = 0;

        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }

        var end = arr.length - 1;

        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }

        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }

      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;

      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }

      var outputParts = [];

      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }

      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join('/');
    }
    var sep = '/';
    var delimiter = ':';
    function dirname(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];

      if (!root && !dir) {
        return '.';
      }

      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }

      return root + dir;
    }
    function basename(path, ext) {
      var f = splitPath(path)[2];

      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }

      return f;
    }
    function extname(path) {
      return splitPath(path)[3];
    }
    var path$1 = {
      extname: extname,
      basename: basename,
      dirname: dirname,
      sep: sep,
      delimiter: delimiter,
      relative: relative,
      join: join,
      isAbsolute: isAbsolute,
      normalize: normalize,
      resolve: resolve$1
    };

    function filter(xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];

      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
      }

      return res;
    }

    var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
      return str.substr(start, len);
    } : function (str, start, len) {
      if (start < 0) start = str.length + start;
      return str.substr(start, len);
    };

    function hasExports(metadata) {
      return metadata.hasExports;
    }
    function isSideEffectImport(source) {
      return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
    }
    function normalizeModuleAndLoadMetadata(programPath, exportName, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$noInterop = _ref.noInterop,
          noInterop = _ref$noInterop === void 0 ? false : _ref$noInterop,
          _ref$loose = _ref.loose,
          loose = _ref$loose === void 0 ? false : _ref$loose,
          _ref$lazy = _ref.lazy,
          lazy = _ref$lazy === void 0 ? false : _ref$lazy,
          _ref$esNamespaceOnly = _ref.esNamespaceOnly,
          esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly;

      if (!exportName) {
        exportName = programPath.scope.generateUidIdentifier("exports").name;
      }

      nameAnonymousExports(programPath);

      var _getModuleMetadata = getModuleMetadata(programPath, {
        loose: loose,
        lazy: lazy
      }),
          local = _getModuleMetadata.local,
          source = _getModuleMetadata.source,
          hasExports = _getModuleMetadata.hasExports;

      removeModuleDeclarations(programPath);

      for (var _iterator = _createForOfIteratorHelperLoose(source), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            metadata = _step$value[1];

        if (metadata.importsNamespace.size > 0) {
          metadata.name = metadata.importsNamespace.values().next().value;
        }

        if (noInterop) metadata.interop = "none";else if (esNamespaceOnly) {
          if (metadata.interop === "namespace") {
            metadata.interop = "default";
          }
        }
      }

      return {
        exportName: exportName,
        exportNameListName: null,
        hasExports: hasExports,
        local: local,
        source: source
      };
    }

    function getModuleMetadata(programPath, _ref2) {
      var loose = _ref2.loose,
          lazy = _ref2.lazy;
      var localData = getLocalExportMetadata(programPath, loose);
      var sourceData = new Map();

      var getData = function getData(sourceNode) {
        var source = sourceNode.value;
        var data = sourceData.get(source);

        if (!data) {
          data = {
            name: programPath.scope.generateUidIdentifier(basename(source, extname(source))).name,
            interop: "none",
            loc: null,
            imports: new Map(),
            importsNamespace: new Set(),
            reexports: new Map(),
            reexportNamespace: new Set(),
            reexportAll: null,
            lazy: false
          };
          sourceData.set(source, data);
        }

        return data;
      };

      var hasExports = false;
      programPath.get("body").forEach(function (child) {
        if (child.isImportDeclaration()) {
          var data = getData(child.node.source);
          if (!data.loc) data.loc = child.node.loc;
          child.get("specifiers").forEach(function (spec) {
            if (spec.isImportDefaultSpecifier()) {
              var localName = spec.get("local").node.name;
              data.imports.set(localName, "default");
              var reexport = localData.get(localName);

              if (reexport) {
                localData["delete"](localName);
                reexport.names.forEach(function (name) {
                  data.reexports.set(name, "default");
                });
              }
            } else if (spec.isImportNamespaceSpecifier()) {
              var _localName = spec.get("local").node.name;
              data.importsNamespace.add(_localName);

              var _reexport = localData.get(_localName);

              if (_reexport) {
                localData["delete"](_localName);

                _reexport.names.forEach(function (name) {
                  data.reexportNamespace.add(name);
                });
              }
            } else if (spec.isImportSpecifier()) {
              var importName = spec.get("imported").node.name;
              var _localName2 = spec.get("local").node.name;
              data.imports.set(_localName2, importName);

              var _reexport2 = localData.get(_localName2);

              if (_reexport2) {
                localData["delete"](_localName2);

                _reexport2.names.forEach(function (name) {
                  data.reexports.set(name, importName);
                });
              }
            }
          });
        } else if (child.isExportAllDeclaration()) {
          hasExports = true;

          var _data = getData(child.node.source);

          if (!_data.loc) _data.loc = child.node.loc;
          _data.reexportAll = {
            loc: child.node.loc
          };
        } else if (child.isExportNamedDeclaration() && child.node.source) {
          hasExports = true;

          var _data2 = getData(child.node.source);

          if (!_data2.loc) _data2.loc = child.node.loc;
          child.get("specifiers").forEach(function (spec) {
            if (!spec.isExportSpecifier()) {
              throw spec.buildCodeFrameError("Unexpected export specifier type");
            }

            var importName = spec.get("local").node.name;
            var exportName = spec.get("exported").node.name;

            _data2.reexports.set(exportName, importName);

            if (exportName === "__esModule") {
              throw exportName.buildCodeFrameError('Illegal export "__esModule".');
            }
          });
        } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
          hasExports = true;
        }
      });

      for (var _iterator2 = _createForOfIteratorHelperLoose(sourceData.values()), _step2; !(_step2 = _iterator2()).done;) {
        var metadata = _step2.value;
        var needsDefault = false;
        var needsNamed = false;

        if (metadata.importsNamespace.size > 0) {
          needsDefault = true;
          needsNamed = true;
        }

        if (metadata.reexportAll) {
          needsNamed = true;
        }

        for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.imports.values()), _step4; !(_step4 = _iterator4()).done;) {
          var importName = _step4.value;
          if (importName === "default") needsDefault = true;else needsNamed = true;
        }

        for (var _iterator5 = _createForOfIteratorHelperLoose(metadata.reexports.values()), _step5; !(_step5 = _iterator5()).done;) {
          var _importName = _step5.value;
          if (_importName === "default") needsDefault = true;else needsNamed = true;
        }

        if (needsDefault && needsNamed) {
          metadata.interop = "namespace";
        } else if (needsDefault) {
          metadata.interop = "default";
        }
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(sourceData), _step3; !(_step3 = _iterator3()).done;) {
        var _step3$value = _step3.value,
            source = _step3$value[0],
            _metadata = _step3$value[1];

        if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {
          if (lazy === true) {
            _metadata.lazy = !/\./.test(source);
          } else if (Array.isArray(lazy)) {
            _metadata.lazy = lazy.indexOf(source) !== -1;
          } else if (typeof lazy === "function") {
            _metadata.lazy = lazy(source);
          } else {
            throw new Error(".lazy must be a boolean, string array, or function");
          }
        }
      }

      return {
        hasExports: hasExports,
        local: localData,
        source: sourceData
      };
    }

    function getLocalExportMetadata(programPath, loose) {
      var bindingKindLookup = new Map();
      programPath.get("body").forEach(function (child) {
        var kind;

        if (child.isImportDeclaration()) {
          kind = "import";
        } else {
          if (child.isExportDefaultDeclaration()) child = child.get("declaration");

          if (child.isExportNamedDeclaration()) {
            if (child.node.declaration) {
              child = child.get("declaration");
            } else if (loose && child.node.source && child.get("source").isStringLiteral()) {
              child.node.specifiers.forEach(function (specifier) {
                bindingKindLookup.set(specifier.local.name, "block");
              });
              return;
            }
          }

          if (child.isFunctionDeclaration()) {
            kind = "hoisted";
          } else if (child.isClassDeclaration()) {
            kind = "block";
          } else if (child.isVariableDeclaration({
            kind: "var"
          })) {
            kind = "var";
          } else if (child.isVariableDeclaration()) {
            kind = "block";
          } else {
            return;
          }
        }

        Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
          bindingKindLookup.set(name, kind);
        });
      });
      var localMetadata = new Map();

      var getLocalMetadata = function getLocalMetadata(idPath) {
        var localName = idPath.node.name;
        var metadata = localMetadata.get(localName);

        if (!metadata) {
          var kind = bindingKindLookup.get(localName);

          if (kind === undefined) {
            throw idPath.buildCodeFrameError("Exporting local \"" + localName + "\", which is not declared.");
          }

          metadata = {
            names: [],
            kind: kind
          };
          localMetadata.set(localName, metadata);
        }

        return metadata;
      };

      programPath.get("body").forEach(function (child) {
        if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {
          if (child.node.declaration) {
            var declaration = child.get("declaration");
            var ids = declaration.getOuterBindingIdentifierPaths();
            Object.keys(ids).forEach(function (name) {
              if (name === "__esModule") {
                throw declaration.buildCodeFrameError('Illegal export "__esModule".');
              }

              getLocalMetadata(ids[name]).names.push(name);
            });
          } else {
            child.get("specifiers").forEach(function (spec) {
              var local = spec.get("local");
              var exported = spec.get("exported");

              if (exported.node.name === "__esModule") {
                throw exported.buildCodeFrameError('Illegal export "__esModule".');
              }

              getLocalMetadata(local).names.push(exported.node.name);
            });
          }
        } else if (child.isExportDefaultDeclaration()) {
          var _declaration = child.get("declaration");

          if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
            getLocalMetadata(_declaration.get("id")).names.push("default");
          } else {
            throw _declaration.buildCodeFrameError("Unexpected default expression export.");
          }
        }
      });
      return localMetadata;
    }

    function nameAnonymousExports(programPath) {
      programPath.get("body").forEach(function (child) {
        if (!child.isExportDefaultDeclaration()) return;
        splitExportDeclaration(child);
      });
    }

    function removeModuleDeclarations(programPath) {
      programPath.get("body").forEach(function (child) {
        if (child.isImportDeclaration()) {
          child.remove();
        } else if (child.isExportNamedDeclaration()) {
          if (child.node.declaration) {
            child.node.declaration._blockHoist = child.node._blockHoist;
            child.replaceWith(child.node.declaration);
          } else {
            child.remove();
          }
        } else if (child.isExportDefaultDeclaration()) {
          var declaration = child.get("declaration");

          if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
            declaration._blockHoist = child.node._blockHoist;
            child.replaceWith(declaration);
          } else {
            throw declaration.buildCodeFrameError("Unexpected default expression export.");
          }
        } else if (child.isExportAllDeclaration()) {
          child.remove();
        }
      });
    }

    function getModuleName(rootOpts, pluginOpts) {
      var _pluginOpts$moduleRoo, _rootOpts$moduleIds, _rootOpts$moduleRoot;

      var filename = rootOpts.filename,
          _rootOpts$filenameRel = rootOpts.filenameRelative,
          filenameRelative = _rootOpts$filenameRel === void 0 ? filename : _rootOpts$filenameRel,
          _rootOpts$sourceRoot = rootOpts.sourceRoot,
          sourceRoot = _rootOpts$sourceRoot === void 0 ? (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot : _rootOpts$sourceRoot;
      var _pluginOpts$moduleId = pluginOpts.moduleId,
          moduleId = _pluginOpts$moduleId === void 0 ? rootOpts.moduleId : _pluginOpts$moduleId,
          _pluginOpts$moduleIds = pluginOpts.moduleIds,
          moduleIds = _pluginOpts$moduleIds === void 0 ? (_rootOpts$moduleIds = rootOpts.moduleIds) != null ? _rootOpts$moduleIds : !!moduleId : _pluginOpts$moduleIds,
          _pluginOpts$getModule = pluginOpts.getModuleId,
          getModuleId = _pluginOpts$getModule === void 0 ? rootOpts.getModuleId : _pluginOpts$getModule,
          _pluginOpts$moduleRoo2 = pluginOpts.moduleRoot,
          moduleRoot = _pluginOpts$moduleRoo2 === void 0 ? (_rootOpts$moduleRoot = rootOpts.moduleRoot) != null ? _rootOpts$moduleRoot : sourceRoot : _pluginOpts$moduleRoo2;
      if (!moduleIds) return null;

      if (moduleId != null && !getModuleId) {
        return moduleId;
      }

      var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

      if (filenameRelative) {
        var sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
        moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
      }

      moduleName = moduleName.replace(/\\/g, "/");

      if (getModuleId) {
        return getModuleId(moduleName) || moduleName;
      } else {
        return moduleName;
      }
    }

    function _templateObject11$1() {
      var data = _taggedTemplateLiteralLoose(["EXPORTS.NAME = VALUE"]);

      _templateObject11$1 = function _templateObject11() {
        return data;
      };

      return data;
    }

    function _templateObject10$1() {
      var data = _taggedTemplateLiteralLoose(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "]);

      _templateObject10$1 = function _templateObject10() {
        return data;
      };

      return data;
    }

    function _templateObject9$1() {
      var data = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]);

      _templateObject9$1 = function _templateObject9() {
        return data;
      };

      return data;
    }

    function _templateObject8$1() {
      var data = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]);

      _templateObject8$1 = function _templateObject8() {
        return data;
      };

      return data;
    }

    function _templateObject7$1() {
      var data = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]);

      _templateObject7$1 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$1() {
      var data = _taggedTemplateLiteralLoose(["\n        EXPORTS.__esModule = true;\n      "]);

      _templateObject6$1 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$1() {
      var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n        enumerable: true,\n        get: function() {\n          return NAMESPACE.IMPORT_NAME;\n        },\n      });\n    "]);

      _templateObject5$1 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$1() {
      var data = _taggedTemplateLiteralLoose(["EXPORTS.EXPORT_NAME = NAMESPACE.IMPORT_NAME;"]);

      _templateObject4$1 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$1() {
      var data = _taggedTemplateLiteralLoose(["EXPORTS.NAME = NAMESPACE;"]);

      _templateObject3$1 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$1() {
      var data = _taggedTemplateLiteralLoose(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]);

      _templateObject2$1 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$2() {
      var data = _taggedTemplateLiteralLoose(["var NAME = SOURCE;"]);

      _templateObject$2 = function _templateObject() {
        return data;
      };

      return data;
    }
    function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
      var exportName = _ref.exportName,
          strict = _ref.strict,
          allowTopLevelThis = _ref.allowTopLevelThis,
          strictMode = _ref.strictMode,
          loose = _ref.loose,
          noInterop = _ref.noInterop,
          lazy = _ref.lazy,
          esNamespaceOnly = _ref.esNamespaceOnly;
      assert$2(isModule(path), "Cannot process module statements in a script");
      path.node.sourceType = "script";
      var meta = normalizeModuleAndLoadMetadata(path, exportName, {
        noInterop: noInterop,
        loose: loose,
        lazy: lazy,
        esNamespaceOnly: esNamespaceOnly
      });

      if (!allowTopLevelThis) {
        rewriteThis(path);
      }

      rewriteLiveReferences(path, meta);

      if (strictMode !== false) {
        var hasStrict = path.node.directives.some(function (directive) {
          return directive.value.value === "use strict";
        });

        if (!hasStrict) {
          path.unshiftContainer("directives", Directive(DirectiveLiteral("use strict")));
        }
      }

      var headers = [];

      if (hasExports(meta) && !strict) {
        headers.push(buildESModuleHeader(meta, loose));
      }

      var nameList = buildExportNameListDeclaration(path, meta);

      if (nameList) {
        meta.exportNameListName = nameList.name;
        headers.push(nameList.statement);
      }

      headers.push.apply(headers, buildExportInitializationStatements(path, meta, loose));
      return {
        meta: meta,
        headers: headers
      };
    }
    function ensureStatementsHoisted(statements) {
      statements.forEach(function (header) {
        header._blockHoist = 3;
      });
    }
    function wrapInterop(programPath, expr, type) {
      if (type === "none") {
        return null;
      }

      var helper;

      if (type === "default") {
        helper = "interopRequireDefault";
      } else if (type === "namespace") {
        helper = "interopRequireWildcard";
      } else {
        throw new Error("Unknown interop: " + type);
      }

      return CallExpression(programPath.hub.addHelper(helper), [expr]);
    }
    function buildNamespaceInitStatements(metadata, sourceMetadata, loose) {
      if (loose === void 0) {
        loose = false;
      }

      var statements = [];
      var srcNamespace = Identifier(sourceMetadata.name);
      if (sourceMetadata.lazy) srcNamespace = CallExpression(srcNamespace, []);

      for (var _iterator = _createForOfIteratorHelperLoose(sourceMetadata.importsNamespace), _step; !(_step = _iterator()).done;) {
        var localName = _step.value;
        if (localName === sourceMetadata.name) continue;
        statements.push(template.statement(_templateObject$2())({
          NAME: localName,
          SOURCE: cloneNode(srcNamespace)
        }));
      }

      if (loose) {
        statements.push.apply(statements, buildReexportsFromMeta(metadata, sourceMetadata, loose));
      }

      for (var _iterator2 = _createForOfIteratorHelperLoose(sourceMetadata.reexportNamespace), _step2; !(_step2 = _iterator2()).done;) {
        var exportName = _step2.value;
        statements.push((sourceMetadata.lazy ? template.statement(_templateObject2$1()) : template.statement(_templateObject3$1()))({
          EXPORTS: metadata.exportName,
          NAME: exportName,
          NAMESPACE: cloneNode(srcNamespace)
        }));
      }

      if (sourceMetadata.reexportAll) {
        var statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), loose);
        statement.loc = sourceMetadata.reexportAll.loc;
        statements.push(statement);
      }

      return statements;
    }

    var getTemplateForReexport = function getTemplateForReexport(loose) {
      return loose ? template.statement(_templateObject4$1()) : template(_templateObject5$1());
    };

    var buildReexportsFromMeta = function buildReexportsFromMeta(meta, metadata, loose) {
      var namespace = metadata.lazy ? CallExpression(Identifier(metadata.name), []) : Identifier(metadata.name);
      var templateForCurrentMode = getTemplateForReexport(loose);
      return Array.from(metadata.reexports, function (_ref2) {
        var exportName = _ref2[0],
            importName = _ref2[1];
        return templateForCurrentMode({
          EXPORTS: meta.exportName,
          EXPORT_NAME: exportName,
          NAMESPACE: cloneNode(namespace),
          IMPORT_NAME: importName
        });
      });
    };

    function buildESModuleHeader(metadata, enumerable) {
      if (enumerable === void 0) {
        enumerable = false;
      }

      return (enumerable ? template.statement(_templateObject6$1()) : template.statement(_templateObject7$1()))({
        EXPORTS: metadata.exportName
      });
    }

    function buildNamespaceReexport(metadata, namespace, loose) {
      return (loose ? template.statement(_templateObject8$1()) : template.statement(_templateObject9$1()))({
        NAMESPACE: namespace,
        EXPORTS: metadata.exportName,
        VERIFY_NAME_LIST: metadata.exportNameListName ? template(_templateObject10$1())({
          EXPORTS_LIST: metadata.exportNameListName
        }) : null
      });
    }

    function buildExportNameListDeclaration(programPath, metadata) {
      var exportedVars = Object.create(null);

      for (var _iterator3 = _createForOfIteratorHelperLoose(metadata.local.values()), _step3; !(_step3 = _iterator3()).done;) {
        var data = _step3.value;

        for (var _iterator5 = _createForOfIteratorHelperLoose(data.names), _step5; !(_step5 = _iterator5()).done;) {
          var _name = _step5.value;
          exportedVars[_name] = true;
        }
      }

      var hasReexport = false;

      for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.source.values()), _step4; !(_step4 = _iterator4()).done;) {
        var _data = _step4.value;

        for (var _iterator6 = _createForOfIteratorHelperLoose(_data.reexports.keys()), _step6; !(_step6 = _iterator6()).done;) {
          var exportName = _step6.value;
          exportedVars[exportName] = true;
        }

        for (var _iterator7 = _createForOfIteratorHelperLoose(_data.reexportNamespace), _step7; !(_step7 = _iterator7()).done;) {
          var _exportName = _step7.value;
          exportedVars[_exportName] = true;
        }

        hasReexport = hasReexport || _data.reexportAll;
      }

      if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
      var name = programPath.scope.generateUidIdentifier("exportNames");
      delete exportedVars["default"];
      return {
        name: name.name,
        statement: VariableDeclaration("var", [VariableDeclarator(name, valueToNode(exportedVars))])
      };
    }

    function buildExportInitializationStatements(programPath, metadata, loose) {
      if (loose === void 0) {
        loose = false;
      }

      var initStatements = [];
      var exportNames = [];

      for (var _iterator8 = _createForOfIteratorHelperLoose(metadata.local), _step8; !(_step8 = _iterator8()).done;) {
        var _step8$value = _step8.value,
            localName = _step8$value[0],
            data = _step8$value[1];

        if (data.kind === "import") ; else if (data.kind === "hoisted") {
          initStatements.push(buildInitStatement(metadata, data.names, Identifier(localName)));
        } else {
          exportNames.push.apply(exportNames, data.names);
        }
      }

      for (var _iterator9 = _createForOfIteratorHelperLoose(metadata.source.values()), _step9; !(_step9 = _iterator9()).done;) {
        var _data2 = _step9.value;

        if (!loose) {
          initStatements.push.apply(initStatements, buildReexportsFromMeta(metadata, _data2, loose));
        }

        for (var _iterator10 = _createForOfIteratorHelperLoose(_data2.reexportNamespace), _step10; !(_step10 = _iterator10()).done;) {
          var exportName = _step10.value;
          exportNames.push(exportName);
        }
      }

      initStatements.push.apply(initStatements, chunk_1(exportNames, 100).map(function (members) {
        return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());
      }));
      return initStatements;
    }

    function buildInitStatement(metadata, exportNames, initExpr) {
      return ExpressionStatement(exportNames.reduce(function (acc, exportName) {
        return template.expression(_templateObject11$1())({
          EXPORTS: metadata.exportName,
          NAME: exportName,
          VALUE: acc
        });
      }, initExpr));
    }

    var semver = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;

    if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    }

    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    }

    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)';
    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*';

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult;
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    }

    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    }

    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    }

    function replaceStars(comp, options) {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    }

    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    }

    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }

        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              break;

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    }

    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    }

    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      if (satisfies(version, range, options)) {
        return false;
      }

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
    });
    var semver_1 = semver.SEMVER_SPEC_VERSION;
    var semver_2 = semver.re;
    var semver_3 = semver.src;
    var semver_4 = semver.tokens;
    var semver_5 = semver.parse;
    var semver_6 = semver.valid;
    var semver_7 = semver.clean;
    var semver_8 = semver.SemVer;
    var semver_9 = semver.inc;
    var semver_10 = semver.diff;
    var semver_11 = semver.compareIdentifiers;
    var semver_12 = semver.rcompareIdentifiers;
    var semver_13 = semver.major;
    var semver_14 = semver.minor;
    var semver_15 = semver.patch;
    var semver_16 = semver.compare;
    var semver_17 = semver.compareLoose;
    var semver_18 = semver.compareBuild;
    var semver_19 = semver.rcompare;
    var semver_20 = semver.sort;
    var semver_21 = semver.rsort;
    var semver_22 = semver.gt;
    var semver_23 = semver.lt;
    var semver_24 = semver.eq;
    var semver_25 = semver.neq;
    var semver_26 = semver.gte;
    var semver_27 = semver.lte;
    var semver_28 = semver.cmp;
    var semver_29 = semver.Comparator;
    var semver_30 = semver.Range;
    var semver_31 = semver.toComparators;
    var semver_32 = semver.satisfies;
    var semver_33 = semver.maxSatisfying;
    var semver_34 = semver.minSatisfying;
    var semver_35 = semver.minVersion;
    var semver_36 = semver.validRange;
    var semver_37 = semver.ltr;
    var semver_38 = semver.gtr;
    var semver_39 = semver.outside;
    var semver_40 = semver.prerelease;
    var semver_41 = semver.intersects;
    var semver_42 = semver.coerce;

    var errorVisitor = {
      enter: function enter(path, state) {
        var loc = path.node.loc;

        if (loc) {
          state.loc = loc;
          path.stop();
        }
      }
    };

    var File$2 = function () {
      function File(options, _ref) {
        var _this = this;

        var code = _ref.code,
            ast = _ref.ast,
            inputMap = _ref.inputMap;
        this._map = new Map();
        this.declarations = {};
        this.path = null;
        this.ast = {};
        this.metadata = {};
        this.code = "";
        this.inputMap = null;
        this.hub = {
          file: this,
          getCode: function getCode() {
            return _this.code;
          },
          getScope: function getScope() {
            return _this.scope;
          },
          addHelper: this.addHelper.bind(this),
          buildError: this.buildCodeFrameError.bind(this)
        };
        this.opts = options;
        this.code = code;
        this.ast = ast;
        this.inputMap = inputMap;
        this.path = NodePath.get({
          hub: this.hub,
          parentPath: null,
          parent: this.ast,
          container: this.ast,
          key: "program"
        }).setContext();
        this.scope = this.path.scope;
      }

      var _proto = File.prototype;

      _proto.set = function set(key, val) {
        if (key === "helpersNamespace") {
          throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
        }

        this._map.set(key, val);
      };

      _proto.get = function get(key) {
        return this._map.get(key);
      };

      _proto.has = function has(key) {
        return this._map.has(key);
      };

      _proto.getModuleName = function getModuleName$1() {
        return getModuleName(this.opts, this.opts);
      };

      _proto.addImport = function addImport() {
        throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
      };

      _proto.availableHelper = function availableHelper(name, versionRange) {
        var minVersion$1;

        try {
          minVersion$1 = minVersion(name);
        } catch (err) {
          if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
          return false;
        }

        if (typeof versionRange !== "string") return true;
        if (semver.valid(versionRange)) versionRange = "^" + versionRange;
        return !semver.intersects("<" + minVersion$1, versionRange) && !semver.intersects(">=8.0.0", versionRange);
      };

      _proto.addHelper = function addHelper(name) {
        var _this2 = this;

        var declar = this.declarations[name];
        if (declar) return cloneNode(declar);
        var generator = this.get("helperGenerator");

        if (generator) {
          var res = generator(name);
          if (res) return res;
        }

        ensure(name, File);
        var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
        var dependencies = {};

        for (var _iterator = _createForOfIteratorHelperLoose(getDependencies(name)), _step; !(_step = _iterator()).done;) {
          var dep = _step.value;
          dependencies[dep] = this.addHelper(dep);
        }

        var _helpers$get = get$1(name, function (dep) {
          return dependencies[dep];
        }, uid, Object.keys(this.scope.getAllBindings())),
            nodes = _helpers$get.nodes,
            globals = _helpers$get.globals;

        globals.forEach(function (name) {
          if (_this2.path.scope.hasBinding(name, true)) {
            _this2.path.scope.rename(name);
          }
        });
        nodes.forEach(function (node) {
          node._compact = true;
        });
        this.path.unshiftContainer("body", nodes);
        this.path.get("body").forEach(function (path) {
          if (nodes.indexOf(path.node) === -1) return;
          if (path.isVariableDeclaration()) _this2.scope.registerDeclaration(path);
        });
        return uid;
      };

      _proto.addTemplateObject = function addTemplateObject() {
        throw new Error("This function has been moved into the template literal transform itself.");
      };

      _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
        if (Error === void 0) {
          Error = SyntaxError;
        }

        var loc = node && (node.loc || node._loc);

        if (!loc && node) {
          var state = {
            loc: null
          };
          traverse$1(node, errorVisitor, this.scope, state);
          loc = state.loc;
          var txt = "This is an error on an internal node. Probably an internal error.";
          if (loc) txt += " Location has been estimated.";
          msg += " (" + txt + ")";
        }

        if (loc) {
          var _this$opts$highlightC = this.opts.highlightCode,
              highlightCode = _this$opts$highlightC === void 0 ? true : _this$opts$highlightC;
          msg += "\n" + codeFrameColumns(this.code, {
            start: {
              line: loc.start.line,
              column: loc.start.column + 1
            },
            end: loc.end && loc.start.line === loc.end.line ? {
              line: loc.end.line,
              column: loc.end.column + 1
            } : undefined
          }, {
            highlightCode: highlightCode
          });
        }

        return new Error(msg);
      };

      _createClass(File, [{
        key: "shebang",
        get: function get() {
          var interpreter = this.path.node.interpreter;
          return interpreter ? interpreter.value : "";
        },
        set: function set(value) {
          if (value) {
            this.path.get("interpreter").replaceWith(InterpreterDirective(value));
          } else {
            this.path.get("interpreter").remove();
          }
        }
      }]);

      return File;
    }();

    function _templateObject$3() {
      var data = _taggedTemplateLiteralLoose(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "]);

      _templateObject$3 = function _templateObject() {
        return data;
      };

      return data;
    }

    var buildUmdWrapper = function buildUmdWrapper(replacements) {
      return template(_templateObject$3())(replacements);
    };

    function buildGlobal(whitelist) {
      var namespace = Identifier("babelHelpers");
      var body = [];
      var container = FunctionExpression(null, [Identifier("global")], BlockStatement(body));
      var tree = Program([ExpressionStatement(CallExpression(container, [ConditionalExpression(BinaryExpression("===", UnaryExpression("typeof", Identifier("global")), StringLiteral("undefined")), Identifier("self"), Identifier("global"))]))]);
      body.push(VariableDeclaration("var", [VariableDeclarator(namespace, AssignmentExpression("=", MemberExpression(Identifier("global"), namespace), ObjectExpression([])))]));
      buildHelpers(body, namespace, whitelist);
      return tree;
    }

    function buildModule(whitelist) {
      var body = [];
      var refs = buildHelpers(body, null, whitelist);
      body.unshift(ExportNamedDeclaration(null, Object.keys(refs).map(function (name) {
        return ExportSpecifier(cloneNode(refs[name]), Identifier(name));
      })));
      return Program(body, [], "module");
    }

    function buildUmd(whitelist) {
      var namespace = Identifier("babelHelpers");
      var body = [];
      body.push(VariableDeclaration("var", [VariableDeclarator(namespace, Identifier("global"))]));
      buildHelpers(body, namespace, whitelist);
      return Program([buildUmdWrapper({
        FACTORY_PARAMETERS: Identifier("global"),
        BROWSER_ARGUMENTS: AssignmentExpression("=", MemberExpression(Identifier("root"), namespace), ObjectExpression([])),
        COMMON_ARGUMENTS: Identifier("exports"),
        AMD_ARGUMENTS: ArrayExpression([StringLiteral("exports")]),
        FACTORY_BODY: body,
        UMD_ROOT: Identifier("this")
      })]);
    }

    function buildVar(whitelist) {
      var namespace = Identifier("babelHelpers");
      var body = [];
      body.push(VariableDeclaration("var", [VariableDeclarator(namespace, ObjectExpression([]))]));
      var tree = Program(body);
      buildHelpers(body, namespace, whitelist);
      body.push(ExpressionStatement(namespace));
      return tree;
    }

    function buildHelpers(body, namespace, whitelist) {
      var getHelperReference = function getHelperReference(name) {
        return namespace ? MemberExpression(namespace, Identifier(name)) : Identifier("_" + name);
      };

      var refs = {};
      list$1.forEach(function (name) {
        if (whitelist && whitelist.indexOf(name) < 0) return;
        var ref = refs[name] = getHelperReference(name);
        ensure(name, File$2);

        var _helpers$get = get$1(name, getHelperReference, ref),
            nodes = _helpers$get.nodes;

        body.push.apply(body, nodes);
      });
      return refs;
    }

    function babelBuildExternalHelpers (whitelist, outputType) {
      if (outputType === void 0) {
        outputType = "global";
      }

      var tree;
      var build = {
        global: buildGlobal,
        module: buildModule,
        umd: buildUmd,
        "var": buildVar
      }[outputType];

      if (build) {
        tree = build(whitelist);
      } else {
        throw new Error("Unsupported output type " + outputType);
      }

      return generateCode(tree).code;
    }

    var runtime_1 = createCommonjsModule(function (module) {
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap;

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var IteratorPrototype = {};

      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;

          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      };

      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }

        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };

      exports.AsyncIterator = AsyncIterator;

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }

            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }

      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          context.delegate = null;

          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          return info;
        }

        context.delegate = null;
        return ContinueSentinel;
      }

      defineIteratorMethods(Gp);
      Gp[toStringTagSymbol] = "Generator";

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse();
        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }

          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        }

        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      };
      return exports;
    }( module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
    });

    var regenerator = runtime_1;

    var _marked = regenerator.mark(findConfigUpwards),
        _marked2 = regenerator.mark(findPackageData),
        _marked3 = regenerator.mark(findRelativeConfig),
        _marked4 = regenerator.mark(findRootConfig),
        _marked5 = regenerator.mark(loadConfig);

    function findConfigUpwards(rootDir) {
      return regenerator.wrap(function findConfigUpwards$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", null);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _marked);
    }
    function findPackageData(filepath) {
      return regenerator.wrap(function findPackageData$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", {
                filepath: filepath,
                directories: [],
                pkg: null,
                isPackage: false
              });

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _marked2);
    }
    function findRelativeConfig(pkgData, envName, caller) {
      return regenerator.wrap(function findRelativeConfig$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", {
                pkg: null,
                config: null,
                ignore: null
              });

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _marked3);
    }
    function findRootConfig(dirname, envName, caller) {
      return regenerator.wrap(function findRootConfig$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", null);

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _marked4);
    }
    function loadConfig(name, dirname, envName, caller) {
      return regenerator.wrap(function loadConfig$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              throw new Error("Cannot load " + name + " relative to " + dirname + " in a browser");

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _marked5);
    }
    var ROOT_CONFIG_FILENAMES = [];
    function resolvePlugin(name, dirname) {
      return null;
    }
    function resolvePreset(name, dirname) {
      return null;
    }
    function loadPlugin(name, dirname) {
      throw new Error("Cannot load plugin " + name + " relative to " + dirname + " in a browser");
    }
    function loadPreset(name, dirname) {
      throw new Error("Cannot load preset " + name + " relative to " + dirname + " in a browser");
    }

    var version$1 = "7.9.0";

    function getEnv(defaultValue) {
      if (defaultValue === void 0) {
        defaultValue = "development";
      }

      return process.env.BABEL_ENV || undefined || defaultValue;
    }

    var GENSYNC_START = Symbol["for"]("gensync:v1:start");
    var GENSYNC_SUSPEND = Symbol["for"]("gensync:v1:suspend");
    var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
    var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
    var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
    var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
    var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
    var gensync = Object.assign(function gensync(optsOrFn) {
      var genFn = optsOrFn;

      if (typeof optsOrFn !== "function") {
        genFn = newGenerator(optsOrFn);
      } else {
        genFn = wrapGenerator(optsOrFn);
      }

      return Object.assign(genFn, makeFunctionAPI(genFn));
    }, {
      all: buildOperation({
        name: "all",
        arity: 1,
        sync: function sync(args) {
          var items = Array.from(args[0]);
          return items.map(function (item) {
            return evaluateSync(item);
          });
        },
        async: function async(args, resolve, reject) {
          var items = Array.from(args[0]);
          var count = 0;
          var results = items.map(function () {
            return undefined;
          });
          items.forEach(function (item, i) {
            evaluateAsync(item, function (val) {
              results[i] = val;
              count += 1;
              if (count === results.length) resolve(results);
            }, reject);
          });
        }
      }),
      race: buildOperation({
        name: "race",
        arity: 1,
        sync: function sync(args) {
          var items = Array.from(args[0]);

          if (items.length === 0) {
            throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
          }

          return evaluateSync(items[0]);
        },
        async: function async(args, resolve, reject) {
          var items = Array.from(args[0]);

          if (items.length === 0) {
            throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
          }

          for (var _i = 0, _items = items; _i < _items.length; _i++) {
            var item = _items[_i];
            evaluateAsync(item, resolve, reject);
          }
        }
      })
    });

    function makeFunctionAPI(genFn) {
      var fns = {
        sync: function sync() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return evaluateSync(genFn.apply(this, args));
        },
        async: function async() {
          var _this = this;

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return new Promise(function (resolve, reject) {
            evaluateAsync(genFn.apply(_this, args), resolve, reject);
          });
        },
        errback: function errback() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          var cb = args.pop();

          if (typeof cb !== "function") {
            throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
          }

          var gen;

          try {
            gen = genFn.apply(this, args);
          } catch (err) {
            cb(err);
            return;
          }

          evaluateAsync(gen, function (val) {
            return cb(undefined, val);
          }, function (err) {
            return cb(err);
          });
        }
      };
      return fns;
    }

    function assertTypeof(type, name, value, allowUndefined) {
      if (typeof value === type || allowUndefined && typeof value === "undefined") {
        return;
      }

      var msg;

      if (allowUndefined) {
        msg = "Expected opts." + name + " to be either a " + type + ", or undefined.";
      } else {
        msg = "Expected opts." + name + " to be a " + type + ".";
      }

      throw makeError(msg, GENSYNC_OPTIONS_ERROR);
    }

    function makeError(msg, code) {
      return Object.assign(new Error(msg), {
        code: code
      });
    }

    function newGenerator(_ref) {
      var name = _ref.name,
          arity = _ref.arity,
          _sync = _ref.sync,
          _async = _ref.async,
          errback = _ref.errback;
      assertTypeof("string", "name", name, true);
      assertTypeof("number", "arity", arity, true);
      assertTypeof("function", "sync", _sync);
      assertTypeof("function", "async", _async, true);
      assertTypeof("function", "errback", errback, true);

      if (_async && errback) {
        throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
      }

      if (typeof name !== "string") {
        var fnName;

        if (errback && errback.name && errback.name !== "errback") {
          fnName = errback.name;
        }

        if (_async && _async.name && _async.name !== "async") {
          fnName = _async.name.replace(/Async$/, "");
        }

        if (_sync && _sync.name && _sync.name !== "sync") {
          fnName = _sync.name.replace(/Sync$/, "");
        }

        if (typeof fnName === "string") {
          name = fnName;
        }
      }

      if (typeof arity !== "number") {
        arity = _sync.length;
      }

      return buildOperation({
        name: name,
        arity: arity,
        sync: function sync(args) {
          return _sync.apply(this, args);
        },
        async: function async(args, resolve, reject) {
          if (_async) {
            _async.apply(this, args).then(resolve, reject);
          } else if (errback) {
            errback.call.apply(errback, [this].concat(args, [function (err, value) {
              if (err == null) resolve(value);else reject(err);
            }]));
          } else {
            resolve(_sync.apply(this, args));
          }
        }
      });
    }

    function wrapGenerator(genFn) {
      return setFunctionMetadata(genFn.name, genFn.length, function () {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return genFn.apply(this, args);
      });
    }

    function buildOperation(_ref2) {
      var name = _ref2.name,
          arity = _ref2.arity,
          sync = _ref2.sync,
          async = _ref2.async;
      return setFunctionMetadata(name, arity, regenerator.mark(function _callee() {
        var resume,
            _len5,
            args,
            _key5,
            result,
            _args = arguments;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return GENSYNC_START;

              case 2:
                resume = _context.sent;

                for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = _args[_key5];
                }

                if (resume) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", sync.call(this, args));

              case 6:
                try {
                  async.call(this, args, function (value) {
                    if (result) return;
                    result = {
                      value: value
                    };
                    resume();
                  }, function (err) {
                    if (result) return;
                    result = {
                      err: err
                    };
                    resume();
                  });
                } catch (err) {
                  result = {
                    err: err
                  };
                  resume();
                }

                _context.next = 9;
                return GENSYNC_SUSPEND;

              case 9:
                if (!result.hasOwnProperty("err")) {
                  _context.next = 11;
                  break;
                }

                throw result.err;

              case 11:
                return _context.abrupt("return", result.value);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }

    function evaluateSync(gen) {
      var value;

      while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {
        var _gen$next;

        assertStart(value, gen);
      }

      return value;
    }

    function evaluateAsync(gen, resolve, reject) {
      (function step() {
        try {
          var value;

          var _loop = function _loop() {
            assertStart(value, gen);
            var sync = true;
            var didSyncResume = false;
            var out = gen.next(function () {
              if (sync) {
                didSyncResume = true;
              } else {
                step();
              }
            });
            sync = false;
            assertSuspend(out, gen);

            if (!didSyncResume) {
              return {
                v: void 0
              };
            }
          };

          while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {
            var _gen$next2;

            var _ret = _loop();

            if (typeof _ret === "object") return _ret.v;
          }

          return resolve(value);
        } catch (err) {
          return reject(err);
        }
      })();
    }

    function assertStart(value, gen) {
      if (value === GENSYNC_START) return;
      throwError(gen, makeError("Got unexpected yielded value in gensync generator: " + JSON.stringify(value) + ". Did you perhaps mean to use 'yield*' instead of 'yield'?", GENSYNC_EXPECTED_START));
    }

    function assertSuspend(_ref3, gen) {
      var value = _ref3.value,
          done = _ref3.done;
      if (!done && value === GENSYNC_SUSPEND) return;
      throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got " + JSON.stringify(value) + ". If you get this, it is probably a gensync bug.", GENSYNC_EXPECTED_SUSPEND));
    }

    function throwError(gen, err) {
      if (gen["throw"]) gen["throw"](err);
      throw err;
    }

    function setFunctionMetadata(name, arity, fn) {
      if (typeof name === "string") {
        var nameDesc = Object.getOwnPropertyDescriptor(fn, "name");

        if (!nameDesc || nameDesc.configurable) {
          Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
            configurable: true,
            value: name
          }));
        }
      }

      if (typeof arity === "number") {
        var lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");

        if (!lengthDesc || lengthDesc.configurable) {
          Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
            configurable: true,
            value: arity
          }));
        }
      }

      return fn;
    }

    var id$1 = function id(x) {
      return x;
    };

    var runGenerator = gensync(regenerator.mark(function _callee(item) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(item, "t0", 1);

            case 1:
              return _context.abrupt("return", _context.t0);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    var isAsync = gensync({
      sync: function sync() {
        return false;
      },
      errback: function errback(cb) {
        return cb(null, true);
      }
    });
    function maybeAsync(fn, message) {
      return gensync({
        sync: function sync() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var result = fn.apply(this, args);
          if (isThenable(result)) throw new Error(message);
          return result;
        },
        async: function async() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return Promise.resolve(fn.apply(this, args));
        }
      });
    }
    var withKind = gensync({
      sync: function sync(cb) {
        return cb("sync");
      },
      async: function async(cb) {
        return cb("async");
      }
    });
    function forwardAsync(action, cb) {
      var g = gensync(action);
      return withKind(function (kind) {
        var adapted = g[kind];
        return cb(adapted);
      });
    }
    var onFirstPause = gensync({
      name: "onFirstPause",
      arity: 2,
      sync: function sync(item) {
        return runGenerator.sync(item);
      },
      errback: function errback(item, firstPause, cb) {
        var completed = false;
        runGenerator.errback(item, function (err, value) {
          completed = true;
          cb(err, value);
        });

        if (!completed) {
          firstPause();
        }
      }
    });
    var waitFor = gensync({
      sync: id$1,
      async: id$1
    });
    function isThenable(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
    }

    function mergeOptions(target, source) {
      for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
        var k = _Object$keys[_i];

        if (k === "parserOpts" && source.parserOpts) {
          var parserOpts = source.parserOpts;
          var targetObj = target.parserOpts = target.parserOpts || {};
          mergeDefaultFields(targetObj, parserOpts);
        } else if (k === "generatorOpts" && source.generatorOpts) {
          var generatorOpts = source.generatorOpts;

          var _targetObj = target.generatorOpts = target.generatorOpts || {};

          mergeDefaultFields(_targetObj, generatorOpts);
        } else {
          var val = source[k];
          if (val !== undefined) target[k] = val;
        }
      }
    }

    function mergeDefaultFields(target, source) {
      for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {
        var k = _Object$keys2[_i2];
        var val = source[k];
        if (val !== undefined) target[k] = val;
      }
    }

    function isIterableIterator(value) {
      return !!value && typeof value.next === "function" && typeof value[Symbol.iterator] === "function";
    }

    var _marked$1 = regenerator.mark(genTrue),
        _marked2$1 = regenerator.mark(getCachedValue),
        _marked3$1 = regenerator.mark(getCachedValueOrWait);

    var synchronize = function synchronize(gen) {
      return gensync(gen).sync;
    };

    function genTrue(data) {
      return regenerator.wrap(function genTrue$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", true);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _marked$1);
    }

    function makeWeakCache(handler) {
      return makeCachedFunction(WeakMap, handler);
    }
    function makeWeakCacheSync(handler) {
      return synchronize(makeWeakCache(handler));
    }
    function makeStrongCache(handler) {
      return makeCachedFunction(Map, handler);
    }
    function makeStrongCacheSync(handler) {
      return synchronize(makeStrongCache(handler));
    }

    function makeCachedFunction(CallCache, handler) {
      var callCacheSync = new CallCache();
      var callCacheAsync = new CallCache();
      var futureCache = new CallCache();
      return regenerator.mark(function cachedFunction(arg, data) {
        var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;
        return regenerator.wrap(function cachedFunction$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.delegateYield(isAsync(), "t0", 1);

              case 1:
                asyncContext = _context2.t0;
                callCache = asyncContext ? callCacheAsync : callCacheSync;
                return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), "t1", 4);

              case 4:
                cached = _context2.t1;

                if (!cached.valid) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", cached.value);

              case 7:
                cache = new CacheConfigurator(data);
                handlerResult = handler(arg, cache);

                if (!isIterableIterator(handlerResult)) {
                  _context2.next = 15;
                  break;
                }

                gen = handlerResult;
                return _context2.delegateYield(onFirstPause(gen, function () {
                  finishLock = setupAsyncLocks(cache, futureCache, arg);
                }), "t2", 12);

              case 12:
                value = _context2.t2;
                _context2.next = 16;
                break;

              case 15:
                value = handlerResult;

              case 16:
                updateFunctionCache(callCache, cache, arg, value);

                if (finishLock) {
                  futureCache["delete"](arg);
                  finishLock.release(value);
                }

                return _context2.abrupt("return", value);

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, cachedFunction);
      });
    }

    function getCachedValue(cache, arg, data) {
      var cachedValue, _iterator, _step, _step$value, _value, valid;

      return regenerator.wrap(function getCachedValue$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              cachedValue = cache.get(arg);

              if (!cachedValue) {
                _context3.next = 10;
                break;
              }

              _iterator = _createForOfIteratorHelperLoose(cachedValue);

            case 3:
              if ((_step = _iterator()).done) {
                _context3.next = 10;
                break;
              }

              _step$value = _step.value, _value = _step$value.value, valid = _step$value.valid;
              return _context3.delegateYield(valid(data), "t0", 6);

            case 6:
              if (!_context3.t0) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", {
                valid: true,
                value: _value
              });

            case 8:
              _context3.next = 3;
              break;

            case 10:
              return _context3.abrupt("return", {
                valid: false,
                value: null
              });

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _marked2$1);
    }

    function getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
      var cached, _cached, _value2;

      return regenerator.wrap(function getCachedValueOrWait$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.delegateYield(getCachedValue(callCache, arg, data), "t0", 1);

            case 1:
              cached = _context4.t0;

              if (!cached.valid) {
                _context4.next = 4;
                break;
              }

              return _context4.abrupt("return", cached);

            case 4:
              if (!asyncContext) {
                _context4.next = 11;
                break;
              }

              return _context4.delegateYield(getCachedValue(futureCache, arg, data), "t1", 6);

            case 6:
              _cached = _context4.t1;

              if (!_cached.valid) {
                _context4.next = 11;
                break;
              }

              return _context4.delegateYield(waitFor(_cached.value.promise), "t2", 9);

            case 9:
              _value2 = _context4.t2;
              return _context4.abrupt("return", {
                valid: true,
                value: _value2
              });

            case 11:
              return _context4.abrupt("return", {
                valid: false,
                value: null
              });

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _marked3$1);
    }

    function setupAsyncLocks(config, futureCache, arg) {
      var finishLock = new Lock();
      updateFunctionCache(futureCache, config, arg, finishLock);
      return finishLock;
    }

    function updateFunctionCache(cache, config, arg, value) {
      if (!config.configured()) config.forever();
      var cachedValue = cache.get(arg);
      config.deactivate();

      switch (config.mode()) {
        case "forever":
          cachedValue = [{
            value: value,
            valid: genTrue
          }];
          cache.set(arg, cachedValue);
          break;

        case "invalidate":
          cachedValue = [{
            value: value,
            valid: config.validator()
          }];
          cache.set(arg, cachedValue);
          break;

        case "valid":
          if (cachedValue) {
            cachedValue.push({
              value: value,
              valid: config.validator()
            });
          } else {
            cachedValue = [{
              value: value,
              valid: config.validator()
            }];
            cache.set(arg, cachedValue);
          }

      }
    }

    var CacheConfigurator = function () {
      function CacheConfigurator(data) {
        this._active = true;
        this._never = false;
        this._forever = false;
        this._invalidate = false;
        this._configured = false;
        this._pairs = [];
        this._data = data;
      }

      var _proto = CacheConfigurator.prototype;

      _proto.simple = function simple() {
        return makeSimpleConfigurator(this);
      };

      _proto.mode = function mode() {
        if (this._never) return "never";
        if (this._forever) return "forever";
        if (this._invalidate) return "invalidate";
        return "valid";
      };

      _proto.forever = function forever() {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }

        if (this._never) {
          throw new Error("Caching has already been configured with .never()");
        }

        this._forever = true;
        this._configured = true;
      };

      _proto.never = function never() {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }

        if (this._forever) {
          throw new Error("Caching has already been configured with .forever()");
        }

        this._never = true;
        this._configured = true;
      };

      _proto.using = function using(handler) {
        var _this = this;

        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }

        if (this._never || this._forever) {
          throw new Error("Caching has already been configured with .never or .forever()");
        }

        this._configured = true;
        var key = handler(this._data);
        var fn = maybeAsync(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");

        if (isThenable(key)) {
          return key.then(function (key) {
            _this._pairs.push([key, fn]);

            return key;
          });
        }

        this._pairs.push([key, fn]);

        return key;
      };

      _proto.invalidate = function invalidate(handler) {
        this._invalidate = true;
        return this.using(handler);
      };

      _proto.validator = function validator() {
        var pairs = this._pairs;
        return regenerator.mark(function _callee(data) {
          var _iterator2, _step2, _step2$value, key, fn;

          return regenerator.wrap(function _callee$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _iterator2 = _createForOfIteratorHelperLoose(pairs);

                case 1:
                  if ((_step2 = _iterator2()).done) {
                    _context5.next = 10;
                    break;
                  }

                  _step2$value = _step2.value, key = _step2$value[0], fn = _step2$value[1];
                  _context5.t0 = key;
                  return _context5.delegateYield(fn(data), "t1", 5);

                case 5:
                  _context5.t2 = _context5.t1;

                  if (!(_context5.t0 !== _context5.t2)) {
                    _context5.next = 8;
                    break;
                  }

                  return _context5.abrupt("return", false);

                case 8:
                  _context5.next = 1;
                  break;

                case 10:
                  return _context5.abrupt("return", true);

                case 11:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee);
        });
      };

      _proto.deactivate = function deactivate() {
        this._active = false;
      };

      _proto.configured = function configured() {
        return this._configured;
      };

      return CacheConfigurator;
    }();

    function makeSimpleConfigurator(cache) {
      function cacheFn(val) {
        if (typeof val === "boolean") {
          if (val) cache.forever();else cache.never();
          return;
        }

        return cache.using(function () {
          return assertSimpleType(val());
        });
      }

      cacheFn.forever = function () {
        return cache.forever();
      };

      cacheFn.never = function () {
        return cache.never();
      };

      cacheFn.using = function (cb) {
        return cache.using(function () {
          return assertSimpleType(cb());
        });
      };

      cacheFn.invalidate = function (cb) {
        return cache.invalidate(function () {
          return assertSimpleType(cb());
        });
      };

      return cacheFn;
    }

    function assertSimpleType(value) {
      if (isThenable(value)) {
        throw new Error("You appear to be using an async cache handler, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously handle your caching logic.");
      }

      if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
        throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
      }

      return value;
    }

    var Lock = function () {
      function Lock() {
        var _this2 = this;

        this.released = false;
        this.promise = new Promise(function (resolve) {
          _this2._resolve = resolve;
        });
      }

      var _proto2 = Lock.prototype;

      _proto2.release = function release(value) {
        this.released = true;

        this._resolve(value);
      };

      return Lock;
    }();

    function isEqualDescriptor(a, b) {
      return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
    }

    function createCachedDescriptors(dirname, options, alias) {
      var plugins = options.plugins,
          presets = options.presets,
          passPerPreset = options.passPerPreset;
      return {
        options: options,
        plugins: plugins ? function () {
          return createCachedPluginDescriptors(plugins, dirname)(alias);
        } : function () {
          return [];
        },
        presets: presets ? function () {
          return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);
        } : function () {
          return [];
        }
      };
    }
    function createUncachedDescriptors(dirname, options, alias) {
      var _plugins;

      var _presets;

      return {
        options: options,
        plugins: function plugins() {
          if (!_plugins) {
            _plugins = createPluginDescriptors(options.plugins || [], dirname, alias);
          }

          return _plugins;
        },
        presets: function presets() {
          if (!_presets) {
            _presets = createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);
          }

          return _presets;
        }
      };
    }
    var PRESET_DESCRIPTOR_CACHE = new WeakMap();
    var createCachedPresetDescriptors = makeWeakCacheSync(function (items, cache) {
      var dirname = cache.using(function (dir) {
        return dir;
      });
      return makeStrongCacheSync(function (alias) {
        return makeStrongCacheSync(function (passPerPreset) {
          return createPresetDescriptors(items, dirname, alias, passPerPreset).map(function (desc) {
            return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
          });
        });
      });
    });
    var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
    var createCachedPluginDescriptors = makeWeakCacheSync(function (items, cache) {
      var dirname = cache.using(function (dir) {
        return dir;
      });
      return makeStrongCacheSync(function (alias) {
        return createPluginDescriptors(items, dirname, alias).map(function (desc) {
          return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
        });
      });
    });
    var DEFAULT_OPTIONS = {};

    function loadCachedDescriptor(cache, desc) {
      var value = desc.value,
          _desc$options = desc.options,
          options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
      if (options === false) return desc;
      var cacheByOptions = cache.get(value);

      if (!cacheByOptions) {
        cacheByOptions = new WeakMap();
        cache.set(value, cacheByOptions);
      }

      var possibilities = cacheByOptions.get(options);

      if (!possibilities) {
        possibilities = [];
        cacheByOptions.set(options, possibilities);
      }

      if (possibilities.indexOf(desc) === -1) {
        var matches = possibilities.filter(function (possibility) {
          return isEqualDescriptor(possibility, desc);
        });

        if (matches.length > 0) {
          return matches[0];
        }

        possibilities.push(desc);
      }

      return desc;
    }

    function createPresetDescriptors(items, dirname, alias, passPerPreset) {
      return createDescriptors("preset", items, dirname, alias, passPerPreset);
    }

    function createPluginDescriptors(items, dirname, alias) {
      return createDescriptors("plugin", items, dirname, alias);
    }

    function createDescriptors(type, items, dirname, alias, ownPass) {
      var descriptors = items.map(function (item, index) {
        return createDescriptor(item, dirname, {
          type: type,
          alias: alias + "$" + index,
          ownPass: !!ownPass
        });
      });
      assertNoDuplicates(descriptors);
      return descriptors;
    }

    function createDescriptor(pair, dirname, _ref) {
      var type = _ref.type,
          alias = _ref.alias,
          ownPass = _ref.ownPass;
      var desc = getItemDescriptor(pair);

      if (desc) {
        return desc;
      }

      var name;
      var options;
      var value = pair;

      if (Array.isArray(value)) {
        if (value.length === 3) {
          var _value = value;
          value = _value[0];
          options = _value[1];
          name = _value[2];
        } else {
          var _value2 = value;
          value = _value2[0];
          options = _value2[1];
        }
      }

      var file = undefined;
      var filepath = null;

      if (typeof value === "string") {
        if (typeof type !== "string") {
          throw new Error("To resolve a string-based item, the type of item must be given");
        }

        var resolver = type === "plugin" ? loadPlugin : loadPreset;
        var request = value;

        var _resolver = resolver(value, dirname);

        filepath = _resolver.filepath;
        value = _resolver.value;
        file = {
          request: request,
          resolved: filepath
        };
      }

      if (!value) {
        throw new Error("Unexpected falsy value: " + String(value));
      }

      if (typeof value === "object" && value.__esModule) {
        if (value["default"]) {
          value = value["default"];
        } else {
          throw new Error("Must export a default export when using ES6 modules.");
        }
      }

      if (typeof value !== "object" && typeof value !== "function") {
        throw new Error("Unsupported format: " + typeof value + ". Expected an object or a function.");
      }

      if (filepath !== null && typeof value === "object" && value) {
        throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In " + filepath);
      }

      return {
        name: name,
        alias: filepath || alias,
        value: value,
        options: options,
        dirname: dirname,
        ownPass: ownPass,
        file: file
      };
    }

    function assertNoDuplicates(items) {
      var map = new Map();

      var _loop = function _loop() {
        var item = _step.value;
        if (typeof item.value !== "function") return "continue";
        var nameMap = map.get(item.value);

        if (!nameMap) {
          nameMap = new Set();
          map.set(item.value, nameMap);
        }

        if (nameMap.has(item.name)) {
          var conflicts = items.filter(function (i) {
            return i.value === item.value;
          });
          throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", "" + JSON.stringify(conflicts, null, 2)].join("\n"));
        }

        nameMap.add(item.name);
      };

      for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    }

    function createItemFromDescriptor(desc) {
      return new ConfigItem(desc);
    }
    function createConfigItem(value, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$dirname = _ref.dirname,
          dirname = _ref$dirname === void 0 ? "." : _ref$dirname,
          type = _ref.type;

      var descriptor = createDescriptor(value, path$1.resolve(dirname), {
        type: type,
        alias: "programmatic item"
      });
      return createItemFromDescriptor(descriptor);
    }
    function getItemDescriptor(item) {
      if (item instanceof ConfigItem) {
        return item._descriptor;
      }

      return undefined;
    }

    var ConfigItem = function ConfigItem(descriptor) {
      this._descriptor = descriptor;
      Object.defineProperty(this, "_descriptor", {
        enumerable: false
      });
      this.value = this._descriptor.value;
      this.options = this._descriptor.options;
      this.dirname = this._descriptor.dirname;
      this.name = this._descriptor.name;
      this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : undefined;
      Object.freeze(this);
    };

    Object.freeze(ConfigItem.prototype);

    var Plugin = function Plugin(plugin, options, key) {
      this.key = plugin.name || key;
      this.manipulateOptions = plugin.manipulateOptions;
      this.post = plugin.post;
      this.pre = plugin.pre;
      this.visitor = plugin.visitor || {};
      this.parserOverride = plugin.parserOverride;
      this.generatorOverride = plugin.generatorOverride;
      this.options = options;
    };

    var s$1 = 1000;
    var m$1 = s$1 * 60;
    var h$1 = m$1 * 60;
    var d$1 = h$1 * 24;
    var w$1 = d$1 * 7;
    var y$1 = d$1 * 365.25;

    var ms$1 = function (val, options) {
      options = options || {};
      var type = typeof val;

      if (type === 'string' && val.length > 0) {
        return parse$2(val);
      } else if (type === 'number' && isFinite(val)) {
        return options["long"] ? fmtLong$1(val) : fmtShort$1(val);
      }

      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };

    function parse$2(str) {
      str = String(str);

      if (str.length > 100) {
        return;
      }

      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

      if (!match) {
        return;
      }

      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();

      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y$1;

        case 'weeks':
        case 'week':
        case 'w':
          return n * w$1;

        case 'days':
        case 'day':
        case 'd':
          return n * d$1;

        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h$1;

        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m$1;

        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s$1;

        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;

        default:
          return undefined;
      }
    }

    function fmtShort$1(ms) {
      var msAbs = Math.abs(ms);

      if (msAbs >= d$1) {
        return Math.round(ms / d$1) + 'd';
      }

      if (msAbs >= h$1) {
        return Math.round(ms / h$1) + 'h';
      }

      if (msAbs >= m$1) {
        return Math.round(ms / m$1) + 'm';
      }

      if (msAbs >= s$1) {
        return Math.round(ms / s$1) + 's';
      }

      return ms + 'ms';
    }

    function fmtLong$1(ms) {
      var msAbs = Math.abs(ms);

      if (msAbs >= d$1) {
        return plural$1(ms, msAbs, d$1, 'day');
      }

      if (msAbs >= h$1) {
        return plural$1(ms, msAbs, h$1, 'hour');
      }

      if (msAbs >= m$1) {
        return plural$1(ms, msAbs, m$1, 'minute');
      }

      if (msAbs >= s$1) {
        return plural$1(ms, msAbs, s$1, 'second');
      }

      return ms + ' ms';
    }

    function plural$1(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    function setup$2(env) {
      createDebug.debug = createDebug;
      createDebug["default"] = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms$1;
      Object.keys(env).forEach(function (key) {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};

      function selectColor(namespace) {
        var hash = 0;

        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }

      createDebug.selectColor = selectColor;

      function createDebug(namespace) {
        var prevTime;

        function debug() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (!debug.enabled) {
            return;
          }

          var self = debug;
          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== 'string') {
            args.unshift('%O');
          }

          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            if (match === '%%') {
              return match;
            }

            index++;
            var formatter = createDebug.formatters[format];

            if (typeof formatter === 'function') {
              var val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }

            return match;
          });
          createDebug.formatArgs.call(self, args);
          var logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;

        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }

        createDebug.instances.push(debug);
        return debug;
      }

      function destroy() {
        var index = createDebug.instances.indexOf(this);

        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }

        return false;
      }

      function extend(namespace, delimiter) {
        var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }

      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }

          namespaces = split[i].replace(/\*/g, '.*?');

          if (namespaces[0] === '-') {
            createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            createDebug.names.push(new RegExp('^' + namespaces + '$'));
          }
        }

        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }

      function disable() {
        var namespaces = [].concat(createDebug.names.map(toNamespace), createDebug.skips.map(toNamespace).map(function (namespace) {
          return '-' + namespace;
        })).join(',');
        createDebug.enable('');
        return namespaces;
      }

      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }

        var i;
        var len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }

      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
      }

      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }

        return val;
      }

      createDebug.enable(createDebug.load());
      return createDebug;
    }

    var common$1 = setup$2;

    var browser$4 = createCommonjsModule(function (module, exports) {
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    function useColors() {
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    function log() {
      var _console;

      return typeof console === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {}
    }

    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {}

      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }

    module.exports = common$1(exports);
    var formatters = module.exports.formatters;

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
    });
    var browser_1$1 = browser$4.log;
    var browser_2$1 = browser$4.formatArgs;
    var browser_3$1 = browser$4.save;
    var browser_4$1 = browser$4.load;
    var browser_5$1 = browser$4.useColors;
    var browser_6$1 = browser$4.storage;
    var browser_7$1 = browser$4.colors;

    var removed = {
      auxiliaryComment: {
        message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
      },
      blacklist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      breakConfig: {
        message: "This is not a necessary option in Babel 6"
      },
      experimental: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      externalHelpers: {
        message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
      },
      extra: {
        message: ""
      },
      jsxPragma: {
        message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
      },
      loose: {
        message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
      },
      metadataUsedHelpers: {
        message: "Not required anymore as this is enabled by default"
      },
      modules: {
        message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
      },
      nonStandard: {
        message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
      },
      optional: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      sourceMapName: {
        message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
      },
      stage: {
        message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
      },
      whitelist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      resolveModuleSource: {
        version: 6,
        message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
      },
      metadata: {
        version: 6,
        message: "Generated plugin metadata is always included in the output result"
      },
      sourceMapTarget: {
        version: 6,
        message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
      }
    };

    function msg(loc) {
      switch (loc.type) {
        case "root":
          return "";

        case "env":
          return msg(loc.parent) + ".env[\"" + loc.name + "\"]";

        case "overrides":
          return msg(loc.parent) + ".overrides[" + loc.index + "]";

        case "option":
          return msg(loc.parent) + "." + loc.name;

        case "access":
          return msg(loc.parent) + "[" + JSON.stringify(loc.name) + "]";

        default:
          throw new Error("Assertion failure: Unknown type " + loc.type);
      }
    }
    function access(loc, name) {
      return {
        type: "access",
        name: name,
        parent: loc
      };
    }
    function assertRootMode(loc, value) {
      if (value !== undefined && value !== "root" && value !== "upward" && value !== "upward-optional") {
        throw new Error(msg(loc) + " must be a \"root\", \"upward\", \"upward-optional\" or undefined");
      }

      return value;
    }
    function assertSourceMaps(loc, value) {
      if (value !== undefined && typeof value !== "boolean" && value !== "inline" && value !== "both") {
        throw new Error(msg(loc) + " must be a boolean, \"inline\", \"both\", or undefined");
      }

      return value;
    }
    function assertCompact(loc, value) {
      if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
        throw new Error(msg(loc) + " must be a boolean, \"auto\", or undefined");
      }

      return value;
    }
    function assertSourceType(loc, value) {
      if (value !== undefined && value !== "module" && value !== "script" && value !== "unambiguous") {
        throw new Error(msg(loc) + " must be \"module\", \"script\", \"unambiguous\", or undefined");
      }

      return value;
    }
    function assertCallerMetadata(loc, value) {
      var obj = assertObject(loc, value);

      if (obj) {
        if (typeof obj["name"] !== "string") {
          throw new Error(msg(loc) + " set but does not contain \"name\" property string");
        }

        for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
          var prop = _Object$keys[_i];
          var propLoc = access(loc, prop);
          var _value = obj[prop];

          if (_value != null && typeof _value !== "boolean" && typeof _value !== "string" && typeof _value !== "number") {
            throw new Error(msg(propLoc) + " must be null, undefined, a boolean, a string, or a number.");
          }
        }
      }

      return value;
    }
    function assertInputSourceMap(loc, value) {
      if (value !== undefined && typeof value !== "boolean" && (typeof value !== "object" || !value)) {
        throw new Error(msg(loc) + " must be a boolean, object, or undefined");
      }

      return value;
    }
    function assertString(loc, value) {
      if (value !== undefined && typeof value !== "string") {
        throw new Error(msg(loc) + " must be a string, or undefined");
      }

      return value;
    }
    function assertFunction$1(loc, value) {
      if (value !== undefined && typeof value !== "function") {
        throw new Error(msg(loc) + " must be a function, or undefined");
      }

      return value;
    }
    function assertBoolean(loc, value) {
      if (value !== undefined && typeof value !== "boolean") {
        throw new Error(msg(loc) + " must be a boolean, or undefined");
      }

      return value;
    }
    function assertObject(loc, value) {
      if (value !== undefined && (typeof value !== "object" || Array.isArray(value) || !value)) {
        throw new Error(msg(loc) + " must be an object, or undefined");
      }

      return value;
    }
    function assertArray(loc, value) {
      if (value != null && !Array.isArray(value)) {
        throw new Error(msg(loc) + " must be an array, or undefined");
      }

      return value;
    }
    function assertIgnoreList(loc, value) {
      var arr = assertArray(loc, value);

      if (arr) {
        arr.forEach(function (item, i) {
          return assertIgnoreItem(access(loc, i), item);
        });
      }

      return arr;
    }

    function assertIgnoreItem(loc, value) {
      if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
        throw new Error(msg(loc) + " must be an array of string/Function/RegExp values, or undefined");
      }

      return value;
    }

    function assertConfigApplicableTest(loc, value) {
      if (value === undefined) return value;

      if (Array.isArray(value)) {
        value.forEach(function (item, i) {
          if (!checkValidTest(item)) {
            throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
          }
        });
      } else if (!checkValidTest(value)) {
        throw new Error(msg(loc) + " must be a string/Function/RegExp, or an array of those");
      }

      return value;
    }

    function checkValidTest(value) {
      return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
    }

    function assertConfigFileSearch(loc, value) {
      if (value !== undefined && typeof value !== "boolean" && typeof value !== "string") {
        throw new Error(msg(loc) + " must be a undefined, a boolean, a string, " + ("got " + JSON.stringify(value)));
      }

      return value;
    }
    function assertBabelrcSearch(loc, value) {
      if (value === undefined || typeof value === "boolean") return value;

      if (Array.isArray(value)) {
        value.forEach(function (item, i) {
          if (!checkValidTest(item)) {
            throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
          }
        });
      } else if (!checkValidTest(value)) {
        throw new Error(msg(loc) + " must be a undefined, a boolean, a string/Function/RegExp " + ("or an array of those, got " + JSON.stringify(value)));
      }

      return value;
    }
    function assertPluginList(loc, value) {
      var arr = assertArray(loc, value);

      if (arr) {
        arr.forEach(function (item, i) {
          return assertPluginItem(access(loc, i), item);
        });
      }

      return arr;
    }

    function assertPluginItem(loc, value) {
      if (Array.isArray(value)) {
        if (value.length === 0) {
          throw new Error(msg(loc) + " must include an object");
        }

        if (value.length > 3) {
          throw new Error(msg(loc) + " may only be a two-tuple or three-tuple");
        }

        assertPluginTarget(access(loc, 0), value[0]);

        if (value.length > 1) {
          var opts = value[1];

          if (opts !== undefined && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
            throw new Error(msg(access(loc, 1)) + " must be an object, false, or undefined");
          }
        }

        if (value.length === 3) {
          var name = value[2];

          if (name !== undefined && typeof name !== "string") {
            throw new Error(msg(access(loc, 2)) + " must be a string, or undefined");
          }
        }
      } else {
        assertPluginTarget(loc, value);
      }

      return value;
    }

    function assertPluginTarget(loc, value) {
      if ((typeof value !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
        throw new Error(msg(loc) + " must be a string, object, function");
      }

      return value;
    }

    var ROOT_VALIDATORS = {
      cwd: assertString,
      root: assertString,
      rootMode: assertRootMode,
      configFile: assertConfigFileSearch,
      caller: assertCallerMetadata,
      filename: assertString,
      filenameRelative: assertString,
      code: assertBoolean,
      ast: assertBoolean,
      envName: assertString
    };
    var BABELRC_VALIDATORS = {
      babelrc: assertBoolean,
      babelrcRoots: assertBabelrcSearch
    };
    var NONPRESET_VALIDATORS = {
      "extends": assertString,
      ignore: assertIgnoreList,
      only: assertIgnoreList
    };
    var COMMON_VALIDATORS = {
      inputSourceMap: assertInputSourceMap,
      presets: assertPluginList,
      plugins: assertPluginList,
      passPerPreset: assertBoolean,
      env: assertEnvSet,
      overrides: assertOverridesList,
      test: assertConfigApplicableTest,
      include: assertConfigApplicableTest,
      exclude: assertConfigApplicableTest,
      retainLines: assertBoolean,
      comments: assertBoolean,
      shouldPrintComment: assertFunction$1,
      compact: assertCompact,
      minified: assertBoolean,
      auxiliaryCommentBefore: assertString,
      auxiliaryCommentAfter: assertString,
      sourceType: assertSourceType,
      wrapPluginVisitorMethod: assertFunction$1,
      highlightCode: assertBoolean,
      sourceMaps: assertSourceMaps,
      sourceMap: assertSourceMaps,
      sourceFileName: assertString,
      sourceRoot: assertString,
      getModuleId: assertFunction$1,
      moduleRoot: assertString,
      moduleIds: assertBoolean,
      moduleId: assertString,
      parserOpts: assertObject,
      generatorOpts: assertObject
    };

    function getSource$1(loc) {
      return loc.type === "root" ? loc.source : getSource$1(loc.parent);
    }

    function validate$3(type, opts) {
      return validateNested({
        type: "root",
        source: type
      }, opts);
    }

    function validateNested(loc, opts) {
      var type = getSource$1(loc);
      assertNoDuplicateSourcemap(opts);
      Object.keys(opts).forEach(function (key) {
        var optLoc = {
          type: "option",
          name: key,
          parent: loc
        };

        if (type === "preset" && NONPRESET_VALIDATORS[key]) {
          throw new Error(msg(optLoc) + " is not allowed in preset options");
        }

        if (type !== "arguments" && ROOT_VALIDATORS[key]) {
          throw new Error(msg(optLoc) + " is only allowed in root programmatic options");
        }

        if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
          if (type === "babelrcfile" || type === "extendsfile") {
            throw new Error(msg(optLoc) + " is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, " + "or babel.config.js/config file options");
          }

          throw new Error(msg(optLoc) + " is only allowed in root programmatic options, or babel.config.js/config file options");
        }

        var validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
        validator(optLoc, opts[key]);
      });
      return opts;
    }

    function throwUnknownError(loc) {
      var key = loc.name;

      if (removed[key]) {
        var _removed$key = removed[key],
            message = _removed$key.message,
            _removed$key$version = _removed$key.version,
            version = _removed$key$version === void 0 ? 5 : _removed$key$version;
        throw new Error("Using removed Babel " + version + " option: " + msg(loc) + " - " + message);
      } else {
        var unknownOptErr = new Error("Unknown option: " + msg(loc) + ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.");
        unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
        throw unknownOptErr;
      }
    }

    function has$3(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    function assertNoDuplicateSourcemap(opts) {
      if (has$3(opts, "sourceMap") && has$3(opts, "sourceMaps")) {
        throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
      }
    }

    function assertEnvSet(loc, value) {
      if (loc.parent.type === "env") {
        throw new Error(msg(loc) + " is not allowed inside of another .env block");
      }

      var parent = loc.parent;
      var obj = assertObject(loc, value);

      if (obj) {
        for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
          var envName = _Object$keys[_i];
          var env = assertObject(access(loc, envName), obj[envName]);
          if (!env) continue;
          var envLoc = {
            type: "env",
            name: envName,
            parent: parent
          };
          validateNested(envLoc, env);
        }
      }

      return obj;
    }

    function assertOverridesList(loc, value) {
      if (loc.parent.type === "env") {
        throw new Error(msg(loc) + " is not allowed inside an .env block");
      }

      if (loc.parent.type === "overrides") {
        throw new Error(msg(loc) + " is not allowed inside an .overrides block");
      }

      var parent = loc.parent;
      var arr = assertArray(loc, value);

      if (arr) {
        for (var _iterator = _createForOfIteratorHelperLoose(arr.entries()), _step; !(_step = _iterator()).done;) {
          var _step$value = _step.value,
              index = _step$value[0],
              item = _step$value[1];
          var objLoc = access(loc, index);
          var env = assertObject(objLoc, item);
          if (!env) throw new Error(msg(objLoc) + " must be an object");
          var overridesLoc = {
            type: "overrides",
            index: index,
            parent: parent
          };
          validateNested(overridesLoc, env);
        }
      }

      return arr;
    }

    function checkNoUnwrappedItemOptionPairs(lastItem, thisItem, type, index, e) {
      if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === "object") {
        e.message += "\n- Maybe you meant to use\n" + ("\"" + type + "\": [\n  [\"" + lastItem.file.request + "\", " + JSON.stringify(thisItem.value, undefined, 2) + "]\n]\n") + ("To be a valid " + type + ", its name and options should be wrapped in a pair of brackets");
      }
    }

    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar$1.source);

    function escapeRegExp(string) {
      string = toString_1(string);
      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar$1, '\\$&') : string;
    }

    var escapeRegExp_1 = escapeRegExp;

    var sep$1 = "\\" + path$1.sep;
    var endSep = "(?:" + sep$1 + "|$)";
    var substitution = "[^" + sep$1 + "]+";
    var starPat = "(?:" + substitution + sep$1 + ")";
    var starPatLast = "(?:" + substitution + endSep + ")";
    var starStarPat = starPat + "*?";
    var starStarPatLast = starPat + "*?" + starPatLast + "?";
    function pathToPattern(pattern, dirname) {
      var parts = path$1.resolve(dirname, pattern).split(path$1.sep);
      return new RegExp(["^"].concat(parts.map(function (part, i) {
        var last = i === parts.length - 1;
        if (part === "**") return last ? starStarPatLast : starStarPat;
        if (part === "*") return last ? starPatLast : starPat;

        if (part.indexOf("*.") === 0) {
          return substitution + escapeRegExp_1(part.slice(1)) + (last ? endSep : sep$1);
        }

        return escapeRegExp_1(part) + (last ? endSep : sep$1);
      })).join(""));
    }

    var _marked$2 = regenerator.mark(buildPresetChain),
        _marked2$2 = regenerator.mark(buildRootChain),
        _marked3$2 = regenerator.mark(mergeExtendsChain);
    var debug = browser$4("babel:config:config-chain");
    function buildPresetChain(arg, context) {
      var chain;
      return regenerator.wrap(function buildPresetChain$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(buildPresetChainWalker(arg, context), "t0", 1);

            case 1:
              chain = _context.t0;

              if (chain) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", null);

            case 4:
              return _context.abrupt("return", {
                plugins: dedupDescriptors(chain.plugins),
                presets: dedupDescriptors(chain.presets),
                options: chain.options.map(function (o) {
                  return normalizeOptions$1(o);
                })
              });

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _marked$2);
    }
    var buildPresetChainWalker = makeChainWalker({
      init: function init(arg) {
        return arg;
      },
      root: function root(preset) {
        return loadPresetDescriptors(preset);
      },
      env: function env(preset, envName) {
        return loadPresetEnvDescriptors(preset)(envName);
      },
      overrides: function overrides(preset, index) {
        return loadPresetOverridesDescriptors(preset)(index);
      },
      overridesEnv: function overridesEnv(preset, index, envName) {
        return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
      }
    });
    var loadPresetDescriptors = makeWeakCacheSync(function (preset) {
      return buildRootDescriptors(preset, preset.alias, createUncachedDescriptors);
    });
    var loadPresetEnvDescriptors = makeWeakCacheSync(function (preset) {
      return makeStrongCacheSync(function (envName) {
        return buildEnvDescriptors(preset, preset.alias, createUncachedDescriptors, envName);
      });
    });
    var loadPresetOverridesDescriptors = makeWeakCacheSync(function (preset) {
      return makeStrongCacheSync(function (index) {
        return buildOverrideDescriptors(preset, preset.alias, createUncachedDescriptors, index);
      });
    });
    var loadPresetOverridesEnvDescriptors = makeWeakCacheSync(function (preset) {
      return makeStrongCacheSync(function (index) {
        return makeStrongCacheSync(function (envName) {
          return buildOverrideEnvDescriptors(preset, preset.alias, createUncachedDescriptors, index, envName);
        });
      });
    });
    function buildRootChain(opts, context) {
      var programmaticChain, configFile, babelrc, babelrcRoots, babelrcRootsDirectory, configFileChain, validatedFile, result, pkgData, ignoreFile, babelrcFile, fileChain, _yield$findRelativeCo, _result, chain;

      return regenerator.wrap(function buildRootChain$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(loadProgrammaticChain({
                options: opts,
                dirname: context.cwd
              }, context), "t0", 1);

            case 1:
              programmaticChain = _context2.t0;

              if (programmaticChain) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", null);

            case 4:
              if (!(typeof opts.configFile === "string")) {
                _context2.next = 9;
                break;
              }

              return _context2.delegateYield(loadConfig(opts.configFile, context.cwd, context.envName, context.caller), "t1", 6);

            case 6:
              configFile = _context2.t1;
              _context2.next = 12;
              break;

            case 9:
              if (!(opts.configFile !== false)) {
                _context2.next = 12;
                break;
              }

              return _context2.delegateYield(findRootConfig(context.root, context.envName, context.caller), "t2", 11);

            case 11:
              configFile = _context2.t2;

            case 12:
              babelrc = opts.babelrc, babelrcRoots = opts.babelrcRoots;
              babelrcRootsDirectory = context.cwd;
              configFileChain = emptyChain();

              if (!configFile) {
                _context2.next = 24;
                break;
              }

              validatedFile = validateConfigFile(configFile);
              return _context2.delegateYield(loadFileChain(validatedFile, context), "t3", 18);

            case 18:
              result = _context2.t3;

              if (result) {
                _context2.next = 21;
                break;
              }

              return _context2.abrupt("return", null);

            case 21:
              if (babelrc === undefined) {
                babelrc = validatedFile.options.babelrc;
              }

              if (babelrcRoots === undefined) {
                babelrcRootsDirectory = validatedFile.dirname;
                babelrcRoots = validatedFile.options.babelrcRoots;
              }

              mergeChain(configFileChain, result);

            case 24:
              if (!(typeof context.filename === "string")) {
                _context2.next = 29;
                break;
              }

              return _context2.delegateYield(findPackageData(context.filename), "t5", 26);

            case 26:
              _context2.t4 = _context2.t5;
              _context2.next = 30;
              break;

            case 29:
              _context2.t4 = null;

            case 30:
              pkgData = _context2.t4;
              fileChain = emptyChain();

              if (!((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory))) {
                _context2.next = 45;
                break;
              }

              return _context2.delegateYield(findRelativeConfig(pkgData, context.envName, context.caller), "t6", 34);

            case 34:
              _yield$findRelativeCo = _context2.t6;
              ignoreFile = _yield$findRelativeCo.ignore;
              babelrcFile = _yield$findRelativeCo.config;

              if (!(ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname))) {
                _context2.next = 39;
                break;
              }

              return _context2.abrupt("return", null);

            case 39:
              if (!babelrcFile) {
                _context2.next = 45;
                break;
              }

              return _context2.delegateYield(loadFileChain(validateBabelrcFile(babelrcFile), context), "t7", 41);

            case 41:
              _result = _context2.t7;

              if (_result) {
                _context2.next = 44;
                break;
              }

              return _context2.abrupt("return", null);

            case 44:
              mergeChain(fileChain, _result);

            case 45:
              chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
              return _context2.abrupt("return", {
                plugins: dedupDescriptors(chain.plugins),
                presets: dedupDescriptors(chain.presets),
                options: chain.options.map(function (o) {
                  return normalizeOptions$1(o);
                }),
                ignore: ignoreFile || undefined,
                babelrc: babelrcFile || undefined,
                config: configFile || undefined
              });

            case 47:
            case "end":
              return _context2.stop();
          }
        }
      }, _marked2$2);
    }

    function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
      if (typeof babelrcRoots === "boolean") return babelrcRoots;
      var absoluteRoot = context.root;

      if (babelrcRoots === undefined) {
        return pkgData.directories.indexOf(absoluteRoot) !== -1;
      }

      var babelrcPatterns = babelrcRoots;
      if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];
      babelrcPatterns = babelrcPatterns.map(function (pat) {
        return typeof pat === "string" ? path$1.resolve(babelrcRootsDirectory, pat) : pat;
      });

      if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
        return pkgData.directories.indexOf(absoluteRoot) !== -1;
      }

      return babelrcPatterns.some(function (pat) {
        if (typeof pat === "string") {
          pat = pathToPattern(pat, babelrcRootsDirectory);
        }

        return pkgData.directories.some(function (directory) {
          return matchPattern(pat, babelrcRootsDirectory, directory, context);
        });
      });
    }

    var validateConfigFile = makeWeakCacheSync(function (file) {
      return {
        filepath: file.filepath,
        dirname: file.dirname,
        options: validate$3("configfile", file.options)
      };
    });
    var validateBabelrcFile = makeWeakCacheSync(function (file) {
      return {
        filepath: file.filepath,
        dirname: file.dirname,
        options: validate$3("babelrcfile", file.options)
      };
    });
    var validateExtendFile = makeWeakCacheSync(function (file) {
      return {
        filepath: file.filepath,
        dirname: file.dirname,
        options: validate$3("extendsfile", file.options)
      };
    });
    var loadProgrammaticChain = makeChainWalker({
      root: function root(input) {
        return buildRootDescriptors(input, "base", createCachedDescriptors);
      },
      env: function env(input, envName) {
        return buildEnvDescriptors(input, "base", createCachedDescriptors, envName);
      },
      overrides: function overrides(input, index) {
        return buildOverrideDescriptors(input, "base", createCachedDescriptors, index);
      },
      overridesEnv: function overridesEnv(input, index, envName) {
        return buildOverrideEnvDescriptors(input, "base", createCachedDescriptors, index, envName);
      }
    });
    var loadFileChain = makeChainWalker({
      root: function root(file) {
        return loadFileDescriptors(file);
      },
      env: function env(file, envName) {
        return loadFileEnvDescriptors(file)(envName);
      },
      overrides: function overrides(file, index) {
        return loadFileOverridesDescriptors(file)(index);
      },
      overridesEnv: function overridesEnv(file, index, envName) {
        return loadFileOverridesEnvDescriptors(file)(index)(envName);
      }
    });
    var loadFileDescriptors = makeWeakCacheSync(function (file) {
      return buildRootDescriptors(file, file.filepath, createUncachedDescriptors);
    });
    var loadFileEnvDescriptors = makeWeakCacheSync(function (file) {
      return makeStrongCacheSync(function (envName) {
        return buildEnvDescriptors(file, file.filepath, createUncachedDescriptors, envName);
      });
    });
    var loadFileOverridesDescriptors = makeWeakCacheSync(function (file) {
      return makeStrongCacheSync(function (index) {
        return buildOverrideDescriptors(file, file.filepath, createUncachedDescriptors, index);
      });
    });
    var loadFileOverridesEnvDescriptors = makeWeakCacheSync(function (file) {
      return makeStrongCacheSync(function (index) {
        return makeStrongCacheSync(function (envName) {
          return buildOverrideEnvDescriptors(file, file.filepath, createUncachedDescriptors, index, envName);
        });
      });
    });

    function buildRootDescriptors(_ref, alias, descriptors) {
      var dirname = _ref.dirname,
          options = _ref.options;
      return descriptors(dirname, options, alias);
    }

    function buildEnvDescriptors(_ref2, alias, descriptors, envName) {
      var dirname = _ref2.dirname,
          options = _ref2.options;
      var opts = options.env && options.env[envName];
      return opts ? descriptors(dirname, opts, alias + ".env[\"" + envName + "\"]") : null;
    }

    function buildOverrideDescriptors(_ref3, alias, descriptors, index) {
      var dirname = _ref3.dirname,
          options = _ref3.options;
      var opts = options.overrides && options.overrides[index];
      if (!opts) throw new Error("Assertion failure - missing override");
      return descriptors(dirname, opts, alias + ".overrides[" + index + "]");
    }

    function buildOverrideEnvDescriptors(_ref4, alias, descriptors, index, envName) {
      var dirname = _ref4.dirname,
          options = _ref4.options;
      var override = options.overrides && options.overrides[index];
      if (!override) throw new Error("Assertion failure - missing override");
      var opts = override.env && override.env[envName];
      return opts ? descriptors(dirname, opts, alias + ".overrides[" + index + "].env[\"" + envName + "\"]") : null;
    }

    function makeChainWalker(_ref5) {
      var root = _ref5.root,
          env = _ref5.env,
          overrides = _ref5.overrides,
          overridesEnv = _ref5.overridesEnv;
      return regenerator.mark(function _callee(input, context, files) {
        var dirname, flattenedConfigs, rootOpts, envOpts, chain, _i, _flattenedConfigs, op;

        return regenerator.wrap(function _callee$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (files === void 0) {
                  files = new Set();
                }

                dirname = input.dirname;
                flattenedConfigs = [];
                rootOpts = root(input);

                if (configIsApplicable(rootOpts, dirname, context)) {
                  flattenedConfigs.push(rootOpts);
                  envOpts = env(input, context.envName);

                  if (envOpts && configIsApplicable(envOpts, dirname, context)) {
                    flattenedConfigs.push(envOpts);
                  }

                  (rootOpts.options.overrides || []).forEach(function (_, index) {
                    var overrideOps = overrides(input, index);

                    if (configIsApplicable(overrideOps, dirname, context)) {
                      flattenedConfigs.push(overrideOps);
                      var overrideEnvOpts = overridesEnv(input, index, context.envName);

                      if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
                        flattenedConfigs.push(overrideEnvOpts);
                      }
                    }
                  });
                }

                if (!flattenedConfigs.some(function (_ref6) {
                  var _ref6$options = _ref6.options,
                      ignore = _ref6$options.ignore,
                      only = _ref6$options.only;
                  return shouldIgnore(context, ignore, only, dirname);
                })) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return", null);

              case 7:
                chain = emptyChain();
                _i = 0, _flattenedConfigs = flattenedConfigs;

              case 9:
                if (!(_i < _flattenedConfigs.length)) {
                  _context3.next = 18;
                  break;
                }

                op = _flattenedConfigs[_i];
                return _context3.delegateYield(mergeExtendsChain(chain, op.options, dirname, context, files), "t0", 12);

              case 12:
                if (_context3.t0) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", null);

              case 14:
                mergeChainOpts(chain, op);

              case 15:
                _i++;
                _context3.next = 9;
                break;

              case 18:
                return _context3.abrupt("return", chain);

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee);
      });
    }

    function mergeExtendsChain(chain, opts, dirname, context, files) {
      var file, fileChain;
      return regenerator.wrap(function mergeExtendsChain$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(opts["extends"] === undefined)) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return", true);

            case 2:
              return _context4.delegateYield(loadConfig(opts["extends"], dirname, context.envName, context.caller), "t0", 3);

            case 3:
              file = _context4.t0;

              if (!files.has(file)) {
                _context4.next = 6;
                break;
              }

              throw new Error("Configuration cycle detected loading " + file.filepath + ".\n" + "File already loaded following the config chain:\n" + Array.from(files, function (file) {
                return " - " + file.filepath;
              }).join("\n"));

            case 6:
              files.add(file);
              return _context4.delegateYield(loadFileChain(validateExtendFile(file), context, files), "t1", 8);

            case 8:
              fileChain = _context4.t1;
              files["delete"](file);

              if (fileChain) {
                _context4.next = 12;
                break;
              }

              return _context4.abrupt("return", false);

            case 12:
              mergeChain(chain, fileChain);
              return _context4.abrupt("return", true);

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _marked3$2);
    }

    function mergeChain(target, source) {
      var _target$options, _target$plugins, _target$presets;

      (_target$options = target.options).push.apply(_target$options, source.options);

      (_target$plugins = target.plugins).push.apply(_target$plugins, source.plugins);

      (_target$presets = target.presets).push.apply(_target$presets, source.presets);

      return target;
    }

    function mergeChainOpts(target, _ref7) {
      var _target$plugins2, _target$presets2;

      var options = _ref7.options,
          plugins = _ref7.plugins,
          presets = _ref7.presets;
      target.options.push(options);

      (_target$plugins2 = target.plugins).push.apply(_target$plugins2, plugins());

      (_target$presets2 = target.presets).push.apply(_target$presets2, presets());

      return target;
    }

    function emptyChain() {
      return {
        options: [],
        presets: [],
        plugins: []
      };
    }

    function normalizeOptions$1(opts) {
      var options = Object.assign({}, opts);
      delete options["extends"];
      delete options.env;
      delete options.overrides;
      delete options.plugins;
      delete options.presets;
      delete options.passPerPreset;
      delete options.ignore;
      delete options.only;
      delete options.test;
      delete options.include;
      delete options.exclude;

      if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
        options.sourceMaps = options.sourceMap;
        delete options.sourceMap;
      }

      return options;
    }

    function dedupDescriptors(items) {
      var map = new Map();
      var descriptors = [];

      for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
        var item = _step.value;

        if (typeof item.value === "function") {
          var fnKey = item.value;
          var nameMap = map.get(fnKey);

          if (!nameMap) {
            nameMap = new Map();
            map.set(fnKey, nameMap);
          }

          var desc = nameMap.get(item.name);

          if (!desc) {
            desc = {
              value: item
            };
            descriptors.push(desc);
            if (!item.ownPass) nameMap.set(item.name, desc);
          } else {
            desc.value = item;
          }
        } else {
          descriptors.push({
            value: item
          });
        }
      }

      return descriptors.reduce(function (acc, desc) {
        acc.push(desc.value);
        return acc;
      }, []);
    }

    function configIsApplicable(_ref8, dirname, context) {
      var options = _ref8.options;
      return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));
    }

    function configFieldIsApplicable(context, test, dirname) {
      var patterns = Array.isArray(test) ? test : [test];
      return matchesPatterns(context, patterns, dirname);
    }

    function shouldIgnore(context, ignore, only, dirname) {
      if (ignore && matchesPatterns(context, ignore, dirname)) {
        debug("Ignored %o because it matched one of %O from %o", context.filename, ignore, dirname);
        return true;
      }

      if (only && !matchesPatterns(context, only, dirname)) {
        debug("Ignored %o because it failed to match one of %O from %o", context.filename, only, dirname);
        return true;
      }

      return false;
    }

    function matchesPatterns(context, patterns, dirname) {
      return patterns.some(function (pattern) {
        return matchPattern(pattern, dirname, context.filename, context);
      });
    }

    function matchPattern(pattern, dirname, pathToTest, context) {
      if (typeof pattern === "function") {
        return !!pattern(pathToTest, {
          dirname: dirname,
          envName: context.envName,
          caller: context.caller
        });
      }

      if (typeof pathToTest !== "string") {
        throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
      }

      if (typeof pattern === "string") {
        pattern = pathToPattern(pattern, dirname);
      }

      return pattern.test(pathToTest);
    }

    var VALIDATORS = {
      name: assertString,
      manipulateOptions: assertFunction$1,
      pre: assertFunction$1,
      post: assertFunction$1,
      inherits: assertFunction$1,
      visitor: assertVisitorMap,
      parserOverride: assertFunction$1,
      generatorOverride: assertFunction$1
    };

    function assertVisitorMap(key, value) {
      var obj = assertObject(key, value);

      if (obj) {
        Object.keys(obj).forEach(function (prop) {
          return assertVisitorHandler(prop, obj[prop]);
        });

        if (obj.enter || obj.exit) {
          throw new Error("." + key + " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.");
        }
      }

      return obj;
    }

    function assertVisitorHandler(key, value) {
      if (value && typeof value === "object") {
        Object.keys(value).forEach(function (handler) {
          if (handler !== "enter" && handler !== "exit") {
            throw new Error(".visitor[\"" + key + "\"] may only have .enter and/or .exit handlers.");
          }
        });
      } else if (typeof value !== "function") {
        throw new Error(".visitor[\"" + key + "\"] must be a function");
      }

      return value;
    }

    function validatePluginObject(obj) {
      var rootPath = {
        type: "root",
        source: "plugin"
      };
      Object.keys(obj).forEach(function (key) {
        var validator = VALIDATORS[key];
        var optLoc = {
          type: "option",
          name: key,
          parent: rootPath
        };
        if (validator) validator(optLoc, obj[key]);else {
          var invalidPluginPropertyError = new Error("." + key + " is not a valid Plugin property");
          invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
          throw invalidPluginPropertyError;
        }
      });
      return obj;
    }

    function makeAPI(cache) {
      var env = function env(value) {
        return cache.using(function (data) {
          if (typeof value === "undefined") return data.envName;

          if (typeof value === "function") {
            return assertSimpleType(value(data.envName));
          }

          if (!Array.isArray(value)) value = [value];
          return value.some(function (entry) {
            if (typeof entry !== "string") {
              throw new Error("Unexpected non-string value");
            }

            return entry === data.envName;
          });
        });
      };

      var caller = function caller(cb) {
        return cache.using(function (data) {
          return assertSimpleType(cb(data.caller));
        });
      };

      return {
        version: version$1,
        cache: cache.simple(),
        env: env,
        async: function async() {
          return false;
        },
        caller: caller,
        assertVersion: assertVersion,
        tokTypes: undefined
      };
    }

    function assertVersion(range) {
      if (typeof range === "number") {
        if (!Number.isInteger(range)) {
          throw new Error("Expected string or integer value.");
        }

        range = "^" + range + ".0.0-0";
      }

      if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
      }

      if (semver.satisfies(version$1, range)) return;
      var limit = Error.stackTraceLimit;

      if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
      }

      var err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version$1 + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");

      if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
      }

      throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version: version$1,
        range: range
      });
    }

    var _marked$3 = regenerator.mark(resolveRootMode),
        _marked2$3 = regenerator.mark(loadPrivatePartialConfig);

    function resolveRootMode(rootDir, rootMode) {
      var upwardRootDir, _upwardRootDir;

      return regenerator.wrap(function resolveRootMode$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = rootMode;
              _context.next = _context.t0 === "root" ? 3 : _context.t0 === "upward-optional" ? 4 : _context.t0 === "upward" ? 7 : 12;
              break;

            case 3:
              return _context.abrupt("return", rootDir);

            case 4:
              return _context.delegateYield(findConfigUpwards(), "t1", 5);

            case 5:
              upwardRootDir = _context.t1;
              return _context.abrupt("return", upwardRootDir === null ? rootDir : upwardRootDir);

            case 7:
              return _context.delegateYield(findConfigUpwards(), "t2", 8);

            case 8:
              _upwardRootDir = _context.t2;

              if (!(_upwardRootDir !== null)) {
                _context.next = 11;
                break;
              }

              return _context.abrupt("return", _upwardRootDir);

            case 11:
              throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + ("be found when searching upward from \"" + rootDir + "\".\n") + "One of the following config files must be in the directory tree: " + ("\"" + ROOT_CONFIG_FILENAMES.join(", ") + "\".")), {
                code: "BABEL_ROOT_NOT_FOUND",
                dirname: rootDir
              });

            case 12:
              throw new Error("Assertion failure - unknown rootMode value.");

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _marked$3);
    }

    function loadPrivatePartialConfig(inputOpts) {
      var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, absoluteCwd, absoluteRootDir, context, configChain, options;

      return regenerator.wrap(function loadPrivatePartialConfig$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts)))) {
                _context2.next = 2;
                break;
              }

              throw new Error("Babel options must be an object, null, or undefined");

            case 2:
              args = inputOpts ? validate$3("arguments", inputOpts) : {};
              _args$envName = args.envName, envName = _args$envName === void 0 ? getEnv() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller;
              absoluteCwd = path$1.resolve(cwd);
              return _context2.delegateYield(resolveRootMode(path$1.resolve(absoluteCwd, rootDir), rootMode), "t0", 6);

            case 6:
              absoluteRootDir = _context2.t0;
              context = {
                filename: typeof args.filename === "string" ? path$1.resolve(cwd, args.filename) : undefined,
                cwd: absoluteCwd,
                root: absoluteRootDir,
                envName: envName,
                caller: caller
              };
              return _context2.delegateYield(buildRootChain(args, context), "t1", 9);

            case 9:
              configChain = _context2.t1;

              if (configChain) {
                _context2.next = 12;
                break;
              }

              return _context2.abrupt("return", null);

            case 12:
              options = {};
              configChain.options.forEach(function (opts) {
                mergeOptions(options, opts);
              });
              options.babelrc = false;
              options.configFile = false;
              options.passPerPreset = false;
              options.envName = context.envName;
              options.cwd = context.cwd;
              options.root = context.root;
              options.filename = typeof context.filename === "string" ? context.filename : undefined;
              options.plugins = configChain.plugins.map(function (descriptor) {
                return createItemFromDescriptor(descriptor);
              });
              options.presets = configChain.presets.map(function (descriptor) {
                return createItemFromDescriptor(descriptor);
              });
              return _context2.abrupt("return", {
                options: options,
                context: context,
                ignore: configChain.ignore,
                babelrc: configChain.babelrc,
                config: configChain.config
              });

            case 24:
            case "end":
              return _context2.stop();
          }
        }
      }, _marked2$3);
    }
    var loadPartialConfig = gensync(regenerator.mark(function _callee(inputOpts) {
      var result, options, babelrc, ignore, config;
      return regenerator.wrap(function _callee$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

            case 1:
              result = _context3.t0;

              if (result) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return", null);

            case 4:
              options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config;
              (options.plugins || []).forEach(function (item) {
                if (item.value instanceof Plugin) {
                  throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
                }
              });
              return _context3.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined));

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee);
    }));

    var PartialConfig = function () {
      function PartialConfig(options, babelrc, ignore, config) {
        this.options = options;
        this.babelignore = ignore;
        this.babelrc = babelrc;
        this.config = config;
        Object.freeze(this);
      }

      var _proto = PartialConfig.prototype;

      _proto.hasFilesystemConfig = function hasFilesystemConfig() {
        return this.babelrc !== undefined || this.config !== undefined;
      };

      return PartialConfig;
    }();

    Object.freeze(PartialConfig.prototype);

    var _marked$4 = regenerator.mark(loadPluginDescriptor),
        _marked2$4 = regenerator.mark(loadPresetDescriptor);
    var loadConfig$1 = gensync(regenerator.mark(function loadFullConfig(inputOpts) {
      var result, options, context, optionDefaults, passes, plugins, presets, ignored, opts;
      return regenerator.wrap(function loadFullConfig$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

            case 1:
              result = _context2.t0;

              if (result) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", null);

            case 4:
              options = result.options, context = result.context;
              optionDefaults = {};
              passes = [[]];
              _context2.prev = 7;
              plugins = options.plugins, presets = options.presets;

              if (!(!plugins || !presets)) {
                _context2.next = 11;
                break;
              }

              throw new Error("Assertion failure - plugins and presets exist");

            case 11:
              return _context2.delegateYield(regenerator.mark(function recurseDescriptors(config, pass) {
                var plugins, i, descriptor, presets, _i, _descriptor, _iterator, _step, _step$value, preset, _pass, _ignored;

                return regenerator.wrap(function recurseDescriptors$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        plugins = [];
                        i = 0;

                      case 2:
                        if (!(i < config.plugins.length)) {
                          _context.next = 19;
                          break;
                        }

                        descriptor = config.plugins[i];

                        if (!(descriptor.options !== false)) {
                          _context.next = 16;
                          break;
                        }

                        _context.prev = 5;
                        _context.t0 = plugins;
                        return _context.delegateYield(loadPluginDescriptor(descriptor, context), "t1", 8);

                      case 8:
                        _context.t2 = _context.t1;

                        _context.t0.push.call(_context.t0, _context.t2);

                        _context.next = 16;
                        break;

                      case 12:
                        _context.prev = 12;
                        _context.t3 = _context["catch"](5);

                        if (i > 0 && _context.t3.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                          checkNoUnwrappedItemOptionPairs(config.plugins[i - 1], descriptor, "plugin", i, _context.t3);
                        }

                        throw _context.t3;

                      case 16:
                        i++;
                        _context.next = 2;
                        break;

                      case 19:
                        presets = [];
                        _i = 0;

                      case 21:
                        if (!(_i < config.presets.length)) {
                          _context.next = 40;
                          break;
                        }

                        _descriptor = config.presets[_i];

                        if (!(_descriptor.options !== false)) {
                          _context.next = 37;
                          break;
                        }

                        _context.prev = 24;
                        _context.t4 = presets;
                        return _context.delegateYield(loadPresetDescriptor(_descriptor, context), "t5", 27);

                      case 27:
                        _context.t6 = _context.t5;
                        _context.t7 = _descriptor.ownPass ? [] : pass;
                        _context.t8 = {
                          preset: _context.t6,
                          pass: _context.t7
                        };

                        _context.t4.push.call(_context.t4, _context.t8);

                        _context.next = 37;
                        break;

                      case 33:
                        _context.prev = 33;
                        _context.t9 = _context["catch"](24);

                        if (_i > 0 && _context.t9.code === "BABEL_UNKNOWN_OPTION") {
                          checkNoUnwrappedItemOptionPairs(config.presets[_i - 1], _descriptor, "preset", _i, _context.t9);
                        }

                        throw _context.t9;

                      case 37:
                        _i++;
                        _context.next = 21;
                        break;

                      case 40:
                        if (!(presets.length > 0)) {
                          _context.next = 54;
                          break;
                        }

                        passes.splice.apply(passes, [1, 0].concat(presets.map(function (o) {
                          return o.pass;
                        }).filter(function (p) {
                          return p !== pass;
                        })));
                        _iterator = _createForOfIteratorHelperLoose(presets);

                      case 43:
                        if ((_step = _iterator()).done) {
                          _context.next = 54;
                          break;
                        }

                        _step$value = _step.value, preset = _step$value.preset, _pass = _step$value.pass;

                        if (preset) {
                          _context.next = 47;
                          break;
                        }

                        return _context.abrupt("return", true);

                      case 47:
                        return _context.delegateYield(recurseDescriptors({
                          plugins: preset.plugins,
                          presets: preset.presets
                        }, _pass), "t10", 48);

                      case 48:
                        _ignored = _context.t10;

                        if (!_ignored) {
                          _context.next = 51;
                          break;
                        }

                        return _context.abrupt("return", true);

                      case 51:
                        preset.options.forEach(function (opts) {
                          mergeOptions(optionDefaults, opts);
                        });

                      case 52:
                        _context.next = 43;
                        break;

                      case 54:
                        if (plugins.length > 0) {
                          pass.unshift.apply(pass, plugins);
                        }

                      case 55:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, recurseDescriptors, null, [[5, 12], [24, 33]]);
              })({
                plugins: plugins.map(function (item) {
                  var desc = getItemDescriptor(item);

                  if (!desc) {
                    throw new Error("Assertion failure - must be config item");
                  }

                  return desc;
                }),
                presets: presets.map(function (item) {
                  var desc = getItemDescriptor(item);

                  if (!desc) {
                    throw new Error("Assertion failure - must be config item");
                  }

                  return desc;
                })
              }, passes[0]), "t1", 12);

            case 12:
              ignored = _context2.t1;

              if (!ignored) {
                _context2.next = 15;
                break;
              }

              return _context2.abrupt("return", null);

            case 15:
              _context2.next = 21;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t2 = _context2["catch"](7);

              if (!/^\[BABEL\]/.test(_context2.t2.message)) {
                _context2.t2.message = "[BABEL] " + (context.filename || "unknown") + ": " + _context2.t2.message;
              }

              throw _context2.t2;

            case 21:
              opts = optionDefaults;
              mergeOptions(opts, options);
              opts.plugins = passes[0];
              opts.presets = passes.slice(1).filter(function (plugins) {
                return plugins.length > 0;
              }).map(function (plugins) {
                return {
                  plugins: plugins
                };
              });
              opts.passPerPreset = opts.presets.length > 0;
              return _context2.abrupt("return", {
                options: opts,
                passes: passes
              });

            case 27:
            case "end":
              return _context2.stop();
          }
        }
      }, loadFullConfig, null, [[7, 17]]);
    }));
    var loadDescriptor = makeWeakCache(regenerator.mark(function _callee(_ref, cache) {
      var value, options, dirname, alias, item, api;
      return regenerator.wrap(function _callee$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              value = _ref.value, options = _ref.options, dirname = _ref.dirname, alias = _ref.alias;

              if (!(options === false)) {
                _context3.next = 3;
                break;
              }

              throw new Error("Assertion failure");

            case 3:
              options = options || {};
              item = value;

              if (!(typeof value === "function")) {
                _context3.next = 15;
                break;
              }

              api = Object.assign({}, context, {}, makeAPI(cache));
              _context3.prev = 7;
              item = value(api, options, dirname);
              _context3.next = 15;
              break;

            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](7);

              if (alias) {
                _context3.t0.message += " (While processing: " + JSON.stringify(alias) + ")";
              }

              throw _context3.t0;

            case 15:
              if (!(!item || typeof item !== "object")) {
                _context3.next = 17;
                break;
              }

              throw new Error("Plugin/Preset did not return an object.");

            case 17:
              if (!(typeof item.then === "function")) {
                _context3.next = 20;
                break;
              }

              return _context3.delegateYield([], "t1", 19);

            case 19:
              throw new Error("You appear to be using an async plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");

            case 20:
              return _context3.abrupt("return", {
                value: item,
                options: options,
                dirname: dirname,
                alias: alias
              });

            case 21:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee, null, [[7, 11]]);
    }));

    function loadPluginDescriptor(descriptor, context) {
      return regenerator.wrap(function loadPluginDescriptor$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(descriptor.value instanceof Plugin)) {
                _context4.next = 4;
                break;
              }

              if (!descriptor.options) {
                _context4.next = 3;
                break;
              }

              throw new Error("Passed options to an existing Plugin instance will not work.");

            case 3:
              return _context4.abrupt("return", descriptor.value);

            case 4:
              _context4.t0 = instantiatePlugin;
              return _context4.delegateYield(loadDescriptor(descriptor, context), "t1", 6);

            case 6:
              _context4.t2 = _context4.t1;
              _context4.t3 = context;
              return _context4.delegateYield((0, _context4.t0)(_context4.t2, _context4.t3), "t4", 9);

            case 9:
              return _context4.abrupt("return", _context4.t4);

            case 10:
            case "end":
              return _context4.stop();
          }
        }
      }, _marked$4);
    }

    var instantiatePlugin = makeWeakCache(regenerator.mark(function _callee2(_ref2, cache) {
      var value, options, dirname, alias, pluginObj, plugin, inheritsDescriptor, inherits;
      return regenerator.wrap(function _callee2$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              value = _ref2.value, options = _ref2.options, dirname = _ref2.dirname, alias = _ref2.alias;
              pluginObj = validatePluginObject(value);
              plugin = Object.assign({}, pluginObj);

              if (plugin.visitor) {
                plugin.visitor = traverse$1.explode(Object.assign({}, plugin.visitor));
              }

              if (!plugin.inherits) {
                _context5.next = 12;
                break;
              }

              inheritsDescriptor = {
                name: undefined,
                alias: alias + "$inherits",
                value: plugin.inherits,
                options: options,
                dirname: dirname
              };
              return _context5.delegateYield(forwardAsync(loadPluginDescriptor, function (run) {
                return cache.invalidate(function (data) {
                  return run(inheritsDescriptor, data);
                });
              }), "t0", 7);

            case 7:
              inherits = _context5.t0;
              plugin.pre = chain$1(inherits.pre, plugin.pre);
              plugin.post = chain$1(inherits.post, plugin.post);
              plugin.manipulateOptions = chain$1(inherits.manipulateOptions, plugin.manipulateOptions);
              plugin.visitor = traverse$1.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);

            case 12:
              return _context5.abrupt("return", new Plugin(plugin, options, alias));

            case 13:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee2);
    }));

    var validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {
      if (options.test || options.include || options.exclude) {
        var formattedPresetName = descriptor.name ? "\"" + descriptor.name + "\"" : "/* your preset */";
        throw new Error(["Preset " + formattedPresetName + " requires a filename to be set when babel is called directly,", "```", "babel.transform(code, { filename: 'file.ts', presets: [" + formattedPresetName + "] });", "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
      }
    };

    var validatePreset = function validatePreset(preset, context, descriptor) {
      if (!context.filename) {
        var options = preset.options;
        validateIfOptionNeedsFilename(options, descriptor);

        if (options.overrides) {
          options.overrides.forEach(function (overrideOptions) {
            return validateIfOptionNeedsFilename(overrideOptions, descriptor);
          });
        }
      }
    };

    function loadPresetDescriptor(descriptor, context) {
      var preset;
      return regenerator.wrap(function loadPresetDescriptor$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.t0 = instantiatePreset;
              return _context6.delegateYield(loadDescriptor(descriptor, context), "t1", 2);

            case 2:
              _context6.t2 = _context6.t1;
              preset = (0, _context6.t0)(_context6.t2);
              validatePreset(preset, context, descriptor);
              return _context6.delegateYield(buildPresetChain(preset, context), "t3", 6);

            case 6:
              return _context6.abrupt("return", _context6.t3);

            case 7:
            case "end":
              return _context6.stop();
          }
        }
      }, _marked2$4);
    }

    var instantiatePreset = makeWeakCacheSync(function (_ref3) {
      var value = _ref3.value,
          dirname = _ref3.dirname,
          alias = _ref3.alias;
      return {
        options: validate$3("preset", value),
        alias: alias,
        dirname: dirname
      };
    });

    function chain$1(a, b) {
      var fns = [a, b].filter(Boolean);
      if (fns.length <= 1) return fns[0];
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(fns), _step2; !(_step2 = _iterator2()).done;) {
          var fn = _step2.value;
          fn.apply(this, args);
        }
      };
    }

    var loadOptionsRunner = gensync(regenerator.mark(function _callee(opts) {
      var config;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(loadConfig$1(opts), "t0", 1);

            case 1:
              config = _context.t0;
              return _context.abrupt("return", config ? config.options : null);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    var maybeErrback = function maybeErrback(runner) {
      return function (opts, callback) {
        if (callback === undefined && typeof opts === "function") {
          callback = opts;
          opts = undefined;
        }

        return callback ? runner.errback(opts, callback) : runner.sync(opts);
      };
    };

    var loadPartialConfig$1 = maybeErrback(loadPartialConfig);
    var loadPartialConfigSync = loadPartialConfig.sync;
    var loadPartialConfigAsync = loadPartialConfig.async;
    var loadOptions = maybeErrback(loadOptionsRunner);
    var loadOptionsSync = loadOptionsRunner.sync;
    var loadOptionsAsync = loadOptionsRunner.async;

    var PluginPass = function () {
      function PluginPass(file, key, options) {
        this._map = new Map();
        this.key = key;
        this.file = file;
        this.opts = options || {};
        this.cwd = file.opts.cwd;
        this.filename = file.opts.filename;
      }

      var _proto = PluginPass.prototype;

      _proto.set = function set(key, val) {
        this._map.set(key, val);
      };

      _proto.get = function get(key) {
        return this._map.get(key);
      };

      _proto.availableHelper = function availableHelper(name, versionRange) {
        return this.file.availableHelper(name, versionRange);
      };

      _proto.addHelper = function addHelper(name) {
        return this.file.addHelper(name);
      };

      _proto.addImport = function addImport() {
        return this.file.addImport();
      };

      _proto.getModuleName = function getModuleName() {
        return this.file.getModuleName();
      };

      _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
        return this.file.buildCodeFrameError(node, msg, Error);
      };

      return PluginPass;
    }();

    var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

    function isFlattenable(value) {
      return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    var _isFlattenable = isFlattenable;

    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;
      predicate || (predicate = _isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];

        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            _arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }

      return result;
    }

    var _baseFlatten = baseFlatten;

    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }

    var _arraySome = arraySome;

    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }

      var stacked = stack.get(array);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var index = -1,
          result = true,
          seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array);

      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }

        if (compared !== undefined) {
          if (compared) {
            continue;
          }

          result = false;
          break;
        }

        if (seen) {
          if (!_arraySome(other, function (othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }

      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays;

    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray;

    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;
    var boolTag$3 = '[object Boolean]',
        dateTag$3 = '[object Date]',
        errorTag$2 = '[object Error]',
        mapTag$5 = '[object Map]',
        numberTag$3 = '[object Number]',
        regexpTag$4 = '[object RegExp]',
        setTag$5 = '[object Set]',
        stringTag$4 = '[object String]',
        symbolTag$3 = '[object Symbol]';
    var arrayBufferTag$3 = '[object ArrayBuffer]',
        dataViewTag$4 = '[object DataView]';
    var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$4:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }

          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$3:
          if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
            return false;
          }

          return true;

        case boolTag$3:
        case dateTag$3:
        case numberTag$3:
          return eq_1(+object, +other);

        case errorTag$2:
          return object.name == other.name && object.message == other.message;

        case regexpTag$4:
        case stringTag$4:
          return object == other + '';

        case mapTag$5:
          var convert = _mapToArray;

        case setTag$5:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
          convert || (convert = _setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }

          var stacked = stack.get(object);

          if (stacked) {
            return stacked == other;
          }

          bitmask |= COMPARE_UNORDERED_FLAG$1;
          stack.set(object, other);
          var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag$3:
          if (symbolValueOf$1) {
            return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
          }

      }

      return false;
    }

    var _equalByTag = equalByTag;

    var COMPARE_PARTIAL_FLAG$2 = 1;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$e = objectProto$f.hasOwnProperty;

    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
          objProps = _getAllKeys(object),
          objLength = objProps.length,
          othProps = _getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }

      var index = objLength;

      while (index--) {
        var key = objProps[index];

        if (!(isPartial ? key in other : hasOwnProperty$e.call(other, key))) {
          return false;
        }
      }

      var stacked = stack.get(object);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;

      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }

        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }

        skipCtor || (skipCtor = key == 'constructor');
      }

      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }

      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects;

    var COMPARE_PARTIAL_FLAG$3 = 1;
    var argsTag$3 = '[object Arguments]',
        arrayTag$2 = '[object Array]',
        objectTag$4 = '[object Object]';
    var objectProto$g = Object.prototype;
    var hasOwnProperty$f = objectProto$g.hasOwnProperty;

    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray_1(object),
          othIsArr = isArray_1(other),
          objTag = objIsArr ? arrayTag$2 : _getTag(object),
          othTag = othIsArr ? arrayTag$2 : _getTag(other);
      objTag = objTag == argsTag$3 ? objectTag$4 : objTag;
      othTag = othTag == argsTag$3 ? objectTag$4 : othTag;
      var objIsObj = objTag == objectTag$4,
          othIsObj = othTag == objectTag$4,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer_1(object)) {
        if (!isBuffer_1(other)) {
          return false;
        }

        objIsArr = true;
        objIsObj = false;
      }

      if (isSameTag && !objIsObj) {
        stack || (stack = new _Stack());
        return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }

      if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
        var objIsWrapped = objIsObj && hasOwnProperty$f.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$f.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new _Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }

      if (!isSameTag) {
        return false;
      }

      stack || (stack = new _Stack());
      return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep;

    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }

      if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
        return value !== value && other !== other;
      }

      return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    var _baseIsEqual = baseIsEqual;

    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }

      object = Object(object);

      while (index--) {
        var data = matchData[index];

        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }

      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new _Stack();

          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }

          if (!(result === undefined ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
            return false;
          }
        }
      }

      return true;
    }

    var _baseIsMatch = baseIsMatch;

    function isStrictComparable(value) {
      return value === value && !isObject_1(value);
    }

    var _isStrictComparable = isStrictComparable;

    function getMatchData(object) {
      var result = keys_1(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];
        result[length] = [key, value, _isStrictComparable(value)];
      }

      return result;
    }

    var _getMatchData = getMatchData;

    function matchesStrictComparable(key, srcValue) {
      return function (object) {
        if (object == null) {
          return false;
        }

        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
      };
    }

    var _matchesStrictComparable = matchesStrictComparable;

    function baseMatches(source) {
      var matchData = _getMatchData(source);

      if (matchData.length == 1 && matchData[0][2]) {
        return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }

      return function (object) {
        return object === source || _baseIsMatch(object, source, matchData);
      };
    }

    var _baseMatches = baseMatches;

    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    function isKey(value, object) {
      if (isArray_1(value)) {
        return false;
      }

      var type = typeof value;

      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
        return true;
      }

      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }

    var _isKey = isKey;

    var FUNC_ERROR_TEXT = 'Expected a function';

    function memoize(func, resolver) {
      if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }

      var memoized = function memoized() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }

        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };

      memoized.cache = new (memoize.Cache || _MapCache)();
      return memoized;
    }

    memoize.Cache = _MapCache;
    var memoize_1 = memoize;

    var MAX_MEMOIZE_SIZE = 500;

    function memoizeCapped(func) {
      var result = memoize_1(func, function (key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }

        return key;
      });
      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped;

    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = _memoizeCapped(function (string) {
      var result = [];

      if (string.charCodeAt(0) === 46) {
          result.push('');
        }

      string.replace(rePropName, function (match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });
    var _stringToPath = stringToPath;

    function castPath(value, object) {
      if (isArray_1(value)) {
        return value;
      }

      return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
    }

    var _castPath = castPath;

    var INFINITY$3 = 1 / 0;

    function toKey(value) {
      if (typeof value == 'string' || isSymbol_1(value)) {
        return value;
      }

      var result = value + '';
      return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result;
    }

    var _toKey = toKey;

    function baseGet(object, path) {
      path = _castPath(path, object);
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[_toKey(path[index++])];
      }

      return index && index == length ? object : undefined;
    }

    var _baseGet = baseGet;

    function get$2(object, path, defaultValue) {
      var result = object == null ? undefined : _baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get$2;

    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    var _baseHasIn = baseHasIn;

    function hasPath(object, path, hasFunc) {
      path = _castPath(path, object);
      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = _toKey(path[index]);

        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }

        object = object[key];
      }

      if (result || ++index != length) {
        return result;
      }

      length = object == null ? 0 : object.length;
      return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
    }

    var _hasPath = hasPath;

    function hasIn(object, path) {
      return object != null && _hasPath(object, path, _baseHasIn);
    }

    var hasIn_1 = hasIn;

    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    function baseMatchesProperty(path, srcValue) {
      if (_isKey(path) && _isStrictComparable(srcValue)) {
        return _matchesStrictComparable(_toKey(path), srcValue);
      }

      return function (object) {
        var objValue = get_1(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
      };
    }

    var _baseMatchesProperty = baseMatchesProperty;

    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }

    var _baseProperty = baseProperty;

    function basePropertyDeep(path) {
      return function (object) {
        return _baseGet(object, path);
      };
    }

    var _basePropertyDeep = basePropertyDeep;

    function property(path) {
      return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
    }

    var property_1 = property;

    function baseIteratee(value) {
      if (typeof value == 'function') {
        return value;
      }

      if (value == null) {
        return identity_1;
      }

      if (typeof value == 'object') {
        return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
      }

      return property_1(value);
    }

    var _baseIteratee = baseIteratee;

    function createBaseFor(fromRight) {
      return function (object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];

          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }

        return object;
      };
    }

    var _createBaseFor = createBaseFor;

    var baseFor = _createBaseFor();
    var _baseFor = baseFor;

    function baseForOwn(object, iteratee) {
      return object && _baseFor(object, iteratee, keys_1);
    }

    var _baseForOwn = baseForOwn;

    function createBaseEach(eachFunc, fromRight) {
      return function (collection, iteratee) {
        if (collection == null) {
          return collection;
        }

        if (!isArrayLike_1(collection)) {
          return eachFunc(collection, iteratee);
        }

        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }

        return collection;
      };
    }

    var _createBaseEach = createBaseEach;

    var baseEach = _createBaseEach(_baseForOwn);
    var _baseEach = baseEach;

    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike_1(collection) ? Array(collection.length) : [];
      _baseEach(collection, function (value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    var _baseMap = baseMap;

    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);

      while (length--) {
        array[length] = array[length].value;
      }

      return array;
    }

    var _baseSortBy = baseSortBy;

    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol_1(value);
        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol_1(other);

        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }

        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }

      return 0;
    }

    var _compareAscending = compareAscending;

    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = _compareAscending(objCriteria[index], othCriteria[index]);

        if (result) {
          if (index >= ordersLength) {
            return result;
          }

          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }

      return object.index - other.index;
    }

    var _compareMultiple = compareMultiple;

    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = _arrayMap(iteratees.length ? iteratees : [identity_1], _baseUnary(_baseIteratee));
      var result = _baseMap(collection, function (value, key, collection) {
        var criteria = _arrayMap(iteratees, function (iteratee) {
          return iteratee(value);
        });
        return {
          'criteria': criteria,
          'index': ++index,
          'value': value
        };
      });
      return _baseSortBy(result, function (object, other) {
        return _compareMultiple(object, other, orders);
      });
    }

    var _baseOrderBy = baseOrderBy;

    var sortBy = _baseRest(function (collection, iteratees) {
      if (collection == null) {
        return [];
      }

      var length = iteratees.length;

      if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }

      return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
    });
    var sortBy_1 = sortBy;

    var LOADED_PLUGIN;
    function loadBlockHoistPlugin() {
      if (!LOADED_PLUGIN) {
        var config = loadConfig$1.sync({
          babelrc: false,
          configFile: false,
          plugins: [blockHoistPlugin]
        });
        LOADED_PLUGIN = config ? config.passes[0][0] : undefined;
        if (!LOADED_PLUGIN) throw new Error("Assertion failure");
      }

      return LOADED_PLUGIN;
    }
    var blockHoistPlugin = {
      name: "internal.blockHoist",
      visitor: {
        Block: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var hasChange = false;

            for (var i = 0; i < node.body.length; i++) {
              var bodyNode = node.body[i];

              if (bodyNode && bodyNode._blockHoist != null) {
                hasChange = true;
                break;
              }
            }

            if (!hasChange) return;
            node.body = sortBy_1(node.body, function (bodyNode) {
              var priority = bodyNode && bodyNode._blockHoist;
              if (priority == null) priority = 1;
              if (priority === true) priority = 2;
              return -1 * priority;
            });
          }
        }
      }
    };

    function normalizeOptions$2(config) {
      var _config$options = config.options,
          filename = _config$options.filename,
          cwd = _config$options.cwd,
          _config$options$filen = _config$options.filenameRelative,
          filenameRelative = _config$options$filen === void 0 ? typeof filename === "string" ? path$1.relative(cwd, filename) : "unknown" : _config$options$filen,
          _config$options$sourc = _config$options.sourceType,
          sourceType = _config$options$sourc === void 0 ? "module" : _config$options$sourc,
          inputSourceMap = _config$options.inputSourceMap,
          _config$options$sourc2 = _config$options.sourceMaps,
          sourceMaps = _config$options$sourc2 === void 0 ? !!inputSourceMap : _config$options$sourc2,
          moduleRoot = _config$options.moduleRoot,
          _config$options$sourc3 = _config$options.sourceRoot,
          sourceRoot = _config$options$sourc3 === void 0 ? moduleRoot : _config$options$sourc3,
          _config$options$sourc4 = _config$options.sourceFileName,
          sourceFileName = _config$options$sourc4 === void 0 ? path$1.basename(filenameRelative) : _config$options$sourc4,
          _config$options$comme = _config$options.comments,
          comments = _config$options$comme === void 0 ? true : _config$options$comme,
          _config$options$compa = _config$options.compact,
          compact = _config$options$compa === void 0 ? "auto" : _config$options$compa;
      var opts = config.options;
      var options = Object.assign({}, opts, {
        parserOpts: Object.assign({
          sourceType: path$1.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
          sourceFileName: filename,
          plugins: []
        }, opts.parserOpts),
        generatorOpts: Object.assign({
          filename: filename,
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          retainLines: opts.retainLines,
          comments: comments,
          shouldPrintComment: opts.shouldPrintComment,
          compact: compact,
          minified: opts.minified,
          sourceMaps: sourceMaps,
          sourceRoot: sourceRoot,
          sourceFileName: sourceFileName
        }, opts.generatorOpts)
      });

      for (var _iterator = _createForOfIteratorHelperLoose(config.passes), _step; !(_step = _iterator()).done;) {
        var plugins = _step.value;

        for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
          var plugin = _step2.value;

          if (plugin.manipulateOptions) {
            plugin.manipulateOptions(options, options.parserOpts);
          }
        }
      }

      return options;
    }

    var fs = {};

    var CLONE_DEEP_FLAG$1 = 1,
        CLONE_SYMBOLS_FLAG$2 = 4;

    function cloneDeep$1(value) {
      return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
    }

    var cloneDeep_1 = cloneDeep$1;

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': _nodeResolve_empty
    });

    var safeBuffer = createCommonjsModule(function (module, exports) {
    var Buffer = bufferEs6.Buffer;

    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }

    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = bufferEs6;
    } else {
      copyProps(bufferEs6, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }

    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }

      return Buffer(arg, encodingOrOffset, length);
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      var buf = Buffer(size);

      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }

      return buf;
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return Buffer(size);
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return bufferEs6.SlowBuffer(size);
    };
    });
    var safeBuffer_1 = safeBuffer.Buffer;

    var path$2 = getCjsExportFromNamespace(_nodeResolve_empty$1);

    var convertSourceMap = createCommonjsModule(function (module, exports) {







    Object.defineProperty(exports, 'commentRegex', {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports, 'mapFileCommentRegex', {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });

    function decodeBase64(base64) {
      return safeBuffer.Buffer.from(base64, 'base64').toString();
    }

    function stripComment(sm) {
      return sm.split(',').pop();
    }

    function readFromFileMap(sm, dir) {
      var r = exports.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path$1.resolve(dir, filename);

      try {
        return path$2.readFileSync(filepath, 'utf8');
      } catch (e) {
        throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
      }
    }

    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment) sm = stripComment(sm);
      if (opts.isEncoded) sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
      this.sourcemap = sm;
    }

    Converter.prototype.toJSON = function (space) {
      return JSON.stringify(this.sourcemap, null, space);
    };

    Converter.prototype.toBase64 = function () {
      var json = this.toJSON();
      return safeBuffer.Buffer.from(json, 'utf8').toString('base64');
    };

    Converter.prototype.toComment = function (options) {
      var base64 = this.toBase64();
      var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
      return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
    };

    Converter.prototype.toObject = function () {
      return JSON.parse(this.toJSON());
    };

    Converter.prototype.addProperty = function (key, value) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value);
    };

    Converter.prototype.setProperty = function (key, value) {
      this.sourcemap[key] = value;
      return this;
    };

    Converter.prototype.getProperty = function (key) {
      return this.sourcemap[key];
    };

    exports.fromObject = function (obj) {
      return new Converter(obj);
    };

    exports.fromJSON = function (json) {
      return new Converter(json, {
        isJSON: true
      });
    };

    exports.fromBase64 = function (base64) {
      return new Converter(base64, {
        isEncoded: true
      });
    };

    exports.fromComment = function (comment) {
      comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
      return new Converter(comment, {
        isEncoded: true,
        hasComment: true
      });
    };

    exports.fromMapFileComment = function (comment, dir) {
      return new Converter(comment, {
        commentFileDir: dir,
        isFileComment: true,
        isJSON: true
      });
    };

    exports.fromSource = function (content) {
      var m = content.match(exports.commentRegex);
      return m ? exports.fromComment(m.pop()) : null;
    };

    exports.fromMapFileSource = function (content, dir) {
      var m = content.match(exports.mapFileCommentRegex);
      return m ? exports.fromMapFileComment(m.pop(), dir) : null;
    };

    exports.removeComments = function (src) {
      return src.replace(exports.commentRegex, '');
    };

    exports.removeMapFileComments = function (src) {
      return src.replace(exports.mapFileCommentRegex, '');
    };

    exports.generateMapFileComment = function (file, options) {
      var data = 'sourceMappingURL=' + file;
      return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
    };
    });
    var convertSourceMap_1 = convertSourceMap.fromObject;
    var convertSourceMap_2 = convertSourceMap.fromJSON;
    var convertSourceMap_3 = convertSourceMap.fromBase64;
    var convertSourceMap_4 = convertSourceMap.fromComment;
    var convertSourceMap_5 = convertSourceMap.fromMapFileComment;
    var convertSourceMap_6 = convertSourceMap.fromSource;
    var convertSourceMap_7 = convertSourceMap.fromMapFileSource;
    var convertSourceMap_8 = convertSourceMap.removeComments;
    var convertSourceMap_9 = convertSourceMap.removeMapFileComments;
    var convertSourceMap_10 = convertSourceMap.generateMapFileComment;

    var pluginNameMap = {
      classProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://git.io/vb4yQ"
        },
        transform: {
          name: "@babel/plugin-proposal-class-properties",
          url: "https://git.io/vb4SL"
        }
      },
      classPrivateProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://git.io/vb4yQ"
        },
        transform: {
          name: "@babel/plugin-proposal-class-properties",
          url: "https://git.io/vb4SL"
        }
      },
      classPrivateMethods: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://git.io/vb4yQ"
        },
        transform: {
          name: "@babel/plugin-proposal-private-methods",
          url: "https://git.io/JvpRG"
        }
      },
      decorators: {
        syntax: {
          name: "@babel/plugin-syntax-decorators",
          url: "https://git.io/vb4y9"
        },
        transform: {
          name: "@babel/plugin-proposal-decorators",
          url: "https://git.io/vb4ST"
        }
      },
      doExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-do-expressions",
          url: "https://git.io/vb4yh"
        },
        transform: {
          name: "@babel/plugin-proposal-do-expressions",
          url: "https://git.io/vb4S3"
        }
      },
      dynamicImport: {
        syntax: {
          name: "@babel/plugin-syntax-dynamic-import",
          url: "https://git.io/vb4Sv"
        }
      },
      exportDefaultFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-default-from",
          url: "https://git.io/vb4SO"
        },
        transform: {
          name: "@babel/plugin-proposal-export-default-from",
          url: "https://git.io/vb4yH"
        }
      },
      exportNamespaceFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-namespace-from",
          url: "https://git.io/vb4Sf"
        },
        transform: {
          name: "@babel/plugin-proposal-export-namespace-from",
          url: "https://git.io/vb4SG"
        }
      },
      flow: {
        syntax: {
          name: "@babel/plugin-syntax-flow",
          url: "https://git.io/vb4yb"
        },
        transform: {
          name: "@babel/preset-flow",
          url: "https://git.io/JfeDn"
        }
      },
      functionBind: {
        syntax: {
          name: "@babel/plugin-syntax-function-bind",
          url: "https://git.io/vb4y7"
        },
        transform: {
          name: "@babel/plugin-proposal-function-bind",
          url: "https://git.io/vb4St"
        }
      },
      functionSent: {
        syntax: {
          name: "@babel/plugin-syntax-function-sent",
          url: "https://git.io/vb4yN"
        },
        transform: {
          name: "@babel/plugin-proposal-function-sent",
          url: "https://git.io/vb4SZ"
        }
      },
      importMeta: {
        syntax: {
          name: "@babel/plugin-syntax-import-meta",
          url: "https://git.io/vbKK6"
        }
      },
      jsx: {
        syntax: {
          name: "@babel/plugin-syntax-jsx",
          url: "https://git.io/vb4yA"
        },
        transform: {
          name: "@babel/preset-react",
          url: "https://git.io/JfeDR"
        }
      },
      logicalAssignment: {
        syntax: {
          name: "@babel/plugin-syntax-logical-assignment-operators",
          url: "https://git.io/vAlBp"
        },
        transform: {
          name: "@babel/plugin-proposal-logical-assignment-operators",
          url: "https://git.io/vAlRe"
        }
      },
      numericSeparator: {
        syntax: {
          name: "@babel/plugin-syntax-numeric-separator",
          url: "https://git.io/vb4Sq"
        },
        transform: {
          name: "@babel/plugin-proposal-numeric-separator",
          url: "https://git.io/vb4yS"
        }
      },
      optionalChaining: {
        syntax: {
          name: "@babel/plugin-syntax-optional-chaining",
          url: "https://git.io/vb4Sc"
        },
        transform: {
          name: "@babel/plugin-proposal-optional-chaining",
          url: "https://git.io/vb4Sk"
        }
      },
      pipelineOperator: {
        syntax: {
          name: "@babel/plugin-syntax-pipeline-operator",
          url: "https://git.io/vb4yj"
        },
        transform: {
          name: "@babel/plugin-proposal-pipeline-operator",
          url: "https://git.io/vb4SU"
        }
      },
      recordAndTuple: {
        syntax: {
          name: "@babel/plugin-syntax-record-and-tuple",
          url: "https://git.io/JvKp3"
        }
      },
      throwExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-throw-expressions",
          url: "https://git.io/vb4SJ"
        },
        transform: {
          name: "@babel/plugin-proposal-throw-expressions",
          url: "https://git.io/vb4yF"
        }
      },
      typescript: {
        syntax: {
          name: "@babel/plugin-syntax-typescript",
          url: "https://git.io/vb4SC"
        },
        transform: {
          name: "@babel/preset-typescript",
          url: "https://git.io/JfeDz"
        }
      },
      asyncGenerators: {
        syntax: {
          name: "@babel/plugin-syntax-async-generators",
          url: "https://git.io/vb4SY"
        },
        transform: {
          name: "@babel/plugin-proposal-async-generator-functions",
          url: "https://git.io/vb4yp"
        }
      },
      nullishCoalescingOperator: {
        syntax: {
          name: "@babel/plugin-syntax-nullish-coalescing-operator",
          url: "https://git.io/vb4yx"
        },
        transform: {
          name: "@babel/plugin-proposal-nullish-coalescing-operator",
          url: "https://git.io/vb4Se"
        }
      },
      objectRestSpread: {
        syntax: {
          name: "@babel/plugin-syntax-object-rest-spread",
          url: "https://git.io/vb4y5"
        },
        transform: {
          name: "@babel/plugin-proposal-object-rest-spread",
          url: "https://git.io/vb4Ss"
        }
      },
      optionalCatchBinding: {
        syntax: {
          name: "@babel/plugin-syntax-optional-catch-binding",
          url: "https://git.io/vb4Sn"
        },
        transform: {
          name: "@babel/plugin-proposal-optional-catch-binding",
          url: "https://git.io/vb4SI"
        }
      }
    };

    var getNameURLCombination = function getNameURLCombination(_ref) {
      var name = _ref.name,
          url = _ref.url;
      return name + " (" + url + ")";
    };

    function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
      var helpMessage = "Support for the experimental syntax '" + missingPluginName + "' isn't currently enabled " + ("(" + loc.line + ":" + (loc.column + 1) + "):\n\n") + codeFrame;
      var pluginInfo = pluginNameMap[missingPluginName];

      if (pluginInfo) {
        var syntaxPlugin = pluginInfo.syntax,
            transformPlugin = pluginInfo.transform;

        if (syntaxPlugin) {
          var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);

          if (transformPlugin) {
            var transformPluginInfo = getNameURLCombination(transformPlugin);
            var sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
            helpMessage += "\n\nAdd " + transformPluginInfo + " to the '" + sectionType + "' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add " + syntaxPluginInfo + " to the 'plugins' section to enable parsing.";
          } else {
            helpMessage += "\n\nAdd " + syntaxPluginInfo + " to the 'plugins' section of your Babel config " + "to enable parsing.";
          }
        }
      }

      return helpMessage;
    }

    var _marked$5 = regenerator.mark(parser);
    function parser(pluginPasses, _ref, code) {
      var parserOpts, _ref$highlightCode, highlightCode, _ref$filename, filename, results, _iterator, _step, plugins, _iterator2, _step2, plugin, parserOverride, ast, loc, missingPlugin, codeFrame;

      return regenerator.wrap(function parser$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              parserOpts = _ref.parserOpts, _ref$highlightCode = _ref.highlightCode, highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode, _ref$filename = _ref.filename, filename = _ref$filename === void 0 ? "unknown" : _ref$filename;
              _context.prev = 1;
              results = [];

              for (_iterator = _createForOfIteratorHelperLoose(pluginPasses); !(_step = _iterator()).done;) {
                plugins = _step.value;

                for (_iterator2 = _createForOfIteratorHelperLoose(plugins); !(_step2 = _iterator2()).done;) {
                  plugin = _step2.value;
                  parserOverride = plugin.parserOverride;

                  if (parserOverride) {
                    ast = parserOverride(code, parserOpts, parse$1);
                    if (ast !== undefined) results.push(ast);
                  }
                }
              }

              if (!(results.length === 0)) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", parse$1(code, parserOpts));

            case 8:
              if (!(results.length === 1)) {
                _context.next = 13;
                break;
              }

              return _context.delegateYield([], "t0", 10);

            case 10:
              if (!(typeof results[0].then === "function")) {
                _context.next = 12;
                break;
              }

              throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

            case 12:
              return _context.abrupt("return", results[0]);

            case 13:
              throw new Error("More than one plugin attempted to override parsing.");

            case 16:
              _context.prev = 16;
              _context.t1 = _context["catch"](1);

              if (_context.t1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
                _context.t1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
              }

              loc = _context.t1.loc, missingPlugin = _context.t1.missingPlugin;

              if (loc) {
                codeFrame = codeFrameColumns(code, {
                  start: {
                    line: loc.line,
                    column: loc.column + 1
                  }
                }, {
                  highlightCode: highlightCode
                });

                if (missingPlugin) {
                  _context.t1.message = filename + ": " + generateMissingPluginMessage(missingPlugin[0], loc, codeFrame);
                } else {
                  _context.t1.message = filename + ": " + _context.t1.message + "\n\n" + codeFrame;
                }

                _context.t1.code = "BABEL_PARSE_ERROR";
              }

              throw _context.t1;

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _marked$5, null, [[1, 16]]);
    }

    var _marked$6 = regenerator.mark(normalizeFile);
    var debug$1 = browser$4("babel:transform:file");
    var LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;
    function normalizeFile(pluginPasses, options, code, ast) {
      var inputMap, lastComment, _lastComment, match, inputMapContent;

      return regenerator.wrap(function normalizeFile$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              code = "" + (code || "");

              if (!ast) {
                _context.next = 11;
                break;
              }

              if (!(ast.type === "Program")) {
                _context.next = 6;
                break;
              }

              ast = File(ast, [], []);
              _context.next = 8;
              break;

            case 6:
              if (!(ast.type !== "File")) {
                _context.next = 8;
                break;
              }

              throw new Error("AST root must be a Program or File node");

            case 8:
              ast = cloneDeep_1(ast);
              _context.next = 13;
              break;

            case 11:
              return _context.delegateYield(parser(pluginPasses, options, code), "t0", 12);

            case 12:
              ast = _context.t0;

            case 13:
              inputMap = null;

              if (options.inputSourceMap !== false) {
                if (typeof options.inputSourceMap === "object") {
                  inputMap = convertSourceMap.fromObject(options.inputSourceMap);
                }

                if (!inputMap) {
                  lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

                  if (lastComment) {
                    try {
                      inputMap = convertSourceMap.fromComment(lastComment);
                    } catch (err) {
                      debug$1("discarding unknown inline input sourcemap", err);
                    }
                  }
                }

                if (!inputMap) {
                  _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

                  if (typeof options.filename === "string" && _lastComment) {
                    try {
                      match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
                      inputMapContent = fs.readFileSync(path$1.resolve(path$1.dirname(options.filename), match[1]));

                      if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
                        debug$1("skip merging input map > 1 MB");
                      } else {
                        inputMap = convertSourceMap.fromJSON(inputMapContent);
                      }
                    } catch (err) {
                      debug$1("discarding unknown file input sourcemap", err);
                    }
                  } else if (_lastComment) {
                    debug$1("discarding un-loadable file input sourcemap");
                  }
                }
              }

              return _context.abrupt("return", new File$2(options, {
                code: code,
                ast: ast,
                inputMap: inputMap
              }));

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _marked$6);
    }
    var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
    var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

    function extractCommentsFromList(regex, comments, lastComment) {
      if (comments) {
        comments = comments.filter(function (_ref) {
          var value = _ref.value;

          if (regex.test(value)) {
            lastComment = value;
            return false;
          }

          return true;
        });
      }

      return [comments, lastComment];
    }

    function extractComments(regex, ast) {
      var lastComment = null;
      traverseFast(ast, function (node) {
        var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

        node.leadingComments = _extractCommentsFromL[0];
        lastComment = _extractCommentsFromL[1];

        var _extractCommentsFromL2 = extractCommentsFromList(regex, node.innerComments, lastComment);

        node.innerComments = _extractCommentsFromL2[0];
        lastComment = _extractCommentsFromL2[1];

        var _extractCommentsFromL3 = extractCommentsFromList(regex, node.trailingComments, lastComment);

        node.trailingComments = _extractCommentsFromL3[0];
        lastComment = _extractCommentsFromL3[1];
      });
      return lastComment;
    }

    function mergeSourceMap(inputMap, map) {
      var input = buildMappingData(inputMap);
      var output = buildMappingData(map);
      var mergedGenerator = new sourceMap.SourceMapGenerator();

      for (var _iterator = _createForOfIteratorHelperLoose(input.sources), _step; !(_step = _iterator()).done;) {
        var source = _step.value.source;

        if (typeof source.content === "string") {
          mergedGenerator.setSourceContent(source.path, source.content);
        }
      }

      if (output.sources.length === 1) {
        var defaultSource = output.sources[0];
        var insertedMappings = new Map();
        eachInputGeneratedRange(input, function (generated, original, source) {
          eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {
            var key = makeMappingKey(item);
            if (insertedMappings.has(key)) return;
            insertedMappings.set(key, item);
            mergedGenerator.addMapping({
              source: source.path,
              original: {
                line: original.line,
                column: original.columnStart
              },
              generated: {
                line: item.line,
                column: item.columnStart
              },
              name: original.name
            });
          });
        });

        for (var _iterator2 = _createForOfIteratorHelperLoose(insertedMappings.values()), _step2; !(_step2 = _iterator2()).done;) {
          var item = _step2.value;

          if (item.columnEnd === Infinity) {
            continue;
          }

          var clearItem = {
            line: item.line,
            columnStart: item.columnEnd
          };
          var key = makeMappingKey(clearItem);

          if (insertedMappings.has(key)) {
            continue;
          }

          mergedGenerator.addMapping({
            generated: {
              line: clearItem.line,
              column: clearItem.columnStart
            }
          });
        }
      }

      var result = mergedGenerator.toJSON();

      if (typeof input.sourceRoot === "string") {
        result.sourceRoot = input.sourceRoot;
      }

      return result;
    }

    function makeMappingKey(item) {
      return item.line + "/" + item.columnStart;
    }

    function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
      var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);

      for (var _iterator3 = _createForOfIteratorHelperLoose(overlappingOriginal), _step3; !(_step3 = _iterator3()).done;) {
        var generated = _step3.value.generated;

        for (var _iterator4 = _createForOfIteratorHelperLoose(generated), _step4; !(_step4 = _iterator4()).done;) {
          var item = _step4.value;
          callback(item);
        }
      }
    }

    function filterApplicableOriginalRanges(_ref, _ref2) {
      var mappings = _ref.mappings;
      var line = _ref2.line,
          columnStart = _ref2.columnStart,
          columnEnd = _ref2.columnEnd;
      return filterSortedArray(mappings, function (_ref3) {
        var outOriginal = _ref3.original;
        if (line > outOriginal.line) return -1;
        if (line < outOriginal.line) return 1;
        if (columnStart >= outOriginal.columnEnd) return -1;
        if (columnEnd <= outOriginal.columnStart) return 1;
        return 0;
      });
    }

    function eachInputGeneratedRange(map, callback) {
      for (var _iterator5 = _createForOfIteratorHelperLoose(map.sources), _step5; !(_step5 = _iterator5()).done;) {
        var _step5$value = _step5.value,
            source = _step5$value.source,
            mappings = _step5$value.mappings;

        for (var _iterator6 = _createForOfIteratorHelperLoose(mappings), _step6; !(_step6 = _iterator6()).done;) {
          var _step6$value = _step6.value,
              original = _step6$value.original,
              generated = _step6$value.generated;

          for (var _iterator7 = _createForOfIteratorHelperLoose(generated), _step7; !(_step7 = _iterator7()).done;) {
            var item = _step7.value;
            callback(item, original, source);
          }
        }
      }
    }

    function buildMappingData(map) {
      var consumer = new sourceMap.SourceMapConsumer(Object.assign({}, map, {
        sourceRoot: null
      }));
      var sources = new Map();
      var mappings = new Map();
      var last = null;
      consumer.computeColumnSpans();
      consumer.eachMapping(function (m) {
        if (m.originalLine === null) return;
        var source = sources.get(m.source);

        if (!source) {
          source = {
            path: m.source,
            content: consumer.sourceContentFor(m.source, true)
          };
          sources.set(m.source, source);
        }

        var sourceData = mappings.get(source);

        if (!sourceData) {
          sourceData = {
            source: source,
            mappings: []
          };
          mappings.set(source, sourceData);
        }

        var obj = {
          line: m.originalLine,
          columnStart: m.originalColumn,
          columnEnd: Infinity,
          name: m.name
        };

        if (last && last.source === source && last.mapping.line === m.originalLine) {
          last.mapping.columnEnd = m.originalColumn;
        }

        last = {
          source: source,
          mapping: obj
        };
        sourceData.mappings.push({
          original: obj,
          generated: consumer.allGeneratedPositionsFor({
            source: m.source,
            line: m.originalLine,
            column: m.originalColumn
          }).map(function (item) {
            return {
              line: item.line,
              columnStart: item.column,
              columnEnd: item.lastColumn + 1
            };
          })
        });
      }, null, sourceMap.SourceMapConsumer.ORIGINAL_ORDER);
      return {
        file: map.file,
        sourceRoot: map.sourceRoot,
        sources: Array.from(mappings.values())
      };
    }

    function findInsertionLocation(array, callback) {
      var left = 0;
      var right = array.length;

      while (left < right) {
        var mid = Math.floor((left + right) / 2);
        var item = array[mid];
        var result = callback(item);

        if (result === 0) {
          left = mid;
          break;
        }

        if (result >= 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      var i = left;

      if (i < array.length) {
        while (i >= 0 && callback(array[i]) >= 0) {
          i--;
        }

        return i + 1;
      }

      return i;
    }

    function filterSortedArray(array, callback) {
      var start = findInsertionLocation(array, callback);
      var results = [];

      for (var i = start; i < array.length && callback(array[i]) === 0; i++) {
        results.push(array[i]);
      }

      return results;
    }

    function generateCode$1(pluginPasses, file) {
      var opts = file.opts,
          ast = file.ast,
          code = file.code,
          inputMap = file.inputMap;
      var results = [];

      for (var _iterator = _createForOfIteratorHelperLoose(pluginPasses), _step; !(_step = _iterator()).done;) {
        var plugins = _step.value;

        for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
          var plugin = _step2.value;
          var generatorOverride = plugin.generatorOverride;

          if (generatorOverride) {
            var _result2 = generatorOverride(ast, opts.generatorOpts, code, generateCode);

            if (_result2 !== undefined) results.push(_result2);
          }
        }
      }

      var result;

      if (results.length === 0) {
        result = generateCode(ast, opts.generatorOpts, code);
      } else if (results.length === 1) {
        result = results[0];

        if (typeof result.then === "function") {
          throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
        }
      } else {
        throw new Error("More than one plugin attempted to override codegen.");
      }

      var _result = result,
          outputCode = _result.code,
          outputMap = _result.map;

      if (outputMap && inputMap) {
        outputMap = mergeSourceMap(inputMap.toObject(), outputMap);
      }

      if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
        outputCode += "\n" + convertSourceMap.fromObject(outputMap).toComment();
      }

      if (opts.sourceMaps === "inline") {
        outputMap = null;
      }

      return {
        outputCode: outputCode,
        outputMap: outputMap
      };
    }

    var _marked$7 = regenerator.mark(run),
        _marked2$5 = regenerator.mark(transformFile);
    function run(config, code, ast) {
      var file, opts, _opts$filename, outputCode, outputMap, _generateCode, _opts$filename2;

      return regenerator.wrap(function run$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(normalizeFile(config.passes, normalizeOptions$2(config), code, ast), "t0", 1);

            case 1:
              file = _context.t0;
              opts = file.opts;
              _context.prev = 3;
              return _context.delegateYield(transformFile(file, config.passes), "t1", 5);

            case 5:
              _context.next = 12;
              break;

            case 7:
              _context.prev = 7;
              _context.t2 = _context["catch"](3);
              _context.t2.message = ((_opts$filename = opts.filename) != null ? _opts$filename : "unknown") + ": " + _context.t2.message;

              if (!_context.t2.code) {
                _context.t2.code = "BABEL_TRANSFORM_ERROR";
              }

              throw _context.t2;

            case 12:
              _context.prev = 12;

              if (opts.code !== false) {
                _generateCode = generateCode$1(config.passes, file);
                outputCode = _generateCode.outputCode;
                outputMap = _generateCode.outputMap;
              }

              _context.next = 21;
              break;

            case 16:
              _context.prev = 16;
              _context.t3 = _context["catch"](12);
              _context.t3.message = ((_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown") + ": " + _context.t3.message;

              if (!_context.t3.code) {
                _context.t3.code = "BABEL_GENERATE_ERROR";
              }

              throw _context.t3;

            case 21:
              return _context.abrupt("return", {
                metadata: file.metadata,
                options: opts,
                ast: opts.ast === true ? file.ast : null,
                code: outputCode === undefined ? null : outputCode,
                map: outputMap === undefined ? null : outputMap,
                sourceType: file.ast.program.sourceType
              });

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _marked$7, null, [[3, 7], [12, 16]]);
    }

    function transformFile(file, pluginPasses) {
      var _iterator, _step, pluginPairs, passPairs, passes, visitors, _iterator2, _step2, _plugin2, _pass2, _i, _passPairs, _passPairs$_i, plugin, pass, fn, result, visitor, _i2, _passPairs2, _passPairs2$_i, _plugin, _pass, _fn, _result;

      return regenerator.wrap(function transformFile$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iterator = _createForOfIteratorHelperLoose(pluginPasses);

            case 1:
              if ((_step = _iterator()).done) {
                _context2.next = 35;
                break;
              }

              pluginPairs = _step.value;
              passPairs = [];
              passes = [];
              visitors = [];

              for (_iterator2 = _createForOfIteratorHelperLoose(pluginPairs.concat([loadBlockHoistPlugin()])); !(_step2 = _iterator2()).done;) {
                _plugin2 = _step2.value;
                _pass2 = new PluginPass(file, _plugin2.key, _plugin2.options);
                passPairs.push([_plugin2, _pass2]);
                passes.push(_pass2);
                visitors.push(_plugin2.visitor);
              }

              _i = 0, _passPairs = passPairs;

            case 8:
              if (!(_i < _passPairs.length)) {
                _context2.next = 19;
                break;
              }

              _passPairs$_i = _passPairs[_i], plugin = _passPairs$_i[0], pass = _passPairs$_i[1];
              fn = plugin.pre;

              if (!fn) {
                _context2.next = 16;
                break;
              }

              result = fn.call(pass, file);
              return _context2.delegateYield([], "t0", 14);

            case 14:
              if (!isThenable$1(result)) {
                _context2.next = 16;
                break;
              }

              throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

            case 16:
              _i++;
              _context2.next = 8;
              break;

            case 19:
              visitor = traverse$1.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
              traverse$1(file.ast, visitor, file.scope);
              _i2 = 0, _passPairs2 = passPairs;

            case 22:
              if (!(_i2 < _passPairs2.length)) {
                _context2.next = 33;
                break;
              }

              _passPairs2$_i = _passPairs2[_i2], _plugin = _passPairs2$_i[0], _pass = _passPairs2$_i[1];
              _fn = _plugin.post;

              if (!_fn) {
                _context2.next = 30;
                break;
              }

              _result = _fn.call(_pass, file);
              return _context2.delegateYield([], "t1", 28);

            case 28:
              if (!isThenable$1(_result)) {
                _context2.next = 30;
                break;
              }

              throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

            case 30:
              _i2++;
              _context2.next = 22;
              break;

            case 33:
              _context2.next = 1;
              break;

            case 35:
            case "end":
              return _context2.stop();
          }
        }
      }, _marked2$5);
    }

    function isThenable$1(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
    }

    var transformRunner = gensync(regenerator.mark(function transform(code, opts) {
      var config;
      return regenerator.wrap(function transform$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(loadConfig$1(opts), "t0", 1);

            case 1:
              config = _context.t0;

              if (!(config === null)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", null);

            case 4:
              return _context.delegateYield(run(config, code), "t1", 5);

            case 5:
              return _context.abrupt("return", _context.t1);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, transform);
    }));
    var transform = function transform(code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = undefined;
      }

      if (callback === undefined) return transformRunner.sync(code, opts);
      transformRunner.errback(code, opts, callback);
    };
    var transformSync = transformRunner.sync;
    var transformAsync = transformRunner.async;

    var transformFile$1 = function transformFile(filename, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
      }

      callback(new Error("Transforming files is not supported in browsers"), null);
    };
    function transformFileSync() {
      throw new Error("Transforming files is not supported in browsers");
    }
    function transformFileAsync() {
      return Promise.reject(new Error("Transforming files is not supported in browsers"));
    }

    var transformFromAstRunner = gensync(regenerator.mark(function _callee(ast, code, opts) {
      var config;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(loadConfig$1(opts), "t0", 1);

            case 1:
              config = _context.t0;

              if (!(config === null)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", null);

            case 4:
              if (ast) {
                _context.next = 6;
                break;
              }

              throw new Error("No AST given");

            case 6:
              return _context.delegateYield(run(config, code, ast), "t1", 7);

            case 7:
              return _context.abrupt("return", _context.t1);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    var transformFromAst = function transformFromAst(ast, code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = undefined;
      }

      if (callback === undefined) {
        return transformFromAstRunner.sync(ast, code, opts);
      }

      transformFromAstRunner.errback(ast, code, opts, callback);
    };
    var transformFromAstSync = transformFromAstRunner.sync;
    var transformFromAstAsync = transformFromAstRunner.async;

    var parseRunner = gensync(regenerator.mark(function parse(code, opts) {
      var config;
      return regenerator.wrap(function parse$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(loadConfig$1(opts), "t0", 1);

            case 1:
              config = _context.t0;

              if (!(config === null)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", null);

            case 4:
              return _context.delegateYield(parser(config.passes, normalizeOptions$2(config), code), "t1", 5);

            case 5:
              return _context.abrupt("return", _context.t1);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, parse);
    }));
    var parse$3 = function parse(code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = undefined;
      }

      if (callback === undefined) return parseRunner.sync(code, opts);
      parseRunner.errback(code, opts, callback);
    };
    var parseSync = parseRunner.sync;
    var parseAsync = parseRunner.async;

    var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs"]);
    var OptionManager = function () {
      function OptionManager() {}

      var _proto = OptionManager.prototype;

      _proto.init = function init(opts) {
        return loadOptions(opts);
      };

      return OptionManager;
    }();
    function Plugin$1(alias) {
      throw new Error("The (" + alias + ") Babel 5 plugin is being run with an unsupported Babel version.");
    }

    function declare(builder) {
      return function (api, options, dirname) {
        if (!api.assertVersion) {
          api = Object.assign(copyApiObject(api), {
            assertVersion: function assertVersion(range) {
              throwVersionError(range, api.version);
            }
          });
        }

        return builder(api, options || {}, dirname);
      };
    }

    function copyApiObject(api) {
      var proto = null;

      if (typeof api.version === "string" && /^7\./.test(api.version)) {
        proto = Object.getPrototypeOf(api);

        if (proto && (!has$4(proto, "version") || !has$4(proto, "transform") || !has$4(proto, "template") || !has$4(proto, "types"))) {
          proto = null;
        }
      }

      return Object.assign({}, proto, {}, api);
    }

    function has$4(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    function throwVersionError(range, version) {
      if (typeof range === "number") {
        if (!Number.isInteger(range)) {
          throw new Error("Expected string or integer value.");
        }

        range = "^" + range + ".0.0-0";
      }

      if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
      }

      var limit = Error.stackTraceLimit;

      if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
      }

      var err;

      if (version.slice(0, 2) === "7.") {
        err = new Error("Requires Babel \"^7.0.0-beta.41\", but was loaded with \"" + version + "\". " + "You'll need to update your @babel/core version.");
      } else {
        err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");
      }

      if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
      }

      throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version: version,
        range: range
      });
    }

    var src = /*#__PURE__*/Object.freeze({
      __proto__: null,
      declare: declare
    });

    var externalHelpers = declare(function (api, options) {
      api.assertVersion(7);
      var _options$helperVersio = options.helperVersion,
          helperVersion = _options$helperVersio === void 0 ? "7.0.0-beta.0" : _options$helperVersio,
          _options$whitelist = options.whitelist,
          whitelist = _options$whitelist === void 0 ? false : _options$whitelist;

      if (whitelist !== false && (!Array.isArray(whitelist) || whitelist.some(function (w) {
        return typeof w !== "string";
      }))) {
        throw new Error(".whitelist must be undefined, false, or an array of strings");
      }

      var helperWhitelist = whitelist ? new Set(whitelist) : null;
      return {
        name: "external-helpers",
        pre: function pre(file) {
          file.set("helperGenerator", function (name) {
            if (file.availableHelper && !file.availableHelper(name, helperVersion)) {
              return;
            }

            if (helperWhitelist && !helperWhitelist.has(name)) return;
            return MemberExpression(Identifier("babelHelpers"), Identifier(name));
          });
        }
      };
    });

    var _helperPluginUtils = getCjsExportFromNamespace(src);

    var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-async-generators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxAsyncGenerators = unwrapExports(lib);

    var syntaxClassProperties = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-class-properties",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        }
      };
    });

    var syntaxDecorators = declare(function (api, options) {
      api.assertVersion(7);
      var _options$legacy = options.legacy,
          legacy = _options$legacy === void 0 ? false : _options$legacy;

      if (typeof legacy !== "boolean") {
        throw new Error("'legacy' must be a boolean.");
      }

      var decoratorsBeforeExport = options.decoratorsBeforeExport;

      if (decoratorsBeforeExport === undefined) {
        if (!legacy) {
          throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a" + " 'decoratorsBeforeExport' option, whose value must be a boolean." + " If you want to use the legacy decorators semantics, you can set" + " the 'legacy: true' option.");
        }
      } else {
        if (legacy) {
          throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
        }

        if (typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
        }
      }

      return {
        name: "syntax-decorators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push(legacy ? "decorators-legacy" : ["decorators", {
            decoratorsBeforeExport: decoratorsBeforeExport
          }]);
        }
      };
    });

    var syntaxDoExpressions = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-do-expressions",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("doExpressions");
        }
      };
    });

    var syntaxEventualSend = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-eventual-send",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("eventualSend");
        }
      };
    });

    var syntaxExportDefaultFrom = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-export-default-from",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("exportDefaultFrom");
        }
      };
    });

    var syntaxFlow = declare(function (api, options) {
      api.assertVersion(7);
      var all = options.all,
          enums = options.enums;

      if (typeof all !== "boolean" && typeof all !== "undefined") {
        throw new Error(".all must be a boolean, or undefined");
      }

      if (typeof enums !== "boolean" && typeof enums !== "undefined") {
        throw new Error(".enums must be a boolean, or undefined");
      }

      return {
        name: "syntax-flow",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          if (parserOpts.plugins.some(function (p) {
            return (Array.isArray(p) ? p[0] : p) === "typescript";
          })) {
            return;
          }

          parserOpts.plugins.push(["flow", {
            all: all,
            enums: enums
          }]);
        }
      };
    });

    var syntaxFunctionBind = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-function-bind",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("functionBind");
        }
      };
    });

    var syntaxFunctionSent = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-function-sent",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("functionSent");
        }
      };
    });

    var syntaxImportMeta = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-import-meta",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("importMeta");
        }
      };
    });

    var syntaxJsx = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-jsx",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          if (parserOpts.plugins.some(function (p) {
            return (Array.isArray(p) ? p[0] : p) === "typescript";
          })) {
            return;
          }

          parserOpts.plugins.push("jsx");
        }
      };
    });

    var lib$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-object-rest-spread",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxObjectRestSpread = unwrapExports(lib$1);

    var lib$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-catch-binding",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxOptionalCatchBinding = unwrapExports(lib$2);

    var proposals = ["minimal", "smart", "fsharp"];
    var syntaxPipelineOperator = declare(function (api, _ref) {
      var proposal = _ref.proposal;
      api.assertVersion(7);

      if (typeof proposal !== "string" || !proposals.includes(proposal)) {
        throw new Error("The pipeline operator plugin requires a 'proposal' option." + "'proposal' must be one of: " + proposals.join(", ") + ". More details: https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator");
      }

      return {
        name: "syntax-pipeline-operator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push(["pipelineOperator", {
            proposal: proposal
          }]);
        }
      };
    });

    var syntaxRecordAndTuple = declare(function (api, options) {
      api.assertVersion(7);
      return {
        name: "syntax-record-and-tuple",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          opts.generatorOpts.recordAndTupleSyntaxType = options.syntaxType;
          parserOpts.plugins.push(["recordAndTuple", {
            syntaxType: options.syntaxType
          }]);
        }
      };
    });

    var syntaxTopLevelAwait = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-top-level-await",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("topLevelAwait");
        }
      };
    });

    function removePlugin(plugins, name) {
      var indices = [];
      plugins.forEach(function (plugin, i) {
        var n = Array.isArray(plugin) ? plugin[0] : plugin;

        if (n === name) {
          indices.unshift(i);
        }
      });

      for (var _i = 0, _indices = indices; _i < _indices.length; _i++) {
        var i = _indices[_i];
        plugins.splice(i, 1);
      }
    }

    var syntaxTypescript = declare(function (api, _ref) {
      var isTSX = _ref.isTSX;
      api.assertVersion(7);
      return {
        name: "syntax-typescript",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          var plugins = parserOpts.plugins;
          removePlugin(plugins, "flow");
          removePlugin(plugins, "jsx");
          parserOpts.plugins.push("typescript", "classProperties", "objectRestSpread");

          if (isTSX) {
            parserOpts.plugins.push("jsx");
          }
        }
      };
    });

    var buildAnonymousExpressionWrapper = template.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n");
    var buildNamedExpressionWrapper = template.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n");
    var buildDeclarationWrapper = template("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");

    function classOrObjectMethod(path, callId) {
      var node = path.node;
      var body = node.body;
      var container = FunctionExpression(null, [], BlockStatement(body.body), true);
      body.body = [ReturnStatement(CallExpression(CallExpression(callId, [container]), []))];
      node.async = false;
      node.generator = false;
      path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
    }

    function plainFunction(path, callId) {
      var node = path.node;
      var isDeclaration = path.isFunctionDeclaration();
      var functionId = node.id;
      var wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;

      if (path.isArrowFunctionExpression()) {
        path.arrowFunctionToExpression();
      }

      node.id = null;

      if (isDeclaration) {
        node.type = "FunctionExpression";
      }

      var built = CallExpression(callId, [node]);
      var container = wrapper({
        NAME: functionId || null,
        REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
        FUNCTION: built,
        PARAMS: node.params.reduce(function (acc, param) {
          acc.done = acc.done || isAssignmentPattern(param) || isRestElement(param);

          if (!acc.done) {
            acc.params.push(path.scope.generateUidIdentifier("x"));
          }

          return acc;
        }, {
          params: [],
          done: false
        }).params
      });

      if (isDeclaration) {
        path.replaceWith(container[0]);
        path.insertAfter(container[1]);
      } else {
        var retFunction = container.callee.body.body[1].argument;

        if (!functionId) {
          nameFunction({
            node: retFunction,
            parent: path.parent,
            scope: path.scope
          });
        }

        if (!retFunction || retFunction.id || node.params.length) {
          path.replaceWith(container);
        } else {
          path.replaceWith(built);
        }
      }
    }

    function wrapFunction(path, callId) {
      if (path.isClassMethod() || path.isObjectMethod()) {
        classOrObjectMethod(path, callId);
      } else {
        plainFunction(path, callId);
      }
    }

    var PURE_ANNOTATION = "#__PURE__";

    var isPureAnnotated = function isPureAnnotated(_ref) {
      var leadingComments = _ref.leadingComments;
      return !!leadingComments && leadingComments.some(function (comment) {
        return /[@#]__PURE__/.test(comment.value);
      });
    };

    function annotateAsPure(pathOrNode) {
      var node = pathOrNode.node || pathOrNode;

      if (isPureAnnotated(node)) {
        return;
      }

      addComment(node, "leading", PURE_ANNOTATION);
    }

    var awaitVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      AwaitExpression: function AwaitExpression(path, _ref) {
        var wrapAwait = _ref.wrapAwait;
        var argument = path.get("argument");

        if (path.parentPath.isYieldExpression()) {
          path.replaceWith(argument.node);
          return;
        }

        path.replaceWith(YieldExpression(wrapAwait ? CallExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));
      }
    };
    function remapAsyncToGenerator (path, helpers) {
      path.traverse(awaitVisitor, {
        wrapAwait: helpers.wrapAwait
      });
      var isIIFE = checkIsIIFE(path);
      path.node.async = false;
      path.node.generator = true;
      wrapFunction(path, cloneNode(helpers.wrapAsync));
      var isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();

      if (!isProperty && !isIIFE && path.isExpression()) {
        annotateAsPure(path);
      }

      function checkIsIIFE(path) {
        if (path.parentPath.isCallExpression({
          callee: path.node
        })) {
          return true;
        }

        var parentPath = path.parentPath;

        if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {
          name: "bind"
        })) {
          var bindCall = parentPath.parentPath;
          return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
            callee: bindCall.node
          });
        }

        return false;
      }
    }

    var lib$3 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-async-generators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxAsyncGenerators$1 = unwrapExports(lib$3);

    var buildForAwait = template("\n  async function wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = await ITERATOR_KEY.next(),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = await STEP_KEY.value,\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
    function rewriteForAwait (path, _ref) {
      var getAsyncIterator = _ref.getAsyncIterator;
      var node = path.node,
          scope = path.scope,
          parent = path.parent;
      var stepKey = scope.generateUidIdentifier("step");
      var stepValue = scope.generateUidIdentifier("value");
      var left = node.left;
      var declar;

      if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
        declar = ExpressionStatement(AssignmentExpression("=", left, stepValue));
      } else if (isVariableDeclaration(left)) {
        declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, stepValue)]);
      }

      var template = buildForAwait({
        ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
        ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
        ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
        ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
        GET_ITERATOR: getAsyncIterator,
        OBJECT: node.right,
        STEP_VALUE: stepValue,
        STEP_KEY: stepKey
      });
      template = template.body.body;
      var isLabeledParent = isLabeledStatement(parent);
      var tryBody = template[3].block.body;
      var loop = tryBody[0];

      if (isLabeledParent) {
        tryBody[0] = LabeledStatement(parent.label, loop);
      }

      return {
        replaceParent: isLabeledParent,
        node: template,
        declar: declar,
        loop: loop
      };
    }

    var proposalAsyncGeneratorFunctions = declare(function (api) {
      api.assertVersion(7);
      var yieldStarVisitor = {
        Function: function Function(path) {
          path.skip();
        },
        YieldExpression: function YieldExpression(_ref, state) {
          var node = _ref.node;
          if (!node.delegate) return;
          var callee = state.addHelper("asyncGeneratorDelegate");
          node.argument = CallExpression(callee, [CallExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
        }
      };
      var forAwaitVisitor = {
        Function: function Function(path) {
          path.skip();
        },
        ForOfStatement: function ForOfStatement(path, _ref2) {
          var file = _ref2.file;
          var node = path.node;
          if (!node["await"]) return;
          var build = rewriteForAwait(path, {
            getAsyncIterator: file.addHelper("asyncIterator")
          });
          var declar = build.declar,
              loop = build.loop;
          var block = loop.body;
          path.ensureBlock();

          if (declar) {
            block.body.push(declar);
          }

          block.body = block.body.concat(node.body.body);
          inherits(loop, node);
          inherits(loop.body, node.body);

          if (build.replaceParent) {
            path.parentPath.replaceWithMultiple(build.node);
          } else {
            path.replaceWithMultiple(build.node);
          }
        }
      };
      var visitor = {
        Function: function Function(path, state) {
          if (!path.node.async) return;
          path.traverse(forAwaitVisitor, state);
          if (!path.node.generator) return;
          path.traverse(yieldStarVisitor, state);
          remapAsyncToGenerator(path, {
            wrapAsync: state.addHelper("wrapAsyncGenerator"),
            wrapAwait: state.addHelper("awaitAsyncGenerator")
          });
        }
      };
      return {
        name: "proposal-async-generator-functions",
        inherits: syntaxAsyncGenerators$1,
        visitor: {
          Program: function Program(path, state) {
            path.traverse(visitor, state);
          }
        }
      };
    });

    function assertFieldTransformed(path) {
      if (path.node.declare) {
        throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by " + "@babel/plugin-transform-typescript.\n" + "If you have already enabled that plugin (or '@babel/preset-typescript'), make sure " + "that it runs before any plugin related to additional class features:\n" + " - @babel/plugin-proposal-class-properties\n" + " - @babel/plugin-proposal-private-methods\n" + " - @babel/plugin-proposal-decorators");
      }
    }

    function _templateObject15$1() {
      var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ", "\n    });\n  "]);

      _templateObject15$1 = function _templateObject15() {
        return data;
      };

      return data;
    }

    function _templateObject14$1() {
      var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      })\n    "]);

      _templateObject14$1 = function _templateObject14() {
        return data;
      };

      return data;
    }

    function _templateObject13$1() {
      var data = _taggedTemplateLiteralLoose(["", ".add(", ")"]);

      _templateObject13$1 = function _templateObject13() {
        return data;
      };

      return data;
    }

    function _templateObject12$1() {
      var data = _taggedTemplateLiteralLoose(["\n      ", ".set(", ", {\n        get: ", ",\n        set: ", "\n      });\n    "]);

      _templateObject12$1 = function _templateObject12() {
        return data;
      };

      return data;
    }

    function _templateObject11$2() {
      var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      });\n    "]);

      _templateObject11$2 = function _templateObject11() {
        return data;
      };

      return data;
    }

    function _templateObject10$2() {
      var data = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "]);

      _templateObject10$2 = function _templateObject10() {
        return data;
      };

      return data;
    }

    function _templateObject9$2() {
      var data = _taggedTemplateLiteralLoose(["\n    var ", " = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    };\n  "]);

      _templateObject9$2 = function _templateObject9() {
        return data;
      };

      return data;
    }

    function _templateObject8$2() {
      var data = _taggedTemplateLiteralLoose(["\n      var ", " = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      }\n    "]);

      _templateObject8$2 = function _templateObject8() {
        return data;
      };

      return data;
    }

    function _templateObject7$2() {
      var data = _taggedTemplateLiteralLoose(["", ".set(", ", {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ", ",\n  })"]);

      _templateObject7$2 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$2() {
      var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    });\n  "]);

      _templateObject6$2 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$2() {
      var data = _taggedTemplateLiteralLoose(["BASE(REF, PROP)[PROP]"]);

      _templateObject5$2 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$2() {
      var data = _taggedTemplateLiteralLoose(["var ", " = new WeakMap();"]);

      _templateObject4$2 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$2() {
      var data = _taggedTemplateLiteralLoose(["var ", " = new WeakSet();"]);

      _templateObject3$2 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$2() {
      var data = _taggedTemplateLiteralLoose(["var ", " = new WeakMap();"]);

      _templateObject2$2 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$4() {
      var data = _taggedTemplateLiteralLoose(["\n          var ", " = ", "(\"", "\")\n        "]);

      _templateObject$4 = function _templateObject() {
        return data;
      };

      return data;
    }
    function buildPrivateNamesMap(props) {
      var privateNamesMap = new Map();

      for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;
        var isPrivate = prop.isPrivate();
        var isMethod = !prop.isProperty();
        var isInstance = !prop.node["static"];

        if (isPrivate) {
          var name = prop.node.key.id.name;
          var update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
            id: prop.scope.generateUidIdentifier(name),
            "static": !isInstance,
            method: isMethod
          };

          if (prop.node.kind === "get") {
            update.getId = prop.scope.generateUidIdentifier("get_" + name);
          } else if (prop.node.kind === "set") {
            update.setId = prop.scope.generateUidIdentifier("set_" + name);
          } else if (prop.node.kind === "method") {
            update.methodId = prop.scope.generateUidIdentifier(name);
          }

          privateNamesMap.set(name, update);
        }
      }

      return privateNamesMap;
    }
    function buildPrivateNamesNodes(privateNamesMap, loose, state) {
      var initNodes = [];

      for (var _iterator2 = _createForOfIteratorHelperLoose(privateNamesMap), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _step2.value,
            name = _step2$value[0],
            value = _step2$value[1];
        var id = value.id,
            isStatic = value["static"],
            isMethod = value.method,
            getId = value.getId,
            setId = value.setId;
        var isAccessor = getId || setId;

        if (loose) {
          initNodes.push(template.statement.ast(_templateObject$4(), id, state.addHelper("classPrivateFieldLooseKey"), name));
        } else if (isMethod && !isStatic) {
          if (isAccessor) {
            initNodes.push(template.statement.ast(_templateObject2$2(), id));
          } else {
            initNodes.push(template.statement.ast(_templateObject3$2(), id));
          }
        } else if (!isStatic) {
          initNodes.push(template.statement.ast(_templateObject4$2(), id));
        }
      }

      return initNodes;
    }
    var privateNameVisitor = {
      PrivateName: function PrivateName(path) {
        var privateNamesMap = this.privateNamesMap;
        var node = path.node,
            parentPath = path.parentPath;
        if (!parentPath.isMemberExpression({
          property: node
        })) return;
        if (!privateNamesMap.has(node.id.name)) return;
        this.handle(parentPath);
      },
      Class: function Class(path) {
        var privateNamesMap = this.privateNamesMap;
        var body = path.get("body.body");
        var visiblePrivateNames = new Map(privateNamesMap);
        var redeclared = [];

        for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
          var prop = _step3.value;
          if (!prop.isPrivate()) continue;
          var name = prop.node.key.id.name;
          visiblePrivateNames["delete"](name);
          redeclared.push(name);
        }

        if (!redeclared.length) {
          return;
        }

        path.get("body").traverse(privateNameNestedVisitor, Object.assign({}, this, {
          redeclared: redeclared
        }));
        path.traverse(privateNameVisitor, Object.assign({}, this, {
          privateNamesMap: visiblePrivateNames
        }));
        path.skipKey("body");
      }
    };
    var privateNameNestedVisitor = traverse$1.visitors.merge([{
      PrivateName: function PrivateName(path) {
        var redeclared = this.redeclared;
        var name = path.node.id.name;
        if (redeclared.includes(name)) path.skip();
      }
    }, {
      PrivateName: privateNameVisitor.PrivateName
    }, environmentVisitor]);
    var privateNameHandlerSpec = {
      memoise: function memoise(member, count) {
        var scope = member.scope;
        var object = member.node.object;
        var memo = scope.maybeGenerateMemoised(object);

        if (!memo) {
          return;
        }

        this.memoiser.set(object, memo, count);
      },
      receiver: function receiver(member) {
        var object = member.node.object;

        if (this.memoiser.has(object)) {
          return cloneNode(this.memoiser.get(object));
        }

        return cloneNode(object);
      },
      get: function get(member) {
        var classRef = this.classRef,
            privateNamesMap = this.privateNamesMap,
            file = this.file;
        var name = member.node.property.id.name;

        var _privateNamesMap$get = privateNamesMap.get(name),
            id = _privateNamesMap$get.id,
            isStatic = _privateNamesMap$get["static"],
            isMethod = _privateNamesMap$get.method,
            methodId = _privateNamesMap$get.methodId,
            getId = _privateNamesMap$get.getId,
            setId = _privateNamesMap$get.setId;

        var isAccessor = getId || setId;

        if (isStatic) {
          var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
          return CallExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id)]);
        }

        if (isMethod) {
          if (isAccessor) {
            return CallExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
          }

          return CallExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), cloneNode(id), cloneNode(methodId)]);
        }

        return CallExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
      },
      set: function set(member, value) {
        var classRef = this.classRef,
            privateNamesMap = this.privateNamesMap,
            file = this.file;
        var name = member.node.property.id.name;

        var _privateNamesMap$get2 = privateNamesMap.get(name),
            id = _privateNamesMap$get2.id,
            isStatic = _privateNamesMap$get2["static"],
            isMethod = _privateNamesMap$get2.method,
            setId = _privateNamesMap$get2.setId,
            getId = _privateNamesMap$get2.getId;

        var isAccessor = getId || setId;

        if (isStatic) {
          var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
          return CallExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id), value]);
        }

        if (isMethod) {
          if (setId) {
            return CallExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
          }

          return CallExpression(file.addHelper("classPrivateMethodSet"), []);
        }

        return CallExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
      },
      destructureSet: function destructureSet(member) {
        var privateNamesMap = this.privateNamesMap,
            file = this.file;
        var name = member.node.property.id.name;

        var _privateNamesMap$get3 = privateNamesMap.get(name),
            id = _privateNamesMap$get3.id;

        return MemberExpression(CallExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneNode(id)]), Identifier("value"));
      },
      call: function call(member, args) {
        this.memoise(member, 1);
        return optimiseCall(this.get(member), this.receiver(member), args);
      }
    };
    var privateNameHandlerLoose = {
      handle: function handle(member) {
        var privateNamesMap = this.privateNamesMap,
            file = this.file;
        var object = member.node.object;
        var name = member.node.property.id.name;
        member.replaceWith(template.expression(_templateObject5$2())({
          BASE: file.addHelper("classPrivateFieldLooseBase"),
          REF: object,
          PROP: privateNamesMap.get(name).id
        }));
      }
    };
    function transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {
      if (!privateNamesMap.size) return;
      var body = path.get("body");

      if (loose) {
        body.traverse(privateNameVisitor, Object.assign({
          privateNamesMap: privateNamesMap,
          file: state
        }, privateNameHandlerLoose));
      } else {
        memberExpressionToFunctions(body, privateNameVisitor, Object.assign({
          privateNamesMap: privateNamesMap,
          classRef: ref,
          file: state
        }, privateNameHandlerSpec));
      }
    }

    function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
      var _privateNamesMap$get4 = privateNamesMap.get(prop.node.key.id.name),
          id = _privateNamesMap$get4.id;

      var value = prop.node.value || prop.scope.buildUndefinedNode();
      return template.statement.ast(_templateObject6$2(), ref, id, value);
    }

    function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {
      var _privateNamesMap$get5 = privateNamesMap.get(prop.node.key.id.name),
          id = _privateNamesMap$get5.id;

      var value = prop.node.value || prop.scope.buildUndefinedNode();
      return template.statement.ast(_templateObject7$2(), id, ref, value);
    }

    function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
      var privateName = privateNamesMap.get(prop.node.key.id.name);
      var id = privateName.id,
          getId = privateName.getId,
          setId = privateName.setId,
          initAdded = privateName.initAdded;
      var isAccessor = getId || setId;
      if (!prop.isProperty() && (initAdded || !isAccessor)) return;

      if (isAccessor) {
        privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: true
        }));
        return template.statement.ast(_templateObject8$2(), id.name, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
      }

      var value = prop.node.value || prop.scope.buildUndefinedNode();
      return template.statement.ast(_templateObject9$2(), id, value);
    }

    function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
      var privateName = privateNamesMap.get(prop.node.key.id.name);
      var methodId = privateName.methodId,
          id = privateName.id,
          getId = privateName.getId,
          setId = privateName.setId,
          initAdded = privateName.initAdded;
      if (initAdded) return;

      if (methodId) {
        return template.statement.ast(_templateObject10$2(), ref, id, methodId.name);
      }

      var isAccessor = getId || setId;

      if (isAccessor) {
        privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: true
        }));
        return template.statement.ast(_templateObject11$2(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
      }
    }

    function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {
      var privateName = privateNamesMap.get(prop.node.key.id.name);
      var id = privateName.id,
          getId = privateName.getId,
          setId = privateName.setId,
          initAdded = privateName.initAdded;
      if (initAdded) return;
      var isAccessor = getId || setId;

      if (isAccessor) {
        privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: true
        }));
        return template.statement.ast(_templateObject12$1(), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
      }

      return template.statement.ast(_templateObject13$1(), id, ref);
    }

    function buildPublicFieldInitLoose(ref, prop) {
      var _prop$node = prop.node,
          key = _prop$node.key,
          computed = _prop$node.computed;
      var value = prop.node.value || prop.scope.buildUndefinedNode();
      return ExpressionStatement(AssignmentExpression("=", MemberExpression(ref, key, computed || isLiteral(key)), value));
    }

    function buildPublicFieldInitSpec(ref, prop, state) {
      var _prop$node2 = prop.node,
          key = _prop$node2.key,
          computed = _prop$node2.computed;
      var value = prop.node.value || prop.scope.buildUndefinedNode();
      return ExpressionStatement(CallExpression(state.addHelper("defineProperty"), [ref, computed || isLiteral(key) ? key : StringLiteral(key.name), value]));
    }

    function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
      var privateName = privateNamesMap.get(prop.node.key.id.name);
      var id = privateName.id,
          methodId = privateName.methodId,
          getId = privateName.getId,
          setId = privateName.setId,
          initAdded = privateName.initAdded;
      if (initAdded) return;
      var isAccessor = getId || setId;

      if (isAccessor) {
        privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: true
        }));
        return template.statement.ast(_templateObject14$1(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
      }

      return template.statement.ast(_templateObject15$1(), ref, id, methodId.name);
    }

    function buildPrivateMethodDeclaration(prop, privateNamesMap, loose) {
      if (loose === void 0) {
        loose = false;
      }

      var privateName = privateNamesMap.get(prop.node.key.id.name);
      var id = privateName.id,
          methodId = privateName.methodId,
          getId = privateName.getId,
          setId = privateName.setId,
          getterDeclared = privateName.getterDeclared,
          setterDeclared = privateName.setterDeclared,
          isStatic = privateName["static"];
      var _prop$node3 = prop.node,
          params = _prop$node3.params,
          body = _prop$node3.body,
          generator = _prop$node3.generator,
          async = _prop$node3.async;
      var methodValue = FunctionExpression(methodId, params, body, generator, async);
      var isGetter = getId && !getterDeclared && params.length === 0;
      var isSetter = setId && !setterDeclared && params.length > 0;

      if (isGetter) {
        privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          getterDeclared: true
        }));
        return VariableDeclaration("var", [VariableDeclarator(getId, methodValue)]);
      }

      if (isSetter) {
        privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          setterDeclared: true
        }));
        return VariableDeclaration("var", [VariableDeclarator(setId, methodValue)]);
      }

      if (isStatic && !loose) {
        return VariableDeclaration("var", [VariableDeclarator(id, FunctionExpression(id, params, body, generator, async))]);
      }

      return VariableDeclaration("var", [VariableDeclarator(methodId, methodValue)]);
    }

    var thisContextVisitor = traverse$1.visitors.merge([{
      ThisExpression: function ThisExpression(path, state) {
        state.needsClassRef = true;
        path.replaceWith(cloneNode(state.classRef));
      }
    }, environmentVisitor]);

    function replaceThisContext(path, ref, superRef, file, loose) {
      var state = {
        classRef: ref,
        needsClassRef: false
      };
      var replacer = new ReplaceSupers({
        methodPath: path,
        isLoose: loose,
        superRef: superRef,
        file: file,
        getObjectRef: function getObjectRef() {
          state.needsClassRef = true;
          return path.node["static"] ? ref : MemberExpression(ref, Identifier("prototype"));
        }
      });
      replacer.replace();

      if (path.isProperty()) {
        path.traverse(thisContextVisitor, state);
      }

      return state.needsClassRef;
    }

    function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {
      var staticNodes = [];
      var instanceNodes = [];
      var needsClassRef = false;

      for (var _iterator4 = _createForOfIteratorHelperLoose(props), _step4; !(_step4 = _iterator4()).done;) {
        var prop = _step4.value;
        assertFieldTransformed(prop);
        var isStatic = prop.node["static"];
        var isInstance = !isStatic;
        var isPrivate = prop.isPrivate();
        var isPublic = !isPrivate;
        var isField = prop.isProperty();
        var isMethod = !isField;

        if (isStatic || isMethod && isPrivate) {
          var replaced = replaceThisContext(prop, ref, superRef, state, loose);
          needsClassRef = needsClassRef || replaced;
        }

        switch (true) {
          case isStatic && isPrivate && isField && loose:
            needsClassRef = true;
            staticNodes.push(buildPrivateFieldInitLoose(cloneNode(ref), prop, privateNamesMap));
            break;

          case isStatic && isPrivate && isField && !loose:
            needsClassRef = true;
            staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
            break;

          case isStatic && isPublic && isField && loose:
            needsClassRef = true;
            staticNodes.push(buildPublicFieldInitLoose(cloneNode(ref), prop));
            break;

          case isStatic && isPublic && isField && !loose:
            needsClassRef = true;
            staticNodes.push(buildPublicFieldInitSpec(cloneNode(ref), prop, state));
            break;

          case isInstance && isPrivate && isField && loose:
            instanceNodes.push(buildPrivateFieldInitLoose(ThisExpression(), prop, privateNamesMap));
            break;

          case isInstance && isPrivate && isField && !loose:
            instanceNodes.push(buildPrivateInstanceFieldInitSpec(ThisExpression(), prop, privateNamesMap));
            break;

          case isInstance && isPrivate && isMethod && loose:
            instanceNodes.unshift(buildPrivateMethodInitLoose(ThisExpression(), prop, privateNamesMap));
            staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
            break;

          case isInstance && isPrivate && isMethod && !loose:
            instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(ThisExpression(), prop, privateNamesMap));
            staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
            break;

          case isStatic && isPrivate && isMethod && !loose:
            needsClassRef = true;
            staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
            staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
            break;

          case isStatic && isPrivate && isMethod && loose:
            needsClassRef = true;
            staticNodes.push(buildPrivateStaticMethodInitLoose(cloneNode(ref), prop, state, privateNamesMap));
            staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
            break;

          case isInstance && isPublic && isField && loose:
            instanceNodes.push(buildPublicFieldInitLoose(ThisExpression(), prop));
            break;

          case isInstance && isPublic && isField && !loose:
            instanceNodes.push(buildPublicFieldInitSpec(ThisExpression(), prop, state));
            break;

          default:
            throw new Error("Unreachable.");
        }
      }

      return {
        staticNodes: staticNodes.filter(Boolean),
        instanceNodes: instanceNodes.filter(Boolean),
        wrapClass: function wrapClass(path) {
          for (var _iterator5 = _createForOfIteratorHelperLoose(props), _step5; !(_step5 = _iterator5()).done;) {
            var prop = _step5.value;
            prop.remove();
          }

          if (!needsClassRef) return path;

          if (path.isClassExpression()) {
            path.scope.push({
              id: ref
            });
            path.replaceWith(AssignmentExpression("=", cloneNode(ref), path.node));
          } else if (!path.node.id) {
            path.node.id = ref;
          }

          return path;
        }
      };
    }

    function _templateObject4$3() {
      var data = _taggedTemplateLiteralLoose(["", "(this)"]);

      _templateObject4$3 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$3() {
      var data = _taggedTemplateLiteralLoose(["let ", " = ", ""]);

      _templateObject3$3 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$3() {
      var data = _taggedTemplateLiteralLoose(["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "]);

      _templateObject2$3 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$5() {
      var data = _taggedTemplateLiteralLoose(["return ", ""]);

      _templateObject$5 = function _templateObject() {
        return data;
      };

      return data;
    }
    function hasOwnDecorators(node) {
      return !!(node.decorators && node.decorators.length);
    }
    function hasDecorators(node) {
      return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
    }

    function prop(key, value) {
      if (!value) return null;
      return ObjectProperty(Identifier(key), value);
    }

    function method(key, body) {
      return ObjectMethod("method", Identifier(key), [], BlockStatement(body));
    }

    function takeDecorators(node) {
      var result;

      if (node.decorators && node.decorators.length > 0) {
        result = ArrayExpression(node.decorators.map(function (decorator) {
          return decorator.expression;
        }));
      }

      node.decorators = undefined;
      return result;
    }

    function getKey(node) {
      if (node.computed) {
        return node.key;
      } else if (isIdentifier(node.key)) {
        return StringLiteral(node.key.name);
      } else {
        return StringLiteral(String(node.key.value));
      }
    }

    function extractElementDescriptor(classRef, superRef, path) {
      var node = path.node,
          scope = path.scope;
      var isMethod = path.isClassMethod();

      if (path.isPrivate()) {
        throw path.buildCodeFrameError("Private " + (isMethod ? "methods" : "fields") + " in decorated classes are not supported yet.");
      }

      new ReplaceSupers({
        methodPath: path,
        methodNode: node,
        objectRef: classRef,
        isStatic: node["static"],
        superRef: superRef,
        scope: scope,
        file: this
      }, true).replace();
      var properties = [prop("kind", StringLiteral(isMethod ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node["static"] && BooleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);

      if (isMethod) {
        var id = node.computed ? null : node.key;
        toExpression(node);
        properties.push(prop("value", nameFunction({
          node: node,
          id: id,
          scope: scope
        }) || node));
      } else if (node.value) {
        properties.push(method("value", template.statements.ast(_templateObject$5(), node.value)));
      } else {
        properties.push(prop("value", scope.buildUndefinedNode()));
      }

      path.remove();
      return ObjectExpression(properties);
    }

    function addDecorateHelper(file) {
      try {
        return file.addHelper("decorate");
      } catch (err) {
        if (err.code === "BABEL_HELPER_UNKNOWN") {
          err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode" + " requires '@babel/core' version ^7.0.2 and you appear to be using" + " an older version.";
        }

        throw err;
      }
    }

    function buildDecoratedClass(ref, path, elements, file) {
      var node = path.node,
          scope = path.scope;
      var initializeId = scope.generateUidIdentifier("initialize");
      var isDeclaration = node.id && path.isDeclaration();
      var isStrict = path.isInStrictMode();
      var superClass = node.superClass;
      node.type = "ClassDeclaration";
      if (!node.id) node.id = cloneNode(ref);
      var superId;

      if (superClass) {
        superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
        node.superClass = superId;
      }

      var classDecorators = takeDecorators(node);
      var definitions = ArrayExpression(elements.filter(function (element) {
        return !element.node["abstract"];
      }).map(extractElementDescriptor.bind(file, node.id, superId)));
      var replacement = template.expression.ast(_templateObject2$3(), addDecorateHelper(file), classDecorators || NullLiteral(), initializeId, superClass ? superId : null, node, cloneNode(node.id), definitions, superClass);
      var classPathDesc = "arguments.1.body.body.0";

      if (!isStrict) {
        replacement.arguments[1].body.directives.push(Directive(DirectiveLiteral("use strict")));
      }

      if (isDeclaration) {
        replacement = template.ast(_templateObject3$3(), ref, replacement);
        classPathDesc = "declarations.0.init." + classPathDesc;
      }

      return {
        instanceNodes: [template.statement.ast(_templateObject4$3(), initializeId)],
        wrapClass: function wrapClass(path) {
          path.replaceWith(replacement);
          return path.get(classPathDesc);
        }
      };
    }

    function _templateObject$6() {
      var data = _taggedTemplateLiteralLoose(["super(...args)"]);

      _templateObject$6 = function _templateObject() {
        return data;
      };

      return data;
    }
    var findBareSupers = traverse$1.visitors.merge([{
      Super: function Super(path) {
        var node = path.node,
            parentPath = path.parentPath;

        if (parentPath.isCallExpression({
          callee: node
        })) {
          this.push(parentPath);
        }
      }
    }, environmentVisitor]);
    var referenceVisitor$1 = {
      "TSTypeAnnotation|TypeAnnotation": function TSTypeAnnotationTypeAnnotation(path) {
        path.skip();
      },
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        if (this.scope.hasOwnBinding(path.node.name)) {
          this.scope.rename(path.node.name);
          path.skip();
        }
      }
    };

    function handleClassTDZ(path, state) {
      if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
        var classNameTDZError = state.file.addHelper("classNameTDZError");
        var throwNode = CallExpression(classNameTDZError, [StringLiteral(path.node.name)]);
        path.replaceWith(SequenceExpression([throwNode, path.node]));
        path.skip();
      }
    }

    var classFieldDefinitionEvaluationTDZVisitor = {
      ReferencedIdentifier: handleClassTDZ
    };
    function injectInitialization(path, constructor, nodes, renamer) {
      if (!nodes.length) return;
      var isDerived = !!path.node.superClass;

      if (!constructor) {
        var newConstructor = ClassMethod("constructor", Identifier("constructor"), [], BlockStatement([]));

        if (isDerived) {
          newConstructor.params = [RestElement(Identifier("args"))];
          newConstructor.body.body.push(template.statement.ast(_templateObject$6()));
        }

        var _path$get$unshiftCont = path.get("body").unshiftContainer("body", newConstructor);

        constructor = _path$get$unshiftCont[0];
      }

      if (renamer) {
        renamer(referenceVisitor$1, {
          scope: constructor.scope
        });
      }

      if (isDerived) {
        var bareSupers = [];
        constructor.traverse(findBareSupers, bareSupers);

        for (var _i = 0, _bareSupers = bareSupers; _i < _bareSupers.length; _i++) {
          var bareSuper = _bareSupers[_i];
          bareSuper.insertAfter(nodes);
        }
      } else {
        constructor.get("body").unshiftContainer("body", nodes);
      }
    }
    function extractComputedKeys(ref, path, computedPaths, file) {
      var declarations = [];
      var state = {
        classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
        file: file
      };

      for (var _iterator = _createForOfIteratorHelperLoose(computedPaths), _step; !(_step = _iterator()).done;) {
        var computedPath = _step.value;
        var computedKey = computedPath.get("key");

        if (computedKey.isReferencedIdentifier()) {
          handleClassTDZ(computedKey, state);
        } else {
          computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
        }

        var computedNode = computedPath.node;

        if (!computedKey.isConstantExpression()) {
          var ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
          path.scope.push({
            id: ident,
            kind: "let"
          });
          declarations.push(ExpressionStatement(AssignmentExpression("=", cloneNode(ident), computedNode.key)));
          computedNode.key = cloneNode(ident);
        }
      }

      return declarations;
    }

    var FEATURES = Object.freeze({
      fields: 1 << 1,
      privateMethods: 1 << 2,
      decorators: 1 << 3
    });
    var featuresKey = "@babel/plugin-class-features/featuresKey";
    var looseKey = "@babel/plugin-class-features/looseKey";
    function enableFeature(file, feature, loose) {
      if (!hasFeature(file, feature)) {
        file.set(featuresKey, file.get(featuresKey) | feature);
        if (loose) file.set(looseKey, file.get(looseKey) | feature);
      }
    }

    function hasFeature(file, feature) {
      return !!(file.get(featuresKey) & feature);
    }

    function isLoose(file, feature) {
      return !!(file.get(looseKey) & feature);
    }
    function verifyUsedFeatures(path, file) {
      if (hasOwnDecorators(path.node)) {
        if (!hasFeature(file, FEATURES.decorators)) {
          throw path.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "legacy": true }], ' + 'make sure it comes *before* "@babel/plugin-proposal-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n' + '\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
        }

        if (path.isPrivate()) {
          throw path.buildCodeFrameError("Private " + (path.isClassMethod() ? "methods" : "fields") + " in decorated classes are not supported yet.");
        }
      }

      if (path.isPrivate() && path.isMethod()) {
        if (!hasFeature(file, FEATURES.privateMethods)) {
          throw path.buildCodeFrameError("Class private methods are not enabled.");
        }
      }

      if (hasFeature(file, FEATURES.privateMethods) && hasFeature(file, FEATURES.fields) && isLoose(file, FEATURES.privateMethods) !== isLoose(file, FEATURES.fields)) {
        throw path.buildCodeFrameError("'loose' mode configuration must be the same for both @babel/plugin-proposal-class-properties " + "and @babel/plugin-proposal-private-methods");
      }

      if (path.isProperty()) {
        if (!hasFeature(file, FEATURES.fields)) {
          throw path.buildCodeFrameError("Class fields are not enabled.");
        }
      }
    }

    var name = "@babel/helper-create-class-features-plugin";
    var version$2 = "7.9.5";
    var author = "The Babel Team (https://babeljs.io/team)";
    var license = "MIT";
    var description = "Compile class public and private fields, private methods and decorators to ES6";
    var repository = "https://github.com/babel/babel/tree/master/packages/babel-helper-create-class-features-plugin";
    var main = "lib/index.js";
    var publishConfig = {
    	access: "public"
    };
    var keywords$2 = [
    	"babel",
    	"babel-plugin"
    ];
    var dependencies = {
    	"@babel/helper-function-name": "^7.9.5",
    	"@babel/helper-member-expression-to-functions": "^7.8.3",
    	"@babel/helper-optimise-call-expression": "^7.8.3",
    	"@babel/helper-plugin-utils": "^7.8.3",
    	"@babel/helper-replace-supers": "^7.8.6",
    	"@babel/helper-split-export-declaration": "^7.8.3"
    };
    var peerDependencies = {
    	"@babel/core": "^7.0.0"
    };
    var devDependencies = {
    	"@babel/core": "^7.8.6",
    	"@babel/helper-plugin-test-runner": "^7.8.3"
    };
    var pkg = {
    	name: name,
    	version: version$2,
    	author: author,
    	license: license,
    	description: description,
    	repository: repository,
    	main: main,
    	publishConfig: publishConfig,
    	keywords: keywords$2,
    	dependencies: dependencies,
    	peerDependencies: peerDependencies,
    	devDependencies: devDependencies
    };

    var version$3 = pkg.version.split(".").reduce(function (v, x) {
      return v * 1e5 + +x;
    }, 0);
    var versionKey = "@babel/plugin-class-features/version";
    function createClassFeaturePlugin(_ref) {
      var name = _ref.name,
          feature = _ref.feature,
          loose = _ref.loose,
          manipulateOptions = _ref.manipulateOptions;
      return {
        name: name,
        manipulateOptions: manipulateOptions,
        pre: function pre() {
          enableFeature(this.file, feature, loose);

          if (!this.file.get(versionKey) || this.file.get(versionKey) < version$3) {
            this.file.set(versionKey, version$3);
          }
        },
        visitor: {
          Class: function Class(path, state) {
            if (this.file.get(versionKey) !== version$3) return;
            verifyUsedFeatures(path, this.file);
            var loose = isLoose(this.file, feature);
            var constructor;
            var isDecorated = hasOwnDecorators(path.node);
            var props = [];
            var elements = [];
            var computedPaths = [];
            var privateNames = new Set();
            var body = path.get("body");

            for (var _iterator = _createForOfIteratorHelperLoose(body.get("body")), _step; !(_step = _iterator()).done;) {
              var _path = _step.value;
              verifyUsedFeatures(_path, this.file);

              if (_path.node.computed) {
                computedPaths.push(_path);
              }

              if (_path.isPrivate()) {
                var _name = _path.node.key.id.name;
                var getName = "get " + _name;
                var setName = "set " + _name;

                if (_path.node.kind === "get") {
                  if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }

                  privateNames.add(getName).add(_name);
                } else if (_path.node.kind === "set") {
                  if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }

                  privateNames.add(setName).add(_name);
                } else {
                  if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }

                  privateNames.add(_name);
                }
              }

              if (_path.isClassMethod({
                kind: "constructor"
              })) {
                constructor = _path;
              } else {
                elements.push(_path);

                if (_path.isProperty() || _path.isPrivate()) {
                  props.push(_path);
                }
              }

              if (!isDecorated) isDecorated = hasOwnDecorators(_path.node);
            }

            if (!props.length && !isDecorated) return;
            var ref;

            if (path.isClassExpression() || !path.node.id) {
              nameFunction(path);
              ref = path.scope.generateUidIdentifier("class");
            } else {
              ref = path.node.id;
            }

            var privateNamesMap = buildPrivateNamesMap(props);
            var privateNamesNodes = buildPrivateNamesNodes(privateNamesMap, loose, state);
            transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state);
            var keysNodes, staticNodes, instanceNodes, wrapClass;

            if (isDecorated) {
              staticNodes = keysNodes = [];

              var _buildDecoratedClass = buildDecoratedClass(ref, path, elements, this.file);

              instanceNodes = _buildDecoratedClass.instanceNodes;
              wrapClass = _buildDecoratedClass.wrapClass;
            } else {
              keysNodes = extractComputedKeys(ref, path, computedPaths, this.file);

              var _buildFieldsInitNodes = buildFieldsInitNodes(ref, path.node.superClass, props, privateNamesMap, state, loose);

              staticNodes = _buildFieldsInitNodes.staticNodes;
              instanceNodes = _buildFieldsInitNodes.instanceNodes;
              wrapClass = _buildFieldsInitNodes.wrapClass;
            }

            if (instanceNodes.length > 0) {
              injectInitialization(path, constructor, instanceNodes, function (referenceVisitor, state) {
                if (isDecorated) return;

                for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
                  var prop = _step2.value;
                  if (prop.node["static"]) continue;
                  prop.traverse(referenceVisitor, state);
                }
              });
            }

            path = wrapClass(path);
            path.insertBefore(keysNodes);
            path.insertAfter([].concat(privateNamesNodes, staticNodes));
          },
          PrivateName: function PrivateName(path) {
            if (this.file.get(versionKey) !== version$3) return;
            throw path.buildCodeFrameError("Unknown PrivateName \"" + path + "\"");
          },
          ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
            if (this.file.get(versionKey) !== version$3) return;
            var decl = path.get("declaration");

            if (decl.isClassDeclaration() && hasDecorators(decl.node)) {
              if (decl.node.id) {
                splitExportDeclaration(path);
              } else {
                decl.node.type = "ClassExpression";
              }
            }
          }
        }
      };
    }

    var proposalClassProperties = declare(function (api, options) {
      api.assertVersion(7);
      return createClassFeaturePlugin({
        name: "proposal-class-properties",
        feature: FEATURES.fields,
        loose: options.loose,
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties");
        }
      });
    });

    var buildClassDecorator = template("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n");
    var buildClassPrototype = template("\n  CLASS_REF.prototype;\n");
    var buildGetDescriptor = template("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n");
    var buildGetObjectInitializer = template("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n");
    var WARNING_CALLS = new WeakSet();

    function applyEnsureOrdering(path) {
      var decorators = (path.isClass() ? [path].concat(path.get("body.body")) : path.get("properties")).reduce(function (acc, prop) {
        return acc.concat(prop.node.decorators || []);
      }, []);
      var identDecorators = decorators.filter(function (decorator) {
        return !isIdentifier(decorator.expression);
      });
      if (identDecorators.length === 0) return;
      return SequenceExpression(identDecorators.map(function (decorator) {
        var expression = decorator.expression;
        var id = decorator.expression = path.scope.generateDeclaredUidIdentifier("dec");
        return AssignmentExpression("=", id, expression);
      }).concat([path.node]));
    }

    function applyClassDecorators(classPath) {
      if (!hasClassDecorators(classPath.node)) return;
      var decorators = classPath.node.decorators || [];
      classPath.node.decorators = null;
      var name = classPath.scope.generateDeclaredUidIdentifier("class");
      return decorators.map(function (dec) {
        return dec.expression;
      }).reverse().reduce(function (acc, decorator) {
        return buildClassDecorator({
          CLASS_REF: cloneNode(name),
          DECORATOR: cloneNode(decorator),
          INNER: acc
        }).expression;
      }, classPath.node);
    }

    function hasClassDecorators(classNode) {
      return !!(classNode.decorators && classNode.decorators.length);
    }

    function applyMethodDecorators(path, state) {
      if (!hasMethodDecorators(path.node.body.body)) return;
      return applyTargetDecorators(path, state, path.node.body.body);
    }

    function hasMethodDecorators(body) {
      return body.some(function (node) {
        return node.decorators && node.decorators.length;
      });
    }

    function applyObjectDecorators(path, state) {
      if (!hasMethodDecorators(path.node.properties)) return;
      return applyTargetDecorators(path, state, path.node.properties);
    }

    function applyTargetDecorators(path, state, decoratedProps) {
      var name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
      var exprs = decoratedProps.reduce(function (acc, node) {
        var decorators = node.decorators || [];
        node.decorators = null;
        if (decorators.length === 0) return acc;

        if (node.computed) {
          throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
        }

        var property = isLiteral(node.key) ? node.key : StringLiteral(node.key.name);
        var target = path.isClass() && !node["static"] ? buildClassPrototype({
          CLASS_REF: name
        }).expression : name;

        if (isClassProperty(node, {
          "static": false
        })) {
          var descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
          var initializer = node.value ? FunctionExpression(null, [], BlockStatement([ReturnStatement(node.value)])) : NullLiteral();
          node.value = CallExpression(state.addHelper("initializerWarningHelper"), [descriptor, ThisExpression()]);
          WARNING_CALLS.add(node.value);
          acc = acc.concat([AssignmentExpression("=", descriptor, CallExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), ArrayExpression(decorators.map(function (dec) {
            return cloneNode(dec.expression);
          })), ObjectExpression([ObjectProperty(Identifier("configurable"), BooleanLiteral(true)), ObjectProperty(Identifier("enumerable"), BooleanLiteral(true)), ObjectProperty(Identifier("writable"), BooleanLiteral(true)), ObjectProperty(Identifier("initializer"), initializer)])]))]);
        } else {
          acc = acc.concat(CallExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), ArrayExpression(decorators.map(function (dec) {
            return cloneNode(dec.expression);
          })), isObjectProperty(node) || isClassProperty(node, {
            "static": true
          }) ? buildGetObjectInitializer({
            TEMP: path.scope.generateDeclaredUidIdentifier("init"),
            TARGET: cloneNode(target),
            PROPERTY: cloneNode(property)
          }).expression : buildGetDescriptor({
            TARGET: cloneNode(target),
            PROPERTY: cloneNode(property)
          }).expression, cloneNode(target)]));
        }

        return acc;
      }, []);
      return SequenceExpression([AssignmentExpression("=", cloneNode(name), path.node), SequenceExpression(exprs), cloneNode(name)]);
    }

    function decoratedClassToExpression(_ref) {
      var node = _ref.node,
          scope = _ref.scope;

      if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
        return;
      }

      var ref = node.id ? cloneNode(node.id) : scope.generateUidIdentifier("class");
      return VariableDeclaration("let", [VariableDeclarator(ref, toExpression(node))]);
    }

    var legacyVisitor = {
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
        var decl = path.get("declaration");
        if (!decl.isClassDeclaration()) return;
        var replacement = decoratedClassToExpression(decl);

        if (replacement) {
          var _path$replaceWithMult = path.replaceWithMultiple([replacement, ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(replacement.declarations[0].id), Identifier("default"))])]),
              varDeclPath = _path$replaceWithMult[0];

          if (!decl.node.id) {
            path.scope.registerDeclaration(varDeclPath);
          }
        }
      },
      ClassDeclaration: function ClassDeclaration(path) {
        var replacement = decoratedClassToExpression(path);

        if (replacement) {
          path.replaceWith(replacement);
        }
      },
      ClassExpression: function ClassExpression(path, state) {
        var decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);
        if (decoratedClass) path.replaceWith(decoratedClass);
      },
      ObjectExpression: function ObjectExpression(path, state) {
        var decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
        if (decoratedObject) path.replaceWith(decoratedObject);
      },
      AssignmentExpression: function AssignmentExpression(path, state) {
        if (!WARNING_CALLS.has(path.node.right)) return;
        path.replaceWith(CallExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("left.object").node), StringLiteral(path.get("left.property").node.name || path.get("left.property").node.value), cloneNode(path.get("right.arguments")[0].node), cloneNode(path.get("right.arguments")[1].node)]));
      },
      CallExpression: function CallExpression$1(path, state) {
        if (path.node.arguments.length !== 3) return;
        if (!WARNING_CALLS.has(path.node.arguments[2])) return;

        if (path.node.callee.name !== state.addHelper("defineProperty").name) {
          return;
        }

        path.replaceWith(CallExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("arguments")[0].node), cloneNode(path.get("arguments")[1].node), cloneNode(path.get("arguments.2.arguments")[0].node), cloneNode(path.get("arguments.2.arguments")[1].node)]));
      }
    };

    var proposalDecorators = declare(function (api, options) {
      api.assertVersion(7);
      var _options$legacy = options.legacy,
          legacy = _options$legacy === void 0 ? false : _options$legacy;

      if (typeof legacy !== "boolean") {
        throw new Error("'legacy' must be a boolean.");
      }

      var decoratorsBeforeExport = options.decoratorsBeforeExport;

      if (decoratorsBeforeExport === undefined) {
        if (!legacy) {
          throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you want to use the legacy" + " decorators semantics, you can set the 'legacy: true' option.");
        }
      } else {
        if (legacy) {
          throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
        }

        if (typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
        }
      }

      if (legacy) {
        return {
          name: "proposal-decorators",
          inherits: syntaxDecorators,
          manipulateOptions: function manipulateOptions(_ref) {
            var generatorOpts = _ref.generatorOpts;
            generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
          },
          visitor: legacyVisitor
        };
      }

      return createClassFeaturePlugin({
        name: "proposal-decorators",
        feature: FEATURES.decorators,
        manipulateOptions: function manipulateOptions(_ref2) {
          var generatorOpts = _ref2.generatorOpts,
              parserOpts = _ref2.parserOpts;
          parserOpts.plugins.push(["decorators", {
            decoratorsBeforeExport: decoratorsBeforeExport
          }]);
          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
        }
      });
    });

    var proposalDoExpressions = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-do-expressions",
        inherits: syntaxDoExpressions,
        visitor: {
          DoExpression: {
            exit: function exit(path) {
              var body = path.node.body.body;

              if (body.length) {
                path.replaceExpressionWithStatements(body);
              } else {
                path.replaceWith(path.scope.buildUndefinedNode());
              }
            }
          }
        }
      };
    });

    var lib$4 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-dynamic-import",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("dynamicImport");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxDynamicImport = unwrapExports(lib$4);

    var version$4 = "7.8.3";

    var SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
    var MODULES_NOT_FOUND = "@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n";
    var proposalDynamicImport = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-dynamic-import",
        inherits: syntaxDynamicImport,
        pre: function pre() {
          this.file.set("@babel/plugin-proposal-dynamic-import", version$4);
        },
        visitor: {
          Program: function Program() {
            var modules = this.file.get("@babel/plugin-transform-modules-*");

            if (!SUPPORTED_MODULES.includes(modules)) {
              throw new Error(MODULES_NOT_FOUND);
            }
          }
        }
      };
    });

    function makeVisitor(t, targetGlobal) {
      if (targetGlobal === void 0) {
        targetGlobal = "HandledPromise";
      }

      var isSendOnlyExpression = function isSendOnlyExpression(path) {
        var ourParent = path.parent;

        switch (ourParent.type) {
          case "ExpressionStatement":
            {
              var maybeProgram = path.parentPath.parent;

              if (maybeProgram.type === "Program") {
                return maybeProgram.body[maybeProgram.body.length - 1] !== ourParent;
              }

              return true;
            }

          case "UnaryExpression":
            {
              return ourParent.operator === "void";
            }

          default:
            return false;
        }
      };

      var fullTarget = function fullTarget(path, id) {
        switch (targetGlobal) {
          case "HandledPromise":
            {
              var sfx = isSendOnlyExpression(path) ? "SendOnly" : "";
              var targetMember;

              switch (id) {
                case "eventualGet":
                  targetMember = "get" + sfx;
                  break;

                case "eventualSend":
                  targetMember = "applyMethod" + sfx;
                  break;

                case "eventualApply":
                  targetMember = "applyFunction" + sfx;
                  break;
              }

              return t.memberExpression(t.identifier(targetGlobal), t.identifier(targetMember));
            }

          case "Promise":
            {
              var _sfx = isSendOnlyExpression(path) ? "Only" : "";

              var _targetMember = "" + id + _sfx;

              return t.memberExpression(t.identifier(targetGlobal), t.identifier(_targetMember));
            }
        }
      };

      return {
        EventualMemberExpression: function EventualMemberExpression(path) {
          var node = path.node;
          var object = node.object,
              computed = node.computed,
              property = node.property;
          var target = fullTarget(path, "eventualGet");
          var targs = [];
          targs.push(object);

          if (computed) {
            targs.push(property);
          } else {
            targs.push(t.stringLiteral(property.name));
          }

          path.replaceWith(t.callExpression(target, targs));
        },
        EventualCallExpression: function EventualCallExpression(path) {
          var node = path.node;
          var callee = node.callee,
              args = node.arguments;
          var target = fullTarget(path, "eventualApply");
          var targs = [];
          targs.push(callee);
          targs.push(t.arrayExpression(args));
          path.replaceWith(t.callExpression(target, targs));
        },
        EventualMemberCallExpression: function EventualMemberCallExpression(path) {
          var node = path.node;
          var callee = node.callee,
              property = node.property,
              computed = node.computed,
              args = node.arguments;
          var target = fullTarget(path, "eventualSend");
          var targs = [];
          targs.push(callee);

          if (computed) {
            targs.push(property);
          } else {
            targs.push(t.stringLiteral(property.name));
          }

          targs.push(t.arrayExpression(args));
          path.replaceWith(t.callExpression(target, targs));
        }
      };
    }

    var DEFAULT_TARGET_GLOBAL = "HandledPromise";
    var targetGlobals = ["Promise", "HandledPromise"];
    var proposalEventualSend = declare(function (api, options) {
      var types = api.types;
      api.assertVersion(7);
      var _options$targetGlobal = options.targetGlobal,
          targetGlobal = _options$targetGlobal === void 0 ? DEFAULT_TARGET_GLOBAL : _options$targetGlobal;

      if (typeof targetGlobal !== "string" || !targetGlobals.includes(targetGlobal)) {
        throw new Error("The eventual send plugin requires a 'targetGlobal' option." + "'targetGlobal' must be one of: " + targetGlobals.join(", ") + ".");
      }

      return {
        name: "proposal-eventual-send",
        inherits: syntaxEventualSend,
        visitor: makeVisitor(types, targetGlobal)
      };
    });

    var proposalExportDefaultFrom = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-export-default-from",
        inherits: syntaxExportDefaultFrom,
        visitor: {
          ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
            var node = path.node,
                scope = path.scope;
            var specifiers = node.specifiers;
            if (!isExportDefaultSpecifier(specifiers[0])) return;
            var specifier = specifiers.shift();
            var exported = specifier.exported;
            var uid = scope.generateUidIdentifier(exported.name);
            var nodes = [ImportDeclaration([ImportDefaultSpecifier(uid)], cloneNode(node.source)), ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(uid), exported)])];

            if (specifiers.length >= 1) {
              nodes.push(node);
            }

            var _path$replaceWithMult = path.replaceWithMultiple(nodes),
                importDeclaration = _path$replaceWithMult[0];

            path.scope.registerDeclaration(importDeclaration);
          }
        }
      };
    });

    var lib$5 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-export-namespace-from",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("exportNamespaceFrom");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxExportNamespaceFrom = unwrapExports(lib$5);

    var proposalExportNamespaceFrom = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-export-namespace-from",
        inherits: syntaxExportNamespaceFrom,
        visitor: {
          ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
            var node = path.node,
                scope = path.scope;
            var specifiers = node.specifiers;
            var index = isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
            if (!isExportNamespaceSpecifier(specifiers[index])) return;
            var nodes = [];

            if (index === 1) {
              nodes.push(ExportNamedDeclaration(null, [specifiers.shift()], node.source));
            }

            var specifier = specifiers.shift();
            var exported = specifier.exported;
            var uid = scope.generateUidIdentifier(exported.name);
            nodes.push(ImportDeclaration([ImportNamespaceSpecifier(uid)], cloneNode(node.source)), ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(uid), exported)]));

            if (node.specifiers.length >= 1) {
              nodes.push(node);
            }

            var _path$replaceWithMult = path.replaceWithMultiple(nodes),
                importDeclaration = _path$replaceWithMult[0];

            path.scope.registerDeclaration(importDeclaration);
          }
        }
      };
    });

    var proposalFunctionBind = declare(function (api) {
      api.assertVersion(7);

      function getTempId(scope) {
        var id = scope.path.getData("functionBind");
        if (id) return id;
        id = scope.generateDeclaredUidIdentifier("context");
        return scope.path.setData("functionBind", id);
      }

      function getStaticContext(bind, scope) {
        var object = bind.object || bind.callee.object;
        return scope.isStatic(object) && object;
      }

      function inferBindContext(bind, scope) {
        var staticContext = getStaticContext(bind, scope);
        if (staticContext) return cloneNode(staticContext);
        var tempId = getTempId(scope);

        if (bind.object) {
          bind.callee = SequenceExpression([AssignmentExpression("=", tempId, bind.object), bind.callee]);
        } else {
          bind.callee.object = AssignmentExpression("=", tempId, bind.callee.object);
        }

        return tempId;
      }

      return {
        name: "proposal-function-bind",
        inherits: syntaxFunctionBind,
        visitor: {
          CallExpression: function CallExpression(_ref) {
            var node = _ref.node,
                scope = _ref.scope;
            var bind = node.callee;
            if (!isBindExpression(bind)) return;
            var context = inferBindContext(bind, scope);
            node.callee = MemberExpression(bind.callee, Identifier("call"));
            node.arguments.unshift(context);
          },
          BindExpression: function BindExpression(path) {
            var node = path.node,
                scope = path.scope;
            var context = inferBindContext(node, scope);
            path.replaceWith(CallExpression(MemberExpression(node.callee, Identifier("bind")), [context]));
          }
        }
      };
    });

    var proposalFunctionSent = declare(function (api) {
      api.assertVersion(7);

      var isFunctionSent = function isFunctionSent(node) {
        return isIdentifier(node.meta, {
          name: "function"
        }) && isIdentifier(node.property, {
          name: "sent"
        });
      };

      var hasBeenReplaced = function hasBeenReplaced(node, sentId) {
        return isAssignmentExpression(node) && isIdentifier(node.left, {
          name: sentId
        });
      };

      var yieldVisitor = {
        Function: function Function(path) {
          path.skip();
        },
        YieldExpression: function YieldExpression(path) {
          if (!hasBeenReplaced(path.parent, this.sentId)) {
            path.replaceWith(AssignmentExpression("=", Identifier(this.sentId), path.node));
          }
        },
        MetaProperty: function MetaProperty(path) {
          if (isFunctionSent(path.node)) {
            path.replaceWith(Identifier(this.sentId));
          }
        }
      };
      return {
        name: "proposal-function-sent",
        inherits: syntaxFunctionSent,
        visitor: {
          MetaProperty: function MetaProperty(path, state) {
            if (!isFunctionSent(path.node)) return;
            var fnPath = path.getFunctionParent();

            if (!fnPath.node.generator) {
              throw new Error("Parent generator function not found");
            }

            var sentId = path.scope.generateUid("function.sent");
            fnPath.traverse(yieldVisitor, {
              sentId: sentId
            });
            fnPath.node.body.body.unshift(VariableDeclaration("let", [VariableDeclarator(Identifier(sentId), YieldExpression())]));
            wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
          }
        }
      };
    });

    var lib$6 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-json-strings",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("jsonStrings");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxJsonStrings = unwrapExports(lib$6);

    var proposalJsonStrings = declare(function (api) {
      api.assertVersion(7);
      var regex = /(\\*)([\u2028\u2029])/g;

      function replace(match, escapes, separator) {
        var isEscaped = escapes.length % 2 === 1;
        if (isEscaped) return match;
        return escapes + "\\u" + separator.charCodeAt(0).toString(16);
      }

      return {
        name: "proposal-json-strings",
        inherits: syntaxJsonStrings,
        visitor: {
          "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(_ref) {
            var node = _ref.node;
            var extra = node.extra;
            if (!extra || !extra.raw) return;
            extra.raw = extra.raw.replace(regex, replace);
          }
        }
      };
    });

    var syntaxLogicalAssignmentOperators = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-logical-assignment-operators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("logicalAssignment");
        }
      };
    });

    var proposalLogicalAssignmentOperators = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-logical-assignment-operators",
        inherits: syntaxLogicalAssignmentOperators,
        visitor: {
          AssignmentExpression: function AssignmentExpression$1(path) {
            var node = path.node,
                scope = path.scope;
            var operator = node.operator,
                left = node.left,
                right = node.right;

            if (operator !== "||=" && operator !== "&&=" && operator !== "??=") {
              return;
            }

            var lhs = cloneNode(left);

            if (isMemberExpression(left)) {
              var object = left.object,
                  property = left.property,
                  computed = left.computed;
              var memo = scope.maybeGenerateMemoised(object);

              if (memo) {
                left.object = memo;
                lhs.object = AssignmentExpression("=", cloneNode(memo), object);
              }

              if (computed) {
                var _memo = scope.maybeGenerateMemoised(property);

                if (_memo) {
                  left.property = _memo;
                  lhs.property = AssignmentExpression("=", cloneNode(_memo), property);
                }
              }
            }

            path.replaceWith(LogicalExpression(operator.slice(0, -1), lhs, AssignmentExpression("=", left, right)));
          }
        }
      };
    });

    var lib$7 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-nullish-coalescing-operator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxNullishCoalescingOperator = unwrapExports(lib$7);

    var proposalNullishCoalescingOperator = declare(function (api, _ref) {
      var _ref$loose = _ref.loose,
          loose = _ref$loose === void 0 ? false : _ref$loose;
      api.assertVersion(7);
      return {
        name: "proposal-nullish-coalescing-operator",
        inherits: syntaxNullishCoalescingOperator,
        visitor: {
          LogicalExpression: function LogicalExpression$1(path) {
            var node = path.node,
                scope = path.scope;

            if (node.operator !== "??") {
              return;
            }

            var ref = scope.maybeGenerateMemoised(node.left);
            var assignment;

            if (ref === null) {
              ref = node.left;
              assignment = cloneNode(node.left);
            } else {
              assignment = AssignmentExpression("=", ref, node.left);
            }

            path.replaceWith(ConditionalExpression(loose ? BinaryExpression("!=", assignment, NullLiteral()) : LogicalExpression("&&", BinaryExpression("!==", assignment, NullLiteral()), BinaryExpression("!==", cloneNode(ref), scope.buildUndefinedNode())), cloneNode(ref), node.right));
          }
        }
      };
    });

    var syntaxNumericSeparator = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-numeric-separator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("numericSeparator");
        }
      };
    });

    var proposalNumericSeparator = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-numeric-separator",
        inherits: syntaxNumericSeparator,
        visitor: {
          NumericLiteral: function NumericLiteral(_ref) {
            var node = _ref.node;
            var extra = node.extra;

            if (extra && /_/.test(extra.raw)) {
              extra.raw = extra.raw.replace(/_/g, "");
            }
          }
        }
      };
    });

    var lib$8 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-object-rest-spread",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxObjectRestSpread$1 = unwrapExports(lib$8);

    var buildDefaultParam = template("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n");
    var buildLooseDefaultParam = template("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n");
    var buildLooseDestructuredDefaultParam = template("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n");
    var buildSafeArgumentsAccess = template("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
    var iifeVisitor = {
      "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
        var scope = path.scope,
            node = path.node;
        var name = node.name;

        if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
          state.needsOuterBinding = true;
          path.stop();
        }
      },
      "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": function TypeAnnotationTSTypeAnnotationTypeParameterDeclarationTSTypeParameterDeclaration(path) {
        return path.skip();
      }
    };
    function convertFunctionParams(path, loose, shouldTransformParam, replaceRestElement) {
      var params = path.get("params");
      var isSimpleParameterList = params.every(function (param) {
        return param.isIdentifier();
      });
      if (isSimpleParameterList) return false;
      var node = path.node,
          scope = path.scope;
      var state = {
        stop: false,
        needsOuterBinding: false,
        scope: scope
      };
      var body = [];
      var shadowedParams = new Set();

      for (var _iterator = _createForOfIteratorHelperLoose(params), _step; !(_step = _iterator()).done;) {
        var _param2 = _step.value;

        for (var _i = 0, _Object$keys = Object.keys(_param2.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
          var _scope$bindings$name;

          var name = _Object$keys[_i];
          var constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;

          if (constantViolations) {
            for (var _iterator4 = _createForOfIteratorHelperLoose(constantViolations), _step4; !(_step4 = _iterator4()).done;) {
              var redeclarator = _step4.value;
              var _node = redeclarator.node;

              switch (_node.type) {
                case "VariableDeclarator":
                  {
                    if (_node.init === null) {
                      var declaration = redeclarator.parentPath;

                      if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                        redeclarator.remove();
                        break;
                      }
                    }

                    shadowedParams.add(name);
                    break;
                  }

                case "FunctionDeclaration":
                  shadowedParams.add(name);
                  break;
              }
            }
          }
        }
      }

      if (shadowedParams.size === 0) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(params), _step2; !(_step2 = _iterator2()).done;) {
          var param = _step2.value;
          if (!param.isIdentifier()) param.traverse(iifeVisitor, state);
          if (state.needsOuterBinding) break;
        }
      }

      var firstOptionalIndex = null;

      for (var i = 0; i < params.length; i++) {
        var _param = params[i];

        if (shouldTransformParam && !shouldTransformParam(i)) {
          continue;
        }

        var transformedRestNodes = [];

        if (replaceRestElement) {
          replaceRestElement(_param.parentPath, _param, transformedRestNodes);
        }

        var paramIsAssignmentPattern = _param.isAssignmentPattern();

        if (paramIsAssignmentPattern && (loose || node.kind === "set")) {
          var left = _param.get("left");

          var right = _param.get("right");

          var undefinedNode = scope.buildUndefinedNode();

          if (left.isIdentifier()) {
            body.push(buildLooseDefaultParam({
              ASSIGNMENT_IDENTIFIER: cloneNode(left.node),
              DEFAULT_VALUE: right.node,
              UNDEFINED: undefinedNode
            }));

            _param.replaceWith(left.node);
          } else if (left.isObjectPattern() || left.isArrayPattern()) {
            var paramName = scope.generateUidIdentifier();
            body.push(buildLooseDestructuredDefaultParam({
              ASSIGNMENT_IDENTIFIER: left.node,
              DEFAULT_VALUE: right.node,
              PARAMETER_NAME: cloneNode(paramName),
              UNDEFINED: undefinedNode
            }));

            _param.replaceWith(paramName);
          }
        } else if (paramIsAssignmentPattern) {
          if (firstOptionalIndex === null) firstOptionalIndex = i;

          var _left = _param.get("left");

          var _right = _param.get("right");

          var defNode = buildDefaultParam({
            VARIABLE_NAME: _left.node,
            DEFAULT_VALUE: _right.node,
            ARGUMENT_KEY: NumericLiteral(i)
          });
          body.push(defNode);
        } else if (firstOptionalIndex !== null) {
          var _defNode = buildSafeArgumentsAccess([_param.node, NumericLiteral(i)]);

          body.push(_defNode);
        } else if (_param.isObjectPattern() || _param.isArrayPattern()) {
          var uid = path.scope.generateUidIdentifier("ref");

          var _defNode2 = VariableDeclaration("let", [VariableDeclarator(_param.node, uid)]);

          body.push(_defNode2);

          _param.replaceWith(cloneNode(uid));
        }

        if (transformedRestNodes) {
          for (var _iterator3 = _createForOfIteratorHelperLoose(transformedRestNodes), _step3; !(_step3 = _iterator3()).done;) {
            var transformedNode = _step3.value;
            body.push(transformedNode);
          }
        }
      }

      if (firstOptionalIndex !== null) {
        node.params = node.params.slice(0, firstOptionalIndex);
      }

      path.ensureBlock();

      if (state.needsOuterBinding || shadowedParams.size > 0) {
        body.push(buildScopeIIFE(shadowedParams, path.get("body").node));
        path.set("body", BlockStatement(body));
        var bodyPath = path.get("body.body");
        var arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
        arrowPath.arrowFunctionToExpression();
        arrowPath.node.generator = path.node.generator;
        arrowPath.node.async = path.node.async;
        path.node.generator = false;
      } else {
        path.get("body").unshiftContainer("body", body);
      }

      return true;
    }

    function buildScopeIIFE(shadowedParams, body) {
      var args = [];
      var params = [];

      for (var _iterator5 = _createForOfIteratorHelperLoose(shadowedParams), _step5; !(_step5 = _iterator5()).done;) {
        var name = _step5.value;
        args.push(Identifier(name));
        params.push(Identifier(name));
      }

      return ReturnStatement(CallExpression(ArrowFunctionExpression(params, body), params));
    }

    var buildRest = template("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n");
    var restIndex = template("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n");
    var restIndexImpure = template("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n");
    var restLength = template("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");

    function referencesRest(path, state) {
      if (path.node.name === state.name) {
        return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
      }

      return false;
    }

    var memberExpressionOptimisationVisitor = {
      Scope: function Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
          path.skip();
        }
      },
      Flow: function Flow(path) {
        if (path.isTypeCastExpression()) return;
        path.skip();
      },
      Function: function Function(path, state) {
        var oldNoOptimise = state.noOptimise;
        state.noOptimise = true;
        path.traverse(memberExpressionOptimisationVisitor, state);
        state.noOptimise = oldNoOptimise;
        path.skip();
      },
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        var node = path.node;

        if (node.name === "arguments") {
          state.deopted = true;
        }

        if (!referencesRest(path, state)) return;

        if (state.noOptimise) {
          state.deopted = true;
        } else {
          var parentPath = path.parentPath;

          if (parentPath.listKey === "params" && parentPath.key < state.offset) {
            return;
          }

          if (parentPath.isMemberExpression({
            object: node
          })) {
            var grandparentPath = parentPath.parentPath;
            var argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
              operator: "delete"
            }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);

            if (argsOptEligible) {
              if (parentPath.node.computed) {
                if (parentPath.get("property").isBaseType("number")) {
                  state.candidates.push({
                    cause: "indexGetter",
                    path: path
                  });
                  return;
                }
              } else if (parentPath.node.property.name === "length") {
                state.candidates.push({
                  cause: "lengthGetter",
                  path: path
                });
                return;
              }
            }
          }

          if (state.offset === 0 && parentPath.isSpreadElement()) {
            var call = parentPath.parentPath;

            if (call.isCallExpression() && call.node.arguments.length === 1) {
              state.candidates.push({
                cause: "argSpread",
                path: path
              });
              return;
            }
          }

          state.references.push(path);
        }
      },
      BindingIdentifier: function BindingIdentifier(path, state) {
        if (referencesRest(path, state)) {
          state.deopted = true;
        }
      }
    };

    function getParamsCount(node) {
      var count = node.params.length;

      if (count > 0 && isIdentifier(node.params[0], {
        name: "this"
      })) {
        count -= 1;
      }

      return count;
    }

    function hasRest(node) {
      var length = node.params.length;
      return length > 0 && isRestElement(node.params[length - 1]);
    }

    function optimiseIndexGetter(path, argsId, offset) {
      var offsetLiteral = NumericLiteral(offset);
      var index;

      if (isNumericLiteral(path.parent.property)) {
        index = NumericLiteral(path.parent.property.value + offset);
      } else if (offset === 0) {
        index = path.parent.property;
      } else {
        index = BinaryExpression("+", path.parent.property, cloneNode(offsetLiteral));
      }

      var scope = path.scope;

      if (!scope.isPure(index)) {
        var temp = scope.generateUidIdentifierBasedOnNode(index);
        scope.push({
          id: temp,
          kind: "var"
        });
        path.parentPath.replaceWith(restIndexImpure({
          ARGUMENTS: argsId,
          OFFSET: offsetLiteral,
          INDEX: index,
          REF: cloneNode(temp)
        }));
      } else {
        var parentPath = path.parentPath;
        parentPath.replaceWith(restIndex({
          ARGUMENTS: argsId,
          OFFSET: offsetLiteral,
          INDEX: index
        }));
        var offsetTestPath = parentPath.get("test").get("left");
        var valRes = offsetTestPath.evaluate();

        if (valRes.confident) {
          if (valRes.value === true) {
            parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
          } else {
            parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
          }
        }
      }
    }

    function optimiseLengthGetter(path, argsId, offset) {
      if (offset) {
        path.parentPath.replaceWith(restLength({
          ARGUMENTS: argsId,
          OFFSET: NumericLiteral(offset)
        }));
      } else {
        path.replaceWith(argsId);
      }
    }

    function convertFunctionRest(path) {
      var node = path.node,
          scope = path.scope;
      if (!hasRest(node)) return false;
      var rest = node.params.pop().argument;
      var argsId = Identifier("arguments");

      if (isPattern(rest)) {
        var pattern = rest;
        rest = scope.generateUidIdentifier("ref");
        var declar = VariableDeclaration("let", [VariableDeclarator(pattern, rest)]);
        node.body.body.unshift(declar);
      }

      var paramsCount = getParamsCount(node);
      var state = {
        references: [],
        offset: paramsCount,
        argumentsNode: argsId,
        outerBinding: scope.getBindingIdentifier(rest.name),
        candidates: [],
        name: rest.name,
        deopted: false
      };
      path.traverse(memberExpressionOptimisationVisitor, state);

      if (!state.deopted && !state.references.length) {
        for (var _i = 0, _arr = state.candidates; _i < _arr.length; _i++) {
          var _arr$_i = _arr[_i],
              _path = _arr$_i.path,
              cause = _arr$_i.cause;
          var clonedArgsId = cloneNode(argsId);

          switch (cause) {
            case "indexGetter":
              optimiseIndexGetter(_path, clonedArgsId, state.offset);
              break;

            case "lengthGetter":
              optimiseLengthGetter(_path, clonedArgsId, state.offset);
              break;

            default:
              _path.replaceWith(clonedArgsId);

          }
        }

        return true;
      }

      state.references = state.references.concat(state.candidates.map(function (_ref) {
        var path = _ref.path;
        return path;
      }));
      var start = NumericLiteral(paramsCount);
      var key = scope.generateUidIdentifier("key");
      var len = scope.generateUidIdentifier("len");
      var arrKey, arrLen;

      if (paramsCount) {
        arrKey = BinaryExpression("-", cloneNode(key), cloneNode(start));
        arrLen = ConditionalExpression(BinaryExpression(">", cloneNode(len), cloneNode(start)), BinaryExpression("-", cloneNode(len), cloneNode(start)), NumericLiteral(0));
      } else {
        arrKey = Identifier(key.name);
        arrLen = Identifier(len.name);
      }

      var loop = buildRest({
        ARGUMENTS: argsId,
        ARRAY_KEY: arrKey,
        ARRAY_LEN: arrLen,
        START: start,
        ARRAY: rest,
        KEY: key,
        LEN: len
      });

      if (state.deopted) {
        node.body.body.unshift(loop);
      } else {
        var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
        target.findParent(function (path) {
          if (path.isLoop()) {
            target = path;
          } else {
            return path.isFunction();
          }
        });
        target.insertBefore(loop);
      }

      return true;
    }

    var transformParameters = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose;
      return {
        name: "transform-parameters",
        visitor: {
          Function: function Function(path) {
            if (path.isArrowFunctionExpression() && path.get("params").some(function (param) {
              return param.isRestElement() || param.isAssignmentPattern();
            })) {
              path.arrowFunctionToExpression();
            }

            var convertedRest = convertFunctionRest(path);
            var convertedParams = convertFunctionParams(path, loose);

            if (convertedRest || convertedParams) {
              path.scope.crawl();
            }
          }
        }
      };
    });

    var ZERO_REFS = function () {
      var node = Identifier("a");
      var property = ObjectProperty(Identifier("key"), node);
      var pattern = ObjectPattern([property]);
      return isReferenced(node, property, pattern) ? 1 : 0;
    }();

    var proposalObjectRestSpread = declare(function (api, opts) {
      api.assertVersion(7);
      var _opts$useBuiltIns = opts.useBuiltIns,
          useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
          _opts$loose = opts.loose,
          loose = _opts$loose === void 0 ? false : _opts$loose;

      if (typeof loose !== "boolean") {
        throw new Error(".loose must be a boolean, or undefined");
      }

      function getExtendsHelper(file) {
        return useBuiltIns ? MemberExpression(Identifier("Object"), Identifier("assign")) : file.addHelper("extends");
      }

      function hasRestElement(path) {
        var foundRestElement = false;
        visitRestElements(path, function (restElement) {
          foundRestElement = true;
          restElement.stop();
        });
        return foundRestElement;
      }

      function hasObjectPatternRestElement(path) {
        var foundRestElement = false;
        visitRestElements(path, function (restElement) {
          if (restElement.parentPath.isObjectPattern()) {
            foundRestElement = true;
            restElement.stop();
          }
        });
        return foundRestElement;
      }

      function visitRestElements(path, visitor) {
        path.traverse({
          Expression: function Expression(path) {
            var parentType = path.parent.type;

            if (parentType === "AssignmentPattern" && path.key === "right" || parentType === "ObjectProperty" && path.parent.computed && path.key === "key") {
              path.skip();
            }
          },
          RestElement: visitor
        });
      }

      function hasSpread(node) {
        for (var _iterator = _createForOfIteratorHelperLoose(node.properties), _step; !(_step = _iterator()).done;) {
          var prop = _step.value;

          if (isSpreadElement(prop)) {
            return true;
          }
        }

        return false;
      }

      function extractNormalizedKeys(path) {
        var props = path.node.properties;
        var keys = [];
        var allLiteral = true;

        for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
          var prop = _step2.value;

          if (isIdentifier(prop.key) && !prop.computed) {
            keys.push(StringLiteral(prop.key.name));
          } else if (isTemplateLiteral(prop.key)) {
            keys.push(cloneNode(prop.key));
          } else if (isLiteral(prop.key)) {
            keys.push(StringLiteral(String(prop.key.value)));
          } else {
            keys.push(cloneNode(prop.key));
            allLiteral = false;
          }
        }

        return {
          keys: keys,
          allLiteral: allLiteral
        };
      }

      function replaceImpureComputedKeys(properties, scope) {
        var impureComputedPropertyDeclarators = [];

        for (var _iterator3 = _createForOfIteratorHelperLoose(properties), _step3; !(_step3 = _iterator3()).done;) {
          var propPath = _step3.value;
          var key = propPath.get("key");

          if (propPath.node.computed && !key.isPure()) {
            var name = scope.generateUidBasedOnNode(key.node);
            var declarator = VariableDeclarator(Identifier(name), key.node);
            impureComputedPropertyDeclarators.push(declarator);
            key.replaceWith(Identifier(name));
          }
        }

        return impureComputedPropertyDeclarators;
      }

      function removeUnusedExcludedKeys(path) {
        var bindings = path.getOuterBindingIdentifierPaths();
        Object.keys(bindings).forEach(function (bindingName) {
          var bindingParentPath = bindings[bindingName].parentPath;

          if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
            return;
          }

          bindingParentPath.remove();
        });
      }

      function createObjectSpread(path, file, objRef) {
        var props = path.get("properties");
        var last = props[props.length - 1];
        assertRestElement(last.node);
        var restElement = cloneNode(last.node);
        last.remove();
        var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);

        var _extractNormalizedKey = extractNormalizedKeys(path),
            keys = _extractNormalizedKey.keys,
            allLiteral = _extractNormalizedKey.allLiteral;

        if (keys.length === 0) {
          return [impureComputedPropertyDeclarators, restElement.argument, CallExpression(getExtendsHelper(file), [ObjectExpression([]), cloneNode(objRef)])];
        }

        var keyExpression;

        if (!allLiteral) {
          keyExpression = CallExpression(MemberExpression(ArrayExpression(keys), Identifier("map")), [file.addHelper("toPropertyKey")]);
        } else {
          keyExpression = ArrayExpression(keys);
        }

        return [impureComputedPropertyDeclarators, restElement.argument, CallExpression(file.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [cloneNode(objRef), keyExpression])];
      }

      function replaceRestElement(parentPath, paramPath, container) {
        if (paramPath.isAssignmentPattern()) {
          replaceRestElement(parentPath, paramPath.get("left"), container);
          return;
        }

        if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
          var elements = paramPath.get("elements");

          for (var i = 0; i < elements.length; i++) {
            replaceRestElement(parentPath, elements[i], container);
          }
        }

        if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
          var uid = parentPath.scope.generateUidIdentifier("ref");
          var declar = VariableDeclaration("let", [VariableDeclarator(paramPath.node, uid)]);

          if (container) {
            container.push(declar);
          } else {
            parentPath.ensureBlock();
            parentPath.get("body").unshiftContainer("body", declar);
          }

          paramPath.replaceWith(cloneNode(uid));
        }
      }

      return {
        name: "proposal-object-rest-spread",
        inherits: syntaxObjectRestSpread$1,
        visitor: {
          Function: function Function(path) {
            var params = path.get("params");
            var paramsWithRestElement = new Set();
            var idsInRestParams = new Set();

            for (var _i = 0; _i < params.length; ++_i) {
              var param = params[_i];

              if (hasRestElement(param)) {
                paramsWithRestElement.add(_i);

                for (var _i2 = 0, _Object$keys = Object.keys(param.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
                  var name = _Object$keys[_i2];
                  idsInRestParams.add(name);
                }
              }
            }

            var idInRest = false;

            var IdentifierHandler = function IdentifierHandler(path, functionScope) {
              var name = path.node.name;

              if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
                idInRest = true;
                path.stop();
              }
            };

            var i;

            for (i = 0; i < params.length && !idInRest; ++i) {
              var _param = params[i];

              if (!paramsWithRestElement.has(i)) {
                if (_param.isReferencedIdentifier() || _param.isBindingIdentifier()) {
                  IdentifierHandler(path, path.scope);
                } else {
                  _param.traverse({
                    "Scope|TypeAnnotation|TSTypeAnnotation": function ScopeTypeAnnotationTSTypeAnnotation(path) {
                      return path.skip();
                    },
                    "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
                  }, path.scope);
                }
              }
            }

            if (!idInRest) {
              for (var _i3 = 0; _i3 < params.length; ++_i3) {
                var _param2 = params[_i3];

                if (paramsWithRestElement.has(_i3)) {
                  replaceRestElement(_param2.parentPath, _param2);
                }
              }
            } else {
              var shouldTransformParam = function shouldTransformParam(idx) {
                return idx >= i - 1 || paramsWithRestElement.has(idx);
              };

              convertFunctionParams(path, loose, shouldTransformParam, replaceRestElement);
            }
          },
          VariableDeclarator: function VariableDeclarator$1(path, file) {
            if (!path.get("id").isObjectPattern()) {
              return;
            }

            var insertionPath = path;
            var originalPath = path;
            visitRestElements(path.get("id"), function (path) {
              if (!path.parentPath.isObjectPattern()) {
                return;
              }

              if (originalPath.node.id.properties.length > 1 && !isIdentifier(originalPath.node.init)) {
                var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
                originalPath.insertBefore(VariableDeclarator(initRef, originalPath.node.init));
                originalPath.replaceWith(VariableDeclarator(originalPath.node.id, cloneNode(initRef)));
                return;
              }

              var ref = originalPath.node.init;
              var refPropertyPath = [];
              var kind;
              path.findParent(function (path) {
                if (path.isObjectProperty()) {
                  refPropertyPath.unshift(path);
                } else if (path.isVariableDeclarator()) {
                  kind = path.parentPath.node.kind;
                  return true;
                }
              });
              var impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
              refPropertyPath.forEach(function (prop) {
                var node = prop.node;
                ref = MemberExpression(ref, cloneNode(node.key), node.computed);
              });
              var objectPatternPath = path.findParent(function (path) {
                return path.isObjectPattern();
              });

              var _createObjectSpread = createObjectSpread(objectPatternPath, file, ref),
                  impureComputedPropertyDeclarators = _createObjectSpread[0],
                  argument = _createObjectSpread[1],
                  callExpression = _createObjectSpread[2];

              if (loose) {
                removeUnusedExcludedKeys(objectPatternPath);
              }

              assertIdentifier(argument);
              insertionPath.insertBefore(impureComputedPropertyDeclarators);
              insertionPath.insertBefore(impureObjRefComputedDeclarators);
              insertionPath.insertAfter(VariableDeclarator(argument, callExpression));
              insertionPath = insertionPath.getSibling(insertionPath.key + 1);
              path.scope.registerBinding(kind, insertionPath);

              if (objectPatternPath.node.properties.length === 0) {
                objectPatternPath.findParent(function (path) {
                  return path.isObjectProperty() || path.isVariableDeclarator();
                }).remove();
              }
            });
          },
          ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
            var declaration = path.get("declaration");
            if (!declaration.isVariableDeclaration()) return;
            var hasRest = declaration.get("declarations").some(function (path) {
              return hasObjectPatternRestElement(path.get("id"));
            });
            if (!hasRest) return;
            var specifiers = [];

            for (var _i4 = 0, _Object$keys2 = Object.keys(path.getOuterBindingIdentifiers(path)); _i4 < _Object$keys2.length; _i4++) {
              var name = _Object$keys2[_i4];
              specifiers.push(ExportSpecifier(Identifier(name), Identifier(name)));
            }

            path.replaceWith(declaration.node);
            path.insertAfter(ExportNamedDeclaration(null, specifiers));
          },
          CatchClause: function CatchClause(path) {
            var paramPath = path.get("param");
            replaceRestElement(paramPath.parentPath, paramPath);
          },
          AssignmentExpression: function AssignmentExpression$1(path, file) {
            var leftPath = path.get("left");

            if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
              var nodes = [];
              var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
              nodes.push(VariableDeclaration("var", [VariableDeclarator(Identifier(refName), path.node.right)]));

              var _createObjectSpread2 = createObjectSpread(leftPath, file, Identifier(refName)),
                  impureComputedPropertyDeclarators = _createObjectSpread2[0],
                  argument = _createObjectSpread2[1],
                  callExpression = _createObjectSpread2[2];

              if (impureComputedPropertyDeclarators.length > 0) {
                nodes.push(VariableDeclaration("var", impureComputedPropertyDeclarators));
              }

              var nodeWithoutSpread = cloneNode(path.node);
              nodeWithoutSpread.right = Identifier(refName);
              nodes.push(ExpressionStatement(nodeWithoutSpread));
              nodes.push(toStatement(AssignmentExpression("=", argument, callExpression)));
              nodes.push(ExpressionStatement(Identifier(refName)));
              path.replaceWithMultiple(nodes);
            }
          },
          ForXStatement: function ForXStatement(path) {
            var node = path.node,
                scope = path.scope;
            var leftPath = path.get("left");
            var left = node.left;

            if (!hasObjectPatternRestElement(leftPath)) {
              return;
            }

            if (!isVariableDeclaration(left)) {
              var temp = scope.generateUidIdentifier("ref");
              node.left = VariableDeclaration("var", [VariableDeclarator(temp)]);
              path.ensureBlock();

              if (node.body.body.length === 0 && path.isCompletionRecord()) {
                node.body.body.unshift(ExpressionStatement(scope.buildUndefinedNode()));
              }

              node.body.body.unshift(ExpressionStatement(AssignmentExpression("=", left, cloneNode(temp))));
            } else {
              var pattern = left.declarations[0].id;
              var key = scope.generateUidIdentifier("ref");
              node.left = VariableDeclaration(left.kind, [VariableDeclarator(key, null)]);
              path.ensureBlock();
              node.body.body.unshift(VariableDeclaration(node.left.kind, [VariableDeclarator(pattern, cloneNode(key))]));
            }
          },
          ArrayPattern: function ArrayPattern(path) {
            var objectPatterns = [];
            visitRestElements(path, function (path) {
              if (!path.parentPath.isObjectPattern()) {
                return;
              }

              var objectPattern = path.parentPath;
              var uid = path.scope.generateUidIdentifier("ref");
              objectPatterns.push(VariableDeclarator(objectPattern.node, uid));
              objectPattern.replaceWith(cloneNode(uid));
              path.skip();
            });

            if (objectPatterns.length > 0) {
              var statementPath = path.getStatementParent();
              statementPath.insertAfter(VariableDeclaration(statementPath.node.kind || "var", objectPatterns));
            }
          },
          ObjectExpression: function ObjectExpression$1(path, file) {
            if (!hasSpread(path.node)) return;
            var scope = path.scope;
            var args = [];
            var props = [];

            function push() {
              args.push(ObjectExpression(props));
              props = [];
            }

            for (var _i5 = 0, _arr = path.node.properties; _i5 < _arr.length; _i5++) {
              var prop = _arr[_i5];

              if (isSpreadElement(prop)) {
                push();
                args.push(prop.argument);
              } else {
                props.push(prop);
              }
            }

            if (props.length) {
              push();
            }

            var helper;

            if (loose) {
              helper = getExtendsHelper(file);
            } else {
              try {
                helper = file.addHelper("objectSpread2");
              } catch (_unused) {
                this.file.declarations["objectSpread2"] = null;
                helper = file.addHelper("objectSpread");
              }
            }

            var chunks = [];
            var currentChunk = [];

            for (var i = 0; i < args.length; i++) {
              currentChunk.push(args[i]);
              var isCurrentChunkEmptyObject = currentChunk.length === 1 && isObjectExpression(args[i]) && args[i].properties.length === 0;
              var isNextArgEffectful = i < args.length - 1 && !scope.isPure(args[i + 1]);

              if (!isCurrentChunkEmptyObject && isNextArgEffectful) {
                chunks.push(currentChunk);
                currentChunk = [];
              }
            }

            if (currentChunk.length) {
              chunks.push(currentChunk);
              currentChunk = [];
            }

            var exp = CallExpression(helper, chunks[0]);
            var nthArg = chunks[0].length;

            for (var _i6 = 1; _i6 < chunks.length; _i6++) {
              if (nthArg % 2) {
                exp = CallExpression(helper, [exp].concat(chunks[_i6]));
              } else {
                exp = CallExpression(helper, [exp, ObjectExpression([])].concat(chunks[_i6]));
              }

              nthArg += chunks[_i6].length;
            }

            path.replaceWith(exp);
          }
        }
      };
    });

    var lib$9 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-catch-binding",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxOptionalCatchBinding$1 = unwrapExports(lib$9);

    var proposalOptionalCatchBinding = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-optional-catch-binding",
        inherits: syntaxOptionalCatchBinding$1,
        visitor: {
          CatchClause: function CatchClause(path) {
            if (!path.node.param) {
              var uid = path.scope.generateUidIdentifier("unused");
              var paramPath = path.get("param");
              paramPath.replaceWith(uid);
            }
          }
        }
      };
    });

    var lib$a = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-chaining",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxOptionalChaining = unwrapExports(lib$a);

    var proposalOptionalChaining = declare(function (api, options) {
      api.assertVersion(7);
      var _options$loose = options.loose,
          loose = _options$loose === void 0 ? false : _options$loose;

      function isSimpleMemberExpression(expression) {
        return isIdentifier(expression) || isSuper(expression) || isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
      }

      return {
        name: "proposal-optional-chaining",
        inherits: syntaxOptionalChaining,
        visitor: {
          "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
            var parentPath = path.parentPath,
                scope = path.scope;
            var isDeleteOperation = false;
            var optionals = [];
            var optionalPath = path;

            while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
              var _optionalPath = optionalPath,
                  node = _optionalPath.node;

              if (node.optional) {
                optionals.push(node);
              }

              if (optionalPath.isOptionalMemberExpression()) {
                optionalPath.node.type = "MemberExpression";
                optionalPath = optionalPath.get("object");
              } else if (optionalPath.isOptionalCallExpression()) {
                optionalPath.node.type = "CallExpression";
                optionalPath = optionalPath.get("callee");
              }
            }

            var replacementPath = path;

            if (parentPath.isUnaryExpression({
              operator: "delete"
            })) {
              replacementPath = parentPath;
              isDeleteOperation = true;
            }

            for (var i = optionals.length - 1; i >= 0; i--) {
              var _node = optionals[i];
              var isCall = isCallExpression(_node);
              var replaceKey = isCall ? "callee" : "object";
              var chain = _node[replaceKey];
              var ref = void 0;
              var check = void 0;

              if (loose && isCall && isSimpleMemberExpression(chain)) {
                check = ref = chain;
              } else {
                ref = scope.maybeGenerateMemoised(chain);

                if (ref) {
                  check = AssignmentExpression("=", cloneNode(ref), chain);
                  _node[replaceKey] = ref;
                } else {
                  check = ref = chain;
                }
              }

              if (isCall && isMemberExpression(chain)) {
                if (loose && isSimpleMemberExpression(chain)) {
                  _node.callee = chain;
                } else {
                  var object = chain.object;
                  var context = scope.maybeGenerateMemoised(object);

                  if (context) {
                    chain.object = AssignmentExpression("=", context, object);
                  } else if (isSuper(object)) {
                    context = ThisExpression();
                  } else {
                    context = object;
                  }

                  _node.arguments.unshift(cloneNode(context));

                  _node.callee = MemberExpression(_node.callee, Identifier("call"));
                }
              }

              replacementPath.replaceWith(ConditionalExpression(loose ? BinaryExpression("==", cloneNode(check), NullLiteral()) : LogicalExpression("||", BinaryExpression("===", cloneNode(check), NullLiteral()), BinaryExpression("===", cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? BooleanLiteral(true) : scope.buildUndefinedNode(), replacementPath.node));
              replacementPath = replacementPath.get("alternate");
            }
          }
        }
      };
    });

    var buildOptimizedSequenceExpression = function buildOptimizedSequenceExpression(_ref) {
      var assign = _ref.assign,
          call = _ref.call,
          path = _ref.path;
      var placeholderNode = assign.left,
          pipelineLeft = assign.right;
      var calledExpression = call.callee;
      var optimizeArrow = isArrowFunctionExpression(calledExpression) && isExpression(calledExpression.body) && !calledExpression.async && !calledExpression.generator;
      var param;

      if (optimizeArrow) {
        var params = calledExpression.params;

        if (params.length === 1 && isIdentifier(params[0])) {
          param = params[0];
        } else if (params.length > 0) {
          optimizeArrow = false;
        }
      } else if (isIdentifier(calledExpression, {
        name: "eval"
      })) {
        var evalSequence = SequenceExpression([NumericLiteral(0), calledExpression]);
        call.callee = evalSequence;
        path.scope.push({
          id: placeholderNode
        });
        return SequenceExpression([assign, call]);
      }

      if (optimizeArrow && !param) {
        return SequenceExpression([pipelineLeft, calledExpression.body]);
      }

      path.scope.push({
        id: placeholderNode
      });

      if (param) {
        path.get("right").scope.rename(param.name, placeholderNode.name);
        return SequenceExpression([assign, calledExpression.body]);
      }

      return SequenceExpression([assign, call]);
    };

    var minimalVisitor = {
      BinaryExpression: function BinaryExpression(path) {
        var scope = path.scope,
            node = path.node;
        var operator = node.operator,
            left = node.left,
            right = node.right;
        if (operator !== "|>") return;
        var placeholder = scope.generateUidIdentifierBasedOnNode(left);
        var call = CallExpression(right, [cloneNode(placeholder)]);
        path.replaceWith(buildOptimizedSequenceExpression({
          assign: AssignmentExpression("=", cloneNode(placeholder), left),
          call: call,
          path: path
        }));
      }
    };

    var updateTopicReferenceVisitor = {
      PipelinePrimaryTopicReference: function PipelinePrimaryTopicReference(path) {
        path.replaceWith(this.topicId);
      },
      PipelineTopicExpression: function PipelineTopicExpression(path) {
        path.skip();
      }
    };
    var smartVisitor = {
      BinaryExpression: function BinaryExpression(path) {
        var scope = path.scope;
        var node = path.node;
        var operator = node.operator,
            left = node.left,
            right = node.right;
        if (operator !== "|>") return;
        var placeholder = scope.generateUidIdentifierBasedOnNode(left);
        scope.push({
          id: placeholder
        });
        var call;

        if (isPipelineTopicExpression(right)) {
          path.get("right").traverse(updateTopicReferenceVisitor, {
            topicId: placeholder
          });
          call = right.expression;
        } else {
          var callee = right.callee;

          if (isIdentifier(callee, {
            name: "eval"
          })) {
            callee = SequenceExpression([NumericLiteral(0), callee]);
          }

          call = CallExpression(callee, [cloneNode(placeholder)]);
        }

        path.replaceWith(SequenceExpression([AssignmentExpression("=", cloneNode(placeholder), left), call]));
      }
    };

    var fsharpVisitor = {
      BinaryExpression: function BinaryExpression(path) {
        var scope = path.scope,
            node = path.node;
        var operator = node.operator,
            left = node.left,
            right = node.right;
        if (operator !== "|>") return;
        var placeholder = scope.generateUidIdentifierBasedOnNode(left);
        var call = right.type === "AwaitExpression" ? AwaitExpression(cloneNode(placeholder)) : CallExpression(right, [cloneNode(placeholder)]);
        var sequence = buildOptimizedSequenceExpression({
          assign: AssignmentExpression("=", cloneNode(placeholder), left),
          call: call,
          path: path
        });
        path.replaceWith(sequence);
      }
    };

    var visitorsPerProposal = {
      minimal: minimalVisitor,
      smart: smartVisitor,
      fsharp: fsharpVisitor
    };
    var proposalPipelineOperator = declare(function (api, options) {
      api.assertVersion(7);
      return {
        name: "proposal-pipeline-operator",
        inherits: syntaxPipelineOperator,
        visitor: visitorsPerProposal[options.proposal]
      };
    });

    var proposalPrivateMethods = declare(function (api, options) {
      api.assertVersion(7);
      return createClassFeaturePlugin({
        name: "proposal-private-methods",
        feature: FEATURES.privateMethods,
        loose: options.loose,
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classPrivateMethods");
        }
      });
    });

    var syntaxThrowExpressions = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-throw-expressions",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("throwExpressions");
        }
      };
    });

    var proposalThrowExpressions = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "proposal-throw-expressions",
        inherits: syntaxThrowExpressions,
        visitor: {
          UnaryExpression: function UnaryExpression(path) {
            var _path$node = path.node,
                operator = _path$node.operator,
                argument = _path$node.argument;
            if (operator !== "throw") return;
            var arrow = FunctionExpression(null, [Identifier("e")], BlockStatement([ThrowStatement(Identifier("e"))]));
            path.replaceWith(CallExpression(arrow, [argument]));
          }
        }
      };
    });

    var regjsgen = createCommonjsModule(function (module, exports) {
    (function () {

      var objectTypes = {
        'function': true,
        'object': true
      };
      var root = objectTypes[typeof window] && window || this;
      var freeExports = objectTypes['object'] && exports && !exports.nodeType && exports;
      var hasFreeModule = objectTypes['object'] && module && !module.nodeType;
      var freeGlobal = freeExports && hasFreeModule && typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1;

      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function fromCodePoint() {
        var codePoint = Number(arguments[0]);

        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || Math.floor(codePoint) != codePoint) {
            throw RangeError('Invalid code point: ' + codePoint);
          }

        if (codePoint <= 0xFFFF) {
          return String.fromCharCode(codePoint);
        } else {
          codePoint -= 0x10000;
          var highSurrogate = (codePoint >> 10) + 0xD800;
          var lowSurrogate = codePoint % 0x400 + 0xDC00;
          return String.fromCharCode(highSurrogate, lowSurrogate);
        }
      }

      var assertTypeRegexMap = {};

      function assertType(type, expected) {
        if (expected.indexOf('|') == -1) {
          if (type == expected) {
            return;
          }

          throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
        }

        expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$');

        if (expected.test(type)) {
          return;
        }

        throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
      }

      function generate(node) {
        var type = node.type;

        if (hasOwnProperty.call(generators, type)) {
          return generators[type](node);
        }

        throw Error('Invalid node type: ' + type);
      }

      function generateAlternative(node) {
        assertType(node.type, 'alternative');
        var terms = node.body,
            i = -1,
            length = terms.length,
            result = '';

        while (++i < length) {
          result += generateTerm(terms[i]);
        }

        return result;
      }

      function generateAnchor(node) {
        assertType(node.type, 'anchor');

        switch (node.kind) {
          case 'start':
            return '^';

          case 'end':
            return '$';

          case 'boundary':
            return '\\b';

          case 'not-boundary':
            return '\\B';

          default:
            throw Error('Invalid assertion');
        }
      }

      function generateAtom(node) {
        assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
        return generate(node);
      }

      function generateCharacterClass(node) {
        assertType(node.type, 'characterClass');
        var classRanges = node.body,
            i = -1,
            length = classRanges.length,
            result = '';

        if (node.negative) {
          result += '^';
        }

        while (++i < length) {
          result += generateClassAtom(classRanges[i]);
        }

        return '[' + result + ']';
      }

      function generateCharacterClassEscape(node) {
        assertType(node.type, 'characterClassEscape');
        return '\\' + node.value;
      }

      function generateUnicodePropertyEscape(node) {
        assertType(node.type, 'unicodePropertyEscape');
        return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
      }

      function generateCharacterClassRange(node) {
        assertType(node.type, 'characterClassRange');
        var min = node.min,
            max = node.max;

        if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
          throw Error('Invalid character class range');
        }

        return generateClassAtom(min) + '-' + generateClassAtom(max);
      }

      function generateClassAtom(node) {
        assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
        return generate(node);
      }

      function generateDisjunction(node) {
        assertType(node.type, 'disjunction');
        var body = node.body,
            i = -1,
            length = body.length,
            result = '';

        while (++i < length) {
          if (i != 0) {
            result += '|';
          }

          result += generate(body[i]);
        }

        return result;
      }

      function generateDot(node) {
        assertType(node.type, 'dot');
        return '.';
      }

      function generateGroup(node) {
        assertType(node.type, 'group');
        var result = '';

        switch (node.behavior) {
          case 'normal':
            if (node.name) {
              result += '?<' + generateIdentifier(node.name) + '>';
            }

            break;

          case 'ignore':
            result += '?:';
            break;

          case 'lookahead':
            result += '?=';
            break;

          case 'negativeLookahead':
            result += '?!';
            break;

          case 'lookbehind':
            result += '?<=';
            break;

          case 'negativeLookbehind':
            result += '?<!';
            break;

          default:
            throw Error('Invalid behaviour: ' + node.behaviour);
        }

        var body = node.body,
            i = -1,
            length = body.length;

        while (++i < length) {
          result += generate(body[i]);
        }

        return '(' + result + ')';
      }

      function generateIdentifier(node) {
        assertType(node.type, 'identifier');
        return node.value;
      }

      function generateQuantifier(node) {
        assertType(node.type, 'quantifier');
        var quantifier = '',
            min = node.min,
            max = node.max;

        if (max == null) {
          if (min == 0) {
            quantifier = '*';
          } else if (min == 1) {
            quantifier = '+';
          } else {
            quantifier = '{' + min + ',}';
          }
        } else if (min == max) {
          quantifier = '{' + min + '}';
        } else if (min == 0 && max == 1) {
          quantifier = '?';
        } else {
          quantifier = '{' + min + ',' + max + '}';
        }

        if (!node.greedy) {
          quantifier += '?';
        }

        return generateAtom(node.body[0]) + quantifier;
      }

      function generateReference(node) {
        assertType(node.type, 'reference');

        if (node.matchIndex) {
          return '\\' + node.matchIndex;
        }

        if (node.name) {
          return '\\k<' + generateIdentifier(node.name) + '>';
        }

        throw new Error('Unknown reference type');
      }

      function generateTerm(node) {
        assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value|dot');
        return generate(node);
      }

      function generateValue(node) {
        assertType(node.type, 'value');
        var kind = node.kind,
            codePoint = node.codePoint;

        if (typeof codePoint != 'number') {
          throw new Error('Invalid code point: ' + codePoint);
        }

        switch (kind) {
          case 'controlLetter':
            return '\\c' + fromCodePoint(codePoint + 64);

          case 'hexadecimalEscape':
            return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);

          case 'identifier':
            return '\\' + fromCodePoint(codePoint);

          case 'null':
            return '\\' + codePoint;

          case 'octal':
            return '\\' + codePoint.toString(8);

          case 'singleEscape':
            switch (codePoint) {
              case 0x0008:
                return '\\b';

              case 0x0009:
                return '\\t';

              case 0x000A:
                return '\\n';

              case 0x000B:
                return '\\v';

              case 0x000C:
                return '\\f';

              case 0x000D:
                return '\\r';

              default:
                throw Error('Invalid code point: ' + codePoint);
            }

          case 'symbol':
            return fromCodePoint(codePoint);

          case 'unicodeEscape':
            return "\\u" + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);

          case 'unicodeCodePointEscape':
            return "\\u{" + codePoint.toString(16).toUpperCase() + '}';

          default:
            throw Error('Unsupported node kind: ' + kind);
        }
      }

      var generators = {
        'alternative': generateAlternative,
        'anchor': generateAnchor,
        'characterClass': generateCharacterClass,
        'characterClassEscape': generateCharacterClassEscape,
        'characterClassRange': generateCharacterClassRange,
        'unicodePropertyEscape': generateUnicodePropertyEscape,
        'disjunction': generateDisjunction,
        'dot': generateDot,
        'group': generateGroup,
        'quantifier': generateQuantifier,
        'reference': generateReference,
        'value': generateValue
      };
      var regjsgen = {
        'generate': generate
      };

      if (freeExports && hasFreeModule) {
          freeExports.generate = generate;
        } else {
          root.regjsgen = regjsgen;
        }
    }).call(commonjsGlobal$1);
    });

    var parser$1 = createCommonjsModule(function (module) {
    (function () {
      var fromCodePoint = String.fromCodePoint || function () {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        return function fromCodePoint() {
          var MAX_SIZE = 0x4000;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;

          if (!length) {
            return '';
          }

          var result = '';

          while (++index < length) {
            var codePoint = Number(arguments[index]);

            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
                throw RangeError('Invalid code point: ' + codePoint);
              }

            if (codePoint <= 0xFFFF) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 0x10000;
              highSurrogate = (codePoint >> 10) + 0xD800;
              lowSurrogate = codePoint % 0x400 + 0xDC00;
              codeUnits.push(highSurrogate, lowSurrogate);
            }

            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }

          return result;
        };
      }();

      function parse(str, flags, features) {
        if (!features) {
          features = {};
        }

        function addRaw(node) {
          node.raw = str.substring(node.range[0], node.range[1]);
          return node;
        }

        function updateRawStart(node, start) {
          node.range[0] = start;
          return addRaw(node);
        }

        function createAnchor(kind, rawLength) {
          return addRaw({
            type: 'anchor',
            kind: kind,
            range: [pos - rawLength, pos]
          });
        }

        function createValue(kind, codePoint, from, to) {
          return addRaw({
            type: 'value',
            kind: kind,
            codePoint: codePoint,
            range: [from, to]
          });
        }

        function createEscaped(kind, codePoint, value, fromOffset) {
          fromOffset = fromOffset || 0;
          return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
        }

        function createCharacter(matches) {
          var _char = matches[0];

          var first = _char.charCodeAt(0);

          if (hasUnicodeFlag) {
            var second;

            if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
              second = lookahead().charCodeAt(0);

              if (second >= 0xDC00 && second <= 0xDFFF) {
                pos++;
                return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
              }
            }
          }

          return createValue('symbol', first, pos - 1, pos);
        }

        function createDisjunction(alternatives, from, to) {
          return addRaw({
            type: 'disjunction',
            body: alternatives,
            range: [from, to]
          });
        }

        function createDot() {
          return addRaw({
            type: 'dot',
            range: [pos - 1, pos]
          });
        }

        function createCharacterClassEscape(value) {
          return addRaw({
            type: 'characterClassEscape',
            value: value,
            range: [pos - 2, pos]
          });
        }

        function createReference(matchIndex) {
          return addRaw({
            type: 'reference',
            matchIndex: parseInt(matchIndex, 10),
            range: [pos - 1 - matchIndex.length, pos]
          });
        }

        function createNamedReference(name) {
          return addRaw({
            type: 'reference',
            name: name,
            range: [name.range[0] - 3, pos]
          });
        }

        function createGroup(behavior, disjunction, from, to) {
          return addRaw({
            type: 'group',
            behavior: behavior,
            body: disjunction,
            range: [from, to]
          });
        }

        function createAlternative(terms, from, to) {
          return addRaw({
            type: 'alternative',
            body: terms,
            range: [from, to]
          });
        }

        function createCharacterClass(classRanges, negative, from, to) {
          return addRaw({
            type: 'characterClass',
            body: classRanges,
            negative: negative,
            range: [from, to]
          });
        }

        function createClassRange(min, max, from, to) {
          if (min.codePoint > max.codePoint) {
            bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
          }

          return addRaw({
            type: 'characterClassRange',
            min: min,
            max: max,
            range: [from, to]
          });
        }

        function flattenBody(body) {
          if (body.type === 'alternative') {
            return body.body;
          } else {
            return [body];
          }
        }

        function incr(amount) {
          amount = amount || 1;
          var res = str.substring(pos, pos + amount);
          pos += amount || 1;
          return res;
        }

        function skip(value) {
          if (!match(value)) {
            bail('character', value);
          }
        }

        function match(value) {
          if (str.indexOf(value, pos) === pos) {
            return incr(value.length);
          }
        }

        function lookahead() {
          return str[pos];
        }

        function current(value) {
          return str.indexOf(value, pos) === pos;
        }

        function next(value) {
          return str[pos + 1] === value;
        }

        function matchReg(regExp) {
          var subStr = str.substring(pos);
          var res = subStr.match(regExp);

          if (res) {
            res.range = [];
            res.range[0] = pos;
            incr(res[0].length);
            res.range[1] = pos;
          }

          return res;
        }

        function parseDisjunction() {
          var res = [],
              from = pos;
          res.push(parseAlternative());

          while (match('|')) {
            res.push(parseAlternative());
          }

          if (res.length === 1) {
            return res[0];
          }

          return createDisjunction(res, from, pos);
        }

        function parseAlternative() {
          var res = [],
              from = pos;
          var term;

          while (term = parseTerm()) {
            res.push(term);
          }

          if (res.length === 1) {
            return res[0];
          }

          return createAlternative(res, from, pos);
        }

        function parseTerm() {
          if (pos >= str.length || current('|') || current(')')) {
            return null;
          }

          var anchor = parseAnchor();

          if (anchor) {
            return anchor;
          }

          var atom = parseAtomAndExtendedAtom();

          if (!atom) {
            bail('Expected atom');
          }

          return atom;
        }

        function parseGroup(matchA, typeA, matchB, typeB) {
          var type = null,
              from = pos;

          if (match(matchA)) {
            type = typeA;
          } else if (match(matchB)) {
            type = typeB;
          } else {
            return false;
          }

          return finishGroup(type, from);
        }

        function finishGroup(type, from) {
          var body = parseDisjunction();

          if (!body) {
            bail('Expected disjunction');
          }

          skip(')');
          var group = createGroup(type, flattenBody(body), from, pos);

          if (type == 'normal') {
            if (firstIteration) {
              closedCaptureCounter++;
            }
          }

          return group;
        }

        function parseAnchor() {

          if (match('^')) {
            return createAnchor('start', 1);
          } else if (match('$')) {
            return createAnchor('end', 1);
          } else if (match('\\b')) {
            return createAnchor('boundary', 2);
          } else if (match('\\B')) {
            return createAnchor('not-boundary', 2);
          } else {
            return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
          }
        }

        function parseAtomAndExtendedAtom() {
          var res;

          if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
            return createCharacter(res);
          } else if (!hasUnicodeFlag && (res = matchReg(/^(?:]|})/))) {
            return createCharacter(res);
          } else if (match('.')) {
            return createDot();
          } else if (match('\\')) {
            res = parseAtomEscape();

            if (!res) {
              if (!hasUnicodeFlag && lookahead() == 'c') {
                return createValue('symbol', 92, pos - 1, pos);
              }

              bail('atomEscape');
            }

            return res;
          } else if (res = parseCharacterClass()) {
            return res;
          } else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
            return res;
          } else if (features.namedGroups && match("(?<")) {
            var name = parseIdentifier();
            skip(">");
            var group = finishGroup("normal", name.range[0] - 3);
            group.name = name;
            return group;
          } else {
            return parseGroup('(?:', 'ignore', '(', 'normal');
          }
        }

        function parseUnicodeSurrogatePairEscape(firstEscape) {
          if (hasUnicodeFlag) {
            var first, second;

            if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
              var prevPos = pos;
              pos++;
              var secondEscape = parseClassEscape();

              if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
                firstEscape.range[1] = secondEscape.range[1];
                firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                firstEscape.type = 'value';
                firstEscape.kind = 'unicodeCodePointEscape';
                addRaw(firstEscape);
              } else {
                pos = prevPos;
              }
            }
          }

          return firstEscape;
        }

        function parseClassEscape() {
          return parseAtomEscape(true);
        }

        function parseAtomEscape(insideCharacterClass) {
          var res,
              from = pos;
          res = parseDecimalEscape() || parseNamedReference();

          if (res) {
            return res;
          }

          if (insideCharacterClass) {
            if (match('b')) {
              return createEscaped('singleEscape', 0x0008, '\\b');
            } else if (match('B')) {
              bail('\\B not possible inside of CharacterClass', '', from);
            } else if (!hasUnicodeFlag && (res = matchReg(/^c([0-9])/))) {
              return createEscaped('controlLetter', res[1] + 16, res[1], 2);
            }

            if (match('-') && hasUnicodeFlag) {
              return createEscaped('singleEscape', 0x002d, '\\-');
            }
          }

          res = parseCharacterEscape();
          return res;
        }

        function parseDecimalEscape() {
          var res, match;

          if (res = matchReg(/^(?!0)\d+/)) {
            match = res[0];
            var refIdx = parseInt(res[0], 10);

            if (refIdx <= closedCaptureCounter) {
              return createReference(res[0]);
            } else {
              backrefDenied.push(refIdx);
              incr(-res[0].length);

              if (res = matchReg(/^[0-7]{1,3}/)) {
                return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
              } else {
                res = createCharacter(matchReg(/^[89]/));
                return updateRawStart(res, res.range[0] - 1);
              }
            }
          } else if (res = matchReg(/^[0-7]{1,3}/)) {
              match = res[0];

              if (/^0{1,3}$/.test(match)) {
                return createEscaped('null', 0x0000, '0', match.length + 1);
              } else {
                return createEscaped('octal', parseInt(match, 8), match, 1);
              }
            } else if (res = matchReg(/^[dDsSwW]/)) {
              return createCharacterClassEscape(res[0]);
            }

          return false;
        }

        function parseNamedReference() {
          if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
            var name = parseIdentifier();
            skip('>');
            return createNamedReference(name);
          }
        }

        function parseRegExpUnicodeEscapeSequence() {
          var res;

          if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
            return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
          } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
            return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
          }
        }

        function parseCharacterEscape() {
          var res;
          var from = pos;

          if (res = matchReg(/^[fnrtv]/)) {
            var codePoint = 0;

            switch (res[0]) {
              case 't':
                codePoint = 0x009;
                break;

              case 'n':
                codePoint = 0x00A;
                break;

              case 'v':
                codePoint = 0x00B;
                break;

              case 'f':
                codePoint = 0x00C;
                break;

              case 'r':
                codePoint = 0x00D;
                break;
            }

            return createEscaped('singleEscape', codePoint, '\\' + res[0]);
          } else if (res = matchReg(/^c([a-zA-Z])/)) {
            return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
          } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
            return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
          } else if (res = parseRegExpUnicodeEscapeSequence()) {
            if (!res || res.codePoint > 0x10FFFF) {
              bail('Invalid escape sequence', null, from, pos);
            }

            return res;
          } else if (features.unicodePropertyEscape && hasUnicodeFlag && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
            return addRaw({
              type: 'unicodePropertyEscape',
              negative: res[1] === 'P',
              value: res[2],
              range: [res.range[0] - 1, res.range[1]],
              raw: res[0]
            });
          } else {
            return parseIdentityEscape();
          }
        }

        function parseIdentifierAtom(check) {
          var ch = lookahead();
          var from = pos;

          if (ch === '\\') {
            incr();
            var esc = parseRegExpUnicodeEscapeSequence();

            if (!esc || !check(esc.codePoint)) {
              bail('Invalid escape sequence', null, from, pos);
            }

            return fromCodePoint(esc.codePoint);
          }

          var code = ch.charCodeAt(0);

          if (code >= 0xD800 && code <= 0xDBFF) {
            ch += str[pos + 1];
            var second = ch.charCodeAt(1);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
          }

          if (!check(code)) return;
          incr();
          if (code > 0xFFFF) incr();
          return ch;
        }

        function parseIdentifier() {
          var start = pos;
          var res = parseIdentifierAtom(isIdentifierStart);

          if (!res) {
            bail('Invalid identifier');
          }

          var ch;

          while (ch = parseIdentifierAtom(isIdentifierPart)) {
            res += ch;
          }

          return addRaw({
            type: 'identifier',
            value: res,
            range: [start, pos]
          });
        }

        function isIdentifierStart(ch) {
          var NonAsciiIdentifierStart = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
          return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 0x80 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }

        function isIdentifierPart(ch) {
          var NonAsciiIdentifierPartOnly = /[0-9_\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC6F\uDC7F-\uDC82\uDCB0-\uDCBA\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDD0-\uDDD9\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6]|\uD81A[\uDE60-\uDE69\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uDB40[\uDD00-\uDDEF]/;
          return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || ch >= 0x80 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
        }

        function parseIdentityEscape() {
          var tmp;
          var l = lookahead();

          if (hasUnicodeFlag && /[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/.test(l) || !hasUnicodeFlag && l !== "c") {
            if (l === "k" && features.lookbehind) {
              return null;
            }

            tmp = incr();
            return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
          }

          return null;
        }

        function parseCharacterClass() {
          var res,
              from = pos;

          if (res = matchReg(/^\[\^/)) {
            res = parseClassRanges();
            skip(']');
            return createCharacterClass(res, true, from, pos);
          } else if (match('[')) {
            res = parseClassRanges();
            skip(']');
            return createCharacterClass(res, false, from, pos);
          }

          return null;
        }

        function parseClassRanges() {
          var res;

          if (current(']')) {
            return [];
          } else {
            res = parseNonemptyClassRanges();

            if (!res) {
              bail('nonEmptyClassRanges');
            }

            return res;
          }
        }

        function parseHelperClassRanges(atom) {
          var from, to, res;

          if (current('-') && !next(']')) {
            skip('-');
            res = parseClassAtom();

            if (!res) {
              bail('classAtom');
            }

            to = pos;
            var classRanges = parseClassRanges();

            if (!classRanges) {
              bail('classRanges');
            }

            from = atom.range[0];

            if (classRanges.type === 'empty') {
              return [createClassRange(atom, res, from, to)];
            }

            return [createClassRange(atom, res, from, to)].concat(classRanges);
          }

          res = parseNonemptyClassRangesNoDash();

          if (!res) {
            bail('nonEmptyClassRangesNoDash');
          }

          return [atom].concat(res);
        }

        function parseNonemptyClassRanges() {
          var atom = parseClassAtom();

          if (!atom) {
            bail('classAtom');
          }

          if (current(']')) {
            return [atom];
          }

          return parseHelperClassRanges(atom);
        }

        function parseNonemptyClassRangesNoDash() {
          var res = parseClassAtom();

          if (!res) {
            bail('classAtom');
          }

          if (current(']')) {
            return res;
          }

          return parseHelperClassRanges(res);
        }

        function parseClassAtom() {
          if (match('-')) {
            return createCharacter('-');
          } else {
            return parseClassAtomNoDash();
          }
        }

        function parseClassAtomNoDash() {
          var res;

          if (res = matchReg(/^[^\\\]-]/)) {
            return createCharacter(res[0]);
          } else if (match('\\')) {
            res = parseClassEscape();

            if (!res) {
              bail('classEscape');
            }

            return parseUnicodeSurrogatePairEscape(res);
          }
        }

        function bail(message, details, from, to) {
          from = from == null ? pos : from;
          to = to == null ? from : to;
          var contextStart = Math.max(0, from - 10);
          var contextEnd = Math.min(to + 10, str.length);
          var context = '    ' + str.substring(contextStart, contextEnd);
          var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
          throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
        }

        var backrefDenied = [];
        var closedCaptureCounter = 0;
        var firstIteration = true;
        var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
        var pos = 0;
        str = String(str);

        if (str === '') {
          str = '(?:)';
        }

        var result = parseDisjunction();

        if (result.range[1] !== str.length) {
          bail('Could not parse entire input - got stuck', '', result.range[1]);
        }

        for (var i = 0; i < backrefDenied.length; i++) {
          if (backrefDenied[i] <= closedCaptureCounter) {
            pos = 0;
            firstIteration = false;
            return parseDisjunction();
          }
        }

        return result;
      }

      var regjsparser = {
        parse: parse
      };

      if ( module.exports) {
        module.exports = regjsparser;
      } else {
        window.regjsparser = regjsparser;
      }
    })();
    });

    var regenerate = createCommonjsModule(function (module, exports) {

    (function (root) {
      var freeExports =  exports;
      var freeModule =  module && module.exports == freeExports && module;
      var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1;

      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }

      var ERRORS = {
        'rangeOrder': "A range\u2019s `stop` value must be greater than or equal " + 'to the `start` value.',
        'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
      };
      var HIGH_SURROGATE_MIN = 0xD800;
      var HIGH_SURROGATE_MAX = 0xDBFF;
      var LOW_SURROGATE_MIN = 0xDC00;
      var LOW_SURROGATE_MAX = 0xDFFF;
      var regexNull = /\\x00([^0123456789]|$)/g;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;

      var extend = function extend(destination, source) {
        var key;

        for (key in source) {
          if (hasOwnProperty.call(source, key)) {
            destination[key] = source[key];
          }
        }

        return destination;
      };

      var forEach = function forEach(array, callback) {
        var index = -1;
        var length = array.length;

        while (++index < length) {
          callback(array[index], index);
        }
      };

      var toString = object.toString;

      var isArray = function isArray(value) {
        return toString.call(value) == '[object Array]';
      };

      var isNumber = function isNumber(value) {
        return typeof value == 'number' || toString.call(value) == '[object Number]';
      };

      var zeroes = '0000';

      var pad = function pad(number, totalCharacters) {
        var string = String(number);
        return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
      };

      var hex = function hex(number) {
        return Number(number).toString(16).toUpperCase();
      };

      var slice = [].slice;

      var dataFromCodePoints = function dataFromCodePoints(codePoints) {
        var index = -1;
        var length = codePoints.length;
        var max = length - 1;
        var result = [];
        var isStart = true;
        var tmp;
        var previous = 0;

        while (++index < length) {
          tmp = codePoints[index];

          if (isStart) {
            result.push(tmp);
            previous = tmp;
            isStart = false;
          } else {
            if (tmp == previous + 1) {
              if (index != max) {
                previous = tmp;
                continue;
              } else {
                isStart = true;
                result.push(tmp + 1);
              }
            } else {
              result.push(previous + 1, tmp);
              previous = tmp;
            }
          }
        }

        if (!isStart) {
          result.push(tmp + 1);
        }

        return result;
      };

      var dataRemove = function dataRemove(data, codePoint) {
        var index = 0;
        var start;
        var end;
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (codePoint >= start && codePoint < end) {
            if (codePoint == start) {
              if (end == start + 1) {
                data.splice(index, 2);
                return data;
              } else {
                data[index] = codePoint + 1;
                return data;
              }
            } else if (codePoint == end - 1) {
              data[index + 1] = codePoint;
              return data;
            } else {
              data.splice(index, 2, start, codePoint, codePoint + 1, end);
              return data;
            }
          }

          index += 2;
        }

        return data;
      };

      var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
        if (rangeEnd < rangeStart) {
          throw Error(ERRORS.rangeOrder);
        }

        var index = 0;
        var start;
        var end;

        while (index < data.length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start > rangeEnd) {
            return data;
          }

          if (rangeStart <= start && rangeEnd >= end) {
            data.splice(index, 2);
            continue;
          }

          if (rangeStart >= start && rangeEnd < end) {
            if (rangeStart == start) {
              data[index] = rangeEnd + 1;
              data[index + 1] = end + 1;
              return data;
            }

            data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
            return data;
          }

          if (rangeStart >= start && rangeStart <= end) {
            data[index + 1] = rangeStart;
          } else if (rangeEnd >= start && rangeEnd <= end) {
              data[index] = rangeEnd + 1;
              return data;
            }

          index += 2;
        }

        return data;
      };

      var dataAdd = function dataAdd(data, codePoint) {
        var index = 0;
        var start;
        var end;
        var lastIndex = null;
        var length = data.length;

        if (codePoint < 0x0 || codePoint > 0x10FFFF) {
          throw RangeError(ERRORS.codePointRange);
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (codePoint >= start && codePoint < end) {
            return data;
          }

          if (codePoint == start - 1) {
            data[index] = codePoint;
            return data;
          }

          if (start > codePoint) {
            data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
            return data;
          }

          if (codePoint == end) {
            if (codePoint + 1 == data[index + 2]) {
              data.splice(index, 4, start, data[index + 3]);
              return data;
            }

            data[index + 1] = codePoint + 1;
            return data;
          }

          lastIndex = index;
          index += 2;
        }

        data.push(codePoint, codePoint + 1);
        return data;
      };

      var dataAddData = function dataAddData(dataA, dataB) {
        var index = 0;
        var start;
        var end;
        var data = dataA.slice();
        var length = dataB.length;

        while (index < length) {
          start = dataB[index];
          end = dataB[index + 1] - 1;

          if (start == end) {
            data = dataAdd(data, start);
          } else {
            data = dataAddRange(data, start, end);
          }

          index += 2;
        }

        return data;
      };

      var dataRemoveData = function dataRemoveData(dataA, dataB) {
        var index = 0;
        var start;
        var end;
        var data = dataA.slice();
        var length = dataB.length;

        while (index < length) {
          start = dataB[index];
          end = dataB[index + 1] - 1;

          if (start == end) {
            data = dataRemove(data, start);
          } else {
            data = dataRemoveRange(data, start, end);
          }

          index += 2;
        }

        return data;
      };

      var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
        if (rangeEnd < rangeStart) {
          throw Error(ERRORS.rangeOrder);
        }

        if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
          throw RangeError(ERRORS.codePointRange);
        }

        var index = 0;
        var start;
        var end;
        var added = false;
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (added) {
            if (start == rangeEnd + 1) {
              data.splice(index - 1, 2);
              return data;
            }

            if (start > rangeEnd) {
              return data;
            }

            if (start >= rangeStart && start <= rangeEnd) {
              if (end > rangeStart && end - 1 <= rangeEnd) {
                data.splice(index, 2);
                index -= 2;
              } else {
                data.splice(index - 1, 2);
                index -= 2;
              }
            }
          } else if (start == rangeEnd + 1) {
            data[index] = rangeStart;
            return data;
          } else if (start > rangeEnd) {
              data.splice(index, 0, rangeStart, rangeEnd + 1);
              return data;
            } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
              return data;
            } else if (rangeStart >= start && rangeStart < end || end == rangeStart) {
              data[index + 1] = rangeEnd + 1;
              added = true;
            } else if (rangeStart <= start && rangeEnd + 1 >= end) {
              data[index] = rangeStart;
              data[index + 1] = rangeEnd + 1;
              added = true;
            }

          index += 2;
        }

        if (!added) {
          data.push(rangeStart, rangeEnd + 1);
        }

        return data;
      };

      var dataContains = function dataContains(data, codePoint) {
        var index = 0;
        var length = data.length;
        var start = data[index];
        var end = data[length - 1];

        if (length >= 2) {
          if (codePoint < start || codePoint > end) {
            return false;
          }
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (codePoint >= start && codePoint < end) {
            return true;
          }

          index += 2;
        }

        return false;
      };

      var dataIntersection = function dataIntersection(data, codePoints) {
        var index = 0;
        var length = codePoints.length;
        var codePoint;
        var result = [];

        while (index < length) {
          codePoint = codePoints[index];

          if (dataContains(data, codePoint)) {
            result.push(codePoint);
          }

          ++index;
        }

        return dataFromCodePoints(result);
      };

      var dataIsEmpty = function dataIsEmpty(data) {
        return !data.length;
      };

      var dataIsSingleton = function dataIsSingleton(data) {
        return data.length == 2 && data[0] + 1 == data[1];
      };

      var dataToArray = function dataToArray(data) {
        var index = 0;
        var start;
        var end;
        var result = [];
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          while (start < end) {
            result.push(start);
            ++start;
          }

          index += 2;
        }

        return result;
      };

      var floor = Math.floor;

      var highSurrogate = function highSurrogate(codePoint) {
        return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
      };

      var lowSurrogate = function lowSurrogate(codePoint) {
        return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
      };

      var stringFromCharCode = String.fromCharCode;

      var codePointToString = function codePointToString(codePoint) {
        var string;

        if (codePoint == 0x09) {
          string = '\\t';
        } else if (codePoint == 0x0A) {
            string = '\\n';
          } else if (codePoint == 0x0C) {
            string = '\\f';
          } else if (codePoint == 0x0D) {
            string = '\\r';
          } else if (codePoint == 0x2D) {
            string = '\\x2D';
          } else if (codePoint == 0x5C) {
            string = '\\\\';
          } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
            string = '\\' + stringFromCharCode(codePoint);
          } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
            string = stringFromCharCode(codePoint);
          } else if (codePoint <= 0xFF) {
            string = '\\x' + pad(hex(codePoint), 2);
          } else {
            string = "\\u" + pad(hex(codePoint), 4);
          }

        return string;
      };

      var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
        if (codePoint <= 0xFFFF) {
          return codePointToString(codePoint);
        }

        return "\\u{" + codePoint.toString(16).toUpperCase() + '}';
      };

      var symbolToCodePoint = function symbolToCodePoint(symbol) {
        var length = symbol.length;
        var first = symbol.charCodeAt(0);
        var second;

        if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
            second = symbol.charCodeAt(1);
            return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
          }

        return first;
      };

      var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
        var result = '';
        var index = 0;
        var start;
        var end;
        var length = data.length;

        if (dataIsSingleton(data)) {
          return codePointToString(data[0]);
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start == end) {
            result += codePointToString(start);
          } else if (start + 1 == end) {
            result += codePointToString(start) + codePointToString(end);
          } else {
            result += codePointToString(start) + '-' + codePointToString(end);
          }

          index += 2;
        }

        return '[' + result + ']';
      };

      var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
        var result = '';
        var index = 0;
        var start;
        var end;
        var length = data.length;

        if (dataIsSingleton(data)) {
          return codePointToStringUnicode(data[0]);
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start == end) {
            result += codePointToStringUnicode(start);
          } else if (start + 1 == end) {
            result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
          } else {
            result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
          }

          index += 2;
        }

        return '[' + result + ']';
      };

      var splitAtBMP = function splitAtBMP(data) {
        var loneHighSurrogates = [];
        var loneLowSurrogates = [];
        var bmp = [];
        var astral = [];
        var index = 0;
        var start;
        var end;
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start < HIGH_SURROGATE_MIN) {
            if (end < HIGH_SURROGATE_MIN) {
              bmp.push(start, end + 1);
            }

            if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
              bmp.push(start, HIGH_SURROGATE_MIN);
              loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
            }

            if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
              bmp.push(start, HIGH_SURROGATE_MIN);
              loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
            }

            if (end > LOW_SURROGATE_MAX) {
              bmp.push(start, HIGH_SURROGATE_MIN);
              loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

              if (end <= 0xFFFF) {
                bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
              } else {
                bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            }
          } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
            if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
              loneHighSurrogates.push(start, end + 1);
            }

            if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
              loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
            }

            if (end > LOW_SURROGATE_MAX) {
              loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

              if (end <= 0xFFFF) {
                bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
              } else {
                bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            }
          } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
            if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
              loneLowSurrogates.push(start, end + 1);
            }

            if (end > LOW_SURROGATE_MAX) {
              loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);

              if (end <= 0xFFFF) {
                bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
              } else {
                bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            }
          } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
            if (end <= 0xFFFF) {
              bmp.push(start, end + 1);
            } else {
              bmp.push(start, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          } else {
            astral.push(start, end + 1);
          }

          index += 2;
        }

        return {
          'loneHighSurrogates': loneHighSurrogates,
          'loneLowSurrogates': loneLowSurrogates,
          'bmp': bmp,
          'astral': astral
        };
      };

      var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
        var result = [];
        var tmpLow = [];
        var addLow = false;
        var mapping;
        var nextMapping;
        var highSurrogates;
        var lowSurrogates;
        var nextHighSurrogates;
        var nextLowSurrogates;
        var index = -1;
        var length = surrogateMappings.length;

        while (++index < length) {
          mapping = surrogateMappings[index];
          nextMapping = surrogateMappings[index + 1];

          if (!nextMapping) {
            result.push(mapping);
            continue;
          }

          highSurrogates = mapping[0];
          lowSurrogates = mapping[1];
          nextHighSurrogates = nextMapping[0];
          nextLowSurrogates = nextMapping[1];
          tmpLow = lowSurrogates;

          while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
            if (dataIsSingleton(nextLowSurrogates)) {
              tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
            } else {
              tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
            }

            ++index;
            mapping = surrogateMappings[index];
            highSurrogates = mapping[0];
            lowSurrogates = mapping[1];
            nextMapping = surrogateMappings[index + 1];
            nextHighSurrogates = nextMapping && nextMapping[0];
            nextLowSurrogates = nextMapping && nextMapping[1];
            addLow = true;
          }

          result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
          addLow = false;
        }

        return optimizeByLowSurrogates(result);
      };

      var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
        if (surrogateMappings.length == 1) {
          return surrogateMappings;
        }

        var index = -1;
        var innerIndex = -1;

        while (++index < surrogateMappings.length) {
          var mapping = surrogateMappings[index];
          var lowSurrogates = mapping[1];
          var lowSurrogateStart = lowSurrogates[0];
          var lowSurrogateEnd = lowSurrogates[1];
          innerIndex = index;

          while (++innerIndex < surrogateMappings.length) {
            var otherMapping = surrogateMappings[innerIndex];
            var otherLowSurrogates = otherMapping[1];
            var otherLowSurrogateStart = otherLowSurrogates[0];
            var otherLowSurrogateEnd = otherLowSurrogates[1];

            if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {
              if (dataIsSingleton(otherMapping[0])) {
                mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
              } else {
                mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
              }

              surrogateMappings.splice(innerIndex, 1);
              --innerIndex;
            }
          }
        }

        return surrogateMappings;
      };

      var surrogateSet = function surrogateSet(data) {
        if (!data.length) {
          return [];
        }

        var index = 0;
        var start;
        var end;
        var startHigh;
        var startLow;
        var endHigh;
        var endLow;
        var surrogateMappings = [];
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;
          startHigh = highSurrogate(start);
          startLow = lowSurrogate(start);
          endHigh = highSurrogate(end);
          endLow = lowSurrogate(end);
          var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
          var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
          var complete = false;

          if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
            surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
            complete = true;
          } else {
            surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
          }

          if (!complete && startHigh + 1 < endHigh) {
            if (endsWithHighestLowSurrogate) {
              surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
              complete = true;
            } else {
              surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
            }
          }

          if (!complete) {
            surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
          }

          index += 2;
        }

        return optimizeSurrogateMappings(surrogateMappings);
      };

      var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
        var result = [];
        forEach(surrogateMappings, function (surrogateMapping) {
          var highSurrogates = surrogateMapping[0];
          var lowSurrogates = surrogateMapping[1];
          result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
        });
        return result.join('|');
      };

      var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
        if (hasUnicodeFlag) {
          return createUnicodeCharacterClasses(data);
        }

        var result = [];
        var parts = splitAtBMP(data);
        var loneHighSurrogates = parts.loneHighSurrogates;
        var loneLowSurrogates = parts.loneLowSurrogates;
        var bmp = parts.bmp;
        var astral = parts.astral;
        var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
        var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
        var surrogateMappings = surrogateSet(astral);

        if (bmpOnly) {
          bmp = dataAddData(bmp, loneHighSurrogates);
          hasLoneHighSurrogates = false;
          bmp = dataAddData(bmp, loneLowSurrogates);
          hasLoneLowSurrogates = false;
        }

        if (!dataIsEmpty(bmp)) {
          result.push(createBMPCharacterClasses(bmp));
        }

        if (surrogateMappings.length) {
          result.push(createSurrogateCharacterClasses(surrogateMappings));
        }

        if (hasLoneHighSurrogates) {
          result.push(createBMPCharacterClasses(loneHighSurrogates) + "(?![\\uDC00-\\uDFFF])");
        }

        if (hasLoneLowSurrogates) {
          result.push("(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates));
        }

        return result.join('|');
      };

      var regenerate = function regenerate(value) {
        if (arguments.length > 1) {
          value = slice.call(arguments);
        }

        if (this instanceof regenerate) {
          this.data = [];
          return value ? this.add(value) : this;
        }

        return new regenerate().add(value);
      };

      regenerate.version = '1.3.3';
      var proto = regenerate.prototype;
      extend(proto, {
        'add': function add(value) {
          var $this = this;

          if (value == null) {
            return $this;
          }

          if (value instanceof regenerate) {
            $this.data = dataAddData($this.data, value.data);
            return $this;
          }

          if (arguments.length > 1) {
            value = slice.call(arguments);
          }

          if (isArray(value)) {
            forEach(value, function (item) {
              $this.add(item);
            });
            return $this;
          }

          $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
          return $this;
        },
        'remove': function remove(value) {
          var $this = this;

          if (value == null) {
            return $this;
          }

          if (value instanceof regenerate) {
            $this.data = dataRemoveData($this.data, value.data);
            return $this;
          }

          if (arguments.length > 1) {
            value = slice.call(arguments);
          }

          if (isArray(value)) {
            forEach(value, function (item) {
              $this.remove(item);
            });
            return $this;
          }

          $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
          return $this;
        },
        'addRange': function addRange(start, end) {
          var $this = this;
          $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
          return $this;
        },
        'removeRange': function removeRange(start, end) {
          var $this = this;
          var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
          var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
          $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
          return $this;
        },
        'intersection': function intersection(argument) {
          var $this = this;
          var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
          $this.data = dataIntersection($this.data, array);
          return $this;
        },
        'contains': function contains(codePoint) {
          return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
        },
        'clone': function clone() {
          var set = new regenerate();
          set.data = this.data.slice(0);
          return set;
        },
        'toString': function toString(options) {
          var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);

          if (!result) {
            return '[]';
          }

          return result.replace(regexNull, '\\0$1');
        },
        'toRegExp': function toRegExp(flags) {
          var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {
            'hasUnicodeFlag': true
          } : null);
          return RegExp(pattern, flags || '');
        },
        'valueOf': function valueOf() {
          return dataToArray(this.data);
        }
      });
      proto.toArray = proto.valueOf;

      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = regenerate;
        } else {
          freeExports.regenerate = regenerate;
        }
      } else {
        root.regenerate = regenerate;
      }
    })(commonjsGlobal$1);
    });

    var unicodeCanonicalPropertyNamesEcmascript = new Set(['General_Category', 'Script', 'Script_Extensions', 'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extended_Pictographic', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']);

    var unicodePropertyAliasesEcmascript = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['EBase', 'Emoji_Modifier_Base'], ['EComp', 'Emoji_Component'], ['EMod', 'Emoji_Modifier'], ['Emoji', 'Emoji'], ['EPres', 'Emoji_Presentation'], ['Ext', 'Extender'], ['ExtPict', 'Extended_Pictographic'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]);

    var matchProperty = function matchProperty(property) {
      if (unicodeCanonicalPropertyNamesEcmascript.has(property)) {
        return property;
      }

      if (unicodePropertyAliasesEcmascript.has(property)) {
        return unicodePropertyAliasesEcmascript.get(property);
      }

      throw new Error("Unknown property: " + property);
    };

    var unicodeMatchPropertyEcmascript = matchProperty;

    var mappings = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]);

    var matchPropertyValue = function matchPropertyValue(property, value) {
      var aliasToValue = mappings.get(property);

      if (!aliasToValue) {
        throw new Error("Unknown property `" + property + "`.");
      }

      var canonicalValue = aliasToValue.get(value);

      if (canonicalValue) {
        return canonicalValue;
      }

      throw new Error("Unknown value `" + value + "` for property `" + property + "`.");
    };

    var unicodeMatchPropertyValueEcmascript = matchPropertyValue;

    var iuMappings = new Map([[0x4B, 0x212A], [0x53, 0x17F], [0x6B, 0x212A], [0x73, 0x17F], [0xB5, 0x39C], [0xC5, 0x212B], [0xDF, 0x1E9E], [0xE5, 0x212B], [0x17F, 0x53], [0x1C4, 0x1C5], [0x1C5, 0x1C4], [0x1C7, 0x1C8], [0x1C8, 0x1C7], [0x1CA, 0x1CB], [0x1CB, 0x1CA], [0x1F1, 0x1F2], [0x1F2, 0x1F1], [0x26A, 0xA7AE], [0x282, 0xA7C5], [0x29D, 0xA7B2], [0x345, 0x1FBE], [0x392, 0x3D0], [0x395, 0x3F5], [0x398, 0x3F4], [0x399, 0x1FBE], [0x39A, 0x3F0], [0x39C, 0xB5], [0x3A0, 0x3D6], [0x3A1, 0x3F1], [0x3A3, 0x3C2], [0x3A6, 0x3D5], [0x3A9, 0x2126], [0x3B8, 0x3F4], [0x3C2, 0x3A3], [0x3C9, 0x2126], [0x3D0, 0x392], [0x3D1, 0x3F4], [0x3D5, 0x3A6], [0x3D6, 0x3A0], [0x3F0, 0x39A], [0x3F1, 0x3A1], [0x3F4, [0x398, 0x3D1, 0x3B8]], [0x3F5, 0x395], [0x412, 0x1C80], [0x414, 0x1C81], [0x41E, 0x1C82], [0x421, 0x1C83], [0x422, 0x1C85], [0x42A, 0x1C86], [0x432, 0x1C80], [0x434, 0x1C81], [0x43E, 0x1C82], [0x441, 0x1C83], [0x442, [0x1C84, 0x1C85]], [0x44A, 0x1C86], [0x462, 0x1C87], [0x463, 0x1C87], [0x10D0, 0x1C90], [0x10D1, 0x1C91], [0x10D2, 0x1C92], [0x10D3, 0x1C93], [0x10D4, 0x1C94], [0x10D5, 0x1C95], [0x10D6, 0x1C96], [0x10D7, 0x1C97], [0x10D8, 0x1C98], [0x10D9, 0x1C99], [0x10DA, 0x1C9A], [0x10DB, 0x1C9B], [0x10DC, 0x1C9C], [0x10DD, 0x1C9D], [0x10DE, 0x1C9E], [0x10DF, 0x1C9F], [0x10E0, 0x1CA0], [0x10E1, 0x1CA1], [0x10E2, 0x1CA2], [0x10E3, 0x1CA3], [0x10E4, 0x1CA4], [0x10E5, 0x1CA5], [0x10E6, 0x1CA6], [0x10E7, 0x1CA7], [0x10E8, 0x1CA8], [0x10E9, 0x1CA9], [0x10EA, 0x1CAA], [0x10EB, 0x1CAB], [0x10EC, 0x1CAC], [0x10ED, 0x1CAD], [0x10EE, 0x1CAE], [0x10EF, 0x1CAF], [0x10F0, 0x1CB0], [0x10F1, 0x1CB1], [0x10F2, 0x1CB2], [0x10F3, 0x1CB3], [0x10F4, 0x1CB4], [0x10F5, 0x1CB5], [0x10F6, 0x1CB6], [0x10F7, 0x1CB7], [0x10F8, 0x1CB8], [0x10F9, 0x1CB9], [0x10FA, 0x1CBA], [0x10FD, 0x1CBD], [0x10FE, 0x1CBE], [0x10FF, 0x1CBF], [0x13A0, 0xAB70], [0x13A1, 0xAB71], [0x13A2, 0xAB72], [0x13A3, 0xAB73], [0x13A4, 0xAB74], [0x13A5, 0xAB75], [0x13A6, 0xAB76], [0x13A7, 0xAB77], [0x13A8, 0xAB78], [0x13A9, 0xAB79], [0x13AA, 0xAB7A], [0x13AB, 0xAB7B], [0x13AC, 0xAB7C], [0x13AD, 0xAB7D], [0x13AE, 0xAB7E], [0x13AF, 0xAB7F], [0x13B0, 0xAB80], [0x13B1, 0xAB81], [0x13B2, 0xAB82], [0x13B3, 0xAB83], [0x13B4, 0xAB84], [0x13B5, 0xAB85], [0x13B6, 0xAB86], [0x13B7, 0xAB87], [0x13B8, 0xAB88], [0x13B9, 0xAB89], [0x13BA, 0xAB8A], [0x13BB, 0xAB8B], [0x13BC, 0xAB8C], [0x13BD, 0xAB8D], [0x13BE, 0xAB8E], [0x13BF, 0xAB8F], [0x13C0, 0xAB90], [0x13C1, 0xAB91], [0x13C2, 0xAB92], [0x13C3, 0xAB93], [0x13C4, 0xAB94], [0x13C5, 0xAB95], [0x13C6, 0xAB96], [0x13C7, 0xAB97], [0x13C8, 0xAB98], [0x13C9, 0xAB99], [0x13CA, 0xAB9A], [0x13CB, 0xAB9B], [0x13CC, 0xAB9C], [0x13CD, 0xAB9D], [0x13CE, 0xAB9E], [0x13CF, 0xAB9F], [0x13D0, 0xABA0], [0x13D1, 0xABA1], [0x13D2, 0xABA2], [0x13D3, 0xABA3], [0x13D4, 0xABA4], [0x13D5, 0xABA5], [0x13D6, 0xABA6], [0x13D7, 0xABA7], [0x13D8, 0xABA8], [0x13D9, 0xABA9], [0x13DA, 0xABAA], [0x13DB, 0xABAB], [0x13DC, 0xABAC], [0x13DD, 0xABAD], [0x13DE, 0xABAE], [0x13DF, 0xABAF], [0x13E0, 0xABB0], [0x13E1, 0xABB1], [0x13E2, 0xABB2], [0x13E3, 0xABB3], [0x13E4, 0xABB4], [0x13E5, 0xABB5], [0x13E6, 0xABB6], [0x13E7, 0xABB7], [0x13E8, 0xABB8], [0x13E9, 0xABB9], [0x13EA, 0xABBA], [0x13EB, 0xABBB], [0x13EC, 0xABBC], [0x13ED, 0xABBD], [0x13EE, 0xABBE], [0x13EF, 0xABBF], [0x13F0, 0x13F8], [0x13F1, 0x13F9], [0x13F2, 0x13FA], [0x13F3, 0x13FB], [0x13F4, 0x13FC], [0x13F5, 0x13FD], [0x13F8, 0x13F0], [0x13F9, 0x13F1], [0x13FA, 0x13F2], [0x13FB, 0x13F3], [0x13FC, 0x13F4], [0x13FD, 0x13F5], [0x1C80, [0x412, 0x432]], [0x1C81, [0x414, 0x434]], [0x1C82, [0x41E, 0x43E]], [0x1C83, [0x421, 0x441]], [0x1C84, [0x1C85, 0x442]], [0x1C85, [0x422, 0x1C84, 0x442]], [0x1C86, [0x42A, 0x44A]], [0x1C87, [0x462, 0x463]], [0x1C88, [0xA64A, 0xA64B]], [0x1C90, 0x10D0], [0x1C91, 0x10D1], [0x1C92, 0x10D2], [0x1C93, 0x10D3], [0x1C94, 0x10D4], [0x1C95, 0x10D5], [0x1C96, 0x10D6], [0x1C97, 0x10D7], [0x1C98, 0x10D8], [0x1C99, 0x10D9], [0x1C9A, 0x10DA], [0x1C9B, 0x10DB], [0x1C9C, 0x10DC], [0x1C9D, 0x10DD], [0x1C9E, 0x10DE], [0x1C9F, 0x10DF], [0x1CA0, 0x10E0], [0x1CA1, 0x10E1], [0x1CA2, 0x10E2], [0x1CA3, 0x10E3], [0x1CA4, 0x10E4], [0x1CA5, 0x10E5], [0x1CA6, 0x10E6], [0x1CA7, 0x10E7], [0x1CA8, 0x10E8], [0x1CA9, 0x10E9], [0x1CAA, 0x10EA], [0x1CAB, 0x10EB], [0x1CAC, 0x10EC], [0x1CAD, 0x10ED], [0x1CAE, 0x10EE], [0x1CAF, 0x10EF], [0x1CB0, 0x10F0], [0x1CB1, 0x10F1], [0x1CB2, 0x10F2], [0x1CB3, 0x10F3], [0x1CB4, 0x10F4], [0x1CB5, 0x10F5], [0x1CB6, 0x10F6], [0x1CB7, 0x10F7], [0x1CB8, 0x10F8], [0x1CB9, 0x10F9], [0x1CBA, 0x10FA], [0x1CBD, 0x10FD], [0x1CBE, 0x10FE], [0x1CBF, 0x10FF], [0x1D8E, 0xA7C6], [0x1E60, 0x1E9B], [0x1E9B, 0x1E60], [0x1E9E, 0xDF], [0x1F80, 0x1F88], [0x1F81, 0x1F89], [0x1F82, 0x1F8A], [0x1F83, 0x1F8B], [0x1F84, 0x1F8C], [0x1F85, 0x1F8D], [0x1F86, 0x1F8E], [0x1F87, 0x1F8F], [0x1F88, 0x1F80], [0x1F89, 0x1F81], [0x1F8A, 0x1F82], [0x1F8B, 0x1F83], [0x1F8C, 0x1F84], [0x1F8D, 0x1F85], [0x1F8E, 0x1F86], [0x1F8F, 0x1F87], [0x1F90, 0x1F98], [0x1F91, 0x1F99], [0x1F92, 0x1F9A], [0x1F93, 0x1F9B], [0x1F94, 0x1F9C], [0x1F95, 0x1F9D], [0x1F96, 0x1F9E], [0x1F97, 0x1F9F], [0x1F98, 0x1F90], [0x1F99, 0x1F91], [0x1F9A, 0x1F92], [0x1F9B, 0x1F93], [0x1F9C, 0x1F94], [0x1F9D, 0x1F95], [0x1F9E, 0x1F96], [0x1F9F, 0x1F97], [0x1FA0, 0x1FA8], [0x1FA1, 0x1FA9], [0x1FA2, 0x1FAA], [0x1FA3, 0x1FAB], [0x1FA4, 0x1FAC], [0x1FA5, 0x1FAD], [0x1FA6, 0x1FAE], [0x1FA7, 0x1FAF], [0x1FA8, 0x1FA0], [0x1FA9, 0x1FA1], [0x1FAA, 0x1FA2], [0x1FAB, 0x1FA3], [0x1FAC, 0x1FA4], [0x1FAD, 0x1FA5], [0x1FAE, 0x1FA6], [0x1FAF, 0x1FA7], [0x1FB3, 0x1FBC], [0x1FBC, 0x1FB3], [0x1FBE, [0x345, 0x399]], [0x1FC3, 0x1FCC], [0x1FCC, 0x1FC3], [0x1FF3, 0x1FFC], [0x1FFC, 0x1FF3], [0x2126, [0x3A9, 0x3C9]], [0x212A, 0x4B], [0x212B, [0xC5, 0xE5]], [0xA64A, 0x1C88], [0xA64B, 0x1C88], [0xA794, 0xA7C4], [0xA7AE, 0x26A], [0xA7B2, 0x29D], [0xA7B3, 0xAB53], [0xA7B4, 0xA7B5], [0xA7B5, 0xA7B4], [0xA7B6, 0xA7B7], [0xA7B7, 0xA7B6], [0xA7B8, 0xA7B9], [0xA7B9, 0xA7B8], [0xA7BA, 0xA7BB], [0xA7BB, 0xA7BA], [0xA7BC, 0xA7BD], [0xA7BD, 0xA7BC], [0xA7BE, 0xA7BF], [0xA7BF, 0xA7BE], [0xA7C2, 0xA7C3], [0xA7C3, 0xA7C2], [0xA7C4, 0xA794], [0xA7C5, 0x282], [0xA7C6, 0x1D8E], [0xAB53, 0xA7B3], [0xAB70, 0x13A0], [0xAB71, 0x13A1], [0xAB72, 0x13A2], [0xAB73, 0x13A3], [0xAB74, 0x13A4], [0xAB75, 0x13A5], [0xAB76, 0x13A6], [0xAB77, 0x13A7], [0xAB78, 0x13A8], [0xAB79, 0x13A9], [0xAB7A, 0x13AA], [0xAB7B, 0x13AB], [0xAB7C, 0x13AC], [0xAB7D, 0x13AD], [0xAB7E, 0x13AE], [0xAB7F, 0x13AF], [0xAB80, 0x13B0], [0xAB81, 0x13B1], [0xAB82, 0x13B2], [0xAB83, 0x13B3], [0xAB84, 0x13B4], [0xAB85, 0x13B5], [0xAB86, 0x13B6], [0xAB87, 0x13B7], [0xAB88, 0x13B8], [0xAB89, 0x13B9], [0xAB8A, 0x13BA], [0xAB8B, 0x13BB], [0xAB8C, 0x13BC], [0xAB8D, 0x13BD], [0xAB8E, 0x13BE], [0xAB8F, 0x13BF], [0xAB90, 0x13C0], [0xAB91, 0x13C1], [0xAB92, 0x13C2], [0xAB93, 0x13C3], [0xAB94, 0x13C4], [0xAB95, 0x13C5], [0xAB96, 0x13C6], [0xAB97, 0x13C7], [0xAB98, 0x13C8], [0xAB99, 0x13C9], [0xAB9A, 0x13CA], [0xAB9B, 0x13CB], [0xAB9C, 0x13CC], [0xAB9D, 0x13CD], [0xAB9E, 0x13CE], [0xAB9F, 0x13CF], [0xABA0, 0x13D0], [0xABA1, 0x13D1], [0xABA2, 0x13D2], [0xABA3, 0x13D3], [0xABA4, 0x13D4], [0xABA5, 0x13D5], [0xABA6, 0x13D6], [0xABA7, 0x13D7], [0xABA8, 0x13D8], [0xABA9, 0x13D9], [0xABAA, 0x13DA], [0xABAB, 0x13DB], [0xABAC, 0x13DC], [0xABAD, 0x13DD], [0xABAE, 0x13DE], [0xABAF, 0x13DF], [0xABB0, 0x13E0], [0xABB1, 0x13E1], [0xABB2, 0x13E2], [0xABB3, 0x13E3], [0xABB4, 0x13E4], [0xABB5, 0x13E5], [0xABB6, 0x13E6], [0xABB7, 0x13E7], [0xABB8, 0x13E8], [0xABB9, 0x13E9], [0xABBA, 0x13EA], [0xABBB, 0x13EB], [0xABBC, 0x13EC], [0xABBD, 0x13ED], [0xABBE, 0x13EE], [0xABBF, 0x13EF], [0x10400, 0x10428], [0x10401, 0x10429], [0x10402, 0x1042A], [0x10403, 0x1042B], [0x10404, 0x1042C], [0x10405, 0x1042D], [0x10406, 0x1042E], [0x10407, 0x1042F], [0x10408, 0x10430], [0x10409, 0x10431], [0x1040A, 0x10432], [0x1040B, 0x10433], [0x1040C, 0x10434], [0x1040D, 0x10435], [0x1040E, 0x10436], [0x1040F, 0x10437], [0x10410, 0x10438], [0x10411, 0x10439], [0x10412, 0x1043A], [0x10413, 0x1043B], [0x10414, 0x1043C], [0x10415, 0x1043D], [0x10416, 0x1043E], [0x10417, 0x1043F], [0x10418, 0x10440], [0x10419, 0x10441], [0x1041A, 0x10442], [0x1041B, 0x10443], [0x1041C, 0x10444], [0x1041D, 0x10445], [0x1041E, 0x10446], [0x1041F, 0x10447], [0x10420, 0x10448], [0x10421, 0x10449], [0x10422, 0x1044A], [0x10423, 0x1044B], [0x10424, 0x1044C], [0x10425, 0x1044D], [0x10426, 0x1044E], [0x10427, 0x1044F], [0x10428, 0x10400], [0x10429, 0x10401], [0x1042A, 0x10402], [0x1042B, 0x10403], [0x1042C, 0x10404], [0x1042D, 0x10405], [0x1042E, 0x10406], [0x1042F, 0x10407], [0x10430, 0x10408], [0x10431, 0x10409], [0x10432, 0x1040A], [0x10433, 0x1040B], [0x10434, 0x1040C], [0x10435, 0x1040D], [0x10436, 0x1040E], [0x10437, 0x1040F], [0x10438, 0x10410], [0x10439, 0x10411], [0x1043A, 0x10412], [0x1043B, 0x10413], [0x1043C, 0x10414], [0x1043D, 0x10415], [0x1043E, 0x10416], [0x1043F, 0x10417], [0x10440, 0x10418], [0x10441, 0x10419], [0x10442, 0x1041A], [0x10443, 0x1041B], [0x10444, 0x1041C], [0x10445, 0x1041D], [0x10446, 0x1041E], [0x10447, 0x1041F], [0x10448, 0x10420], [0x10449, 0x10421], [0x1044A, 0x10422], [0x1044B, 0x10423], [0x1044C, 0x10424], [0x1044D, 0x10425], [0x1044E, 0x10426], [0x1044F, 0x10427], [0x104B0, 0x104D8], [0x104B1, 0x104D9], [0x104B2, 0x104DA], [0x104B3, 0x104DB], [0x104B4, 0x104DC], [0x104B5, 0x104DD], [0x104B6, 0x104DE], [0x104B7, 0x104DF], [0x104B8, 0x104E0], [0x104B9, 0x104E1], [0x104BA, 0x104E2], [0x104BB, 0x104E3], [0x104BC, 0x104E4], [0x104BD, 0x104E5], [0x104BE, 0x104E6], [0x104BF, 0x104E7], [0x104C0, 0x104E8], [0x104C1, 0x104E9], [0x104C2, 0x104EA], [0x104C3, 0x104EB], [0x104C4, 0x104EC], [0x104C5, 0x104ED], [0x104C6, 0x104EE], [0x104C7, 0x104EF], [0x104C8, 0x104F0], [0x104C9, 0x104F1], [0x104CA, 0x104F2], [0x104CB, 0x104F3], [0x104CC, 0x104F4], [0x104CD, 0x104F5], [0x104CE, 0x104F6], [0x104CF, 0x104F7], [0x104D0, 0x104F8], [0x104D1, 0x104F9], [0x104D2, 0x104FA], [0x104D3, 0x104FB], [0x104D8, 0x104B0], [0x104D9, 0x104B1], [0x104DA, 0x104B2], [0x104DB, 0x104B3], [0x104DC, 0x104B4], [0x104DD, 0x104B5], [0x104DE, 0x104B6], [0x104DF, 0x104B7], [0x104E0, 0x104B8], [0x104E1, 0x104B9], [0x104E2, 0x104BA], [0x104E3, 0x104BB], [0x104E4, 0x104BC], [0x104E5, 0x104BD], [0x104E6, 0x104BE], [0x104E7, 0x104BF], [0x104E8, 0x104C0], [0x104E9, 0x104C1], [0x104EA, 0x104C2], [0x104EB, 0x104C3], [0x104EC, 0x104C4], [0x104ED, 0x104C5], [0x104EE, 0x104C6], [0x104EF, 0x104C7], [0x104F0, 0x104C8], [0x104F1, 0x104C9], [0x104F2, 0x104CA], [0x104F3, 0x104CB], [0x104F4, 0x104CC], [0x104F5, 0x104CD], [0x104F6, 0x104CE], [0x104F7, 0x104CF], [0x104F8, 0x104D0], [0x104F9, 0x104D1], [0x104FA, 0x104D2], [0x104FB, 0x104D3], [0x10C80, 0x10CC0], [0x10C81, 0x10CC1], [0x10C82, 0x10CC2], [0x10C83, 0x10CC3], [0x10C84, 0x10CC4], [0x10C85, 0x10CC5], [0x10C86, 0x10CC6], [0x10C87, 0x10CC7], [0x10C88, 0x10CC8], [0x10C89, 0x10CC9], [0x10C8A, 0x10CCA], [0x10C8B, 0x10CCB], [0x10C8C, 0x10CCC], [0x10C8D, 0x10CCD], [0x10C8E, 0x10CCE], [0x10C8F, 0x10CCF], [0x10C90, 0x10CD0], [0x10C91, 0x10CD1], [0x10C92, 0x10CD2], [0x10C93, 0x10CD3], [0x10C94, 0x10CD4], [0x10C95, 0x10CD5], [0x10C96, 0x10CD6], [0x10C97, 0x10CD7], [0x10C98, 0x10CD8], [0x10C99, 0x10CD9], [0x10C9A, 0x10CDA], [0x10C9B, 0x10CDB], [0x10C9C, 0x10CDC], [0x10C9D, 0x10CDD], [0x10C9E, 0x10CDE], [0x10C9F, 0x10CDF], [0x10CA0, 0x10CE0], [0x10CA1, 0x10CE1], [0x10CA2, 0x10CE2], [0x10CA3, 0x10CE3], [0x10CA4, 0x10CE4], [0x10CA5, 0x10CE5], [0x10CA6, 0x10CE6], [0x10CA7, 0x10CE7], [0x10CA8, 0x10CE8], [0x10CA9, 0x10CE9], [0x10CAA, 0x10CEA], [0x10CAB, 0x10CEB], [0x10CAC, 0x10CEC], [0x10CAD, 0x10CED], [0x10CAE, 0x10CEE], [0x10CAF, 0x10CEF], [0x10CB0, 0x10CF0], [0x10CB1, 0x10CF1], [0x10CB2, 0x10CF2], [0x10CC0, 0x10C80], [0x10CC1, 0x10C81], [0x10CC2, 0x10C82], [0x10CC3, 0x10C83], [0x10CC4, 0x10C84], [0x10CC5, 0x10C85], [0x10CC6, 0x10C86], [0x10CC7, 0x10C87], [0x10CC8, 0x10C88], [0x10CC9, 0x10C89], [0x10CCA, 0x10C8A], [0x10CCB, 0x10C8B], [0x10CCC, 0x10C8C], [0x10CCD, 0x10C8D], [0x10CCE, 0x10C8E], [0x10CCF, 0x10C8F], [0x10CD0, 0x10C90], [0x10CD1, 0x10C91], [0x10CD2, 0x10C92], [0x10CD3, 0x10C93], [0x10CD4, 0x10C94], [0x10CD5, 0x10C95], [0x10CD6, 0x10C96], [0x10CD7, 0x10C97], [0x10CD8, 0x10C98], [0x10CD9, 0x10C99], [0x10CDA, 0x10C9A], [0x10CDB, 0x10C9B], [0x10CDC, 0x10C9C], [0x10CDD, 0x10C9D], [0x10CDE, 0x10C9E], [0x10CDF, 0x10C9F], [0x10CE0, 0x10CA0], [0x10CE1, 0x10CA1], [0x10CE2, 0x10CA2], [0x10CE3, 0x10CA3], [0x10CE4, 0x10CA4], [0x10CE5, 0x10CA5], [0x10CE6, 0x10CA6], [0x10CE7, 0x10CA7], [0x10CE8, 0x10CA8], [0x10CE9, 0x10CA9], [0x10CEA, 0x10CAA], [0x10CEB, 0x10CAB], [0x10CEC, 0x10CAC], [0x10CED, 0x10CAD], [0x10CEE, 0x10CAE], [0x10CEF, 0x10CAF], [0x10CF0, 0x10CB0], [0x10CF1, 0x10CB1], [0x10CF2, 0x10CB2], [0x118A0, 0x118C0], [0x118A1, 0x118C1], [0x118A2, 0x118C2], [0x118A3, 0x118C3], [0x118A4, 0x118C4], [0x118A5, 0x118C5], [0x118A6, 0x118C6], [0x118A7, 0x118C7], [0x118A8, 0x118C8], [0x118A9, 0x118C9], [0x118AA, 0x118CA], [0x118AB, 0x118CB], [0x118AC, 0x118CC], [0x118AD, 0x118CD], [0x118AE, 0x118CE], [0x118AF, 0x118CF], [0x118B0, 0x118D0], [0x118B1, 0x118D1], [0x118B2, 0x118D2], [0x118B3, 0x118D3], [0x118B4, 0x118D4], [0x118B5, 0x118D5], [0x118B6, 0x118D6], [0x118B7, 0x118D7], [0x118B8, 0x118D8], [0x118B9, 0x118D9], [0x118BA, 0x118DA], [0x118BB, 0x118DB], [0x118BC, 0x118DC], [0x118BD, 0x118DD], [0x118BE, 0x118DE], [0x118BF, 0x118DF], [0x118C0, 0x118A0], [0x118C1, 0x118A1], [0x118C2, 0x118A2], [0x118C3, 0x118A3], [0x118C4, 0x118A4], [0x118C5, 0x118A5], [0x118C6, 0x118A6], [0x118C7, 0x118A7], [0x118C8, 0x118A8], [0x118C9, 0x118A9], [0x118CA, 0x118AA], [0x118CB, 0x118AB], [0x118CC, 0x118AC], [0x118CD, 0x118AD], [0x118CE, 0x118AE], [0x118CF, 0x118AF], [0x118D0, 0x118B0], [0x118D1, 0x118B1], [0x118D2, 0x118B2], [0x118D3, 0x118B3], [0x118D4, 0x118B4], [0x118D5, 0x118B5], [0x118D6, 0x118B6], [0x118D7, 0x118B7], [0x118D8, 0x118B8], [0x118D9, 0x118B9], [0x118DA, 0x118BA], [0x118DB, 0x118BB], [0x118DC, 0x118BC], [0x118DD, 0x118BD], [0x118DE, 0x118BE], [0x118DF, 0x118BF], [0x16E40, 0x16E60], [0x16E41, 0x16E61], [0x16E42, 0x16E62], [0x16E43, 0x16E63], [0x16E44, 0x16E64], [0x16E45, 0x16E65], [0x16E46, 0x16E66], [0x16E47, 0x16E67], [0x16E48, 0x16E68], [0x16E49, 0x16E69], [0x16E4A, 0x16E6A], [0x16E4B, 0x16E6B], [0x16E4C, 0x16E6C], [0x16E4D, 0x16E6D], [0x16E4E, 0x16E6E], [0x16E4F, 0x16E6F], [0x16E50, 0x16E70], [0x16E51, 0x16E71], [0x16E52, 0x16E72], [0x16E53, 0x16E73], [0x16E54, 0x16E74], [0x16E55, 0x16E75], [0x16E56, 0x16E76], [0x16E57, 0x16E77], [0x16E58, 0x16E78], [0x16E59, 0x16E79], [0x16E5A, 0x16E7A], [0x16E5B, 0x16E7B], [0x16E5C, 0x16E7C], [0x16E5D, 0x16E7D], [0x16E5E, 0x16E7E], [0x16E5F, 0x16E7F], [0x16E60, 0x16E40], [0x16E61, 0x16E41], [0x16E62, 0x16E42], [0x16E63, 0x16E43], [0x16E64, 0x16E44], [0x16E65, 0x16E45], [0x16E66, 0x16E46], [0x16E67, 0x16E47], [0x16E68, 0x16E48], [0x16E69, 0x16E49], [0x16E6A, 0x16E4A], [0x16E6B, 0x16E4B], [0x16E6C, 0x16E4C], [0x16E6D, 0x16E4D], [0x16E6E, 0x16E4E], [0x16E6F, 0x16E4F], [0x16E70, 0x16E50], [0x16E71, 0x16E51], [0x16E72, 0x16E52], [0x16E73, 0x16E53], [0x16E74, 0x16E54], [0x16E75, 0x16E55], [0x16E76, 0x16E56], [0x16E77, 0x16E57], [0x16E78, 0x16E58], [0x16E79, 0x16E59], [0x16E7A, 0x16E5A], [0x16E7B, 0x16E5B], [0x16E7C, 0x16E5C], [0x16E7D, 0x16E5D], [0x16E7E, 0x16E5E], [0x16E7F, 0x16E5F], [0x1E900, 0x1E922], [0x1E901, 0x1E923], [0x1E902, 0x1E924], [0x1E903, 0x1E925], [0x1E904, 0x1E926], [0x1E905, 0x1E927], [0x1E906, 0x1E928], [0x1E907, 0x1E929], [0x1E908, 0x1E92A], [0x1E909, 0x1E92B], [0x1E90A, 0x1E92C], [0x1E90B, 0x1E92D], [0x1E90C, 0x1E92E], [0x1E90D, 0x1E92F], [0x1E90E, 0x1E930], [0x1E90F, 0x1E931], [0x1E910, 0x1E932], [0x1E911, 0x1E933], [0x1E912, 0x1E934], [0x1E913, 0x1E935], [0x1E914, 0x1E936], [0x1E915, 0x1E937], [0x1E916, 0x1E938], [0x1E917, 0x1E939], [0x1E918, 0x1E93A], [0x1E919, 0x1E93B], [0x1E91A, 0x1E93C], [0x1E91B, 0x1E93D], [0x1E91C, 0x1E93E], [0x1E91D, 0x1E93F], [0x1E91E, 0x1E940], [0x1E91F, 0x1E941], [0x1E920, 0x1E942], [0x1E921, 0x1E943], [0x1E922, 0x1E900], [0x1E923, 0x1E901], [0x1E924, 0x1E902], [0x1E925, 0x1E903], [0x1E926, 0x1E904], [0x1E927, 0x1E905], [0x1E928, 0x1E906], [0x1E929, 0x1E907], [0x1E92A, 0x1E908], [0x1E92B, 0x1E909], [0x1E92C, 0x1E90A], [0x1E92D, 0x1E90B], [0x1E92E, 0x1E90C], [0x1E92F, 0x1E90D], [0x1E930, 0x1E90E], [0x1E931, 0x1E90F], [0x1E932, 0x1E910], [0x1E933, 0x1E911], [0x1E934, 0x1E912], [0x1E935, 0x1E913], [0x1E936, 0x1E914], [0x1E937, 0x1E915], [0x1E938, 0x1E916], [0x1E939, 0x1E917], [0x1E93A, 0x1E918], [0x1E93B, 0x1E919], [0x1E93C, 0x1E91A], [0x1E93D, 0x1E91B], [0x1E93E, 0x1E91C], [0x1E93F, 0x1E91D], [0x1E940, 0x1E91E], [0x1E941, 0x1E91F], [0x1E942, 0x1E920], [0x1E943, 0x1E921]]);

    var REGULAR = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)]]);
    var UNICODE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)]]);
    var UNICODE_IGNORE_CASE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x17E).addRange(0x180, 0x2129).addRange(0x212B, 0x10FFFF)]]);

    var characterClassEscapeSets = {
    	REGULAR: REGULAR,
    	UNICODE: UNICODE,
    	UNICODE_IGNORE_CASE: UNICODE_IGNORE_CASE
    };

    var _createForOfIteratorHelperLoose$2 = require$$0$1.createForOfIteratorHelperLoose;

    var generate = regjsgen.generate;

    var parse$4 = parser$1.parse;











    var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
    var BMP_SET = regenerate().addRange(0x0, 0xFFFF);
    var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);

    var getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {
      if (unicode) {
        if (ignoreCase) {
          return characterClassEscapeSets.UNICODE_IGNORE_CASE.get(character);
        }

        return characterClassEscapeSets.UNICODE.get(character);
      }

      return characterClassEscapeSets.REGULAR.get(character);
    };

    var getUnicodeDotSet = function getUnicodeDotSet(dotAll) {
      return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
    };

    var getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {
      var path = value ? property + "/" + value : "Binary_Property/" + property;

      try {
        return commonjsRequire("regenerate-unicode-properties/" + path + ".js");
      } catch (exception) {
        throw new Error("Failed to recognize value `" + value + "` for property " + ("`" + property + "`."));
      }
    };

    var handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {
      try {
        var _property = 'General_Category';
        var category = unicodeMatchPropertyValueEcmascript(_property, value);
        return getUnicodePropertyValueSet(_property, category);
      } catch (exception) {}

      var property = unicodeMatchPropertyEcmascript(value);
      return getUnicodePropertyValueSet(property);
    };

    var getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {
      var parts = value.split('=');
      var firstPart = parts[0];
      var set;

      if (parts.length == 1) {
        set = handleLoneUnicodePropertyNameOrValue(firstPart);
      } else {
        var property = unicodeMatchPropertyEcmascript(firstPart);

        var _value = unicodeMatchPropertyValueEcmascript(property, parts[1]);

        set = getUnicodePropertyValueSet(property, _value);
      }

      if (isNegative) {
        return UNICODE_SET.clone().remove(set);
      }

      return set.clone();
    };

    regenerate.prototype.iuAddRange = function (min, max) {
      var $this = this;

      do {
        var folded = caseFold(min);

        if (folded) {
          $this.add(folded);
        }
      } while (++min <= max);

      return $this;
    };

    var update = function update(item, pattern) {
      var tree = parse$4(pattern, config$1.useUnicodeFlag ? 'u' : '');

      switch (tree.type) {
        case 'characterClass':
        case 'group':
        case 'value':
          break;

        default:
          tree = wrap$1(tree, pattern);
      }

      Object.assign(item, tree);
    };

    var wrap$1 = function wrap(tree, pattern) {
      return {
        'type': 'group',
        'behavior': 'ignore',
        'body': [tree],
        'raw': "(?:" + pattern + ")"
      };
    };

    var caseFold = function caseFold(codePoint) {
      return iuMappings.get(codePoint) || false;
    };

    var processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {
      var set = regenerate();

      for (var _iterator = _createForOfIteratorHelperLoose$2(characterClassItem.body), _step; !(_step = _iterator()).done;) {
        var item = _step.value;

        switch (item.type) {
          case 'value':
            set.add(item.codePoint);

            if (config$1.ignoreCase && config$1.unicode && !config$1.useUnicodeFlag) {
              var folded = caseFold(item.codePoint);

              if (folded) {
                set.add(folded);
              }
            }

            break;

          case 'characterClassRange':
            var min = item.min.codePoint;
            var max = item.max.codePoint;
            set.addRange(min, max);

            if (config$1.ignoreCase && config$1.unicode && !config$1.useUnicodeFlag) {
              set.iuAddRange(min, max);
            }

            break;

          case 'characterClassEscape':
            set.add(getCharacterClassEscapeSet(item.value, config$1.unicode, config$1.ignoreCase));
            break;

          case 'unicodePropertyEscape':
            set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
            break;

          default:
            throw new Error("Unknown term type: " + item.type);
        }
      }

      if (characterClassItem.negative) {
        set = (config$1.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
      }

      update(characterClassItem, set.toString(regenerateOptions));
      return characterClassItem;
    };

    var updateNamedReference = function updateNamedReference(item, index) {
      delete item.name;
      item.matchIndex = index;
    };

    var assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {
      var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);

      if (unmatchedReferencesNames.length > 0) {
        throw new Error("Unknown group names: " + unmatchedReferencesNames);
      }
    };

    var processTerm = function processTerm(item, regenerateOptions, groups) {
      switch (item.type) {
        case 'dot':
          if (config$1.unicode) {
            update(item, getUnicodeDotSet(config$1.dotAll).toString(regenerateOptions));
          } else if (config$1.dotAll) {
            update(item, '[\\s\\S]');
          }

          break;

        case 'characterClass':
          item = processCharacterClass(item, regenerateOptions);
          break;

        case 'unicodePropertyEscape':
          if (config$1.unicodePropertyEscape) {
            update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));
          }

          break;

        case 'characterClassEscape':
          update(item, getCharacterClassEscapeSet(item.value, config$1.unicode, config$1.ignoreCase).toString(regenerateOptions));
          break;

        case 'group':
          if (item.behavior == 'normal') {
            groups.lastIndex++;
          }

          if (item.name && config$1.namedGroup) {
            var name = item.name.value;

            if (groups.names[name]) {
              throw new Error("Multiple groups with the same name (" + name + ") are not allowed.");
            }

            var index = groups.lastIndex;
            delete item.name;
            groups.names[name] = index;

            if (groups.onNamedGroup) {
              groups.onNamedGroup.call(null, name, index);
            }

            if (groups.unmatchedReferences[name]) {
              groups.unmatchedReferences[name].forEach(function (reference) {
                updateNamedReference(reference, index);
              });
              delete groups.unmatchedReferences[name];
            }
          }

        case 'alternative':
        case 'disjunction':
        case 'quantifier':
          item.body = item.body.map(function (term) {
            return processTerm(term, regenerateOptions, groups);
          });
          break;

        case 'value':
          var codePoint = item.codePoint;
          var set = regenerate(codePoint);

          if (config$1.ignoreCase && config$1.unicode && !config$1.useUnicodeFlag) {
            var folded = caseFold(codePoint);

            if (folded) {
              set.add(folded);
            }
          }

          update(item, set.toString(regenerateOptions));
          break;

        case 'reference':
          if (item.name) {
            var _name = item.name.value;
            var _index = groups.names[_name];

            if (_index) {
              updateNamedReference(item, _index);
              break;
            }

            if (!groups.unmatchedReferences[_name]) {
              groups.unmatchedReferences[_name] = [];
            }

            groups.unmatchedReferences[_name].push(item);
          }

          break;

        case 'anchor':
        case 'empty':
        case 'group':
          break;

        default:
          throw new Error("Unknown term type: " + item.type);
      }

      return item;
    };

    var config$1 = {
      'ignoreCase': false,
      'unicode': false,
      'dotAll': false,
      'useUnicodeFlag': false,
      'unicodePropertyEscape': false,
      'namedGroup': false
    };

    var rewritePattern = function rewritePattern(pattern, flags, options) {
      config$1.unicode = flags && flags.includes('u');
      var regjsparserFeatures = {
        'unicodePropertyEscape': config$1.unicode,
        'namedGroups': true,
        'lookbehind': options && options.lookbehind
      };
      config$1.ignoreCase = flags && flags.includes('i');
      var supportDotAllFlag = options && options.dotAllFlag;
      config$1.dotAll = supportDotAllFlag && flags && flags.includes('s');
      config$1.namedGroup = options && options.namedGroup;
      config$1.useUnicodeFlag = options && options.useUnicodeFlag;
      config$1.unicodePropertyEscape = options && options.unicodePropertyEscape;
      var regenerateOptions = {
        'hasUnicodeFlag': config$1.useUnicodeFlag,
        'bmpOnly': !config$1.unicode
      };
      var groups = {
        'onNamedGroup': options && options.onNamedGroup,
        'lastIndex': 0,
        'names': Object.create(null),
        'unmatchedReferences': Object.create(null)
      };
      var tree = parse$4(pattern, flags, regjsparserFeatures);
      processTerm(tree, regenerateOptions, groups);
      assertNoUnmatchedReferences(groups);
      return generate(tree);
    };

    var rewritePattern_1 = rewritePattern;

    var FEATURES$1 = Object.freeze({
      unicodeFlag: 1 << 0,
      dotAllFlag: 1 << 1,
      unicodePropertyEscape: 1 << 2,
      namedCaptureGroups: 1 << 3
    });
    var featuresKey$1 = "@babel/plugin-regexp-features/featuresKey";
    var runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
    function enableFeature$1(features, feature) {
      return features | feature;
    }
    function hasFeature$1(features, feature) {
      return !!(features & feature);
    }

    function generateRegexpuOptions(node, features) {
      var useUnicodeFlag = false,
          dotAllFlag = false,
          unicodePropertyEscape = false,
          namedGroup = false;
      var flags = node.flags,
          pattern = node.pattern;
      var flagsIncludesU = flags.includes("u");

      if (flagsIncludesU) {
        if (!hasFeature$1(features, FEATURES$1.unicodeFlag)) {
          useUnicodeFlag = true;
        }

        if (hasFeature$1(features, FEATURES$1.unicodePropertyEscape) && /\\[pP]{/.test(pattern)) {
          unicodePropertyEscape = true;
        }
      }

      if (hasFeature$1(features, FEATURES$1.dotAllFlag) && flags.indexOf("s") >= 0) {
        dotAllFlag = true;
      }

      if (hasFeature$1(features, FEATURES$1.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern)) {
        namedGroup = true;
      }

      if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {
        return null;
      }

      if (flagsIncludesU && flags.indexOf("s") >= 0) {
        dotAllFlag = true;
      }

      return {
        useUnicodeFlag: useUnicodeFlag,
        onNamedGroup: function onNamedGroup() {},
        namedGroup: namedGroup,
        unicodePropertyEscape: unicodePropertyEscape,
        dotAllFlag: dotAllFlag,
        lookbehind: true
      };
    }

    var name$1 = "@babel/helper-create-regexp-features-plugin";
    var version$5 = "7.8.8";
    var author$1 = "The Babel Team (https://babeljs.io/team)";
    var license$1 = "MIT";
    var description$1 = "Compile ESNext Regular Expressions to ES5";
    var repository$1 = {
    	type: "git",
    	url: "https://github.com/babel/babel",
    	directory: "packages/babel-helper-create-regexp-features-plugin"
    };
    var main$1 = "lib/index.js";
    var publishConfig$1 = {
    	access: "public"
    };
    var keywords$3 = [
    	"babel",
    	"babel-plugin"
    ];
    var dependencies$1 = {
    	"@babel/helper-annotate-as-pure": "^7.8.3",
    	"@babel/helper-regex": "^7.8.3",
    	"regexpu-core": "^4.7.0"
    };
    var peerDependencies$1 = {
    	"@babel/core": "^7.0.0"
    };
    var devDependencies$1 = {
    	"@babel/core": "^7.8.6",
    	"@babel/helper-plugin-test-runner": "^7.8.3"
    };
    var pkg$1 = {
    	name: name$1,
    	version: version$5,
    	author: author$1,
    	license: license$1,
    	description: description$1,
    	repository: repository$1,
    	main: main$1,
    	publishConfig: publishConfig$1,
    	keywords: keywords$3,
    	dependencies: dependencies$1,
    	peerDependencies: peerDependencies$1,
    	devDependencies: devDependencies$1
    };

    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }

      return -1;
    }

    var _baseIndexOfWith = baseIndexOfWith;

    var arrayProto$1 = Array.prototype;
    var splice$1 = arrayProto$1.splice;

    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? _baseIndexOfWith : _baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = _copyArray(values);
      }

      if (iteratee) {
        seen = _arrayMap(array, _baseUnary(iteratee));
      }

      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice$1.call(seen, fromIndex, 1);
          }

          splice$1.call(array, fromIndex, 1);
        }
      }

      return array;
    }

    var _basePullAll = basePullAll;

    function pullAll(array, values) {
      return array && array.length && values && values.length ? _basePullAll(array, values) : array;
    }

    var pullAll_1 = pullAll;

    var pull = _baseRest(pullAll_1);
    var pull_1 = pull;

    function is$2(node, flag) {
      return node.type === "RegExpLiteral" && node.flags.indexOf(flag) >= 0;
    }
    function pullFlag(node, flag) {
      var flags = node.flags.split("");
      if (node.flags.indexOf(flag) < 0) return;
      pull_1(flags, flag);
      node.flags = flags.join("");
    }

    var version$6 = pkg$1.version.split(".").reduce(function (v, x) {
      return v * 1e5 + +x;
    }, 0);
    var versionKey$1 = "@babel/plugin-regexp-features/version";
    function createRegExpFeaturePlugin(_ref) {
      var name = _ref.name,
          feature = _ref.feature,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options;
      return {
        name: name,
        pre: function pre() {
          var _file$get;

          var file = this.file;
          var features = (_file$get = file.get(featuresKey$1)) != null ? _file$get : 0;
          var newFeatures = enableFeature$1(features, FEATURES$1[feature]);
          var useUnicodeFlag = options.useUnicodeFlag,
              _options$runtime = options.runtime,
              runtime = _options$runtime === void 0 ? true : _options$runtime;

          if (useUnicodeFlag === false) {
            newFeatures = enableFeature$1(newFeatures, FEATURES$1.unicodeFlag);
          }

          if (newFeatures !== features) {
            file.set(featuresKey$1, newFeatures);
          }

          if (!runtime) {
            file.set(runtimeKey, false);
          }

          if (!file.has(versionKey$1) || file.get(versionKey$1) < version$6) {
            file.set(versionKey$1, version$6);
          }
        },
        visitor: {
          RegExpLiteral: function RegExpLiteral(path) {
            var _file$get2;

            var node = path.node;
            var file = this.file;
            var features = file.get(featuresKey$1);
            var runtime = (_file$get2 = file.get(runtimeKey)) != null ? _file$get2 : true;
            var regexpuOptions = generateRegexpuOptions(node, features);

            if (regexpuOptions === null) {
              return;
            }

            var namedCaptureGroups = {};

            if (regexpuOptions.namedGroup) {
              regexpuOptions.onNamedGroup = function (name, index) {
                namedCaptureGroups[name] = index;
              };
            }

            node.pattern = rewritePattern_1(node.pattern, node.flags, regexpuOptions);

            if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
              var call = CallExpression(this.addHelper("wrapRegExp"), [node, valueToNode(namedCaptureGroups)]);
              annotateAsPure(call);
              path.replaceWith(call);
            }

            if (hasFeature$1(features, FEATURES$1.unicodeFlag)) {
              pullFlag(node, "u");
            }

            if (hasFeature$1(features, FEATURES$1.dotAllFlag)) {
              pullFlag(node, "s");
            }
          }
        }
      };
    }

    function isRegExpTest(path) {
      return path.parentPath.isMemberExpression({
        object: path.node,
        computed: false
      }) && path.parentPath.get("property").isIdentifier({
        name: "test"
      });
    }

    var proposalUnicodePropertyRegex = declare(function (api, options) {
      api.assertVersion(7);
      var _options$useUnicodeFl = options.useUnicodeFlag,
          useUnicodeFlag = _options$useUnicodeFl === void 0 ? true : _options$useUnicodeFl;

      if (typeof useUnicodeFlag !== "boolean") {
        throw new Error(".useUnicodeFlag must be a boolean, or undefined");
      }

      return createRegExpFeaturePlugin({
        name: "proposal-unicode-property-regex",
        feature: "unicodePropertyEscape",
        options: {
          useUnicodeFlag: useUnicodeFlag
        }
      });
    });

    var transformAsyncToGenerator = declare(function (api, options) {
      api.assertVersion(7);
      var method = options.method,
          module = options.module;

      if (method && module) {
        return {
          name: "transform-async-to-generator",
          visitor: {
            Function: function Function(path, state) {
              if (!path.node.async || path.node.generator) return;
              var wrapAsync = state.methodWrapper;

              if (wrapAsync) {
                wrapAsync = cloneNode(wrapAsync);
              } else {
                wrapAsync = state.methodWrapper = addNamed(path, method, module);
              }

              remapAsyncToGenerator(path, {
                wrapAsync: wrapAsync
              });
            }
          }
        };
      }

      return {
        name: "transform-async-to-generator",
        visitor: {
          Function: function Function(path, state) {
            if (!path.node.async || path.node.generator) return;
            remapAsyncToGenerator(path, {
              wrapAsync: state.addHelper("asyncToGenerator")
            });
          }
        }
      };
    });

    var transformArrowFunctions = declare(function (api, options) {
      api.assertVersion(7);
      var spec = options.spec;
      return {
        name: "transform-arrow-functions",
        visitor: {
          ArrowFunctionExpression: function ArrowFunctionExpression(path) {
            if (!path.isArrowFunctionExpression()) return;
            path.arrowFunctionToExpression({
              allowInsertArrow: false,
              specCompliant: !!spec
            });
          }
        }
      };
    });

    var transformBlockScopedFunctions = declare(function (api) {
      api.assertVersion(7);

      function statementList(key, path) {
        var paths = path.get(key);

        for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
          var _path = _step.value;
          var func = _path.node;
          if (!_path.isFunctionDeclaration()) continue;
          var declar = VariableDeclaration("let", [VariableDeclarator(func.id, toExpression(func))]);
          declar._blockHoist = 2;
          func.id = null;

          _path.replaceWith(declar);
        }
      }

      return {
        name: "transform-block-scoped-functions",
        visitor: {
          BlockStatement: function BlockStatement(path) {
            var node = path.node,
                parent = path.parent;

            if (isFunction(parent, {
              body: node
            }) || isExportDeclaration(parent)) {
              return;
            }

            statementList("body", path);
          },
          SwitchCase: function SwitchCase(path) {
            statementList("consequent", path);
          }
        }
      };
    });

    function _templateObject$7() {
      var data = _taggedTemplateLiteralLoose(["", "(\"", "\")"]);

      _templateObject$7 = function _templateObject() {
        return data;
      };

      return data;
    }

    function getTDZStatus(refPath, bindingPath) {
      var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);

      if (executionStatus === "before") {
        return "outside";
      } else if (executionStatus === "after") {
        return "inside";
      } else {
        return "maybe";
      }
    }

    function buildTDZAssert(node, state) {
      return CallExpression(state.addHelper("temporalRef"), [node, StringLiteral(node.name)]);
    }

    function isReference(node, scope, state) {
      var declared = state.letReferences[node.name];
      if (!declared) return false;
      return scope.getBindingIdentifier(node.name) === declared;
    }

    var visitor$2 = {
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        if (!state.tdzEnabled) return;
        var node = path.node,
            parent = path.parent,
            scope = path.scope;
        if (path.parentPath.isFor({
          left: node
        })) return;
        if (!isReference(node, scope, state)) return;
        var bindingPath = scope.getBinding(node.name).path;
        if (bindingPath.isFunctionDeclaration()) return;
        var status = getTDZStatus(path, bindingPath);
        if (status === "outside") return;

        if (status === "maybe") {
          var assert = buildTDZAssert(node, state);
          bindingPath.parent._tdzThis = true;
          path.skip();

          if (path.parentPath.isUpdateExpression()) {
            if (parent._ignoreBlockScopingTDZ) return;
            path.parentPath.replaceWith(SequenceExpression([assert, parent]));
          } else {
            path.replaceWith(assert);
          }
        } else if (status === "inside") {
          path.replaceWith(template.ast(_templateObject$7(), state.addHelper("tdz"), node.name));
        }
      },
      AssignmentExpression: {
        exit: function exit(path, state) {
          if (!state.tdzEnabled) return;
          var node = path.node;
          if (node._ignoreBlockScopingTDZ) return;
          var nodes = [];
          var ids = path.getBindingIdentifiers();

          for (var _i = 0, _Object$keys = Object.keys(ids); _i < _Object$keys.length; _i++) {
            var name = _Object$keys[_i];
            var id = ids[name];

            if (isReference(id, path.scope, state)) {
              nodes.push(id);
            }
          }

          if (nodes.length) {
            node._ignoreBlockScopingTDZ = true;
            nodes.push(node);
            path.replaceWithMultiple(nodes.map(function (n) {
              return ExpressionStatement(n);
            }));
          }
        }
      }
    };

    function createAssigner(assigner) {
      return _baseRest(function (object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

        if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }

        object = Object(object);

        while (++index < length) {
          var source = sources[index];

          if (source) {
            assigner(object, source, index, customizer);
          }
        }

        return object;
      });
    }

    var _createAssigner = createAssigner;

    var assignIn = _createAssigner(function (object, source) {
      _copyObject(source, keysIn_1(source), object);
    });
    var assignIn_1 = assignIn;

    var extend$1 = assignIn_1;

    var DONE = new WeakSet();
    var transformBlockScoping = declare(function (api, opts) {
      api.assertVersion(7);
      var _opts$throwIfClosureR = opts.throwIfClosureRequired,
          throwIfClosureRequired = _opts$throwIfClosureR === void 0 ? false : _opts$throwIfClosureR,
          _opts$tdz = opts.tdz,
          tdzEnabled = _opts$tdz === void 0 ? false : _opts$tdz;

      if (typeof throwIfClosureRequired !== "boolean") {
        throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
      }

      if (typeof tdzEnabled !== "boolean") {
        throw new Error(".tdz must be a boolean, or undefined");
      }

      return {
        name: "transform-block-scoping",
        visitor: {
          VariableDeclaration: function VariableDeclaration(path) {
            var node = path.node,
                parent = path.parent,
                scope = path.scope;
            if (!isBlockScoped$1(node)) return;
            convertBlockScopedToVar(path, null, parent, scope, true);

            if (node._tdzThis) {
              var nodes = [node];

              for (var i = 0; i < node.declarations.length; i++) {
                var decl = node.declarations[i];
                var assign = AssignmentExpression("=", decl.id, decl.init || scope.buildUndefinedNode());
                assign._ignoreBlockScopingTDZ = true;
                nodes.push(ExpressionStatement(assign));
                decl.init = this.addHelper("temporalUndefined");
              }

              node._blockHoist = 2;

              if (path.isCompletionRecord()) {
                nodes.push(ExpressionStatement(scope.buildUndefinedNode()));
              }

              path.replaceWithMultiple(nodes);
            }
          },
          Loop: function Loop(path, state) {
            var parent = path.parent,
                scope = path.scope;
            path.ensureBlock();
            var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
            var replace = blockScoping.run();
            if (replace) path.replaceWith(replace);
          },
          CatchClause: function CatchClause(path, state) {
            var parent = path.parent,
                scope = path.scope;
            var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
            blockScoping.run();
          },
          "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, state) {
            if (!ignoreBlock(path)) {
              var blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);
              blockScoping.run();
            }
          }
        }
      };
    });

    function ignoreBlock(path) {
      return isLoop(path.parent) || isCatchClause(path.parent);
    }

    var buildRetCheck = template("\n  if (typeof RETURN === \"object\") return RETURN.v;\n");

    function isBlockScoped$1(node) {
      if (!isVariableDeclaration(node)) return false;
      if (node[BLOCK_SCOPED_SYMBOL]) return true;
      if (node.kind !== "let" && node.kind !== "const") return false;
      return true;
    }

    function isInLoop(path) {
      var loopOrFunctionParent = path.find(function (path) {
        return path.isLoop() || path.isFunction();
      });
      return loopOrFunctionParent && loopOrFunctionParent.isLoop();
    }

    function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent) {
      if (moveBindingsToParent === void 0) {
        moveBindingsToParent = false;
      }

      if (!node) {
        node = path.node;
      }

      if (isInLoop(path) && !isFor(parent)) {
        for (var i = 0; i < node.declarations.length; i++) {
          var declar = node.declarations[i];
          declar.init = declar.init || scope.buildUndefinedNode();
        }
      }

      node[BLOCK_SCOPED_SYMBOL] = true;
      node.kind = "var";

      if (moveBindingsToParent) {
        var parentScope = scope.getFunctionParent() || scope.getProgramParent();

        for (var _i = 0, _Object$keys = Object.keys(path.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          var binding = scope.getOwnBinding(name);
          if (binding) binding.kind = "var";
          scope.moveBindingTo(name, parentScope);
        }
      }
    }

    function isVar$1(node) {
      return isVariableDeclaration(node, {
        kind: "var"
      }) && !isBlockScoped$1(node);
    }

    var letReferenceBlockVisitor = traverse$1.visitors.merge([{
      Loop: {
        enter: function enter(path, state) {
          state.loopDepth++;
        },
        exit: function exit(path, state) {
          state.loopDepth--;
        }
      },
      Function: function Function(path, state) {
        if (state.loopDepth > 0) {
          path.traverse(letReferenceFunctionVisitor, state);
        } else {
          path.traverse(visitor$2, state);
        }

        return path.skip();
      }
    }, visitor$2]);
    var letReferenceFunctionVisitor = traverse$1.visitors.merge([{
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        var ref = state.letReferences[path.node.name];
        if (!ref) return;
        var localBinding = path.scope.getBindingIdentifier(path.node.name);
        if (localBinding && localBinding !== ref) return;
        state.closurify = true;
      }
    }, visitor$2]);
    var hoistVarDeclarationsVisitor = {
      enter: function enter(path, self) {
        var node = path.node,
            parent = path.parent;

        if (path.isForStatement()) {
          if (isVar$1(node.init)) {
            var nodes = self.pushDeclar(node.init);

            if (nodes.length === 1) {
              node.init = nodes[0];
            } else {
              node.init = SequenceExpression(nodes);
            }
          }
        } else if (path.isFor()) {
          if (isVar$1(node.left)) {
            self.pushDeclar(node.left);
            node.left = node.left.declarations[0].id;
          }
        } else if (isVar$1(node)) {
          path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) {
            return ExpressionStatement(expr);
          }));
        } else if (path.isFunction()) {
          return path.skip();
        }
      }
    };
    var loopLabelVisitor = {
      LabeledStatement: function LabeledStatement(_ref, state) {
        var node = _ref.node;
        state.innerLabels.push(node.label.name);
      }
    };
    var continuationVisitor = {
      enter: function enter(path, state) {
        if (path.isAssignmentExpression() || path.isUpdateExpression()) {
          for (var _i2 = 0, _Object$keys2 = Object.keys(path.getBindingIdentifiers()); _i2 < _Object$keys2.length; _i2++) {
            var name = _Object$keys2[_i2];

            if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) {
              continue;
            }

            state.reassignments[name] = true;
          }
        } else if (path.isReturnStatement()) {
          state.returnStatements.push(path);
        }
      }
    };

    function loopNodeTo(node) {
      if (isBreakStatement(node)) {
        return "break";
      } else if (isContinueStatement(node)) {
        return "continue";
      }
    }

    var loopVisitor = {
      Loop: function Loop(path, state) {
        var oldIgnoreLabeless = state.ignoreLabeless;
        state.ignoreLabeless = true;
        path.traverse(loopVisitor, state);
        state.ignoreLabeless = oldIgnoreLabeless;
        path.skip();
      },
      Function: function Function(path) {
        path.skip();
      },
      SwitchCase: function SwitchCase(path, state) {
        var oldInSwitchCase = state.inSwitchCase;
        state.inSwitchCase = true;
        path.traverse(loopVisitor, state);
        state.inSwitchCase = oldInSwitchCase;
        path.skip();
      },
      "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) {
        var node = path.node,
            scope = path.scope;
        if (node[this.LOOP_IGNORE]) return;
        var replace;
        var loopText = loopNodeTo(node);

        if (loopText) {
          if (node.label) {
            if (state.innerLabels.indexOf(node.label.name) >= 0) {
              return;
            }

            loopText = loopText + "|" + node.label.name;
          } else {
            if (state.ignoreLabeless) return;
            if (isBreakStatement(node) && state.inSwitchCase) return;
          }

          state.hasBreakContinue = true;
          state.map[loopText] = node;
          replace = StringLiteral(loopText);
        }

        if (path.isReturnStatement()) {
          state.hasReturn = true;
          replace = ObjectExpression([ObjectProperty(Identifier("v"), node.argument || scope.buildUndefinedNode())]);
        }

        if (replace) {
          replace = ReturnStatement(replace);
          replace[this.LOOP_IGNORE] = true;
          path.skip();
          path.replaceWith(inherits(replace, node));
        }
      }
    };

    var BlockScoping = function () {
      function BlockScoping(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
        this.parent = parent;
        this.scope = scope;
        this.state = state;
        this.throwIfClosureRequired = throwIfClosureRequired;
        this.tdzEnabled = tdzEnabled;
        this.blockPath = blockPath;
        this.block = blockPath.node;
        this.outsideLetReferences = Object.create(null);
        this.hasLetReferences = false;
        this.letReferences = Object.create(null);
        this.body = [];

        if (loopPath) {
          this.loopParent = loopPath.parent;
          this.loopLabel = isLabeledStatement(this.loopParent) && this.loopParent.label;
          this.loopPath = loopPath;
          this.loop = loopPath.node;
        }
      }

      var _proto = BlockScoping.prototype;

      _proto.run = function run() {
        var block = this.block;
        if (DONE.has(block)) return;
        DONE.add(block);
        var needsClosure = this.getLetReferences();
        this.checkConstants();

        if (isFunction(this.parent) || isProgram(this.block)) {
          this.updateScopeInfo();
          return;
        }

        if (!this.hasLetReferences) return;

        if (needsClosure) {
          this.wrapClosure();
        } else {
          this.remap();
        }

        this.updateScopeInfo(needsClosure);

        if (this.loopLabel && !isLabeledStatement(this.loopParent)) {
          return LabeledStatement(this.loopLabel, this.loop);
        }
      };

      _proto.checkConstants = function checkConstants() {
        var scope = this.scope;
        var state = this.state;

        for (var _i3 = 0, _Object$keys3 = Object.keys(scope.bindings); _i3 < _Object$keys3.length; _i3++) {
          var name = _Object$keys3[_i3];
          var binding = scope.bindings[name];
          if (binding.kind !== "const") continue;

          for (var _i4 = 0, _arr = binding.constantViolations; _i4 < _arr.length; _i4++) {
            var violation = _arr[_i4];
            var readOnlyError = state.addHelper("readOnlyError");
            var throwNode = CallExpression(readOnlyError, [StringLiteral(name)]);

            if (violation.isAssignmentExpression()) {
              violation.get("right").replaceWith(SequenceExpression([throwNode, violation.get("right").node]));
            } else if (violation.isUpdateExpression()) {
              violation.replaceWith(SequenceExpression([throwNode, violation.node]));
            } else if (violation.isForXStatement()) {
              violation.ensureBlock();
              violation.node.body.body.unshift(ExpressionStatement(throwNode));
            }
          }
        }
      };

      _proto.updateScopeInfo = function updateScopeInfo(wrappedInClosure) {
        var blockScope = this.blockPath.scope;
        var parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
        var letRefs = this.letReferences;

        for (var _i5 = 0, _Object$keys4 = Object.keys(letRefs); _i5 < _Object$keys4.length; _i5++) {
          var key = _Object$keys4[_i5];
          var ref = letRefs[key];
          var binding = blockScope.getBinding(ref.name);
          if (!binding) continue;

          if (binding.kind === "let" || binding.kind === "const") {
            binding.kind = "var";

            if (wrappedInClosure) {
              if (blockScope.hasOwnBinding(ref.name)) {
                blockScope.removeBinding(ref.name);
              }
            } else {
              blockScope.moveBindingTo(ref.name, parentScope);
            }
          }
        }
      };

      _proto.remap = function remap() {
        var letRefs = this.letReferences;
        var outsideLetRefs = this.outsideLetReferences;
        var scope = this.scope;
        var blockPathScope = this.blockPath.scope;

        for (var _i6 = 0, _Object$keys5 = Object.keys(letRefs); _i6 < _Object$keys5.length; _i6++) {
          var key = _Object$keys5[_i6];
          var ref = letRefs[key];

          if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
            if (scope.hasOwnBinding(key)) {
              scope.rename(ref.name);
            }

            if (blockPathScope.hasOwnBinding(key)) {
              blockPathScope.rename(ref.name);
            }
          }
        }

        for (var _i7 = 0, _Object$keys6 = Object.keys(outsideLetRefs); _i7 < _Object$keys6.length; _i7++) {
          var _key = _Object$keys6[_i7];
          var _ref2 = letRefs[_key];

          if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(_key)) {
            blockPathScope.rename(_ref2.name);
          }
        }
      };

      _proto.wrapClosure = function wrapClosure() {
        if (this.throwIfClosureRequired) {
          throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
        }

        var block = this.block;
        var outsideRefs = this.outsideLetReferences;

        if (this.loop) {
          for (var _i8 = 0, _Object$keys7 = Object.keys(outsideRefs); _i8 < _Object$keys7.length; _i8++) {
            var name = _Object$keys7[_i8];
            var id = outsideRefs[name];

            if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
              delete outsideRefs[id.name];
              delete this.letReferences[id.name];
              this.scope.rename(id.name);
              this.letReferences[id.name] = id;
              outsideRefs[id.name] = id;
            }
          }
        }

        this.has = this.checkLoop();
        this.hoistVarDeclarations();
        var args = values_1(outsideRefs).map(function (id) {
          return cloneNode(id);
        });
        var params = args.map(function (id) {
          return cloneNode(id);
        });
        var isSwitch = this.blockPath.isSwitchStatement();
        var fn = FunctionExpression(null, params, BlockStatement(isSwitch ? [block] : block.body));
        this.addContinuations(fn);
        var call = CallExpression(NullLiteral(), args);
        var basePath = ".callee";
        var hasYield = traverse$1.hasType(fn.body, "YieldExpression", FUNCTION_TYPES);

        if (hasYield) {
          fn.generator = true;
          call = YieldExpression(call, true);
          basePath = ".argument" + basePath;
        }

        var hasAsync = traverse$1.hasType(fn.body, "AwaitExpression", FUNCTION_TYPES);

        if (hasAsync) {
          fn.async = true;
          call = AwaitExpression(call);
          basePath = ".argument" + basePath;
        }

        var placeholderPath;
        var index;

        if (this.has.hasReturn || this.has.hasBreakContinue) {
          var ret = this.scope.generateUid("ret");
          this.body.push(VariableDeclaration("var", [VariableDeclarator(Identifier(ret), call)]));
          placeholderPath = "declarations.0.init" + basePath;
          index = this.body.length - 1;
          this.buildHas(ret);
        } else {
          this.body.push(ExpressionStatement(call));
          placeholderPath = "expression" + basePath;
          index = this.body.length - 1;
        }

        var callPath;

        if (isSwitch) {
          var _this$blockPath = this.blockPath,
              parentPath = _this$blockPath.parentPath,
              listKey = _this$blockPath.listKey,
              key = _this$blockPath.key;
          this.blockPath.replaceWithMultiple(this.body);
          callPath = parentPath.get(listKey)[key + index];
        } else {
          block.body = this.body;
          callPath = this.blockPath.get("body")[index];
        }

        var placeholder = callPath.get(placeholderPath);
        var fnPath;

        if (this.loop) {
          var loopId = this.scope.generateUid("loop");
          var p = this.loopPath.insertBefore(VariableDeclaration("var", [VariableDeclarator(Identifier(loopId), fn)]));
          placeholder.replaceWith(Identifier(loopId));
          fnPath = p[0].get("declarations.0.init");
        } else {
          placeholder.replaceWith(fn);
          fnPath = placeholder;
        }

        fnPath.unwrapFunctionEnvironment();
      };

      _proto.addContinuations = function addContinuations(fn) {
        var _this = this;

        var state = {
          reassignments: {},
          returnStatements: [],
          outsideReferences: this.outsideLetReferences
        };
        this.scope.traverse(fn, continuationVisitor, state);

        var _loop = function _loop(i) {
          var param = fn.params[i];
          if (!state.reassignments[param.name]) return "continue";
          var paramName = param.name;

          var newParamName = _this.scope.generateUid(param.name);

          fn.params[i] = Identifier(newParamName);

          _this.scope.rename(paramName, newParamName, fn);

          state.returnStatements.forEach(function (returnStatement) {
            returnStatement.insertBefore(ExpressionStatement(AssignmentExpression("=", Identifier(paramName), Identifier(newParamName))));
          });
          fn.body.body.push(ExpressionStatement(AssignmentExpression("=", Identifier(paramName), Identifier(newParamName))));
        };

        for (var i = 0; i < fn.params.length; i++) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }
      };

      _proto.getLetReferences = function getLetReferences() {
        var _this2 = this;

        var block = this.block;
        var declarators = [];

        if (this.loop) {
          var init = this.loop.left || this.loop.init;

          if (isBlockScoped$1(init)) {
            declarators.push(init);
            extend$1(this.outsideLetReferences, getBindingIdentifiers(init));
          }
        }

        var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {
          node = node || path.node;

          if (isClassDeclaration(node) || isFunctionDeclaration(node) || isBlockScoped$1(node)) {
            if (isBlockScoped$1(node)) {
              convertBlockScopedToVar(path, node, block, _this2.scope);
            }

            declarators = declarators.concat(node.declarations || node);
          }

          if (isLabeledStatement(node)) {
            addDeclarationsFromChild(path.get("body"), node.body);
          }
        };

        if (block.body) {
          var declarPaths = this.blockPath.get("body");

          for (var i = 0; i < block.body.length; i++) {
            addDeclarationsFromChild(declarPaths[i]);
          }
        }

        if (block.cases) {
          var _declarPaths = this.blockPath.get("cases");

          for (var _i9 = 0; _i9 < block.cases.length; _i9++) {
            var consequents = block.cases[_i9].consequent;

            for (var j = 0; j < consequents.length; j++) {
              var declar = consequents[j];
              addDeclarationsFromChild(_declarPaths[_i9], declar);
            }
          }
        }

        for (var _i10 = 0; _i10 < declarators.length; _i10++) {
          var _declar = declarators[_i10];
          var keys = getBindingIdentifiers(_declar, false, true);
          extend$1(this.letReferences, keys);
          this.hasLetReferences = true;
        }

        if (!this.hasLetReferences) return;
        var state = {
          letReferences: this.letReferences,
          closurify: false,
          loopDepth: 0,
          tdzEnabled: this.tdzEnabled,
          addHelper: function addHelper(name) {
            return _this2.state.addHelper(name);
          }
        };

        if (isInLoop(this.blockPath)) {
          state.loopDepth++;
        }

        this.blockPath.traverse(letReferenceBlockVisitor, state);
        return state.closurify;
      };

      _proto.checkLoop = function checkLoop() {
        var state = {
          hasBreakContinue: false,
          ignoreLabeless: false,
          inSwitchCase: false,
          innerLabels: [],
          hasReturn: false,
          isLoop: !!this.loop,
          map: {},
          LOOP_IGNORE: Symbol()
        };
        this.blockPath.traverse(loopLabelVisitor, state);
        this.blockPath.traverse(loopVisitor, state);
        return state;
      };

      _proto.hoistVarDeclarations = function hoistVarDeclarations() {
        this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
      };

      _proto.pushDeclar = function pushDeclar(node) {
        var declars = [];
        var names = getBindingIdentifiers(node);

        for (var _i11 = 0, _Object$keys8 = Object.keys(names); _i11 < _Object$keys8.length; _i11++) {
          var name = _Object$keys8[_i11];
          declars.push(VariableDeclarator(names[name]));
        }

        this.body.push(VariableDeclaration(node.kind, declars));
        var replace = [];

        for (var i = 0; i < node.declarations.length; i++) {
          var declar = node.declarations[i];
          if (!declar.init) continue;
          var expr = AssignmentExpression("=", cloneNode(declar.id), cloneNode(declar.init));
          replace.push(inherits(expr, declar));
        }

        return replace;
      };

      _proto.buildHas = function buildHas(ret) {
        var body = this.body;
        var retCheck;
        var has = this.has;
        var cases = [];

        if (has.hasReturn) {
          retCheck = buildRetCheck({
            RETURN: Identifier(ret)
          });
        }

        if (has.hasBreakContinue) {
          for (var _i12 = 0, _Object$keys9 = Object.keys(has.map); _i12 < _Object$keys9.length; _i12++) {
            var key = _Object$keys9[_i12];
            cases.push(SwitchCase(StringLiteral(key), [has.map[key]]));
          }

          if (has.hasReturn) {
            cases.push(SwitchCase(null, [retCheck]));
          }

          if (cases.length === 1) {
            var single = cases[0];
            body.push(IfStatement(BinaryExpression("===", Identifier(ret), single.test), single.consequent[0]));
          } else {
            if (this.loop) {
              for (var i = 0; i < cases.length; i++) {
                var caseConsequent = cases[i].consequent[0];

                if (isBreakStatement(caseConsequent) && !caseConsequent.label) {
                  if (!this.loopLabel) {
                    this.loopLabel = this.scope.generateUidIdentifier("loop");
                  }

                  caseConsequent.label = cloneNode(this.loopLabel);
                }
              }
            }

            body.push(SwitchStatement(Identifier(ret), cases));
          }
        } else {
          if (has.hasReturn) {
            body.push(retCheck);
          }
        }
      };

      return BlockScoping;
    }();

    var builtin$1 = {
    	"Array": false,
    	"ArrayBuffer": false,
    	Atomics: false,
    	BigInt: false,
    	BigInt64Array: false,
    	BigUint64Array: false,
    	"Boolean": false,
    	constructor: false,
    	"DataView": false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Float32Array": false,
    	"Float64Array": false,
    	"Function": false,
    	globalThis: false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"Int16Array": false,
    	"Int32Array": false,
    	"Int8Array": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Map": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	"Promise": false,
    	propertyIsEnumerable: false,
    	"Proxy": false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"Reflect": false,
    	"RegExp": false,
    	"Set": false,
    	SharedArrayBuffer: false,
    	"String": false,
    	"Symbol": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"Uint16Array": false,
    	"Uint32Array": false,
    	"Uint8Array": false,
    	"Uint8ClampedArray": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false,
    	"WeakMap": false,
    	"WeakSet": false
    };
    var es5$1 = {
    	"Array": false,
    	"Boolean": false,
    	constructor: false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Function": false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	propertyIsEnumerable: false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"RegExp": false,
    	"String": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false
    };
    var es2015$1 = {
    	"Array": false,
    	"ArrayBuffer": false,
    	"Boolean": false,
    	constructor: false,
    	"DataView": false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Float32Array": false,
    	"Float64Array": false,
    	"Function": false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"Int16Array": false,
    	"Int32Array": false,
    	"Int8Array": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Map": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	"Promise": false,
    	propertyIsEnumerable: false,
    	"Proxy": false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"Reflect": false,
    	"RegExp": false,
    	"Set": false,
    	"String": false,
    	"Symbol": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"Uint16Array": false,
    	"Uint32Array": false,
    	"Uint8Array": false,
    	"Uint8ClampedArray": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false,
    	"WeakMap": false,
    	"WeakSet": false
    };
    var es2017$1 = {
    	"Array": false,
    	"ArrayBuffer": false,
    	Atomics: false,
    	"Boolean": false,
    	constructor: false,
    	"DataView": false,
    	"Date": false,
    	"decodeURI": false,
    	"decodeURIComponent": false,
    	"encodeURI": false,
    	"encodeURIComponent": false,
    	"Error": false,
    	"escape": false,
    	"eval": false,
    	"EvalError": false,
    	"Float32Array": false,
    	"Float64Array": false,
    	"Function": false,
    	hasOwnProperty: false,
    	"Infinity": false,
    	"Int16Array": false,
    	"Int32Array": false,
    	"Int8Array": false,
    	"isFinite": false,
    	"isNaN": false,
    	isPrototypeOf: false,
    	"JSON": false,
    	"Map": false,
    	"Math": false,
    	"NaN": false,
    	"Number": false,
    	"Object": false,
    	"parseFloat": false,
    	"parseInt": false,
    	"Promise": false,
    	propertyIsEnumerable: false,
    	"Proxy": false,
    	"RangeError": false,
    	"ReferenceError": false,
    	"Reflect": false,
    	"RegExp": false,
    	"Set": false,
    	SharedArrayBuffer: false,
    	"String": false,
    	"Symbol": false,
    	"SyntaxError": false,
    	toLocaleString: false,
    	toString: false,
    	"TypeError": false,
    	"Uint16Array": false,
    	"Uint32Array": false,
    	"Uint8Array": false,
    	"Uint8ClampedArray": false,
    	"undefined": false,
    	"unescape": false,
    	"URIError": false,
    	valueOf: false,
    	"WeakMap": false,
    	"WeakSet": false
    };
    var browser$5 = {
    	AbortController: false,
    	AbortSignal: false,
    	addEventListener: false,
    	alert: false,
    	AnalyserNode: false,
    	Animation: false,
    	AnimationEffectReadOnly: false,
    	AnimationEffectTiming: false,
    	AnimationEffectTimingReadOnly: false,
    	AnimationEvent: false,
    	AnimationPlaybackEvent: false,
    	AnimationTimeline: false,
    	applicationCache: false,
    	ApplicationCache: false,
    	ApplicationCacheErrorEvent: false,
    	atob: false,
    	Attr: false,
    	Audio: false,
    	AudioBuffer: false,
    	AudioBufferSourceNode: false,
    	AudioContext: false,
    	AudioDestinationNode: false,
    	AudioListener: false,
    	AudioNode: false,
    	AudioParam: false,
    	AudioProcessingEvent: false,
    	AudioScheduledSourceNode: false,
    	"AudioWorkletGlobalScope ": false,
    	AudioWorkletNode: false,
    	AudioWorkletProcessor: false,
    	BarProp: false,
    	BaseAudioContext: false,
    	BatteryManager: false,
    	BeforeUnloadEvent: false,
    	BiquadFilterNode: false,
    	Blob: false,
    	BlobEvent: false,
    	blur: false,
    	BroadcastChannel: false,
    	btoa: false,
    	BudgetService: false,
    	ByteLengthQueuingStrategy: false,
    	Cache: false,
    	caches: false,
    	CacheStorage: false,
    	cancelAnimationFrame: false,
    	cancelIdleCallback: false,
    	CanvasCaptureMediaStreamTrack: false,
    	CanvasGradient: false,
    	CanvasPattern: false,
    	CanvasRenderingContext2D: false,
    	ChannelMergerNode: false,
    	ChannelSplitterNode: false,
    	CharacterData: false,
    	clearInterval: false,
    	clearTimeout: false,
    	clientInformation: false,
    	ClipboardEvent: false,
    	close: false,
    	closed: false,
    	CloseEvent: false,
    	Comment: false,
    	CompositionEvent: false,
    	confirm: false,
    	console: false,
    	ConstantSourceNode: false,
    	ConvolverNode: false,
    	CountQueuingStrategy: false,
    	createImageBitmap: false,
    	Credential: false,
    	CredentialsContainer: false,
    	crypto: false,
    	Crypto: false,
    	CryptoKey: false,
    	CSS: false,
    	CSSConditionRule: false,
    	CSSFontFaceRule: false,
    	CSSGroupingRule: false,
    	CSSImportRule: false,
    	CSSKeyframeRule: false,
    	CSSKeyframesRule: false,
    	CSSMediaRule: false,
    	CSSNamespaceRule: false,
    	CSSPageRule: false,
    	CSSRule: false,
    	CSSRuleList: false,
    	CSSStyleDeclaration: false,
    	CSSStyleRule: false,
    	CSSStyleSheet: false,
    	CSSSupportsRule: false,
    	CustomElementRegistry: false,
    	customElements: false,
    	CustomEvent: false,
    	DataTransfer: false,
    	DataTransferItem: false,
    	DataTransferItemList: false,
    	defaultstatus: false,
    	defaultStatus: false,
    	DelayNode: false,
    	DeviceMotionEvent: false,
    	DeviceOrientationEvent: false,
    	devicePixelRatio: false,
    	dispatchEvent: false,
    	document: false,
    	Document: false,
    	DocumentFragment: false,
    	DocumentType: false,
    	DOMError: false,
    	DOMException: false,
    	DOMImplementation: false,
    	DOMMatrix: false,
    	DOMMatrixReadOnly: false,
    	DOMParser: false,
    	DOMPoint: false,
    	DOMPointReadOnly: false,
    	DOMQuad: false,
    	DOMRect: false,
    	DOMRectReadOnly: false,
    	DOMStringList: false,
    	DOMStringMap: false,
    	DOMTokenList: false,
    	DragEvent: false,
    	DynamicsCompressorNode: false,
    	Element: false,
    	ErrorEvent: false,
    	event: false,
    	Event: false,
    	EventSource: false,
    	EventTarget: false,
    	external: false,
    	fetch: false,
    	File: false,
    	FileList: false,
    	FileReader: false,
    	find: false,
    	focus: false,
    	FocusEvent: false,
    	FontFace: false,
    	FontFaceSetLoadEvent: false,
    	FormData: false,
    	frameElement: false,
    	frames: false,
    	GainNode: false,
    	Gamepad: false,
    	GamepadButton: false,
    	GamepadEvent: false,
    	getComputedStyle: false,
    	getSelection: false,
    	HashChangeEvent: false,
    	Headers: false,
    	history: false,
    	History: false,
    	HTMLAllCollection: false,
    	HTMLAnchorElement: false,
    	HTMLAreaElement: false,
    	HTMLAudioElement: false,
    	HTMLBaseElement: false,
    	HTMLBodyElement: false,
    	HTMLBRElement: false,
    	HTMLButtonElement: false,
    	HTMLCanvasElement: false,
    	HTMLCollection: false,
    	HTMLContentElement: false,
    	HTMLDataElement: false,
    	HTMLDataListElement: false,
    	HTMLDetailsElement: false,
    	HTMLDialogElement: false,
    	HTMLDirectoryElement: false,
    	HTMLDivElement: false,
    	HTMLDListElement: false,
    	HTMLDocument: false,
    	HTMLElement: false,
    	HTMLEmbedElement: false,
    	HTMLFieldSetElement: false,
    	HTMLFontElement: false,
    	HTMLFormControlsCollection: false,
    	HTMLFormElement: false,
    	HTMLFrameElement: false,
    	HTMLFrameSetElement: false,
    	HTMLHeadElement: false,
    	HTMLHeadingElement: false,
    	HTMLHRElement: false,
    	HTMLHtmlElement: false,
    	HTMLIFrameElement: false,
    	HTMLImageElement: false,
    	HTMLInputElement: false,
    	HTMLLabelElement: false,
    	HTMLLegendElement: false,
    	HTMLLIElement: false,
    	HTMLLinkElement: false,
    	HTMLMapElement: false,
    	HTMLMarqueeElement: false,
    	HTMLMediaElement: false,
    	HTMLMenuElement: false,
    	HTMLMetaElement: false,
    	HTMLMeterElement: false,
    	HTMLModElement: false,
    	HTMLObjectElement: false,
    	HTMLOListElement: false,
    	HTMLOptGroupElement: false,
    	HTMLOptionElement: false,
    	HTMLOptionsCollection: false,
    	HTMLOutputElement: false,
    	HTMLParagraphElement: false,
    	HTMLParamElement: false,
    	HTMLPictureElement: false,
    	HTMLPreElement: false,
    	HTMLProgressElement: false,
    	HTMLQuoteElement: false,
    	HTMLScriptElement: false,
    	HTMLSelectElement: false,
    	HTMLShadowElement: false,
    	HTMLSlotElement: false,
    	HTMLSourceElement: false,
    	HTMLSpanElement: false,
    	HTMLStyleElement: false,
    	HTMLTableCaptionElement: false,
    	HTMLTableCellElement: false,
    	HTMLTableColElement: false,
    	HTMLTableElement: false,
    	HTMLTableRowElement: false,
    	HTMLTableSectionElement: false,
    	HTMLTemplateElement: false,
    	HTMLTextAreaElement: false,
    	HTMLTimeElement: false,
    	HTMLTitleElement: false,
    	HTMLTrackElement: false,
    	HTMLUListElement: false,
    	HTMLUnknownElement: false,
    	HTMLVideoElement: false,
    	IDBCursor: false,
    	IDBCursorWithValue: false,
    	IDBDatabase: false,
    	IDBFactory: false,
    	IDBIndex: false,
    	IDBKeyRange: false,
    	IDBObjectStore: false,
    	IDBOpenDBRequest: false,
    	IDBRequest: false,
    	IDBTransaction: false,
    	IDBVersionChangeEvent: false,
    	IdleDeadline: false,
    	IIRFilterNode: false,
    	Image: false,
    	ImageBitmap: false,
    	ImageBitmapRenderingContext: false,
    	ImageCapture: false,
    	ImageData: false,
    	indexedDB: false,
    	innerHeight: false,
    	innerWidth: false,
    	InputEvent: false,
    	IntersectionObserver: false,
    	IntersectionObserverEntry: false,
    	"Intl": false,
    	isSecureContext: false,
    	KeyboardEvent: false,
    	KeyframeEffect: false,
    	KeyframeEffectReadOnly: false,
    	length: false,
    	localStorage: false,
    	location: true,
    	Location: false,
    	locationbar: false,
    	matchMedia: false,
    	MediaDeviceInfo: false,
    	MediaDevices: false,
    	MediaElementAudioSourceNode: false,
    	MediaEncryptedEvent: false,
    	MediaError: false,
    	MediaKeyMessageEvent: false,
    	MediaKeySession: false,
    	MediaKeyStatusMap: false,
    	MediaKeySystemAccess: false,
    	MediaList: false,
    	MediaQueryList: false,
    	MediaQueryListEvent: false,
    	MediaRecorder: false,
    	MediaSettingsRange: false,
    	MediaSource: false,
    	MediaStream: false,
    	MediaStreamAudioDestinationNode: false,
    	MediaStreamAudioSourceNode: false,
    	MediaStreamEvent: false,
    	MediaStreamTrack: false,
    	MediaStreamTrackEvent: false,
    	menubar: false,
    	MessageChannel: false,
    	MessageEvent: false,
    	MessagePort: false,
    	MIDIAccess: false,
    	MIDIConnectionEvent: false,
    	MIDIInput: false,
    	MIDIInputMap: false,
    	MIDIMessageEvent: false,
    	MIDIOutput: false,
    	MIDIOutputMap: false,
    	MIDIPort: false,
    	MimeType: false,
    	MimeTypeArray: false,
    	MouseEvent: false,
    	moveBy: false,
    	moveTo: false,
    	MutationEvent: false,
    	MutationObserver: false,
    	MutationRecord: false,
    	name: false,
    	NamedNodeMap: false,
    	NavigationPreloadManager: false,
    	navigator: false,
    	Navigator: false,
    	NetworkInformation: false,
    	Node: false,
    	NodeFilter: false,
    	NodeIterator: false,
    	NodeList: false,
    	Notification: false,
    	OfflineAudioCompletionEvent: false,
    	OfflineAudioContext: false,
    	offscreenBuffering: false,
    	OffscreenCanvas: true,
    	onabort: true,
    	onafterprint: true,
    	onanimationend: true,
    	onanimationiteration: true,
    	onanimationstart: true,
    	onappinstalled: true,
    	onauxclick: true,
    	onbeforeinstallprompt: true,
    	onbeforeprint: true,
    	onbeforeunload: true,
    	onblur: true,
    	oncancel: true,
    	oncanplay: true,
    	oncanplaythrough: true,
    	onchange: true,
    	onclick: true,
    	onclose: true,
    	oncontextmenu: true,
    	oncuechange: true,
    	ondblclick: true,
    	ondevicemotion: true,
    	ondeviceorientation: true,
    	ondeviceorientationabsolute: true,
    	ondrag: true,
    	ondragend: true,
    	ondragenter: true,
    	ondragleave: true,
    	ondragover: true,
    	ondragstart: true,
    	ondrop: true,
    	ondurationchange: true,
    	onemptied: true,
    	onended: true,
    	onerror: true,
    	onfocus: true,
    	ongotpointercapture: true,
    	onhashchange: true,
    	oninput: true,
    	oninvalid: true,
    	onkeydown: true,
    	onkeypress: true,
    	onkeyup: true,
    	onlanguagechange: true,
    	onload: true,
    	onloadeddata: true,
    	onloadedmetadata: true,
    	onloadstart: true,
    	onlostpointercapture: true,
    	onmessage: true,
    	onmessageerror: true,
    	onmousedown: true,
    	onmouseenter: true,
    	onmouseleave: true,
    	onmousemove: true,
    	onmouseout: true,
    	onmouseover: true,
    	onmouseup: true,
    	onmousewheel: true,
    	onoffline: true,
    	ononline: true,
    	onpagehide: true,
    	onpageshow: true,
    	onpause: true,
    	onplay: true,
    	onplaying: true,
    	onpointercancel: true,
    	onpointerdown: true,
    	onpointerenter: true,
    	onpointerleave: true,
    	onpointermove: true,
    	onpointerout: true,
    	onpointerover: true,
    	onpointerup: true,
    	onpopstate: true,
    	onprogress: true,
    	onratechange: true,
    	onrejectionhandled: true,
    	onreset: true,
    	onresize: true,
    	onscroll: true,
    	onsearch: true,
    	onseeked: true,
    	onseeking: true,
    	onselect: true,
    	onstalled: true,
    	onstorage: true,
    	onsubmit: true,
    	onsuspend: true,
    	ontimeupdate: true,
    	ontoggle: true,
    	ontransitionend: true,
    	onunhandledrejection: true,
    	onunload: true,
    	onvolumechange: true,
    	onwaiting: true,
    	onwheel: true,
    	open: false,
    	openDatabase: false,
    	opener: false,
    	Option: false,
    	origin: false,
    	OscillatorNode: false,
    	outerHeight: false,
    	outerWidth: false,
    	PageTransitionEvent: false,
    	pageXOffset: false,
    	pageYOffset: false,
    	PannerNode: false,
    	parent: false,
    	Path2D: false,
    	PaymentAddress: false,
    	PaymentRequest: false,
    	PaymentRequestUpdateEvent: false,
    	PaymentResponse: false,
    	performance: false,
    	Performance: false,
    	PerformanceEntry: false,
    	PerformanceLongTaskTiming: false,
    	PerformanceMark: false,
    	PerformanceMeasure: false,
    	PerformanceNavigation: false,
    	PerformanceNavigationTiming: false,
    	PerformanceObserver: false,
    	PerformanceObserverEntryList: false,
    	PerformancePaintTiming: false,
    	PerformanceResourceTiming: false,
    	PerformanceTiming: false,
    	PeriodicWave: false,
    	Permissions: false,
    	PermissionStatus: false,
    	personalbar: false,
    	PhotoCapabilities: false,
    	Plugin: false,
    	PluginArray: false,
    	PointerEvent: false,
    	PopStateEvent: false,
    	postMessage: false,
    	Presentation: false,
    	PresentationAvailability: false,
    	PresentationConnection: false,
    	PresentationConnectionAvailableEvent: false,
    	PresentationConnectionCloseEvent: false,
    	PresentationConnectionList: false,
    	PresentationReceiver: false,
    	PresentationRequest: false,
    	print: false,
    	ProcessingInstruction: false,
    	ProgressEvent: false,
    	PromiseRejectionEvent: false,
    	prompt: false,
    	PushManager: false,
    	PushSubscription: false,
    	PushSubscriptionOptions: false,
    	queueMicrotask: false,
    	RadioNodeList: false,
    	Range: false,
    	ReadableStream: false,
    	registerProcessor: false,
    	RemotePlayback: false,
    	removeEventListener: false,
    	Request: false,
    	requestAnimationFrame: false,
    	requestIdleCallback: false,
    	resizeBy: false,
    	ResizeObserver: false,
    	ResizeObserverEntry: false,
    	resizeTo: false,
    	Response: false,
    	RTCCertificate: false,
    	RTCDataChannel: false,
    	RTCDataChannelEvent: false,
    	RTCDtlsTransport: false,
    	RTCIceCandidate: false,
    	RTCIceGatherer: false,
    	RTCIceTransport: false,
    	RTCPeerConnection: false,
    	RTCPeerConnectionIceEvent: false,
    	RTCRtpContributingSource: false,
    	RTCRtpReceiver: false,
    	RTCRtpSender: false,
    	RTCSctpTransport: false,
    	RTCSessionDescription: false,
    	RTCStatsReport: false,
    	RTCTrackEvent: false,
    	screen: false,
    	Screen: false,
    	screenLeft: false,
    	ScreenOrientation: false,
    	screenTop: false,
    	screenX: false,
    	screenY: false,
    	ScriptProcessorNode: false,
    	scroll: false,
    	scrollbars: false,
    	scrollBy: false,
    	scrollTo: false,
    	scrollX: false,
    	scrollY: false,
    	SecurityPolicyViolationEvent: false,
    	Selection: false,
    	self: false,
    	ServiceWorker: false,
    	ServiceWorkerContainer: false,
    	ServiceWorkerRegistration: false,
    	sessionStorage: false,
    	setInterval: false,
    	setTimeout: false,
    	ShadowRoot: false,
    	SharedWorker: false,
    	SourceBuffer: false,
    	SourceBufferList: false,
    	speechSynthesis: false,
    	SpeechSynthesisEvent: false,
    	SpeechSynthesisUtterance: false,
    	StaticRange: false,
    	status: false,
    	statusbar: false,
    	StereoPannerNode: false,
    	stop: false,
    	Storage: false,
    	StorageEvent: false,
    	StorageManager: false,
    	styleMedia: false,
    	StyleSheet: false,
    	StyleSheetList: false,
    	SubtleCrypto: false,
    	SVGAElement: false,
    	SVGAngle: false,
    	SVGAnimatedAngle: false,
    	SVGAnimatedBoolean: false,
    	SVGAnimatedEnumeration: false,
    	SVGAnimatedInteger: false,
    	SVGAnimatedLength: false,
    	SVGAnimatedLengthList: false,
    	SVGAnimatedNumber: false,
    	SVGAnimatedNumberList: false,
    	SVGAnimatedPreserveAspectRatio: false,
    	SVGAnimatedRect: false,
    	SVGAnimatedString: false,
    	SVGAnimatedTransformList: false,
    	SVGAnimateElement: false,
    	SVGAnimateMotionElement: false,
    	SVGAnimateTransformElement: false,
    	SVGAnimationElement: false,
    	SVGCircleElement: false,
    	SVGClipPathElement: false,
    	SVGComponentTransferFunctionElement: false,
    	SVGDefsElement: false,
    	SVGDescElement: false,
    	SVGDiscardElement: false,
    	SVGElement: false,
    	SVGEllipseElement: false,
    	SVGFEBlendElement: false,
    	SVGFEColorMatrixElement: false,
    	SVGFEComponentTransferElement: false,
    	SVGFECompositeElement: false,
    	SVGFEConvolveMatrixElement: false,
    	SVGFEDiffuseLightingElement: false,
    	SVGFEDisplacementMapElement: false,
    	SVGFEDistantLightElement: false,
    	SVGFEDropShadowElement: false,
    	SVGFEFloodElement: false,
    	SVGFEFuncAElement: false,
    	SVGFEFuncBElement: false,
    	SVGFEFuncGElement: false,
    	SVGFEFuncRElement: false,
    	SVGFEGaussianBlurElement: false,
    	SVGFEImageElement: false,
    	SVGFEMergeElement: false,
    	SVGFEMergeNodeElement: false,
    	SVGFEMorphologyElement: false,
    	SVGFEOffsetElement: false,
    	SVGFEPointLightElement: false,
    	SVGFESpecularLightingElement: false,
    	SVGFESpotLightElement: false,
    	SVGFETileElement: false,
    	SVGFETurbulenceElement: false,
    	SVGFilterElement: false,
    	SVGForeignObjectElement: false,
    	SVGGElement: false,
    	SVGGeometryElement: false,
    	SVGGradientElement: false,
    	SVGGraphicsElement: false,
    	SVGImageElement: false,
    	SVGLength: false,
    	SVGLengthList: false,
    	SVGLinearGradientElement: false,
    	SVGLineElement: false,
    	SVGMarkerElement: false,
    	SVGMaskElement: false,
    	SVGMatrix: false,
    	SVGMetadataElement: false,
    	SVGMPathElement: false,
    	SVGNumber: false,
    	SVGNumberList: false,
    	SVGPathElement: false,
    	SVGPatternElement: false,
    	SVGPoint: false,
    	SVGPointList: false,
    	SVGPolygonElement: false,
    	SVGPolylineElement: false,
    	SVGPreserveAspectRatio: false,
    	SVGRadialGradientElement: false,
    	SVGRect: false,
    	SVGRectElement: false,
    	SVGScriptElement: false,
    	SVGSetElement: false,
    	SVGStopElement: false,
    	SVGStringList: false,
    	SVGStyleElement: false,
    	SVGSVGElement: false,
    	SVGSwitchElement: false,
    	SVGSymbolElement: false,
    	SVGTextContentElement: false,
    	SVGTextElement: false,
    	SVGTextPathElement: false,
    	SVGTextPositioningElement: false,
    	SVGTitleElement: false,
    	SVGTransform: false,
    	SVGTransformList: false,
    	SVGTSpanElement: false,
    	SVGUnitTypes: false,
    	SVGUseElement: false,
    	SVGViewElement: false,
    	TaskAttributionTiming: false,
    	Text: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	TextEvent: false,
    	TextMetrics: false,
    	TextTrack: false,
    	TextTrackCue: false,
    	TextTrackCueList: false,
    	TextTrackList: false,
    	TimeRanges: false,
    	toolbar: false,
    	top: false,
    	Touch: false,
    	TouchEvent: false,
    	TouchList: false,
    	TrackEvent: false,
    	TransitionEvent: false,
    	TreeWalker: false,
    	UIEvent: false,
    	URL: false,
    	URLSearchParams: false,
    	ValidityState: false,
    	visualViewport: false,
    	VisualViewport: false,
    	VTTCue: false,
    	WaveShaperNode: false,
    	WebAssembly: false,
    	WebGL2RenderingContext: false,
    	WebGLActiveInfo: false,
    	WebGLBuffer: false,
    	WebGLContextEvent: false,
    	WebGLFramebuffer: false,
    	WebGLProgram: false,
    	WebGLQuery: false,
    	WebGLRenderbuffer: false,
    	WebGLRenderingContext: false,
    	WebGLSampler: false,
    	WebGLShader: false,
    	WebGLShaderPrecisionFormat: false,
    	WebGLSync: false,
    	WebGLTexture: false,
    	WebGLTransformFeedback: false,
    	WebGLUniformLocation: false,
    	WebGLVertexArrayObject: false,
    	WebSocket: false,
    	WheelEvent: false,
    	window: false,
    	Window: false,
    	Worker: false,
    	WritableStream: false,
    	XMLDocument: false,
    	XMLHttpRequest: false,
    	XMLHttpRequestEventTarget: false,
    	XMLHttpRequestUpload: false,
    	XMLSerializer: false,
    	XPathEvaluator: false,
    	XPathExpression: false,
    	XPathResult: false,
    	XSLTProcessor: false
    };
    var worker$1 = {
    	addEventListener: false,
    	applicationCache: false,
    	atob: false,
    	Blob: false,
    	BroadcastChannel: false,
    	btoa: false,
    	Cache: false,
    	caches: false,
    	clearInterval: false,
    	clearTimeout: false,
    	close: true,
    	console: false,
    	fetch: false,
    	FileReaderSync: false,
    	FormData: false,
    	Headers: false,
    	IDBCursor: false,
    	IDBCursorWithValue: false,
    	IDBDatabase: false,
    	IDBFactory: false,
    	IDBIndex: false,
    	IDBKeyRange: false,
    	IDBObjectStore: false,
    	IDBOpenDBRequest: false,
    	IDBRequest: false,
    	IDBTransaction: false,
    	IDBVersionChangeEvent: false,
    	ImageData: false,
    	importScripts: true,
    	indexedDB: false,
    	location: false,
    	MessageChannel: false,
    	MessagePort: false,
    	name: false,
    	navigator: false,
    	Notification: false,
    	onclose: true,
    	onconnect: true,
    	onerror: true,
    	onlanguagechange: true,
    	onmessage: true,
    	onoffline: true,
    	ononline: true,
    	onrejectionhandled: true,
    	onunhandledrejection: true,
    	performance: false,
    	Performance: false,
    	PerformanceEntry: false,
    	PerformanceMark: false,
    	PerformanceMeasure: false,
    	PerformanceNavigation: false,
    	PerformanceResourceTiming: false,
    	PerformanceTiming: false,
    	postMessage: true,
    	"Promise": false,
    	queueMicrotask: false,
    	removeEventListener: false,
    	Request: false,
    	Response: false,
    	self: true,
    	ServiceWorkerRegistration: false,
    	setInterval: false,
    	setTimeout: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	URL: false,
    	URLSearchParams: false,
    	WebSocket: false,
    	Worker: false,
    	WorkerGlobalScope: false,
    	XMLHttpRequest: false
    };
    var node$1 = {
    	__dirname: false,
    	__filename: false,
    	Buffer: false,
    	clearImmediate: false,
    	clearInterval: false,
    	clearTimeout: false,
    	console: false,
    	exports: true,
    	global: false,
    	"Intl": false,
    	module: false,
    	process: false,
    	queueMicrotask: false,
    	require: false,
    	setImmediate: false,
    	setInterval: false,
    	setTimeout: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	URL: false,
    	URLSearchParams: false
    };
    var commonjs$1 = {
    	exports: true,
    	global: false,
    	module: false,
    	require: false
    };
    var amd$1 = {
    	define: false,
    	require: false
    };
    var mocha$1 = {
    	after: false,
    	afterEach: false,
    	before: false,
    	beforeEach: false,
    	context: false,
    	describe: false,
    	it: false,
    	mocha: false,
    	run: false,
    	setup: false,
    	specify: false,
    	suite: false,
    	suiteSetup: false,
    	suiteTeardown: false,
    	teardown: false,
    	test: false,
    	xcontext: false,
    	xdescribe: false,
    	xit: false,
    	xspecify: false
    };
    var jasmine$1 = {
    	afterAll: false,
    	afterEach: false,
    	beforeAll: false,
    	beforeEach: false,
    	describe: false,
    	expect: false,
    	fail: false,
    	fdescribe: false,
    	fit: false,
    	it: false,
    	jasmine: false,
    	pending: false,
    	runs: false,
    	spyOn: false,
    	spyOnProperty: false,
    	waits: false,
    	waitsFor: false,
    	xdescribe: false,
    	xit: false
    };
    var jest$1 = {
    	afterAll: false,
    	afterEach: false,
    	beforeAll: false,
    	beforeEach: false,
    	describe: false,
    	expect: false,
    	fdescribe: false,
    	fit: false,
    	it: false,
    	jest: false,
    	pit: false,
    	require: false,
    	test: false,
    	xdescribe: false,
    	xit: false,
    	xtest: false
    };
    var qunit$1 = {
    	asyncTest: false,
    	deepEqual: false,
    	equal: false,
    	expect: false,
    	module: false,
    	notDeepEqual: false,
    	notEqual: false,
    	notOk: false,
    	notPropEqual: false,
    	notStrictEqual: false,
    	ok: false,
    	propEqual: false,
    	QUnit: false,
    	raises: false,
    	start: false,
    	stop: false,
    	strictEqual: false,
    	test: false,
    	throws: false
    };
    var phantomjs$1 = {
    	console: true,
    	exports: true,
    	phantom: true,
    	require: true,
    	WebPage: true
    };
    var couch$1 = {
    	emit: false,
    	exports: false,
    	getRow: false,
    	log: false,
    	module: false,
    	provides: false,
    	require: false,
    	respond: false,
    	send: false,
    	start: false,
    	sum: false
    };
    var rhino$1 = {
    	defineClass: false,
    	deserialize: false,
    	gc: false,
    	help: false,
    	importClass: false,
    	importPackage: false,
    	java: false,
    	load: false,
    	loadClass: false,
    	Packages: false,
    	print: false,
    	quit: false,
    	readFile: false,
    	readUrl: false,
    	runCommand: false,
    	seal: false,
    	serialize: false,
    	spawn: false,
    	sync: false,
    	toint32: false,
    	version: false
    };
    var nashorn$1 = {
    	__DIR__: false,
    	__FILE__: false,
    	__LINE__: false,
    	com: false,
    	edu: false,
    	exit: false,
    	java: false,
    	Java: false,
    	javafx: false,
    	JavaImporter: false,
    	javax: false,
    	JSAdapter: false,
    	load: false,
    	loadWithNewGlobal: false,
    	org: false,
    	Packages: false,
    	print: false,
    	quit: false
    };
    var wsh$1 = {
    	ActiveXObject: true,
    	Enumerator: true,
    	GetObject: true,
    	ScriptEngine: true,
    	ScriptEngineBuildVersion: true,
    	ScriptEngineMajorVersion: true,
    	ScriptEngineMinorVersion: true,
    	VBArray: true,
    	WScript: true,
    	WSH: true,
    	XDomainRequest: true
    };
    var jquery$1 = {
    	$: false,
    	jQuery: false
    };
    var yui$1 = {
    	YAHOO: false,
    	YAHOO_config: false,
    	YUI: false,
    	YUI_config: false
    };
    var shelljs$1 = {
    	cat: false,
    	cd: false,
    	chmod: false,
    	config: false,
    	cp: false,
    	dirs: false,
    	echo: false,
    	env: false,
    	error: false,
    	exec: false,
    	exit: false,
    	find: false,
    	grep: false,
    	ln: false,
    	ls: false,
    	mkdir: false,
    	mv: false,
    	popd: false,
    	pushd: false,
    	pwd: false,
    	rm: false,
    	sed: false,
    	set: false,
    	target: false,
    	tempdir: false,
    	test: false,
    	touch: false,
    	which: false
    };
    var prototypejs$1 = {
    	$: false,
    	$$: false,
    	$A: false,
    	$break: false,
    	$continue: false,
    	$F: false,
    	$H: false,
    	$R: false,
    	$w: false,
    	Abstract: false,
    	Ajax: false,
    	Autocompleter: false,
    	Builder: false,
    	Class: false,
    	Control: false,
    	Draggable: false,
    	Draggables: false,
    	Droppables: false,
    	Effect: false,
    	Element: false,
    	Enumerable: false,
    	Event: false,
    	Field: false,
    	Form: false,
    	Hash: false,
    	Insertion: false,
    	ObjectRange: false,
    	PeriodicalExecuter: false,
    	Position: false,
    	Prototype: false,
    	Scriptaculous: false,
    	Selector: false,
    	Sortable: false,
    	SortableObserver: false,
    	Sound: false,
    	Template: false,
    	Toggle: false,
    	Try: false
    };
    var meteor$1 = {
    	_: false,
    	$: false,
    	Accounts: false,
    	AccountsClient: false,
    	AccountsCommon: false,
    	AccountsServer: false,
    	App: false,
    	Assets: false,
    	Blaze: false,
    	check: false,
    	Cordova: false,
    	DDP: false,
    	DDPRateLimiter: false,
    	DDPServer: false,
    	Deps: false,
    	EJSON: false,
    	Email: false,
    	HTTP: false,
    	Log: false,
    	Match: false,
    	Meteor: false,
    	Mongo: false,
    	MongoInternals: false,
    	Npm: false,
    	Package: false,
    	Plugin: false,
    	process: false,
    	Random: false,
    	ReactiveDict: false,
    	ReactiveVar: false,
    	Router: false,
    	ServiceConfiguration: false,
    	Session: false,
    	share: false,
    	Spacebars: false,
    	Template: false,
    	Tinytest: false,
    	Tracker: false,
    	UI: false,
    	Utils: false,
    	WebApp: false,
    	WebAppInternals: false
    };
    var mongo$1 = {
    	_isWindows: false,
    	_rand: false,
    	BulkWriteResult: false,
    	cat: false,
    	cd: false,
    	connect: false,
    	db: false,
    	getHostName: false,
    	getMemInfo: false,
    	hostname: false,
    	ISODate: false,
    	listFiles: false,
    	load: false,
    	ls: false,
    	md5sumFile: false,
    	mkdir: false,
    	Mongo: false,
    	NumberInt: false,
    	NumberLong: false,
    	ObjectId: false,
    	PlanCache: false,
    	print: false,
    	printjson: false,
    	pwd: false,
    	quit: false,
    	removeFile: false,
    	rs: false,
    	sh: false,
    	UUID: false,
    	version: false,
    	WriteResult: false
    };
    var applescript$1 = {
    	$: false,
    	Application: false,
    	Automation: false,
    	console: false,
    	delay: false,
    	Library: false,
    	ObjC: false,
    	ObjectSpecifier: false,
    	Path: false,
    	Progress: false,
    	Ref: false
    };
    var serviceworker$1 = {
    	addEventListener: false,
    	applicationCache: false,
    	atob: false,
    	Blob: false,
    	BroadcastChannel: false,
    	btoa: false,
    	Cache: false,
    	caches: false,
    	CacheStorage: false,
    	clearInterval: false,
    	clearTimeout: false,
    	Client: false,
    	clients: false,
    	Clients: false,
    	close: true,
    	console: false,
    	ExtendableEvent: false,
    	ExtendableMessageEvent: false,
    	fetch: false,
    	FetchEvent: false,
    	FileReaderSync: false,
    	FormData: false,
    	Headers: false,
    	IDBCursor: false,
    	IDBCursorWithValue: false,
    	IDBDatabase: false,
    	IDBFactory: false,
    	IDBIndex: false,
    	IDBKeyRange: false,
    	IDBObjectStore: false,
    	IDBOpenDBRequest: false,
    	IDBRequest: false,
    	IDBTransaction: false,
    	IDBVersionChangeEvent: false,
    	ImageData: false,
    	importScripts: false,
    	indexedDB: false,
    	location: false,
    	MessageChannel: false,
    	MessagePort: false,
    	name: false,
    	navigator: false,
    	Notification: false,
    	onclose: true,
    	onconnect: true,
    	onerror: true,
    	onfetch: true,
    	oninstall: true,
    	onlanguagechange: true,
    	onmessage: true,
    	onmessageerror: true,
    	onnotificationclick: true,
    	onnotificationclose: true,
    	onoffline: true,
    	ononline: true,
    	onpush: true,
    	onpushsubscriptionchange: true,
    	onrejectionhandled: true,
    	onsync: true,
    	onunhandledrejection: true,
    	performance: false,
    	Performance: false,
    	PerformanceEntry: false,
    	PerformanceMark: false,
    	PerformanceMeasure: false,
    	PerformanceNavigation: false,
    	PerformanceResourceTiming: false,
    	PerformanceTiming: false,
    	postMessage: true,
    	"Promise": false,
    	queueMicrotask: false,
    	registration: false,
    	removeEventListener: false,
    	Request: false,
    	Response: false,
    	self: false,
    	ServiceWorker: false,
    	ServiceWorkerContainer: false,
    	ServiceWorkerGlobalScope: false,
    	ServiceWorkerMessageEvent: false,
    	ServiceWorkerRegistration: false,
    	setInterval: false,
    	setTimeout: false,
    	skipWaiting: false,
    	TextDecoder: false,
    	TextEncoder: false,
    	URL: false,
    	URLSearchParams: false,
    	WebSocket: false,
    	WindowClient: false,
    	Worker: false,
    	WorkerGlobalScope: false,
    	XMLHttpRequest: false
    };
    var atomtest$1 = {
    	advanceClock: false,
    	fakeClearInterval: false,
    	fakeClearTimeout: false,
    	fakeSetInterval: false,
    	fakeSetTimeout: false,
    	resetTimeouts: false,
    	waitsForPromise: false
    };
    var embertest$1 = {
    	andThen: false,
    	click: false,
    	currentPath: false,
    	currentRouteName: false,
    	currentURL: false,
    	fillIn: false,
    	find: false,
    	findAll: false,
    	findWithAssert: false,
    	keyEvent: false,
    	pauseTest: false,
    	resumeTest: false,
    	triggerEvent: false,
    	visit: false,
    	wait: false
    };
    var protractor$1 = {
    	$: false,
    	$$: false,
    	browser: false,
    	by: false,
    	By: false,
    	DartObject: false,
    	element: false,
    	protractor: false
    };
    var webextensions$1 = {
    	browser: false,
    	chrome: false,
    	opr: false
    };
    var greasemonkey$1 = {
    	cloneInto: false,
    	createObjectIn: false,
    	exportFunction: false,
    	GM: false,
    	GM_addStyle: false,
    	GM_deleteValue: false,
    	GM_getResourceText: false,
    	GM_getResourceURL: false,
    	GM_getValue: false,
    	GM_info: false,
    	GM_listValues: false,
    	GM_log: false,
    	GM_openInTab: false,
    	GM_registerMenuCommand: false,
    	GM_setClipboard: false,
    	GM_setValue: false,
    	GM_xmlhttpRequest: false,
    	unsafeWindow: false
    };
    var devtools$1 = {
    	$: false,
    	$_: false,
    	$$: false,
    	$0: false,
    	$1: false,
    	$2: false,
    	$3: false,
    	$4: false,
    	$x: false,
    	chrome: false,
    	clear: false,
    	copy: false,
    	debug: false,
    	dir: false,
    	dirxml: false,
    	getEventListeners: false,
    	inspect: false,
    	keys: false,
    	monitor: false,
    	monitorEvents: false,
    	profile: false,
    	profileEnd: false,
    	queryObjects: false,
    	table: false,
    	undebug: false,
    	unmonitor: false,
    	unmonitorEvents: false,
    	values: false
    };
    var globals$3 = {
    	builtin: builtin$1,
    	es5: es5$1,
    	es2015: es2015$1,
    	es2017: es2017$1,
    	browser: browser$5,
    	worker: worker$1,
    	node: node$1,
    	commonjs: commonjs$1,
    	amd: amd$1,
    	mocha: mocha$1,
    	jasmine: jasmine$1,
    	jest: jest$1,
    	qunit: qunit$1,
    	phantomjs: phantomjs$1,
    	couch: couch$1,
    	rhino: rhino$1,
    	nashorn: nashorn$1,
    	wsh: wsh$1,
    	jquery: jquery$1,
    	yui: yui$1,
    	shelljs: shelljs$1,
    	prototypejs: prototypejs$1,
    	meteor: meteor$1,
    	mongo: mongo$1,
    	applescript: applescript$1,
    	serviceworker: serviceworker$1,
    	atomtest: atomtest$1,
    	embertest: embertest$1,
    	protractor: protractor$1,
    	"shared-node-browser": {
    	clearInterval: false,
    	clearTimeout: false,
    	console: false,
    	setInterval: false,
    	setTimeout: false,
    	URL: false,
    	URLSearchParams: false
    },
    	webextensions: webextensions$1,
    	greasemonkey: greasemonkey$1,
    	devtools: devtools$1
    };

    var globals$4 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      builtin: builtin$1,
      es5: es5$1,
      es2015: es2015$1,
      es2017: es2017$1,
      browser: browser$5,
      worker: worker$1,
      node: node$1,
      commonjs: commonjs$1,
      amd: amd$1,
      mocha: mocha$1,
      jasmine: jasmine$1,
      jest: jest$1,
      qunit: qunit$1,
      phantomjs: phantomjs$1,
      couch: couch$1,
      rhino: rhino$1,
      nashorn: nashorn$1,
      wsh: wsh$1,
      jquery: jquery$1,
      yui: yui$1,
      shelljs: shelljs$1,
      prototypejs: prototypejs$1,
      meteor: meteor$1,
      mongo: mongo$1,
      applescript: applescript$1,
      serviceworker: serviceworker$1,
      atomtest: atomtest$1,
      embertest: embertest$1,
      protractor: protractor$1,
      webextensions: webextensions$1,
      greasemonkey: greasemonkey$1,
      devtools: devtools$1,
      'default': globals$3
    });

    var require$$0$2 = getCjsExportFromNamespace(globals$4);

    var globals$5 = require$$0$2;

    var objectProto$h = Object.prototype;
    var hasOwnProperty$g = objectProto$h.hasOwnProperty;

    function baseHas(object, key) {
      return object != null && hasOwnProperty$g.call(object, key);
    }

    var _baseHas = baseHas;

    function has$5(object, path) {
      return object != null && _hasPath(object, path, _baseHas);
    }

    var has_1 = has$5;

    function toKind(node) {
      if (isClassMethod(node) || isObjectMethod(node)) {
        if (node.kind === "get" || node.kind === "set") {
          return node.kind;
        }
      }

      return "value";
    }

    function push(mutatorMap, node, kind, file, scope) {
      var alias = toKeyAlias(node);
      var map = {};
      if (has_1(mutatorMap, alias)) map = mutatorMap[alias];
      mutatorMap[alias] = map;
      map._inherits = map._inherits || [];

      map._inherits.push(node);

      map._key = node.key;

      if (node.computed) {
        map._computed = true;
      }

      if (node.decorators) {
        var decorators = map.decorators = map.decorators || ArrayExpression([]);
        decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {
          return dec.expression;
        }).reverse());
      }

      if (map.value || map.initializer) {
        throw file.buildCodeFrameError(node, "Key conflict with sibling node");
      }

      var key, value;

      if (isObjectProperty(node) || isObjectMethod(node) || isClassMethod(node)) {
        key = toComputedKey(node, node.key);
      }

      if (isProperty(node)) {
        value = node.value;
      } else if (isObjectMethod(node) || isClassMethod(node)) {
        value = FunctionExpression(null, node.params, node.body, node.generator, node.async);
        value.returnType = node.returnType;
      }

      var inheritedKind = toKind(node);

      if (!kind || inheritedKind !== "value") {
        kind = inheritedKind;
      }

      if (scope && isStringLiteral(key) && (kind === "value" || kind === "initializer") && isFunctionExpression(value)) {
        value = nameFunction({
          id: key,
          node: value,
          scope: scope
        });
      }

      if (value) {
        inheritsComments(value, node);
        map[kind] = value;
      }

      return map;
    }
    function toComputedObjectFromClass(obj) {
      var objExpr = ArrayExpression([]);

      for (var i = 0; i < obj.properties.length; i++) {
        var prop = obj.properties[i];
        var val = prop.value;
        val.properties.unshift(ObjectProperty(Identifier("key"), toComputedKey(prop)));
        objExpr.elements.push(val);
      }

      return objExpr;
    }
    function toClassObject(mutatorMap) {
      var objExpr = ObjectExpression([]);
      Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
        var map = mutatorMap[mutatorMapKey];
        var mapNode = ObjectExpression([]);
        var propNode = ObjectProperty(map._key, mapNode, map._computed);
        Object.keys(map).forEach(function (key) {
          var node = map[key];
          if (key[0] === "_") return;
          var prop = ObjectProperty(Identifier(key), node);
          inheritsComments(prop, node);
          removeComments(node);
          mapNode.properties.push(prop);
        });
        objExpr.properties.push(propNode);
      });
      return objExpr;
    }
    function toDefineObject(mutatorMap) {
      Object.keys(mutatorMap).forEach(function (key) {
        var map = mutatorMap[key];
        if (map.value) map.writable = BooleanLiteral(true);
        map.configurable = BooleanLiteral(true);
        map.enumerable = BooleanLiteral(true);
      });
      return toClassObject(mutatorMap);
    }

    function _templateObject$8() {
      var data = _taggedTemplateLiteralLoose(["\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n"]);

      _templateObject$8 = function _templateObject() {
        return data;
      };

      return data;
    }
    var helperIDs = new WeakMap();
    function addCreateSuperHelper(file) {
      if (helperIDs.has(file)) {
        return (cloneNode || clone$1)(helperIDs.get(file));
      }

      try {
        return file.addHelper("createSuper");
      } catch (_unused) {}

      var id = file.scope.generateUidIdentifier("createSuper");
      helperIDs.set(file, id);
      var fn = helper$1({
        CREATE_SUPER: id,
        GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
        POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
      });
      file.path.unshiftContainer("body", [fn]);
      file.scope.registerDeclaration(file.path.get("body.0"));
      return cloneNode(id);
    }
    var helper$1 = template.statement(_templateObject$8());

    function _templateObject$9() {
      var data = _taggedTemplateLiteralLoose(["\n        (function () {\n          super(...arguments);\n        })\n      "]);

      _templateObject$9 = function _templateObject() {
        return data;
      };

      return data;
    }

    function buildConstructor(classRef, constructorBody, node) {
      var func = FunctionDeclaration(cloneNode(classRef), [], constructorBody);
      inherits(func, node);
      return func;
    }

    function transformClass(path, file, builtinClasses, isLoose) {
      var classState = {
        parent: undefined,
        scope: undefined,
        node: undefined,
        path: undefined,
        file: undefined,
        classId: undefined,
        classRef: undefined,
        superFnId: undefined,
        superName: undefined,
        superReturns: [],
        isDerived: false,
        extendsNative: false,
        construct: undefined,
        constructorBody: undefined,
        userConstructor: undefined,
        userConstructorPath: undefined,
        hasConstructor: false,
        instancePropBody: [],
        instancePropRefs: {},
        staticPropBody: [],
        body: [],
        superThises: [],
        pushedConstructor: false,
        pushedInherits: false,
        protoAlias: null,
        isLoose: false,
        hasInstanceDescriptors: false,
        hasStaticDescriptors: false,
        instanceMutatorMap: {},
        staticMutatorMap: {}
      };

      var setState = function setState(newState) {
        Object.assign(classState, newState);
      };

      var findThisesVisitor = traverse$1.visitors.merge([environmentVisitor, {
        ThisExpression: function ThisExpression(path) {
          classState.superThises.push(path);
        }
      }]);

      function pushToMap(node, enumerable, kind, scope) {
        if (kind === void 0) {
          kind = "value";
        }

        var mutatorMap;

        if (node["static"]) {
          setState({
            hasStaticDescriptors: true
          });
          mutatorMap = classState.staticMutatorMap;
        } else {
          setState({
            hasInstanceDescriptors: true
          });
          mutatorMap = classState.instanceMutatorMap;
        }

        var map = push(mutatorMap, node, kind, classState.file, scope);

        if (enumerable) {
          map.enumerable = BooleanLiteral(true);
        }

        return map;
      }

      function maybeCreateConstructor() {
        var hasConstructor = false;
        var paths = classState.path.get("body.body");

        for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
          var _path = _step.value;
          hasConstructor = _path.equals("kind", "constructor");
          if (hasConstructor) break;
        }

        if (hasConstructor) return;
        var params, body;

        if (classState.isDerived) {
          var _constructor = template.expression.ast(_templateObject$9());

          params = _constructor.params;
          body = _constructor.body;
        } else {
          params = [];
          body = BlockStatement([]);
        }

        classState.path.get("body").unshiftContainer("body", ClassMethod("constructor", Identifier("constructor"), params, body));
      }

      function buildBody() {
        maybeCreateConstructor();
        pushBody();
        verifyConstructor();

        if (classState.userConstructor) {
          var constructorBody = classState.constructorBody,
              userConstructor = classState.userConstructor,
              construct = classState.construct;
          constructorBody.body = constructorBody.body.concat(userConstructor.body.body);
          inherits(construct, userConstructor);
          inherits(constructorBody, userConstructor.body);
        }

        pushDescriptors();
      }

      function pushBody() {
        var classBodyPaths = classState.path.get("body.body");

        for (var _iterator2 = _createForOfIteratorHelperLoose(classBodyPaths), _step2; !(_step2 = _iterator2()).done;) {
          var _path2 = _step2.value;
          var node = _path2.node;

          if (_path2.isClassProperty()) {
            throw _path2.buildCodeFrameError("Missing class properties transform.");
          }

          if (node.decorators) {
            throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
          }

          if (isClassMethod(node)) {
            (function () {
              var isConstructor = node.kind === "constructor";
              var replaceSupers = new ReplaceSupers({
                methodPath: _path2,
                objectRef: classState.classRef,
                superRef: classState.superName,
                isLoose: classState.isLoose,
                file: classState.file
              });
              replaceSupers.replace();
              var superReturns = [];

              _path2.traverse(traverse$1.visitors.merge([environmentVisitor, {
                ReturnStatement: function ReturnStatement(path) {
                  if (!path.getFunctionParent().isArrowFunctionExpression()) {
                    superReturns.push(path);
                  }
                }
              }]));

              if (isConstructor) {
                pushConstructor(superReturns, node, _path2);
              } else {
                pushMethod(node, _path2);
              }
            })();
          }
        }
      }

      function clearDescriptors() {
        setState({
          hasInstanceDescriptors: false,
          hasStaticDescriptors: false,
          instanceMutatorMap: {},
          staticMutatorMap: {}
        });
      }

      function pushDescriptors() {
        pushInheritsToBody();
        var body = classState.body;
        var instanceProps;
        var staticProps;

        if (classState.hasInstanceDescriptors) {
          instanceProps = toClassObject(classState.instanceMutatorMap);
        }

        if (classState.hasStaticDescriptors) {
          staticProps = toClassObject(classState.staticMutatorMap);
        }

        if (instanceProps || staticProps) {
          if (instanceProps) {
            instanceProps = toComputedObjectFromClass(instanceProps);
          }

          if (staticProps) {
            staticProps = toComputedObjectFromClass(staticProps);
          }

          var args = [cloneNode(classState.classRef), NullLiteral(), NullLiteral()];
          if (instanceProps) args[1] = instanceProps;
          if (staticProps) args[2] = staticProps;
          var lastNonNullIndex = 0;

          for (var i = 0; i < args.length; i++) {
            if (!isNullLiteral(args[i])) lastNonNullIndex = i;
          }

          args = args.slice(0, lastNonNullIndex + 1);
          body.push(ExpressionStatement(CallExpression(classState.file.addHelper("createClass"), args)));
        }

        clearDescriptors();
      }

      function wrapSuperCall(bareSuper, superRef, thisRef, body) {
        var bareSuperNode = bareSuper.node;
        var call;

        if (classState.isLoose) {
          bareSuperNode.arguments.unshift(ThisExpression());

          if (bareSuperNode.arguments.length === 2 && isSpreadElement(bareSuperNode.arguments[1]) && isIdentifier(bareSuperNode.arguments[1].argument, {
            name: "arguments"
          })) {
            bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
            bareSuperNode.callee = MemberExpression(cloneNode(superRef), Identifier("apply"));
          } else {
            bareSuperNode.callee = MemberExpression(cloneNode(superRef), Identifier("call"));
          }

          call = LogicalExpression("||", bareSuperNode, ThisExpression());
        } else {
          call = optimiseCall(cloneNode(classState.superFnId), ThisExpression(), bareSuperNode.arguments);
        }

        if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
          if (classState.superThises.length) {
            call = AssignmentExpression("=", thisRef(), call);
          }

          bareSuper.parentPath.replaceWith(ReturnStatement(call));
        } else {
          bareSuper.replaceWith(AssignmentExpression("=", thisRef(), call));
        }
      }

      function verifyConstructor() {
        if (!classState.isDerived) return;
        var path = classState.userConstructorPath;
        var body = path.get("body");
        path.traverse(findThisesVisitor);

        var _thisRef = function thisRef() {
          var ref = path.scope.generateDeclaredUidIdentifier("this");

          _thisRef = function thisRef() {
            return cloneNode(ref);
          };

          return ref;
        };

        for (var _iterator3 = _createForOfIteratorHelperLoose(classState.superThises), _step3; !(_step3 = _iterator3()).done;) {
          var thisPath = _step3.value;
          var node = thisPath.node,
              parentPath = thisPath.parentPath;

          if (parentPath.isMemberExpression({
            object: node
          })) {
            thisPath.replaceWith(_thisRef());
            continue;
          }

          thisPath.replaceWith(CallExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
        }

        var bareSupers = new Set();
        path.traverse(traverse$1.visitors.merge([environmentVisitor, {
          Super: function Super(path) {
            var node = path.node,
                parentPath = path.parentPath;

            if (parentPath.isCallExpression({
              callee: node
            })) {
              bareSupers.add(parentPath);
            }
          }
        }]));
        var guaranteedSuperBeforeFinish = !!bareSupers.size;

        for (var _iterator4 = _createForOfIteratorHelperLoose(bareSupers), _step4; !(_step4 = _iterator4()).done;) {
          var bareSuper = _step4.value;
          wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

          if (guaranteedSuperBeforeFinish) {
            bareSuper.find(function (parentPath) {
              if (parentPath === path) {
                return true;
              }

              if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
                guaranteedSuperBeforeFinish = false;
                return true;
              }
            });
          }
        }

        var wrapReturn;

        if (classState.isLoose) {
          wrapReturn = function wrapReturn(returnArg) {
            var thisExpr = CallExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);
            return returnArg ? LogicalExpression("||", returnArg, thisExpr) : thisExpr;
          };
        } else {
          wrapReturn = function wrapReturn(returnArg) {
            return CallExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
          };
        }

        var bodyPaths = body.get("body");

        if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
          body.pushContainer("body", ReturnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
        }

        for (var _iterator5 = _createForOfIteratorHelperLoose(classState.superReturns), _step5; !(_step5 = _iterator5()).done;) {
          var returnPath = _step5.value;
          returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
        }
      }

      function pushMethod(node, path) {
        var scope = path ? path.scope : classState.scope;

        if (node.kind === "method") {
          if (processMethod(node, scope)) return;
        }

        pushToMap(node, false, null, scope);
      }

      function processMethod(node, scope) {
        if (classState.isLoose && !node.decorators) {
          var classRef = classState.classRef;

          if (!node["static"]) {
            insertProtoAliasOnce();
            classRef = classState.protoAlias;
          }

          var methodName = MemberExpression(cloneNode(classRef), node.key, node.computed || isLiteral(node.key));
          var func = FunctionExpression(null, node.params, node.body, node.generator, node.async);
          inherits(func, node);
          var key = toComputedKey(node, node.key);

          if (isStringLiteral(key)) {
            func = nameFunction({
              node: func,
              id: key,
              scope: scope
            });
          }

          var expr = ExpressionStatement(AssignmentExpression("=", methodName, func));
          inheritsComments(expr, node);
          classState.body.push(expr);
          return true;
        }

        return false;
      }

      function insertProtoAliasOnce() {
        if (classState.protoAlias === null) {
          setState({
            protoAlias: classState.scope.generateUidIdentifier("proto")
          });
          var classProto = MemberExpression(classState.classRef, Identifier("prototype"));
          var protoDeclaration = VariableDeclaration("var", [VariableDeclarator(classState.protoAlias, classProto)]);
          classState.body.push(protoDeclaration);
        }
      }

      function pushConstructor(superReturns, method, path) {
        if (path.scope.hasOwnBinding(classState.classRef.name)) {
          path.scope.rename(classState.classRef.name);
        }

        setState({
          userConstructorPath: path,
          userConstructor: method,
          hasConstructor: true,
          superReturns: superReturns
        });
        var construct = classState.construct;
        inheritsComments(construct, method);
        construct.params = method.params;
        inherits(construct.body, method.body);
        construct.body.directives = method.body.directives;
        pushConstructorToBody();
      }

      function pushConstructorToBody() {
        if (classState.pushedConstructor) return;
        classState.pushedConstructor = true;

        if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
          pushDescriptors();
        }

        classState.body.push(classState.construct);
        pushInheritsToBody();
      }

      function pushInheritsToBody() {
        if (!classState.isDerived || classState.pushedInherits) return;
        var superFnId = path.scope.generateUidIdentifier("super");
        setState({
          pushedInherits: true,
          superFnId: superFnId
        });

        if (!classState.isLoose) {
          classState.body.unshift(VariableDeclaration("var", [VariableDeclarator(superFnId, CallExpression(addCreateSuperHelper(classState.file), [cloneNode(classState.classRef)]))]));
        }

        classState.body.unshift(ExpressionStatement(CallExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [cloneNode(classState.classRef), cloneNode(classState.superName)])));
      }

      function setupClosureParamsArgs() {
        var superName = classState.superName;
        var closureParams = [];
        var closureArgs = [];

        if (classState.isDerived) {
          var arg = cloneNode(superName);

          if (classState.extendsNative) {
            arg = CallExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
            annotateAsPure(arg);
          }

          var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
          closureParams.push(param);
          closureArgs.push(arg);
          setState({
            superName: cloneNode(param)
          });
        }

        return {
          closureParams: closureParams,
          closureArgs: closureArgs
        };
      }

      function classTransformer(path, file, builtinClasses, isLoose) {
        setState({
          parent: path.parent,
          scope: path.scope,
          node: path.node,
          path: path,
          file: file,
          isLoose: isLoose
        });
        setState({
          classId: classState.node.id,
          classRef: classState.node.id ? Identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
          superName: classState.node.superClass,
          isDerived: !!classState.node.superClass,
          constructorBody: BlockStatement([])
        });
        setState({
          extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
        });
        var classRef = classState.classRef,
            node = classState.node,
            constructorBody = classState.constructorBody;
        setState({
          construct: buildConstructor(classRef, constructorBody, node)
        });
        var body = classState.body;

        var _setupClosureParamsAr = setupClosureParamsArgs(),
            closureParams = _setupClosureParamsAr.closureParams,
            closureArgs = _setupClosureParamsAr.closureArgs;

        buildBody();

        if (!classState.isLoose) {
          constructorBody.body.unshift(ExpressionStatement(CallExpression(classState.file.addHelper("classCallCheck"), [ThisExpression(), cloneNode(classState.classRef)])));
        }

        body = body.concat(classState.staticPropBody.map(function (fn) {
          return fn(cloneNode(classState.classRef));
        }));
        var isStrict = path.isInStrictMode();
        var constructorOnly = classState.classId && body.length === 1;

        if (constructorOnly && !isStrict) {
          for (var _iterator6 = _createForOfIteratorHelperLoose(classState.construct.params), _step6; !(_step6 = _iterator6()).done;) {
            var param = _step6.value;

            if (!isIdentifier(param)) {
              constructorOnly = false;
              break;
            }
          }
        }

        var directives = constructorOnly ? body[0].body.directives : [];

        if (!isStrict) {
          directives.push(Directive(DirectiveLiteral("use strict")));
        }

        if (constructorOnly) {
          return toExpression(body[0]);
        }

        body.push(ReturnStatement(cloneNode(classState.classRef)));
        var container = ArrowFunctionExpression(closureParams, BlockStatement(body, directives));
        return CallExpression(container, closureArgs);
      }

      return classTransformer(path, file, builtinClasses, isLoose);
    }

    var getBuiltinClasses = function getBuiltinClasses(category) {
      return Object.keys(globals$5[category]).filter(function (name) {
        return /^[A-Z]/.test(name);
      });
    };

    var builtinClasses = new Set([].concat(getBuiltinClasses("builtin"), getBuiltinClasses("browser")));
    var transformClasses = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose;
      var VISITED = Symbol();
      return {
        name: "transform-classes",
        visitor: {
          ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
            if (!path.get("declaration").isClassDeclaration()) return;
            splitExportDeclaration(path);
          },
          ClassDeclaration: function ClassDeclaration(path) {
            var node = path.node;
            var ref = node.id || path.scope.generateUidIdentifier("class");
            path.replaceWith(VariableDeclaration("let", [VariableDeclarator(ref, toExpression(node))]));
          },
          ClassExpression: function ClassExpression(path, state) {
            var node = path.node;
            if (node[VISITED]) return;
            var inferred = nameFunction(path);

            if (inferred && inferred !== node) {
              path.replaceWith(inferred);
              return;
            }

            node[VISITED] = true;
            path.replaceWith(transformClass(path, state.file, builtinClasses, loose));

            if (path.isCallExpression()) {
              annotateAsPure(path);

              if (path.get("callee").isArrowFunctionExpression()) {
                path.get("callee").arrowFunctionToExpression();
              }
            }
          }
        }
      };
    });

    var transformComputedProperties = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose;
      var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
      var buildMutatorMapAssign = template("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");

      function getValue(prop) {
        if (isObjectProperty(prop)) {
          return prop.value;
        } else if (isObjectMethod(prop)) {
          return FunctionExpression(null, prop.params, prop.body, prop.generator, prop.async);
        }
      }

      function pushAssign(objId, prop, body) {
        if (prop.kind === "get" && prop.kind === "set") {
          pushMutatorDefine(objId, prop);
        } else {
          body.push(ExpressionStatement(AssignmentExpression("=", MemberExpression(cloneNode(objId), prop.key, prop.computed || isLiteral(prop.key)), getValue(prop))));
        }
      }

      function pushMutatorDefine(_ref, prop) {
        var body = _ref.body,
            getMutatorId = _ref.getMutatorId,
            scope = _ref.scope;
        var key = !prop.computed && isIdentifier(prop.key) ? StringLiteral(prop.key.name) : prop.key;
        var maybeMemoise = scope.maybeGenerateMemoised(key);

        if (maybeMemoise) {
          body.push(ExpressionStatement(AssignmentExpression("=", maybeMemoise, key)));
          key = maybeMemoise;
        }

        body.push.apply(body, buildMutatorMapAssign({
          MUTATOR_MAP_REF: getMutatorId(),
          KEY: cloneNode(key),
          VALUE: getValue(prop),
          KIND: Identifier(prop.kind)
        }));
      }

      function pushComputedPropsLoose(info) {
        for (var _iterator = _createForOfIteratorHelperLoose(info.computedProps), _step; !(_step = _iterator()).done;) {
          var prop = _step.value;

          if (prop.kind === "get" || prop.kind === "set") {
            pushMutatorDefine(info, prop);
          } else {
            pushAssign(cloneNode(info.objId), prop, info.body);
          }
        }
      }

      function pushComputedPropsSpec(info) {
        var objId = info.objId,
            body = info.body,
            computedProps = info.computedProps,
            state = info.state;

        for (var _iterator2 = _createForOfIteratorHelperLoose(computedProps), _step2; !(_step2 = _iterator2()).done;) {
          var prop = _step2.value;
          var key = toComputedKey(prop);

          if (prop.kind === "get" || prop.kind === "set") {
            pushMutatorDefine(info, prop);
          } else if (isStringLiteral(key, {
            value: "__proto__"
          })) {
            pushAssign(objId, prop, body);
          } else {
            if (computedProps.length === 1) {
              return CallExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]);
            } else {
              body.push(ExpressionStatement(CallExpression(state.addHelper("defineProperty"), [cloneNode(objId), key, getValue(prop)])));
            }
          }
        }
      }

      return {
        name: "transform-computed-properties",
        visitor: {
          ObjectExpression: {
            exit: function exit(path, state) {
              var node = path.node,
                  parent = path.parent,
                  scope = path.scope;
              var hasComputed = false;

              for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
                var prop = _arr[_i];
                hasComputed = prop.computed === true;
                if (hasComputed) break;
              }

              if (!hasComputed) return;
              var initProps = [];
              var computedProps = [];
              var foundComputed = false;

              for (var _iterator3 = _createForOfIteratorHelperLoose(node.properties), _step3; !(_step3 = _iterator3()).done;) {
                var _prop = _step3.value;

                if (_prop.computed) {
                  foundComputed = true;
                }

                if (foundComputed) {
                  computedProps.push(_prop);
                } else {
                  initProps.push(_prop);
                }
              }

              var objId = scope.generateUidIdentifierBasedOnNode(parent);
              var initPropExpression = ObjectExpression(initProps);
              var body = [];
              body.push(VariableDeclaration("var", [VariableDeclarator(objId, initPropExpression)]));
              var mutatorRef;

              var getMutatorId = function getMutatorId() {
                if (!mutatorRef) {
                  mutatorRef = scope.generateUidIdentifier("mutatorMap");
                  body.push(VariableDeclaration("var", [VariableDeclarator(mutatorRef, ObjectExpression([]))]));
                }

                return cloneNode(mutatorRef);
              };

              var single = pushComputedProps({
                scope: scope,
                objId: objId,
                body: body,
                computedProps: computedProps,
                initPropExpression: initPropExpression,
                getMutatorId: getMutatorId,
                state: state
              });

              if (mutatorRef) {
                body.push(ExpressionStatement(CallExpression(state.addHelper("defineEnumerableProperties"), [cloneNode(objId), cloneNode(mutatorRef)])));
              }

              if (single) {
                path.replaceWith(single);
              } else {
                body.push(ExpressionStatement(cloneNode(objId)));
                path.replaceWithMultiple(body);
              }
            }
          }
        }
      };
    });

    var transformDestructuring = declare(function (api, options) {
      api.assertVersion(7);
      var _options$loose = options.loose,
          loose = _options$loose === void 0 ? false : _options$loose,
          _options$useBuiltIns = options.useBuiltIns,
          useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

      if (typeof loose !== "boolean") {
        throw new Error(".loose must be a boolean or undefined");
      }

      var arrayOnlySpread = loose;

      function getExtendsHelper(file) {
        return useBuiltIns ? MemberExpression(Identifier("Object"), Identifier("assign")) : file.addHelper("extends");
      }

      function variableDeclarationHasPattern(node) {
        for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
          var declar = _arr[_i];

          if (isPattern(declar.id)) {
            return true;
          }
        }

        return false;
      }

      function hasRest(pattern) {
        for (var _i2 = 0, _arr2 = pattern.elements; _i2 < _arr2.length; _i2++) {
          var elem = _arr2[_i2];

          if (isRestElement(elem)) {
            return true;
          }
        }

        return false;
      }

      function hasObjectRest(pattern) {
        for (var _i3 = 0, _arr3 = pattern.properties; _i3 < _arr3.length; _i3++) {
          var elem = _arr3[_i3];

          if (isRestElement(elem)) {
            return true;
          }
        }

        return false;
      }

      var STOP_TRAVERSAL = {};

      var arrayUnpackVisitor = function arrayUnpackVisitor(node, ancestors, state) {
        if (!ancestors.length) {
          return;
        }

        if (isIdentifier(node) && isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
          state.deopt = true;
          throw STOP_TRAVERSAL;
        }
      };

      var DestructuringTransformer = function () {
        function DestructuringTransformer(opts) {
          this.blockHoist = opts.blockHoist;
          this.operator = opts.operator;
          this.arrays = {};
          this.nodes = opts.nodes || [];
          this.scope = opts.scope;
          this.kind = opts.kind;
          this.arrayOnlySpread = opts.arrayOnlySpread;
          this.addHelper = opts.addHelper;
        }

        var _proto = DestructuringTransformer.prototype;

        _proto.buildVariableAssignment = function buildVariableAssignment(id, init) {
          var op = this.operator;
          if (isMemberExpression(id)) op = "=";
          var node;

          if (op) {
            node = ExpressionStatement(AssignmentExpression(op, id, cloneNode(init) || this.scope.buildUndefinedNode()));
          } else {
            node = VariableDeclaration(this.kind, [VariableDeclarator(id, cloneNode(init))]);
          }

          node._blockHoist = this.blockHoist;
          return node;
        };

        _proto.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
          var declar = VariableDeclaration("var", [VariableDeclarator(cloneNode(id), cloneNode(init))]);
          declar._blockHoist = this.blockHoist;
          return declar;
        };

        _proto.push = function push(id, _init) {
          var init = cloneNode(_init);

          if (isObjectPattern(id)) {
            this.pushObjectPattern(id, init);
          } else if (isArrayPattern(id)) {
            this.pushArrayPattern(id, init);
          } else if (isAssignmentPattern(id)) {
            this.pushAssignmentPattern(id, init);
          } else {
            this.nodes.push(this.buildVariableAssignment(id, init));
          }
        };

        _proto.toArray = function toArray(node, count) {
          if (this.arrayOnlySpread || isIdentifier(node) && this.arrays[node.name]) {
            return node;
          } else {
            return this.scope.toArray(node, count);
          }
        };

        _proto.pushAssignmentPattern = function pushAssignmentPattern(_ref, valueRef) {
          var left = _ref.left,
              right = _ref.right;
          var tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
          this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
          var tempConditional = ConditionalExpression(BinaryExpression("===", cloneNode(tempId), this.scope.buildUndefinedNode()), right, cloneNode(tempId));

          if (isPattern(left)) {
            var patternId;
            var node;

            if (this.kind === "const" || this.kind === "let") {
              patternId = this.scope.generateUidIdentifier(tempId.name);
              node = this.buildVariableDeclaration(patternId, tempConditional);
            } else {
              patternId = tempId;
              node = ExpressionStatement(AssignmentExpression("=", cloneNode(tempId), tempConditional));
            }

            this.nodes.push(node);
            this.push(left, patternId);
          } else {
            this.nodes.push(this.buildVariableAssignment(left, tempConditional));
          }
        };

        _proto.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
          var keys = [];
          var allLiteral = true;

          for (var i = 0; i < pattern.properties.length; i++) {
            var prop = pattern.properties[i];
            if (i >= spreadPropIndex) break;
            if (isRestElement(prop)) continue;
            var key = prop.key;

            if (isIdentifier(key) && !prop.computed) {
              keys.push(StringLiteral(key.name));
            } else if (isTemplateLiteral(prop.key)) {
              keys.push(cloneNode(prop.key));
            } else if (isLiteral(key)) {
              keys.push(StringLiteral(String(key.value)));
            } else {
              keys.push(cloneNode(key));
              allLiteral = false;
            }
          }

          var value;

          if (keys.length === 0) {
            value = CallExpression(getExtendsHelper(this), [ObjectExpression([]), cloneNode(objRef)]);
          } else {
            var keyExpression = ArrayExpression(keys);

            if (!allLiteral) {
              keyExpression = CallExpression(MemberExpression(keyExpression, Identifier("map")), [this.addHelper("toPropertyKey")]);
            }

            value = CallExpression(this.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [cloneNode(objRef), keyExpression]);
          }

          this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
        };

        _proto.pushObjectProperty = function pushObjectProperty(prop, propRef) {
          if (isLiteral(prop.key)) prop.computed = true;
          var pattern = prop.value;
          var objRef = MemberExpression(cloneNode(propRef), prop.key, prop.computed);

          if (isPattern(pattern)) {
            this.push(pattern, objRef);
          } else {
            this.nodes.push(this.buildVariableAssignment(pattern, objRef));
          }
        };

        _proto.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
          if (!pattern.properties.length) {
            this.nodes.push(ExpressionStatement(CallExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
          }

          if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
            var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
            this.nodes.push(this.buildVariableDeclaration(temp, objRef));
            objRef = temp;
          }

          if (hasObjectRest(pattern)) {
            var copiedPattern;

            for (var i = 0; i < pattern.properties.length; i++) {
              var prop = pattern.properties[i];

              if (isRestElement(prop)) {
                break;
              }

              var key = prop.key;

              if (prop.computed && !this.scope.isPure(key)) {
                var name = this.scope.generateUidIdentifierBasedOnNode(key);
                this.nodes.push(this.buildVariableDeclaration(name, key));

                if (!copiedPattern) {
                  copiedPattern = pattern = Object.assign({}, pattern, {
                    properties: pattern.properties.slice()
                  });
                }

                copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                  key: name
                });
              }
            }
          }

          for (var _i4 = 0; _i4 < pattern.properties.length; _i4++) {
            var _prop = pattern.properties[_i4];

            if (isRestElement(_prop)) {
              this.pushObjectRest(pattern, objRef, _prop, _i4);
            } else {
              this.pushObjectProperty(_prop, objRef);
            }
          }
        };

        _proto.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
          if (!isArrayExpression(arr)) return false;
          if (pattern.elements.length > arr.elements.length) return;

          if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
            return false;
          }

          for (var _i5 = 0, _arr4 = pattern.elements; _i5 < _arr4.length; _i5++) {
            var elem = _arr4[_i5];
            if (!elem) return false;
            if (isMemberExpression(elem)) return false;
          }

          for (var _i6 = 0, _arr5 = arr.elements; _i6 < _arr5.length; _i6++) {
            var _elem = _arr5[_i6];
            if (isSpreadElement(_elem)) return false;
            if (isCallExpression(_elem)) return false;
            if (isMemberExpression(_elem)) return false;
          }

          var bindings = getBindingIdentifiers(pattern);
          var state = {
            deopt: false,
            bindings: bindings
          };

          try {
            traverse(arr, arrayUnpackVisitor, state);
          } catch (e) {
            if (e !== STOP_TRAVERSAL) throw e;
          }

          return !state.deopt;
        };

        _proto.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
          for (var i = 0; i < pattern.elements.length; i++) {
            var elem = pattern.elements[i];

            if (isRestElement(elem)) {
              this.push(elem.argument, ArrayExpression(arr.elements.slice(i)));
            } else {
              this.push(elem, arr.elements[i]);
            }
          }
        };

        _proto.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
          if (!pattern.elements) return;

          if (this.canUnpackArrayPattern(pattern, arrayRef)) {
            return this.pushUnpackedArrayPattern(pattern, arrayRef);
          }

          var count = !hasRest(pattern) && pattern.elements.length;
          var toArray = this.toArray(arrayRef, count);

          if (isIdentifier(toArray)) {
            arrayRef = toArray;
          } else {
            arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
            this.arrays[arrayRef.name] = true;
            this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
          }

          for (var i = 0; i < pattern.elements.length; i++) {
            var elem = pattern.elements[i];
            if (!elem) continue;
            var elemRef = void 0;

            if (isRestElement(elem)) {
              elemRef = this.toArray(arrayRef);
              elemRef = CallExpression(MemberExpression(elemRef, Identifier("slice")), [NumericLiteral(i)]);
              elem = elem.argument;
            } else {
              elemRef = MemberExpression(arrayRef, NumericLiteral(i), true);
            }

            this.push(elem, elemRef);
          }
        };

        _proto.init = function init(pattern, ref) {
          if (!isArrayExpression(ref) && !isMemberExpression(ref)) {
            var memo = this.scope.maybeGenerateMemoised(ref, true);

            if (memo) {
              this.nodes.push(this.buildVariableDeclaration(memo, cloneNode(ref)));
              ref = memo;
            }
          }

          this.push(pattern, ref);
          return this.nodes;
        };

        return DestructuringTransformer;
      }();

      return {
        name: "transform-destructuring",
        visitor: {
          ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
            var declaration = path.get("declaration");
            if (!declaration.isVariableDeclaration()) return;
            if (!variableDeclarationHasPattern(declaration.node)) return;
            var specifiers = [];

            for (var _i7 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i7 < _Object$keys.length; _i7++) {
              var name = _Object$keys[_i7];
              specifiers.push(ExportSpecifier(Identifier(name), Identifier(name)));
            }

            path.replaceWith(declaration.node);
            path.insertAfter(ExportNamedDeclaration(null, specifiers));
          },
          ForXStatement: function ForXStatement(path) {
            var _this = this;

            var node = path.node,
                scope = path.scope;
            var left = node.left;

            if (isPattern(left)) {
              var temp = scope.generateUidIdentifier("ref");
              node.left = VariableDeclaration("var", [VariableDeclarator(temp)]);
              path.ensureBlock();

              if (node.body.body.length === 0 && path.isCompletionRecord()) {
                node.body.body.unshift(ExpressionStatement(scope.buildUndefinedNode()));
              }

              node.body.body.unshift(ExpressionStatement(AssignmentExpression("=", left, temp)));
              return;
            }

            if (!isVariableDeclaration(left)) return;
            var pattern = left.declarations[0].id;
            if (!isPattern(pattern)) return;
            var key = scope.generateUidIdentifier("ref");
            node.left = VariableDeclaration(left.kind, [VariableDeclarator(key, null)]);
            var nodes = [];
            var destructuring = new DestructuringTransformer({
              kind: left.kind,
              scope: scope,
              nodes: nodes,
              arrayOnlySpread: arrayOnlySpread,
              addHelper: function addHelper(name) {
                return _this.addHelper(name);
              }
            });
            destructuring.init(pattern, key);
            path.ensureBlock();
            var block = node.body;
            block.body = nodes.concat(block.body);
          },
          CatchClause: function CatchClause(_ref2) {
            var _this2 = this;

            var node = _ref2.node,
                scope = _ref2.scope;
            var pattern = node.param;
            if (!isPattern(pattern)) return;
            var ref = scope.generateUidIdentifier("ref");
            node.param = ref;
            var nodes = [];
            var destructuring = new DestructuringTransformer({
              kind: "let",
              scope: scope,
              nodes: nodes,
              arrayOnlySpread: arrayOnlySpread,
              addHelper: function addHelper(name) {
                return _this2.addHelper(name);
              }
            });
            destructuring.init(pattern, ref);
            node.body.body = nodes.concat(node.body.body);
          },
          AssignmentExpression: function AssignmentExpression(path) {
            var _this3 = this;

            var node = path.node,
                scope = path.scope;
            if (!isPattern(node.left)) return;
            var nodes = [];
            var destructuring = new DestructuringTransformer({
              operator: node.operator,
              scope: scope,
              nodes: nodes,
              arrayOnlySpread: arrayOnlySpread,
              addHelper: function addHelper(name) {
                return _this3.addHelper(name);
              }
            });
            var ref;

            if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
              ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
              nodes.push(VariableDeclaration("var", [VariableDeclarator(ref, node.right)]));

              if (isArrayExpression(node.right)) {
                destructuring.arrays[ref.name] = true;
              }
            }

            destructuring.init(node.left, ref || node.right);

            if (ref) {
              if (path.parentPath.isArrowFunctionExpression()) {
                path.replaceWith(BlockStatement([]));
                nodes.push(ReturnStatement(cloneNode(ref)));
              } else {
                nodes.push(ExpressionStatement(cloneNode(ref)));
              }
            }

            path.replaceWithMultiple(nodes);
            path.scope.crawl();
          },
          VariableDeclaration: function VariableDeclaration(path) {
            var _this4 = this;

            var node = path.node,
                scope = path.scope,
                parent = path.parent;
            if (isForXStatement(parent)) return;
            if (!parent || !path.container) return;
            if (!variableDeclarationHasPattern(node)) return;
            var nodeKind = node.kind;
            var nodes = [];
            var declar;

            for (var i = 0; i < node.declarations.length; i++) {
              declar = node.declarations[i];
              var patternId = declar.init;
              var pattern = declar.id;
              var destructuring = new DestructuringTransformer({
                blockHoist: node._blockHoist,
                nodes: nodes,
                scope: scope,
                kind: node.kind,
                arrayOnlySpread: arrayOnlySpread,
                addHelper: function addHelper(name) {
                  return _this4.addHelper(name);
                }
              });

              if (isPattern(pattern)) {
                destructuring.init(pattern, patternId);

                if (+i !== node.declarations.length - 1) {
                  inherits(nodes[nodes.length - 1], declar);
                }
              } else {
                nodes.push(inherits(destructuring.buildVariableAssignment(declar.id, cloneNode(declar.init)), declar));
              }
            }

            var tail = null;
            var nodesOut = [];

            for (var _i8 = 0, _nodes = nodes; _i8 < _nodes.length; _i8++) {
              var _node = _nodes[_i8];

              if (tail !== null && isVariableDeclaration(_node)) {
                var _tail$declarations;

                (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _node.declarations);
              } else {
                _node.kind = nodeKind;
                nodesOut.push(_node);
                tail = isVariableDeclaration(_node) ? _node : null;
              }
            }

            for (var _i9 = 0, _nodesOut = nodesOut; _i9 < _nodesOut.length; _i9++) {
              var nodeOut = _nodesOut[_i9];
              if (!nodeOut.declarations) continue;

              for (var _iterator = _createForOfIteratorHelperLoose(nodeOut.declarations), _step; !(_step = _iterator()).done;) {
                var declaration = _step.value;
                var name = declaration.id.name;

                if (scope.bindings[name]) {
                  scope.bindings[name].kind = nodeOut.kind;
                }
              }
            }

            if (nodesOut.length === 1) {
              path.replaceWith(nodesOut[0]);
            } else {
              path.replaceWithMultiple(nodesOut);
            }
          }
        }
      };
    });

    var transformDotallRegex = declare(function (api) {
      api.assertVersion(7);
      return createRegExpFeaturePlugin({
        name: "transform-dotall-regex",
        feature: "dotAllFlag"
      });
    });

    function getName$1(key) {
      if (isIdentifier(key)) {
        return key.name;
      }

      return key.value.toString();
    }

    var transformDuplicateKeys = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-duplicate-keys",
        visitor: {
          ObjectExpression: function ObjectExpression(path) {
            var node = path.node;
            var plainProps = node.properties.filter(function (prop) {
              return !isSpreadElement(prop) && !prop.computed;
            });
            var alreadySeenData = Object.create(null);
            var alreadySeenGetters = Object.create(null);
            var alreadySeenSetters = Object.create(null);

            for (var _iterator = _createForOfIteratorHelperLoose(plainProps), _step; !(_step = _iterator()).done;) {
              var prop = _step.value;
              var name = getName$1(prop.key);
              var isDuplicate = false;

              switch (prop.kind) {
                case "get":
                  if (alreadySeenData[name] || alreadySeenGetters[name]) {
                    isDuplicate = true;
                  }

                  alreadySeenGetters[name] = true;
                  break;

                case "set":
                  if (alreadySeenData[name] || alreadySeenSetters[name]) {
                    isDuplicate = true;
                  }

                  alreadySeenSetters[name] = true;
                  break;

                default:
                  if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                    isDuplicate = true;
                  }

                  alreadySeenData[name] = true;
              }

              if (isDuplicate) {
                prop.computed = true;
                prop.key = StringLiteral(name);
              }
            }
          }
        }
      };
    });

    function getObjRef(node, nodes, file, scope) {
      var ref;

      if (isSuper(node)) {
        return node;
      } else if (isIdentifier(node)) {
        if (scope.hasBinding(node.name)) {
          return node;
        } else {
          ref = node;
        }
      } else if (isMemberExpression(node)) {
        ref = node.object;

        if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {
          return ref;
        }
      } else {
        throw new Error("We can't explode this node type " + node.type);
      }

      var temp = scope.generateUidIdentifierBasedOnNode(ref);
      scope.push({
        id: temp
      });
      nodes.push(AssignmentExpression("=", cloneNode(temp), cloneNode(ref)));
      return temp;
    }

    function getPropRef(node, nodes, file, scope) {
      var prop = node.property;
      var key = toComputedKey(node, prop);
      if (isLiteral(key) && isPureish(key)) return key;
      var temp = scope.generateUidIdentifierBasedOnNode(prop);
      scope.push({
        id: temp
      });
      nodes.push(AssignmentExpression("=", cloneNode(temp), cloneNode(prop)));
      return temp;
    }

    function explode$1 (node, nodes, file, scope, allowedSingleIdent) {
      var obj;

      if (isIdentifier(node) && allowedSingleIdent) {
        obj = node;
      } else {
        obj = getObjRef(node, nodes, file, scope);
      }

      var ref, uid;

      if (isIdentifier(node)) {
        ref = cloneNode(node);
        uid = obj;
      } else {
        var prop = getPropRef(node, nodes, file, scope);
        var computed = node.computed || isLiteral(prop);
        uid = MemberExpression(cloneNode(obj), cloneNode(prop), computed);
        ref = MemberExpression(cloneNode(obj), cloneNode(prop), computed);
      }

      return {
        uid: uid,
        ref: ref
      };
    }

    function build (opts) {
      var build = opts.build,
          operator = opts.operator;
      return {
        AssignmentExpression: function AssignmentExpression$1(path) {
          var node = path.node,
              scope = path.scope;
          if (node.operator !== operator + "=") return;
          var nodes = [];
          var exploded = explode$1(node.left, nodes, this, scope);
          nodes.push(AssignmentExpression("=", exploded.ref, build(exploded.uid, node.right)));
          path.replaceWith(SequenceExpression(nodes));
        },
        BinaryExpression: function BinaryExpression(path) {
          var node = path.node;

          if (node.operator === operator) {
            path.replaceWith(build(node.left, node.right));
          }
        }
      };
    }

    var transformExponentialOperator = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-exponentiation-operator",
        visitor: build({
          operator: "**",
          build: function build(left, right) {
            return CallExpression(MemberExpression(Identifier("Math"), Identifier("pow")), [left, right]);
          }
        })
      };
    });

    var transformFlowComments = declare(function (api) {
      api.assertVersion(7);

      function commentFromString(comment) {
        return typeof comment === "string" ? {
          type: "CommentBlock",
          value: comment
        } : comment;
      }

      function attachComment(_ref) {
        var ofPath = _ref.ofPath,
            toPath = _ref.toPath,
            _ref$where = _ref.where,
            where = _ref$where === void 0 ? "trailing" : _ref$where,
            _ref$optional = _ref.optional,
            optional = _ref$optional === void 0 ? false : _ref$optional,
            _ref$comments = _ref.comments,
            comments = _ref$comments === void 0 ? generateComment(ofPath, optional) : _ref$comments,
            _ref$keepType = _ref.keepType,
            keepType = _ref$keepType === void 0 ? false : _ref$keepType;

        if (!toPath || !toPath.node) {
          toPath = ofPath.getPrevSibling();
          where = "trailing";
        }

        if (!toPath.node) {
          toPath = ofPath.getNextSibling();
          where = "leading";
        }

        if (!toPath.node) {
          toPath = ofPath.parentPath;
          where = "inner";
        }

        if (!Array.isArray(comments)) {
          comments = [comments];
        }

        comments = comments.map(commentFromString);

        if (!keepType && ofPath && ofPath.node) {
          var node = ofPath.node;
          var parent = ofPath.parentPath;
          var prev = ofPath.getPrevSibling();
          var next = ofPath.getNextSibling();
          var isSingleChild = !(prev.node || next.node);
          var leading = node.leadingComments;
          var trailing = node.trailingComments;

          if (isSingleChild && leading) {
            parent.addComments("inner", leading);
          }

          toPath.addComments(where, comments);
          ofPath.remove();

          if (isSingleChild && trailing) {
            parent.addComments("inner", trailing);
          }
        } else {
          toPath.addComments(where, comments);
        }
      }

      function wrapInFlowComment(path) {
        attachComment({
          ofPath: path,
          comments: generateComment(path, path.parent.optional)
        });
      }

      function generateComment(path, optional) {
        var comment = path.getSource().replace(/\*-\//g, "*-ESCAPED/").replace(/\*\//g, "*-/");
        if (optional) comment = "?" + comment;
        if (comment[0] !== ":") comment = ":: " + comment;
        return comment;
      }

      function isTypeImport(importKind) {
        return importKind === "type" || importKind === "typeof";
      }

      return {
        name: "transform-flow-comments",
        inherits: syntaxFlow,
        visitor: {
          TypeCastExpression: function TypeCastExpression(path) {
            var node = path.node;
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path.get("expression"),
              keepType: true
            });
            path.replaceWith(ParenthesizedExpression(node.expression));
          },
          Identifier: function Identifier(path) {
            if (path.parentPath.isFlow()) return;
            var node = path.node;

            if (node.typeAnnotation) {
              attachComment({
                ofPath: path.get("typeAnnotation"),
                toPath: path,
                optional: node.optional || node.typeAnnotation.optional
              });

              if (node.optional) {
                node.optional = false;
              }
            } else if (node.optional) {
              attachComment({
                toPath: path,
                comments: ":: ?"
              });
              node.optional = false;
            }
          },
          AssignmentPattern: {
            exit: function exit(_ref2) {
              var node = _ref2.node;
              var left = node.left;

              if (left.optional) {
                left.optional = false;
              }
            }
          },
          Function: function Function(path) {
            if (path.isDeclareFunction()) return;
            var node = path.node;

            if (node.typeParameters) {
              attachComment({
                ofPath: path.get("typeParameters"),
                toPath: path.get("id"),
                optional: node.typeParameters.optional
              });
            }

            if (node.returnType) {
              attachComment({
                ofPath: path.get("returnType"),
                toPath: path.get("body"),
                where: "leading",
                optional: node.returnType.typeAnnotation.optional
              });
            }
          },
          ClassProperty: function ClassProperty(path) {
            var node = path.node;

            if (!node.value) {
              wrapInFlowComment(path);
            } else if (node.typeAnnotation) {
              attachComment({
                ofPath: path.get("typeAnnotation"),
                toPath: path.get("key"),
                optional: node.typeAnnotation.optional
              });
            }
          },
          ExportNamedDeclaration: function ExportNamedDeclaration(path) {
            var node = path.node;

            if (node.exportKind !== "type" && !isFlow(node.declaration)) {
              return;
            }

            wrapInFlowComment(path);
          },
          ImportDeclaration: function ImportDeclaration(path) {
            var node = path.node;

            if (isTypeImport(node.importKind)) {
              wrapInFlowComment(path);
              return;
            }

            var typeSpecifiers = node.specifiers.filter(function (specifier) {
              return isTypeImport(specifier.importKind);
            });
            var nonTypeSpecifiers = node.specifiers.filter(function (specifier) {
              return !isTypeImport(specifier.importKind);
            });
            node.specifiers = nonTypeSpecifiers;

            if (typeSpecifiers.length > 0) {
              var typeImportNode = cloneNode(node);
              typeImportNode.specifiers = typeSpecifiers;
              var comment = ":: " + generateCode(typeImportNode).code;

              if (nonTypeSpecifiers.length > 0) {
                attachComment({
                  toPath: path,
                  comments: comment
                });
              } else {
                attachComment({
                  ofPath: path,
                  comments: comment
                });
              }
            }
          },
          ObjectPattern: function ObjectPattern(path) {
            var node = path.node;

            if (node.typeAnnotation) {
              attachComment({
                ofPath: path.get("typeAnnotation"),
                toPath: path,
                optional: node.optional || node.typeAnnotation.optional
              });
            }
          },
          Flow: function Flow(path) {
            wrapInFlowComment(path);
          },
          Class: function Class(path) {
            var node = path.node;
            var comments = [];

            if (node.typeParameters) {
              var typeParameters = path.get("typeParameters");
              comments.push(generateComment(typeParameters, node.typeParameters.optional));
              var trailingComments = node.typeParameters.trailingComments;

              if (trailingComments) {
                var _comments;

                (_comments = comments).push.apply(_comments, trailingComments);
              }

              typeParameters.remove();
            }

            if (node.superClass) {
              if (comments.length > 0) {
                attachComment({
                  toPath: path.get("id"),
                  comments: comments
                });
                comments = [];
              }

              if (node.superTypeParameters) {
                var superTypeParameters = path.get("superTypeParameters");
                comments.push(generateComment(superTypeParameters, superTypeParameters.node.optional));
                superTypeParameters.remove();
              }
            }

            if (node["implements"]) {
              var impls = path.get("implements");
              var comment = "implements " + impls.map(function (impl) {
                return generateComment(impl).replace(/^:: /, "");
              }).join(", ");
              delete node["implements"];

              if (comments.length === 1) {
                comments[0] += " " + comment;
              } else {
                comments.push(":: " + comment);
              }
            }

            if (comments.length > 0) {
              attachComment({
                toPath: path.get("body"),
                where: "leading",
                comments: comments
              });
            }
          }
        }
      };
    });

    var transformFlowStripTypes = declare(function (api, opts) {
      api.assertVersion(7);
      var FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
      var skipStrip = false;
      var _opts$requireDirectiv = opts.requireDirective,
          requireDirective = _opts$requireDirectiv === void 0 ? false : _opts$requireDirectiv,
          _opts$allowDeclareFie = opts.allowDeclareFields,
          allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
      return {
        name: "transform-flow-strip-types",
        inherits: syntaxFlow,
        visitor: {
          Program: function Program(path, _ref) {
            var comments = _ref.file.ast.comments;
            skipStrip = false;
            var directiveFound = false;

            if (comments) {
              for (var _i = 0, _arr = comments; _i < _arr.length; _i++) {
                var comment = _arr[_i];

                if (FLOW_DIRECTIVE.test(comment.value)) {
                  directiveFound = true;
                  comment.value = comment.value.replace(FLOW_DIRECTIVE, "");

                  if (!comment.value.replace(/\*/g, "").trim()) {
                    comment.ignore = true;
                  }
                }
              }
            }

            if (!directiveFound && requireDirective) {
              skipStrip = true;
            }
          },
          ImportDeclaration: function ImportDeclaration(path) {
            if (skipStrip) return;
            if (!path.node.specifiers.length) return;
            var typeCount = 0;
            path.node.specifiers.forEach(function (_ref2) {
              var importKind = _ref2.importKind;

              if (importKind === "type" || importKind === "typeof") {
                typeCount++;
              }
            });

            if (typeCount === path.node.specifiers.length) {
              path.remove();
            }
          },
          Flow: function Flow(path) {
            if (skipStrip) {
              throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
            }

            path.remove();
          },
          ClassPrivateProperty: function ClassPrivateProperty(path) {
            if (skipStrip) return;
            path.node.typeAnnotation = null;
          },
          Class: function Class(path) {
            if (skipStrip) return;
            path.node["implements"] = null;
            path.get("body.body").forEach(function (child) {
              if (child.isClassProperty()) {
                var node = child.node;

                if (!allowDeclareFields && node.declare) {
                  throw child.buildCodeFrameError("The 'declare' modifier is only allowed when the " + "'allowDeclareFields' option of " + "@babel/plugin-transform-flow-strip-types or " + "@babel/preset-flow is enabled.");
                }

                if (node.declare) {
                  child.remove();
                } else if (!allowDeclareFields && !node.value && !node.decorators) {
                  child.remove();
                } else {
                  node.variance = null;
                  node.typeAnnotation = null;
                }
              }
            });
          },
          AssignmentPattern: function AssignmentPattern(_ref3) {
            var node = _ref3.node;
            if (skipStrip) return;
            node.left.optional = false;
          },
          Function: function Function(_ref4) {
            var node = _ref4.node;
            if (skipStrip) return;

            for (var i = 0; i < node.params.length; i++) {
              var param = node.params[i];
              param.optional = false;

              if (param.type === "AssignmentPattern") {
                param.left.optional = false;
              }
            }

            node.predicate = null;
          },
          TypeCastExpression: function TypeCastExpression(path) {
            if (skipStrip) return;
            var node = path.node;

            do {
              node = node.expression;
            } while (isTypeCastExpression(node));

            path.replaceWith(node);
          },
          CallExpression: function CallExpression(_ref5) {
            var node = _ref5.node;
            if (skipStrip) return;
            node.typeArguments = null;
          },
          OptionalCallExpression: function OptionalCallExpression(_ref6) {
            var node = _ref6.node;
            if (skipStrip) return;
            node.typeArguments = null;
          },
          NewExpression: function NewExpression(_ref7) {
            var node = _ref7.node;
            if (skipStrip) return;
            node.typeArguments = null;
          }
        }
      };
    });

    function transformWithoutHelper(loose, path, state) {
      var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
      var node = path.node;
      var build = pushComputedProps(path, state);
      var declar = build.declar;
      var loop = build.loop;
      var block = loop.body;
      path.ensureBlock();

      if (declar) {
        block.body.push(declar);
      }

      block.body = block.body.concat(node.body.body);
      inherits(loop, node);
      inherits(loop.body, node.body);

      if (build.replaceParent) {
        path.parentPath.replaceWithMultiple(build.node);
        path.remove();
      } else {
        path.replaceWithMultiple(build.node);
      }
    }
    var buildForOfLoose = template("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n");
    var buildForOf = template("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");

    function pushComputedPropsLoose(path, file) {
      var node = path.node,
          scope = path.scope,
          parent = path.parent;
      var left = node.left;
      var declar, id, intermediate;

      if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
        id = left;
        intermediate = null;
      } else if (isVariableDeclaration(left)) {
        id = scope.generateUidIdentifier("ref");
        declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, Identifier(id.name))]);
        intermediate = VariableDeclaration("var", [VariableDeclarator(Identifier(id.name))]);
      } else {
        throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
      }

      var iteratorKey = scope.generateUidIdentifier("iterator");
      var isArrayKey = scope.generateUidIdentifier("isArray");
      var loop = buildForOfLoose({
        LOOP_OBJECT: iteratorKey,
        IS_ARRAY: isArrayKey,
        OBJECT: node.right,
        INDEX: scope.generateUidIdentifier("i"),
        ID: id,
        INTERMEDIATE: intermediate
      });
      var isLabeledParent = isLabeledStatement(parent);
      var labeled;

      if (isLabeledParent) {
        labeled = LabeledStatement(parent.label, loop);
      }

      return {
        replaceParent: isLabeledParent,
        declar: declar,
        node: labeled || loop,
        loop: loop
      };
    }

    function pushComputedPropsSpec(path, file) {
      var node = path.node,
          scope = path.scope,
          parent = path.parent;
      var left = node.left;
      var declar;
      var stepKey = scope.generateUid("step");
      var stepValue = MemberExpression(Identifier(stepKey), Identifier("value"));

      if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
        declar = ExpressionStatement(AssignmentExpression("=", left, stepValue));
      } else if (isVariableDeclaration(left)) {
        declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, stepValue)]);
      } else {
        throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
      }

      var template = buildForOf({
        ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
        ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
        ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
        ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
        STEP_KEY: Identifier(stepKey),
        OBJECT: node.right
      });
      var isLabeledParent = isLabeledStatement(parent);
      var tryBody = template[3].block.body;
      var loop = tryBody[0];

      if (isLabeledParent) {
        tryBody[0] = LabeledStatement(parent.label, loop);
      }

      return {
        replaceParent: isLabeledParent,
        declar: declar,
        loop: loop,
        node: template
      };
    }

    var transformForOf = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose,
          assumeArray = options.assumeArray;

      if (loose === true && assumeArray === true) {
        throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
      }

      if (assumeArray) {
        return {
          name: "transform-for-of",
          visitor: {
            ForOfStatement: function ForOfStatement(path) {
              var scope = path.scope;
              var _path$node = path.node,
                  left = _path$node.left,
                  right = _path$node.right,
                  isAwait = _path$node["await"];

              if (isAwait) {
                return;
              }

              var i = scope.generateUidIdentifier("i");
              var array = scope.maybeGenerateMemoised(right, true);
              var inits = [VariableDeclarator(i, NumericLiteral(0))];

              if (array) {
                inits.push(VariableDeclarator(array, right));
              } else {
                array = right;
              }

              var item = MemberExpression(cloneNode(array), cloneNode(i), true);
              var assignment;

              if (isVariableDeclaration(left)) {
                assignment = left;
                assignment.declarations[0].init = item;
              } else {
                assignment = ExpressionStatement(AssignmentExpression("=", left, item));
              }

              var blockBody;
              var body = path.get("body");

              if (body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(function (id) {
                return body.scope.hasOwnBinding(id);
              })) {
                blockBody = BlockStatement([assignment, body.node]);
              } else {
                blockBody = toBlock(body.node);
                blockBody.body.unshift(assignment);
              }

              path.replaceWith(ForStatement(VariableDeclaration("let", inits), BinaryExpression("<", cloneNode(i), MemberExpression(cloneNode(array), Identifier("length"))), UpdateExpression("++", cloneNode(i)), blockBody));
            }
          }
        };
      }

      var buildForOfArray = template("\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  ");
      var buildForOfLoose = template.statements("\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  ");
      var buildForOf = template.statements("\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  ");
      var builder = loose ? {
        build: buildForOfLoose,
        helper: "createForOfIteratorHelperLoose",
        getContainer: function getContainer(nodes) {
          return nodes;
        }
      } : {
        build: buildForOf,
        helper: "createForOfIteratorHelper",
        getContainer: function getContainer(nodes) {
          return nodes[1].block.body;
        }
      };

      function _ForOfStatementArray(path) {
        var node = path.node,
            scope = path.scope;
        var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
        var iterationKey = scope.generateUidIdentifier("i");
        var loop = buildForOfArray({
          BODY: node.body,
          KEY: iterationKey,
          NAME: right,
          ARR: node.right
        });
        inherits(loop, node);
        ensureBlock(loop);
        var iterationValue = MemberExpression(cloneNode(right), cloneNode(iterationKey), true);
        var left = node.left;

        if (isVariableDeclaration(left)) {
          left.declarations[0].init = iterationValue;
          loop.body.body.unshift(left);
        } else {
          loop.body.body.unshift(ExpressionStatement(AssignmentExpression("=", left, iterationValue)));
        }

        return loop;
      }

      return {
        name: "transform-for-of",
        visitor: {
          ForOfStatement: function ForOfStatement(path, state) {
            var right = path.get("right");

            if (right.isArrayExpression() || right.isGenericType("Array") || isArrayTypeAnnotation(right.getTypeAnnotation())) {
              path.replaceWith(_ForOfStatementArray(path));
              return;
            }

            if (!state.availableHelper(builder.helper)) {
              transformWithoutHelper(loose, path, state);
              return;
            }

            var node = path.node,
                parent = path.parent,
                scope = path.scope;
            var left = node.left;
            var declar;
            var stepKey = scope.generateUid("step");
            var stepValue = MemberExpression(Identifier(stepKey), Identifier("value"));

            if (isVariableDeclaration(left)) {
              declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, stepValue)]);
            } else {
              declar = ExpressionStatement(AssignmentExpression("=", left, stepValue));
            }

            path.ensureBlock();
            node.body.body.unshift(declar);
            var nodes = builder.build({
              CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
              ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
              STEP_KEY: Identifier(stepKey),
              OBJECT: node.right,
              BODY: node.body
            });
            var container = builder.getContainer(nodes);
            inherits(container[0], node);
            inherits(container[0].body, node.body);

            if (isLabeledStatement(parent)) {
              container[0] = LabeledStatement(parent.label, container[0]);
              path.parentPath.replaceWithMultiple(nodes);
              path.remove();
            } else {
              path.replaceWithMultiple(nodes);
            }
          }
        }
      };
    });

    var transformFunctionName = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-function-name",
        visitor: {
          FunctionExpression: {
            exit: function exit(path) {
              if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
                var replacement = nameFunction(path);
                if (replacement) path.replaceWith(replacement);
              }
            }
          },
          ObjectProperty: function ObjectProperty(path) {
            var value = path.get("value");

            if (value.isFunction()) {
              var newNode = nameFunction(value);
              if (newNode) value.replaceWith(newNode);
            }
          }
        }
      };
    });

    var transformInstanceof = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-instanceof",
        visitor: {
          BinaryExpression: function BinaryExpression(path) {
            var node = path.node;

            if (node.operator === "instanceof") {
              var helper = this.addHelper("instanceof");
              var isUnderHelper = path.findParent(function (path) {
                return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
              });

              if (isUnderHelper) {
                return;
              } else {
                path.replaceWith(CallExpression(helper, [node.left, node.right]));
              }
            }
          }
        }
      };
    });

    var transformJscript = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-jscript",
        visitor: {
          FunctionExpression: {
            exit: function exit(path) {
              var node = path.node;
              if (!node.id) return;
              path.replaceWith(CallExpression(FunctionExpression(null, [], BlockStatement([toStatement(node), ReturnStatement(cloneNode(node.id))])), []));
            }
          }
        }
      };
    });

    var transformLiterals = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-literals",
        visitor: {
          NumericLiteral: function NumericLiteral(_ref) {
            var node = _ref.node;

            if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
              node.extra = undefined;
            }
          },
          StringLiteral: function StringLiteral(_ref2) {
            var node = _ref2.node;

            if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
              node.extra = undefined;
            }
          }
        }
      };
    });

    var transformMemberExpressionLiterals = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-member-expression-literals",
        visitor: {
          MemberExpression: {
            exit: function exit(_ref) {
              var node = _ref.node;
              var prop = node.property;

              if (!node.computed && isIdentifier(prop) && !isValidES3Identifier(prop.name)) {
                node.property = StringLiteral(prop.name);
                node.computed = true;
              }
            }
          }
        }
      };
    });

    var utils = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getImportSource = getImportSource;
    exports.createDynamicImportTransform = createDynamicImportTransform;

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function getImportSource(t, callNode) {
      var importArguments = callNode.arguments;

      var _importArguments = _slicedToArray(importArguments, 1),
          importPath = _importArguments[0];

      var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

      if (isString) {
        t.removeComments(importPath);
        return importPath;
      }

      return t.templateLiteral([t.templateElement({
        raw: '',
        cooked: ''
      }), t.templateElement({
        raw: '',
        cooked: ''
      }, true)], importArguments);
    }

    function createDynamicImportTransform(_ref) {
      var template = _ref.template,
          t = _ref.types;
      var buildImport = template('Promise.resolve().then(() => MODULE)');
      return function (context, path) {
        var requireCall = t.callExpression(t.identifier('require'), [getImportSource(t, path.parent)]);
        var _context$opts$noInter = context.opts.noInterop,
            noInterop = _context$opts$noInter === undefined ? false : _context$opts$noInter;
        var MODULE = noInterop === true ? requireCall : t.callExpression(context.addHelper('interopRequireWildcard'), [requireCall]);
        var newImport = buildImport({
          MODULE: MODULE
        });
        path.parentPath.replaceWith(newImport);
      };
    }
    });

    unwrapExports(utils);
    var utils_1 = utils.getImportSource;
    var utils_2 = utils.createDynamicImportTransform;

    var utils$1 = utils;
    var utils_1$1 = utils$1.createDynamicImportTransform;
    var utils_2$1 = utils$1.getImportSource;

    function _templateObject$a() {
      var data = _taggedTemplateLiteralLoose(["\n            new Promise((", ", ", ") =>\n              ", "(\n                [", "],\n                imported => ", "(", "),\n                ", "\n              )\n            )"]);

      _templateObject$a = function _templateObject() {
        return data;
      };

      return data;
    }
    var buildWrapper = template("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n");
    var buildAnonymousWrapper = template("\n  define([\"require\"], function(REQUIRE) {\n  })\n");

    function injectWrapper(path, wrapper) {
      var _path$node = path.node,
          body = _path$node.body,
          directives = _path$node.directives;
      path.node.directives = [];
      path.node.body = [];
      var amdWrapper = path.pushContainer("body", wrapper)[0];
      var amdFactory = amdWrapper.get("expression.arguments").filter(function (arg) {
        return arg.isFunctionExpression();
      })[0].get("body");
      amdFactory.pushContainer("directives", directives);
      amdFactory.pushContainer("body", body);
    }

    var transformModulesAmd = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose,
          allowTopLevelThis = options.allowTopLevelThis,
          strict = options.strict,
          strictMode = options.strictMode,
          noInterop = options.noInterop;
      return {
        name: "transform-modules-amd",
        pre: function pre() {
          this.file.set("@babel/plugin-transform-modules-*", "amd");
        },
        visitor: {
          CallExpression: function CallExpression(path, state) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
            if (!path.get("callee").isImport()) return;
            var requireId = state.requireId,
                resolveId = state.resolveId,
                rejectId = state.rejectId;

            if (!requireId) {
              requireId = path.scope.generateUidIdentifier("require");
              state.requireId = requireId;
            }

            if (!resolveId || !rejectId) {
              resolveId = path.scope.generateUidIdentifier("resolve");
              rejectId = path.scope.generateUidIdentifier("reject");
              state.resolveId = resolveId;
              state.rejectId = rejectId;
            }

            var result = Identifier("imported");
            if (!noInterop) result = wrapInterop(path, result, "namespace");
            path.replaceWith(template.expression.ast(_templateObject$a(), resolveId, rejectId, requireId, utils_2$1(t, path.node), resolveId, result, rejectId));
          },
          Program: {
            exit: function exit(path, _ref) {
              var requireId = _ref.requireId;

              if (!isModule(path)) {
                if (requireId) {
                  injectWrapper(path, buildAnonymousWrapper({
                    REQUIRE: requireId
                  }));
                }

                return;
              }

              var amdArgs = [];
              var importNames = [];

              if (requireId) {
                amdArgs.push(StringLiteral("require"));
                importNames.push(requireId);
              }

              var moduleName = getModuleName(this.file.opts, options);
              if (moduleName) moduleName = StringLiteral(moduleName);

              var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
                loose: loose,
                strict: strict,
                strictMode: strictMode,
                allowTopLevelThis: allowTopLevelThis,
                noInterop: noInterop
              }),
                  meta = _rewriteModuleStateme.meta,
                  headers = _rewriteModuleStateme.headers;

              if (hasExports(meta)) {
                amdArgs.push(StringLiteral("exports"));
                importNames.push(Identifier(meta.exportName));
              }

              for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
                var _step$value = _step.value,
                    source = _step$value[0],
                    metadata = _step$value[1];
                amdArgs.push(StringLiteral(source));
                importNames.push(Identifier(metadata.name));

                if (!isSideEffectImport(metadata)) {
                  var interop = wrapInterop(path, Identifier(metadata.name), metadata.interop);

                  if (interop) {
                    var header = ExpressionStatement(AssignmentExpression("=", Identifier(metadata.name), interop));
                    header.loc = metadata.loc;
                    headers.push(header);
                  }
                }

                headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
              }

              ensureStatementsHoisted(headers);
              path.unshiftContainer("body", headers);
              injectWrapper(path, buildWrapper({
                MODULE_NAME: moduleName,
                AMD_ARGUMENTS: ArrayExpression(amdArgs),
                IMPORT_NAMES: importNames
              }));
            }
          }
        }
      };
    });

    function _templateObject3$4() {
      var data = _taggedTemplateLiteralLoose(["\n                  var ", " = ", ";\n                "]);

      _templateObject3$4 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$4() {
      var data = _taggedTemplateLiteralLoose(["\n                  function ", "() {\n                    const data = ", ";\n                    ", " = function(){ return data; };\n                    return data;\n                  }\n                "]);

      _templateObject2$4 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$b() {
      var data = _taggedTemplateLiteralLoose(["\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"", "\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  "]);

      _templateObject$b = function _templateObject() {
        return data;
      };

      return data;
    }
    var transformModulesCommonjs = declare(function (api, options) {
      api.assertVersion(7);
      var transformImportCall = utils_1$1(api);
      var loose = options.loose,
          _options$strictNamesp = options.strictNamespace,
          strictNamespace = _options$strictNamesp === void 0 ? false : _options$strictNamesp,
          _options$mjsStrictNam = options.mjsStrictNamespace,
          mjsStrictNamespace = _options$mjsStrictNam === void 0 ? true : _options$mjsStrictNam,
          allowTopLevelThis = options.allowTopLevelThis,
          strict = options.strict,
          strictMode = options.strictMode,
          noInterop = options.noInterop,
          _options$lazy = options.lazy,
          lazy = _options$lazy === void 0 ? false : _options$lazy,
          _options$allowCommonJ = options.allowCommonJSExports,
          allowCommonJSExports = _options$allowCommonJ === void 0 ? true : _options$allowCommonJ;

      if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(function (item) {
        return typeof item === "string";
      }))) {
        throw new Error(".lazy must be a boolean, array of strings, or a function");
      }

      if (typeof strictNamespace !== "boolean") {
        throw new Error(".strictNamespace must be a boolean, or undefined");
      }

      if (typeof mjsStrictNamespace !== "boolean") {
        throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
      }

      var getAssertion = function getAssertion(localName) {
        return template.expression.ast(_templateObject$b(), localName);
      };

      var moduleExportsVisitor = {
        ReferencedIdentifier: function ReferencedIdentifier(path) {
          var localName = path.node.name;
          if (localName !== "module" && localName !== "exports") return;
          var localBinding = path.scope.getBinding(localName);
          var rootBinding = this.scope.getBinding(localName);

          if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
            value: path.node
          }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
            left: path.node
          }) || path.isAssignmentExpression({
            left: path.node
          })) {
            return;
          }

          path.replaceWith(getAssertion(localName));
        },
        AssignmentExpression: function AssignmentExpression(path) {
          var _this = this;

          var left = path.get("left");

          if (left.isIdentifier()) {
            var localName = path.node.name;
            if (localName !== "module" && localName !== "exports") return;
            var localBinding = path.scope.getBinding(localName);
            var rootBinding = this.scope.getBinding(localName);
            if (rootBinding !== localBinding) return;
            var right = path.get("right");
            right.replaceWith(SequenceExpression([right.node, getAssertion(localName)]));
          } else if (left.isPattern()) {
            var ids = left.getOuterBindingIdentifiers();
            var _localName = Object.keys(ids).filter(function (localName) {
              if (localName !== "module" && localName !== "exports") return false;
              return _this.scope.getBinding(localName) === path.scope.getBinding(localName);
            })[0];

            if (_localName) {
              var _right = path.get("right");

              _right.replaceWith(SequenceExpression([_right.node, getAssertion(_localName)]));
            }
          }
        }
      };
      return {
        name: "transform-modules-commonjs",
        pre: function pre() {
          this.file.set("@babel/plugin-transform-modules-*", "commonjs");
        },
        visitor: {
          CallExpression: function CallExpression(path) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
            if (!path.get("callee").isImport()) return;
            var scope = path.scope;

            do {
              scope.rename("require");
            } while (scope = scope.parent);

            transformImportCall(this, path.get("callee"));
          },
          Program: {
            exit: function exit(path, state) {
              if (!isModule(path)) return;
              path.scope.rename("exports");
              path.scope.rename("module");
              path.scope.rename("require");
              path.scope.rename("__filename");
              path.scope.rename("__dirname");

              if (!allowCommonJSExports) {
                simplifyAccess(path, new Set(["module", "exports"]));
                path.traverse(moduleExportsVisitor, {
                  scope: path.scope
                });
              }

              var moduleName = getModuleName(this.file.opts, options);
              if (moduleName) moduleName = StringLiteral(moduleName);

              var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
                exportName: "exports",
                loose: loose,
                strict: strict,
                strictMode: strictMode,
                allowTopLevelThis: allowTopLevelThis,
                noInterop: noInterop,
                lazy: lazy,
                esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace
              }),
                  meta = _rewriteModuleStateme.meta,
                  headers = _rewriteModuleStateme.headers;

              for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
                var _step$value = _step.value,
                    source = _step$value[0],
                    metadata = _step$value[1];
                var loadExpr = CallExpression(Identifier("require"), [StringLiteral(source)]);
                var header = void 0;

                if (isSideEffectImport(metadata)) {
                  if (metadata.lazy) throw new Error("Assertion failure");
                  header = ExpressionStatement(loadExpr);
                } else {
                  var init = wrapInterop(path, loadExpr, metadata.interop) || loadExpr;

                  if (metadata.lazy) {
                    header = template.ast(_templateObject2$4(), metadata.name, init, metadata.name);
                  } else {
                    header = template.ast(_templateObject3$4(), metadata.name, init);
                  }
                }

                header.loc = metadata.loc;
                headers.push(header);
                headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
              }

              ensureStatementsHoisted(headers);
              path.unshiftContainer("body", headers);
            }
          }
        }
      };
    });

    var visitor$3 = {
      Scope: function Scope(path, state) {
        if (state.kind === "let") path.skip();
      },
      Function: function Function(path) {
        path.skip();
      },
      VariableDeclaration: function VariableDeclaration(path, state) {
        if (state.kind && path.node.kind !== state.kind) return;
        var nodes = [];
        var declarations = path.get("declarations");
        var firstId;

        for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
          var declar = _step.value;
          firstId = declar.node.id;

          if (declar.node.init) {
            nodes.push(ExpressionStatement(AssignmentExpression("=", declar.node.id, declar.node.init)));
          }

          for (var _i = 0, _Object$keys = Object.keys(declar.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
            var name = _Object$keys[_i];
            state.emit(Identifier(name), name, declar.node.init !== null);
          }
        }

        if (path.parentPath.isFor({
          left: path.node
        })) {
          path.replaceWith(firstId);
        } else {
          path.replaceWithMultiple(nodes);
        }
      }
    };
    function hoistVariables (path, emit, kind) {
      if (kind === void 0) {
        kind = "var";
      }

      path.traverse(visitor$3, {
        kind: kind,
        emit: emit
      });
    }

    var buildTemplate = template("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n");
    var buildExportAll = template("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
    var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";

    function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {
      var statements = [];

      if (exportNames.length === 1) {
        statements.push(ExpressionStatement(CallExpression(exportIdent, [StringLiteral(exportNames[0]), exportValues[0]])));
      } else if (!exportStarTarget) {
        var objectProperties = [];

        for (var i = 0; i < exportNames.length; i++) {
          var exportName = exportNames[i];
          var exportValue = exportValues[i];
          objectProperties.push(ObjectProperty(Identifier(exportName), exportValue));
        }

        statements.push(ExpressionStatement(CallExpression(exportIdent, [ObjectExpression(objectProperties)])));
      } else {
        var exportObj = path.scope.generateUid("exportObj");
        statements.push(VariableDeclaration("var", [VariableDeclarator(Identifier(exportObj), ObjectExpression([]))]));
        statements.push(buildExportAll({
          KEY: path.scope.generateUidIdentifier("key"),
          EXPORT_OBJ: Identifier(exportObj),
          TARGET: exportStarTarget
        }));

        for (var _i = 0; _i < exportNames.length; _i++) {
          var _exportName = exportNames[_i];
          var _exportValue = exportValues[_i];
          statements.push(ExpressionStatement(AssignmentExpression("=", MemberExpression(Identifier(exportObj), Identifier(_exportName)), _exportValue)));
        }

        statements.push(ExpressionStatement(CallExpression(exportIdent, [Identifier(exportObj)])));
      }

      return statements;
    }

    var transformModulesSystemjs = declare(function (api, options) {
      api.assertVersion(7);
      var _options$systemGlobal = options.systemGlobal,
          systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal,
          _options$allowTopLeve = options.allowTopLevelThis,
          allowTopLevelThis = _options$allowTopLeve === void 0 ? false : _options$allowTopLeve;
      var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
      var reassignmentVisitor = {
        "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
          if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
          path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
          var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

          if (arg.isObjectPattern() || arg.isArrayPattern()) {
            var exprs = [path.node];

            for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
              var _name = _Object$keys[_i2];

              if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
                return;
              }

              var _exportedNames = this.exports[_name];
              if (!_exportedNames) return;

              for (var _iterator = _createForOfIteratorHelperLoose(_exportedNames), _step; !(_step = _iterator()).done;) {
                var exportedName = _step.value;
                exprs.push(this.buildCall(exportedName, Identifier(_name)).expression);
              }
            }

            path.replaceWith(SequenceExpression(exprs));
            return;
          }

          if (!arg.isIdentifier()) return;
          var name = arg.node.name;
          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
          var exportedNames = this.exports[name];
          if (!exportedNames) return;
          var node = path.node;
          var isPostUpdateExpression = path.isUpdateExpression({
            prefix: false
          });

          if (isPostUpdateExpression) {
            node = BinaryExpression(node.operator[0], UnaryExpression("+", cloneNode(node.argument)), NumericLiteral(1));
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(exportedNames), _step2; !(_step2 = _iterator2()).done;) {
            var _exportedName = _step2.value;
            node = this.buildCall(_exportedName, node).expression;
          }

          if (isPostUpdateExpression) {
            node = SequenceExpression([node, path.node]);
          }

          path.replaceWith(node);
        }
      };
      return {
        name: "transform-modules-systemjs",
        pre: function pre() {
          this.file.set("@babel/plugin-transform-modules-*", "systemjs");
        },
        visitor: {
          CallExpression: function CallExpression$1(path, state) {
            if (isImport(path.node.callee)) {
              if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
                console.warn(MISSING_PLUGIN_WARNING);
              }

              path.replaceWith(CallExpression(MemberExpression(Identifier(state.contextIdent), Identifier("import")), [utils_2$1(t, path.node)]));
            }
          },
          MetaProperty: function MetaProperty(path, state) {
            if (path.node.meta.name === "import" && path.node.property.name === "meta") {
              path.replaceWith(MemberExpression(Identifier(state.contextIdent), Identifier("meta")));
            }
          },
          ReferencedIdentifier: function ReferencedIdentifier(path, state) {
            if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
              path.replaceWith(MemberExpression(Identifier(state.contextIdent), Identifier("id")));
            }
          },
          Program: {
            enter: function enter(path, state) {
              state.contextIdent = path.scope.generateUid("context");

              if (!allowTopLevelThis) {
                rewriteThis(path);
              }
            },
            exit: function exit(path, state) {
              var undefinedIdent = path.scope.buildUndefinedNode();
              var exportIdent = path.scope.generateUid("export");
              var contextIdent = state.contextIdent;
              var exportMap = Object.create(null);
              var modules = [];
              var beforeBody = [];
              var setters = [];
              var sources = [];
              var variableIds = [];
              var removedPaths = [];

              function addExportName(key, val) {
                exportMap[key] = exportMap[key] || [];
                exportMap[key].push(val);
              }

              function pushModule(source, key, specifiers) {
                var module;
                modules.forEach(function (m) {
                  if (m.key === source) {
                    module = m;
                  }
                });

                if (!module) {
                  modules.push(module = {
                    key: source,
                    imports: [],
                    exports: []
                  });
                }

                module[key] = module[key].concat(specifiers);
              }

              function buildExportCall(name, val) {
                return ExpressionStatement(CallExpression(Identifier(exportIdent), [StringLiteral(name), val]));
              }

              var exportNames = [];
              var exportValues = [];
              var body = path.get("body");

              for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
                var _path2 = _step3.value;

                if (_path2.isFunctionDeclaration()) {
                  beforeBody.push(_path2.node);
                  removedPaths.push(_path2);
                } else if (_path2.isClassDeclaration()) {
                  variableIds.push(_path2.node.id);

                  _path2.replaceWith(ExpressionStatement(AssignmentExpression("=", cloneNode(_path2.node.id), toExpression(_path2.node))));
                } else if (_path2.isImportDeclaration()) {
                  var source = _path2.node.source.value;
                  pushModule(source, "imports", _path2.node.specifiers);

                  for (var _i4 = 0, _Object$keys2 = Object.keys(_path2.getBindingIdentifiers()); _i4 < _Object$keys2.length; _i4++) {
                    var name = _Object$keys2[_i4];

                    _path2.scope.removeBinding(name);

                    variableIds.push(Identifier(name));
                  }

                  _path2.remove();
                } else if (_path2.isExportAllDeclaration()) {
                  pushModule(_path2.node.source.value, "exports", _path2.node);

                  _path2.remove();
                } else if (_path2.isExportDefaultDeclaration()) {
                  var declar = _path2.get("declaration");

                  var id = declar.node.id;

                  if (declar.isClassDeclaration()) {
                    if (id) {
                      exportNames.push("default");
                      exportValues.push(undefinedIdent);
                      variableIds.push(id);
                      addExportName(id.name, "default");

                      _path2.replaceWith(ExpressionStatement(AssignmentExpression("=", cloneNode(id), toExpression(declar.node))));
                    } else {
                      exportNames.push("default");
                      exportValues.push(toExpression(declar.node));
                      removedPaths.push(_path2);
                    }
                  } else if (declar.isFunctionDeclaration()) {
                    if (id) {
                      beforeBody.push(declar.node);
                      exportNames.push("default");
                      exportValues.push(cloneNode(id));
                      addExportName(id.name, "default");
                    } else {
                      exportNames.push("default");
                      exportValues.push(toExpression(declar.node));
                    }

                    removedPaths.push(_path2);
                  } else {
                    _path2.replaceWith(buildExportCall("default", declar.node));
                  }
                } else if (_path2.isExportNamedDeclaration()) {
                  var _declar = _path2.get("declaration");

                  if (_declar.node) {
                    _path2.replaceWith(_declar);

                    if (_path2.isFunction()) {
                      var node = _declar.node;
                      var _name2 = node.id.name;
                      addExportName(_name2, _name2);
                      beforeBody.push(node);
                      exportNames.push(_name2);
                      exportValues.push(cloneNode(node.id));
                      removedPaths.push(_path2);
                    } else if (_path2.isClass()) {
                      var _name3 = _declar.node.id.name;
                      exportNames.push(_name3);
                      exportValues.push(undefinedIdent);
                      variableIds.push(_declar.node.id);

                      _path2.replaceWith(ExpressionStatement(AssignmentExpression("=", cloneNode(_declar.node.id), toExpression(_declar.node))));

                      addExportName(_name3, _name3);
                    } else {
                      for (var _i5 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i5 < _Object$keys3.length; _i5++) {
                        var _name4 = _Object$keys3[_i5];
                        addExportName(_name4, _name4);
                      }
                    }
                  } else {
                    var specifiers = _path2.node.specifiers;

                    if (specifiers && specifiers.length) {
                      if (_path2.node.source) {
                        pushModule(_path2.node.source.value, "exports", specifiers);

                        _path2.remove();
                      } else {
                        var nodes = [];

                        for (var _iterator6 = _createForOfIteratorHelperLoose(specifiers), _step6; !(_step6 = _iterator6()).done;) {
                          var specifier = _step6.value;

                          var binding = _path2.scope.getBinding(specifier.local.name);

                          if (binding && isFunctionDeclaration(binding.path.node)) {
                            exportNames.push(specifier.exported.name);
                            exportValues.push(cloneNode(specifier.local));
                          } else if (!binding) {
                              nodes.push(buildExportCall(specifier.exported.name, specifier.local));
                            }

                          addExportName(specifier.local.name, specifier.exported.name);
                        }

                        _path2.replaceWithMultiple(nodes);
                      }
                    } else {
                      _path2.remove();
                    }
                  }
                }
              }

              modules.forEach(function (specifiers) {
                var setterBody = [];
                var target = path.scope.generateUid(specifiers.key);

                for (var _iterator4 = _createForOfIteratorHelperLoose(specifiers.imports), _step4; !(_step4 = _iterator4()).done;) {
                  var specifier = _step4.value;

                  if (isImportNamespaceSpecifier(specifier)) {
                    setterBody.push(ExpressionStatement(AssignmentExpression("=", specifier.local, Identifier(target))));
                  } else if (isImportDefaultSpecifier(specifier)) {
                    specifier = ImportSpecifier(specifier.local, Identifier("default"));
                  }

                  if (isImportSpecifier(specifier)) {
                    setterBody.push(ExpressionStatement(AssignmentExpression("=", specifier.local, MemberExpression(Identifier(target), specifier.imported))));
                  }
                }

                if (specifiers.exports.length) {
                  var _exportNames = [];
                  var _exportValues = [];
                  var hasExportStar = false;

                  for (var _iterator5 = _createForOfIteratorHelperLoose(specifiers.exports), _step5; !(_step5 = _iterator5()).done;) {
                    var node = _step5.value;

                    if (isExportAllDeclaration(node)) {
                      hasExportStar = true;
                    } else if (isExportSpecifier(node)) {
                      _exportNames.push(node.exported.name);

                      _exportValues.push(MemberExpression(Identifier(target), node.local));
                    }
                  }

                  setterBody = setterBody.concat(constructExportCall(path, Identifier(exportIdent), _exportNames, _exportValues, hasExportStar ? Identifier(target) : null));
                }

                sources.push(StringLiteral(specifiers.key));
                setters.push(FunctionExpression(null, [Identifier(target)], BlockStatement(setterBody)));
              });
              var moduleName = getModuleName(this.file.opts, options);
              if (moduleName) moduleName = StringLiteral(moduleName);
              hoistVariables(path, function (id, name, hasInit) {
                variableIds.push(id);

                if (!hasInit) {
                  exportNames.push(name);
                  exportValues.push(undefinedIdent);
                }
              }, null);

              if (variableIds.length) {
                beforeBody.unshift(VariableDeclaration("var", variableIds.map(function (id) {
                  return VariableDeclarator(id);
                })));
              }

              if (exportNames.length) {
                beforeBody = beforeBody.concat(constructExportCall(path, Identifier(exportIdent), exportNames, exportValues, null));
              }

              path.traverse(reassignmentVisitor, {
                exports: exportMap,
                buildCall: buildExportCall,
                scope: path.scope
              });

              for (var _i3 = 0, _removedPaths = removedPaths; _i3 < _removedPaths.length; _i3++) {
                var _path = _removedPaths[_i3];

                _path.remove();
              }

              path.node.body = [buildTemplate({
                SYSTEM_REGISTER: MemberExpression(Identifier(systemGlobal), Identifier("register")),
                BEFORE_BODY: beforeBody,
                MODULE_NAME: moduleName,
                SETTERS: ArrayExpression(setters),
                SOURCES: ArrayExpression(sources),
                BODY: path.node.body,
                EXPORT_IDENTIFIER: Identifier(exportIdent),
                CONTEXT_IDENTIFIER: Identifier(contextIdent)
              })];
            }
          }
        }
      };
    });

    var buildPrerequisiteAssignment = template("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n");
    var buildWrapper$1 = template("\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n");
    var transformModulesUmd = declare(function (api, options) {
      api.assertVersion(7);
      var globals = options.globals,
          exactGlobals = options.exactGlobals,
          loose = options.loose,
          allowTopLevelThis = options.allowTopLevelThis,
          strict = options.strict,
          strictMode = options.strictMode,
          noInterop = options.noInterop;

      function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
        var moduleNameOrBasename = moduleName ? moduleName.value : basename(filename, extname(filename));
        var globalToAssign = MemberExpression(Identifier("global"), Identifier(toIdentifier(moduleNameOrBasename)));
        var initAssignments = [];

        if (exactGlobals) {
          var globalName = browserGlobals[moduleNameOrBasename];

          if (globalName) {
            initAssignments = [];
            var members = globalName.split(".");
            globalToAssign = members.slice(1).reduce(function (accum, curr) {
              initAssignments.push(buildPrerequisiteAssignment({
                GLOBAL_REFERENCE: cloneNode(accum)
              }));
              return MemberExpression(accum, Identifier(curr));
            }, MemberExpression(Identifier("global"), Identifier(members[0])));
          }
        }

        initAssignments.push(ExpressionStatement(AssignmentExpression("=", globalToAssign, MemberExpression(Identifier("mod"), Identifier("exports")))));
        return initAssignments;
      }

      function buildBrowserArg(browserGlobals, exactGlobals, source) {
        var memberExpression;

        if (exactGlobals) {
          var globalRef = browserGlobals[source];

          if (globalRef) {
            memberExpression = globalRef.split(".").reduce(function (accum, curr) {
              return MemberExpression(accum, Identifier(curr));
            }, Identifier("global"));
          } else {
            memberExpression = MemberExpression(Identifier("global"), Identifier(toIdentifier(source)));
          }
        } else {
          var requireName = basename(source, extname(source));
          var globalName = browserGlobals[requireName] || requireName;
          memberExpression = MemberExpression(Identifier("global"), Identifier(toIdentifier(globalName)));
        }

        return memberExpression;
      }

      return {
        name: "transform-modules-umd",
        visitor: {
          Program: {
            exit: function exit(path) {
              if (!isModule(path)) return;
              var browserGlobals = globals || {};
              var moduleName = getModuleName(this.file.opts, options);
              if (moduleName) moduleName = StringLiteral(moduleName);

              var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
                loose: loose,
                strict: strict,
                strictMode: strictMode,
                allowTopLevelThis: allowTopLevelThis,
                noInterop: noInterop
              }),
                  meta = _rewriteModuleStateme.meta,
                  headers = _rewriteModuleStateme.headers;

              var amdArgs = [];
              var commonjsArgs = [];
              var browserArgs = [];
              var importNames = [];

              if (hasExports(meta)) {
                amdArgs.push(StringLiteral("exports"));
                commonjsArgs.push(Identifier("exports"));
                browserArgs.push(MemberExpression(Identifier("mod"), Identifier("exports")));
                importNames.push(Identifier(meta.exportName));
              }

              for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
                var _step$value = _step.value,
                    source = _step$value[0],
                    metadata = _step$value[1];
                amdArgs.push(StringLiteral(source));
                commonjsArgs.push(CallExpression(Identifier("require"), [StringLiteral(source)]));
                browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
                importNames.push(Identifier(metadata.name));

                if (!isSideEffectImport(metadata)) {
                  var interop = wrapInterop(path, Identifier(metadata.name), metadata.interop);

                  if (interop) {
                    var header = ExpressionStatement(AssignmentExpression("=", Identifier(metadata.name), interop));
                    header.loc = meta.loc;
                    headers.push(header);
                  }
                }

                headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
              }

              ensureStatementsHoisted(headers);
              path.unshiftContainer("body", headers);
              var _path$node = path.node,
                  body = _path$node.body,
                  directives = _path$node.directives;
              path.node.directives = [];
              path.node.body = [];
              var umdWrapper = path.pushContainer("body", [buildWrapper$1({
                MODULE_NAME: moduleName,
                AMD_ARGUMENTS: ArrayExpression(amdArgs),
                COMMONJS_ARGUMENTS: commonjsArgs,
                BROWSER_ARGUMENTS: browserArgs,
                IMPORT_NAMES: importNames,
                GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
              })])[0];
              var umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
              umdFactory.pushContainer("directives", directives);
              umdFactory.pushContainer("body", body);
            }
          }
        }
      };
    });

    function transformNamedCapturingGroupsRegex (core, options) {
      var _options$runtime = options.runtime,
          runtime = _options$runtime === void 0 ? true : _options$runtime;

      if (typeof runtime !== "boolean") {
        throw new Error("The 'runtime' option must be boolean");
      }

      return createRegExpFeaturePlugin({
        name: "transform-named-capturing-groups-regex",
        feature: "namedCaptureGroups",
        options: {
          runtime: runtime
        }
      });
    }

    var transformNewTarget = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-new-target",
        visitor: {
          MetaProperty: function MetaProperty(path) {
            var meta = path.get("meta");
            var property = path.get("property");
            var scope = path.scope;

            if (meta.isIdentifier({
              name: "new"
            }) && property.isIdentifier({
              name: "target"
            })) {
              var func = path.findParent(function (path) {
                if (path.isClass()) return true;

                if (path.isFunction() && !path.isArrowFunctionExpression()) {
                  if (path.isClassMethod({
                    kind: "constructor"
                  })) {
                    return false;
                  }

                  return true;
                }

                return false;
              });

              if (!func) {
                throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
              }

              var node = func.node;

              if (!node.id) {
                if (func.isMethod()) {
                  path.replaceWith(scope.buildUndefinedNode());
                  return;
                }

                node.id = scope.generateUidIdentifier("target");
              }

              var _constructor = MemberExpression(ThisExpression(), Identifier("constructor"));

              if (func.isClass()) {
                path.replaceWith(_constructor);
                return;
              }

              path.replaceWith(ConditionalExpression(BinaryExpression("instanceof", ThisExpression(), cloneNode(node.id)), _constructor, scope.buildUndefinedNode()));
            }
          }
        }
      };
    });

    var transformObjectAssign = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-object-assign",
        visitor: {
          CallExpression: function CallExpression(path, file) {
            if (path.get("callee").matchesPattern("Object.assign")) {
              path.node.callee = file.addHelper("extends");
            }
          }
        }
      };
    });

    function replacePropertySuper(path, getObjectRef, file) {
      var replaceSupers = new ReplaceSupers({
        getObjectRef: getObjectRef,
        methodPath: path,
        file: file
      });
      replaceSupers.replace();
    }

    var transformObjectSuper = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-object-super",
        visitor: {
          ObjectExpression: function ObjectExpression(path, state) {
            var objectRef;

            var getObjectRef = function getObjectRef() {
              return objectRef = objectRef || path.scope.generateUidIdentifier("obj");
            };

            path.get("properties").forEach(function (propPath) {
              if (!propPath.isMethod()) return;
              replacePropertySuper(propPath, getObjectRef, state);
            });

            if (objectRef) {
              path.scope.push({
                id: cloneNode(objectRef)
              });
              path.replaceWith(AssignmentExpression("=", cloneNode(objectRef), path.node));
            }
          }
        }
      };
    });

    var transformObjectSetPrototypeOfToAssign = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-object-set-prototype-of-to-assign",
        visitor: {
          CallExpression: function CallExpression(path, file) {
            if (path.get("callee").matchesPattern("Object.setPrototypeOf")) {
              path.node.callee = file.addHelper("defaults");
            }
          }
        }
      };
    });

    var transformPropertyLiterals = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-property-literals",
        visitor: {
          ObjectProperty: {
            exit: function exit(_ref) {
              var node = _ref.node;
              var key = node.key;

              if (!node.computed && isIdentifier(key) && !isValidES3Identifier(key.name)) {
                node.key = StringLiteral(key.name);
              }
            }
          }
        }
      };
    });

    var transformPropertyMutators = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-property-mutators",
        visitor: {
          ObjectExpression: function ObjectExpression(path, file) {
            var node = path.node;
            var hasAny = false;

            for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
              var prop = _arr[_i];

              if (prop.kind === "get" || prop.kind === "set") {
                hasAny = true;
                break;
              }
            }

            if (!hasAny) return;
            var mutatorMap = {};
            node.properties = node.properties.filter(function (prop) {
              if (!prop.computed && (prop.kind === "get" || prop.kind === "set")) {
                push(mutatorMap, prop, null, file);
                return false;
              } else {
                return true;
              }
            });
            path.replaceWith(CallExpression(MemberExpression(Identifier("Object"), Identifier("defineProperties")), [node, toDefineObject(mutatorMap)]));
          }
        }
      };
    });

    var transformProtoToAssign = declare(function (api) {
      api.assertVersion(7);

      function isProtoKey(node) {
        return isLiteral(toComputedKey(node, node.key), {
          value: "__proto__"
        });
      }

      function isProtoAssignmentExpression(node) {
        var left = node.left;
        return isMemberExpression(left) && isLiteral(toComputedKey(left, left.property), {
          value: "__proto__"
        });
      }

      function buildDefaultsCallExpression(expr, ref, file) {
        return ExpressionStatement(CallExpression(file.addHelper("defaults"), [ref, expr.right]));
      }

      return {
        name: "transform-proto-to-assign",
        visitor: {
          AssignmentExpression: function AssignmentExpression$1(path, file) {
            if (!isProtoAssignmentExpression(path.node)) return;
            var nodes = [];
            var left = path.node.left.object;
            var temp = path.scope.maybeGenerateMemoised(left);

            if (temp) {
              nodes.push(ExpressionStatement(AssignmentExpression("=", temp, left)));
            }

            nodes.push(buildDefaultsCallExpression(path.node, cloneNode(temp || left), file));
            if (temp) nodes.push(cloneNode(temp));
            path.replaceWithMultiple(nodes);
          },
          ExpressionStatement: function ExpressionStatement(path, file) {
            var expr = path.node.expression;
            if (!isAssignmentExpression(expr, {
              operator: "="
            })) return;

            if (isProtoAssignmentExpression(expr)) {
              path.replaceWith(buildDefaultsCallExpression(expr, expr.left.object, file));
            }
          },
          ObjectExpression: function ObjectExpression$1(path, file) {
            var proto;
            var node = path.node;

            for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
              var prop = _arr[_i];

              if (isProtoKey(prop)) {
                proto = prop.value;
                pull_1(node.properties, prop);
              }
            }

            if (proto) {
              var args = [ObjectExpression([]), proto];
              if (node.properties.length) args.push(node);
              path.replaceWith(CallExpression(file.addHelper("extends"), args));
            }
          }
        }
      };
    });

    var transformReactConstantElements = declare(function (api, options) {
      api.assertVersion(7);
      var allowMutablePropsOnTags = options.allowMutablePropsOnTags;

      if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
        throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
      }

      var HOISTED = new WeakSet();
      var immutabilityVisitor = {
        enter: function enter(path, state) {
          var stop = function stop() {
            state.isImmutable = false;
            path.stop();
          };

          if (path.isJSXClosingElement()) {
            path.skip();
            return;
          }

          if (path.isJSXIdentifier({
            name: "ref"
          }) && path.parentPath.isJSXAttribute({
            name: path.node
          })) {
            return stop();
          }

          if (path.isJSXIdentifier() || path.isIdentifier() || path.isJSXMemberExpression()) {
            return;
          }

          if (!path.isImmutable()) {
            if (path.isPure()) {
              var expressionResult = path.evaluate();

              if (expressionResult.confident) {
                var value = expressionResult.value;
                var isMutable = !state.mutablePropsAllowed && value && typeof value === "object" || typeof value === "function";

                if (!isMutable) {
                  path.skip();
                  return;
                }
              } else if (isIdentifier(expressionResult.deopt)) {
                return;
              }
            }

            stop();
          }
        }
      };
      return {
        name: "transform-react-constant-elements",
        visitor: {
          JSXElement: function JSXElement(path) {
            if (HOISTED.has(path.node)) return;
            HOISTED.add(path.node);
            var state = {
              isImmutable: true
            };

            if (allowMutablePropsOnTags != null) {
              var namePath = path.get("openingElement.name");

              while (namePath.isJSXMemberExpression()) {
                namePath = namePath.get("property");
              }

              var elementName = namePath.node.name;
              state.mutablePropsAllowed = allowMutablePropsOnTags.indexOf(elementName) > -1;
            }

            path.traverse(immutabilityVisitor, state);
            if (state.isImmutable) path.hoist();
          }
        }
      };
    });

    var transformReactDisplayName = declare(function (api) {
      api.assertVersion(7);

      function addDisplayName(id, call) {
        var props = call.arguments[0].properties;
        var safe = true;

        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          var key = toComputedKey(prop);

          if (isLiteral(key, {
            value: "displayName"
          })) {
            safe = false;
            break;
          }
        }

        if (safe) {
          props.unshift(ObjectProperty(Identifier("displayName"), StringLiteral(id)));
        }
      }

      var isCreateClassCallExpression = buildMatchMemberExpression("React.createClass");

      var isCreateClassAddon = function isCreateClassAddon(callee) {
        return callee.name === "createReactClass";
      };

      function isCreateClass(node) {
        if (!node || !isCallExpression(node)) return false;

        if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
          return false;
        }

        var args = node.arguments;
        if (args.length !== 1) return false;
        var first = args[0];
        if (!isObjectExpression(first)) return false;
        return true;
      }

      return {
        name: "transform-react-display-name",
        visitor: {
          ExportDefaultDeclaration: function ExportDefaultDeclaration(_ref, state) {
            var node = _ref.node;

            if (isCreateClass(node.declaration)) {
              var filename = state.filename || "unknown";
              var displayName = path$1.basename(filename, path$1.extname(filename));

              if (displayName === "index") {
                displayName = path$1.basename(path$1.dirname(filename));
              }

              addDisplayName(displayName, node.declaration);
            }
          },
          CallExpression: function CallExpression(path) {
            var node = path.node;
            if (!isCreateClass(node)) return;
            var id;
            path.find(function (path) {
              if (path.isAssignmentExpression()) {
                id = path.node.left;
              } else if (path.isObjectProperty()) {
                id = path.node.key;
              } else if (path.isVariableDeclarator()) {
                id = path.node.id;
              } else if (path.isStatement()) {
                return true;
              }

              if (id) return true;
            });
            if (!id) return;

            if (isMemberExpression(id)) {
              id = id.property;
            }

            if (isIdentifier(id)) {
              addDisplayName(id.name, node);
            }
          }
        }
      };
    });

    function helper$2 (opts) {
      var visitor = {};

      visitor.JSXNamespacedName = function (path) {
        if (opts.throwIfNamespace) {
          throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
        }
      };

      visitor.JSXSpreadChild = function (path) {
        throw path.buildCodeFrameError("Spread children are not supported in React.");
      };

      visitor.JSXElement = {
        exit: function exit(path, file) {
          var callExpr = buildElementCall(path, file);

          if (callExpr) {
            path.replaceWith(inherits(callExpr, path.node));
          }
        }
      };
      visitor.JSXFragment = {
        exit: function exit(path, file) {
          if (opts.compat) {
            throw path.buildCodeFrameError("Fragment tags are only supported in React 16 and up.");
          }

          var callExpr = buildFragmentCall(path, file);

          if (callExpr) {
            path.replaceWith(inherits(callExpr, path.node));
          }
        }
      };
      return visitor;

      function convertJSXIdentifier(node, parent) {
        if (isJSXIdentifier(node)) {
          if (node.name === "this" && isReferenced(node, parent)) {
            return ThisExpression();
          } else if (isValidIdentifier(node.name, false)) {
            node.type = "Identifier";
          } else {
            return StringLiteral(node.name);
          }
        } else if (isJSXMemberExpression(node)) {
          return MemberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
        } else if (isJSXNamespacedName(node)) {
          return StringLiteral(node.namespace.name + ":" + node.name.name);
        }

        return node;
      }

      function convertAttributeValue(node) {
        if (isJSXExpressionContainer(node)) {
          return node.expression;
        } else {
          return node;
        }
      }

      function convertAttribute(node) {
        var value = convertAttributeValue(node.value || BooleanLiteral(true));

        if (isJSXSpreadAttribute(node)) {
          return SpreadElement(node.argument);
        }

        if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
          var _value$extra;

          value.value = value.value.replace(/\n\s+/g, " ");
          (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
        }

        if (isJSXNamespacedName(node.name)) {
          node.name = StringLiteral(node.name.namespace.name + ":" + node.name.name.name);
        } else if (isValidIdentifier(node.name.name, false)) {
          node.name.type = "Identifier";
        } else {
          node.name = StringLiteral(node.name.name);
        }

        return inherits(ObjectProperty(node.name, value), node);
      }

      function buildElementCall(path, file) {
        if (opts.filter && !opts.filter(path.node, file)) return;
        var openingPath = path.get("openingElement");
        openingPath.parent.children = react.buildChildren(openingPath.parent);
        var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
        var args = [];
        var tagName;

        if (isIdentifier(tagExpr)) {
          tagName = tagExpr.name;
        } else if (isLiteral(tagExpr)) {
          tagName = tagExpr.value;
        }

        var state = {
          tagExpr: tagExpr,
          tagName: tagName,
          args: args,
          pure: false
        };

        if (opts.pre) {
          opts.pre(state, file);
        }

        var attribs = openingPath.node.attributes;

        if (attribs.length) {
          attribs = buildOpeningElementAttributes(attribs, file);
        } else {
          attribs = NullLiteral();
        }

        args.push.apply(args, [attribs].concat(path.node.children));

        if (opts.post) {
          opts.post(state, file);
        }

        var call = state.call || CallExpression(state.callee, args);
        if (state.pure) annotateAsPure(call);
        return call;
      }

      function pushProps(_props, objs) {
        if (!_props.length) return _props;
        objs.push(ObjectExpression(_props));
        return [];
      }

      function buildOpeningElementAttributes(attribs, file) {
        var _props = [];
        var objs = [];
        var _file$opts$useSpread = file.opts.useSpread,
            useSpread = _file$opts$useSpread === void 0 ? false : _file$opts$useSpread;

        if (typeof useSpread !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
        }

        var useBuiltIns = file.opts.useBuiltIns || false;

        if (typeof useBuiltIns !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
        }

        if (useSpread && useBuiltIns) {
          throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
        }

        if (useSpread) {
          var props = attribs.map(convertAttribute);
          return ObjectExpression(props);
        }

        while (attribs.length) {
          var prop = attribs.shift();

          if (isJSXSpreadAttribute(prop)) {
            _props = pushProps(_props, objs);
            objs.push(prop.argument);
          } else {
            _props.push(convertAttribute(prop));
          }
        }

        pushProps(_props, objs);

        if (objs.length === 1) {
          attribs = objs[0];
        } else {
          if (!isObjectExpression(objs[0])) {
            objs.unshift(ObjectExpression([]));
          }

          var helper = useBuiltIns ? MemberExpression(Identifier("Object"), Identifier("assign")) : file.addHelper("extends");
          attribs = CallExpression(helper, objs);
        }

        return attribs;
      }

      function buildFragmentCall(path, file) {
        if (opts.filter && !opts.filter(path.node, file)) return;
        var openingPath = path.get("openingElement");
        openingPath.parent.children = react.buildChildren(openingPath.parent);
        var args = [];
        var tagName = null;
        var tagExpr = file.get("jsxFragIdentifier")();
        var state = {
          tagExpr: tagExpr,
          tagName: tagName,
          args: args,
          pure: false
        };

        if (opts.pre) {
          opts.pre(state, file);
        }

        args.push.apply(args, [NullLiteral()].concat(path.node.children));

        if (opts.post) {
          opts.post(state, file);
        }

        file.set("usedFragment", true);
        var call = state.call || CallExpression(state.callee, args);
        if (state.pure) annotateAsPure(call);
        return call;
      }
    }

    var transformReactInlineElements = declare(function (api) {
      api.assertVersion(7);

      function hasRefOrSpread(attrs) {
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          if (isJSXSpreadAttribute(attr)) return true;
          if (isJSXAttributeOfName(attr, "ref")) return true;
        }

        return false;
      }

      function isJSXAttributeOfName(attr, name) {
        return isJSXAttribute(attr) && isJSXIdentifier(attr.name, {
          name: name
        });
      }

      var visitor = helper$2({
        filter: function filter(node) {
          return node.openingElement && !hasRefOrSpread(node.openingElement.attributes);
        },
        pre: function pre(state) {
          var tagName = state.tagName;
          var args = state.args;

          if (react.isCompatTag(tagName)) {
            args.push(StringLiteral(tagName));
          } else {
            args.push(state.tagExpr);
          }
        },
        post: function post(state, pass) {
          state.callee = pass.addHelper("jsx");
          var props = state.args[1];
          var hasKey = false;

          if (isObjectExpression(props)) {
            var keyIndex = props.properties.findIndex(function (prop) {
              return isIdentifier(prop.key, {
                name: "key"
              });
            });

            if (keyIndex > -1) {
              state.args.splice(2, 0, props.properties[keyIndex].value);
              props.properties.splice(keyIndex, 1);
              hasKey = true;
            }
          } else if (isNullLiteral(props)) {
            state.args.splice(1, 1, ObjectExpression([]));
          }

          if (!hasKey && state.args.length > 2) {
            state.args.splice(2, 0, UnaryExpression("void", NumericLiteral(0)));
          }

          state.pure = true;
        }
      });
      return {
        name: "transform-react-inline-elements",
        visitor: visitor
      };
    });

    var DEFAULT = {
      pragma: "React.createElement",
      pragmaFrag: "React.Fragment"
    };
    var transformClassic = declare(function (api, options) {
      var THROW_IF_NAMESPACE = options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;
      var PRAGMA_DEFAULT = options.pragma || DEFAULT.pragma;
      var PRAGMA_FRAG_DEFAULT = options.pragmaFrag || DEFAULT.pragmaFrag;
      var PURE_ANNOTATION = options.pure;
      var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
      var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;

      var createIdentifierParser = function createIdentifierParser(id) {
        return function () {
          return id.split(".").map(function (name) {
            return Identifier(name);
          }).reduce(function (object, property) {
            return MemberExpression(object, property);
          });
        };
      };

      var visitor = helper$2({
        pre: function pre(state) {
          var tagName = state.tagName;
          var args = state.args;

          if (react.isCompatTag(tagName)) {
            args.push(StringLiteral(tagName));
          } else {
            args.push(state.tagExpr);
          }
        },
        post: function post(state, pass) {
          state.callee = pass.get("jsxIdentifier")();
          state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : pass.get("pragma") === DEFAULT.pragma;
        },
        throwIfNamespace: THROW_IF_NAMESPACE
      });
      visitor.Program = {
        enter: function enter(path, state) {
          var file = state.file;
          var pragma = PRAGMA_DEFAULT;
          var pragmaFrag = PRAGMA_FRAG_DEFAULT;
          var pragmaSet = !!options.pragma;
          var pragmaFragSet = !!options.pragma;

          if (file.ast.comments) {
            for (var _i = 0, _arr = file.ast.comments; _i < _arr.length; _i++) {
              var comment = _arr[_i];
              var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

              if (jsxMatches) {
                pragma = jsxMatches[1];
                pragmaSet = true;
              }

              var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

              if (jsxFragMatches) {
                pragmaFrag = jsxFragMatches[1];
                pragmaFragSet = true;
              }
            }
          }

          state.set("jsxIdentifier", createIdentifierParser(pragma));
          state.set("jsxFragIdentifier", createIdentifierParser(pragmaFrag));
          state.set("usedFragment", false);
          state.set("pragma", pragma);
          state.set("pragmaSet", pragmaSet);
          state.set("pragmaFragSet", pragmaFragSet);
        },
        exit: function exit(path, state) {
          if (state.get("pragmaSet") && state.get("usedFragment") && !state.get("pragmaFragSet")) {
            throw new Error("transform-react-jsx: pragma has been set but " + "pragmaFrag has not been set");
          }
        }
      };

      visitor.JSXAttribute = function (path) {
        if (isJSXElement(path.node.value)) {
          path.node.value = JSXExpressionContainer(path.node.value);
        }
      };

      return {
        name: "transform-react-jsx",
        inherits: syntaxJsx,
        visitor: visitor
      };
    });

    var DEFAULT$1 = {
      importSource: "react",
      runtime: "automatic",
      pragma: "React.createElement",
      pragmaFrag: "React.Fragment"
    };
    function helper$3(babel, options) {
      var FILE_NAME_VAR = "_jsxFileName";
      var JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
      var JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
      var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
      var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;
      var IMPORT_NAME_SIZE = options.development ? 3 : 4;
      var _options$importSource = options.importSource,
          IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT$1.importSource : _options$importSource,
          _options$runtime = options.runtime,
          RUNTIME_DEFAULT = _options$runtime === void 0 ? DEFAULT$1.runtime : _options$runtime,
          _options$pragma = options.pragma,
          PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT$1.pragma : _options$pragma,
          _options$pragmaFrag = options.pragmaFrag,
          PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT$1.pragmaFrag : _options$pragmaFrag;
      var injectMetaPropertiesVisitor = {
        JSXOpeningElement: function JSXOpeningElement(path, state) {
          for (var _iterator = _createForOfIteratorHelperLoose(path.get("attributes")), _step; !(_step = _iterator()).done;) {
            var attr = _step.value;
            if (!attr.isJSXElement()) continue;
            var name = attr.node.name.name;

            if (name === "__source" || name === "__self") {
              throw path.buildCodeFrameError("__source and __self should not be defined in props and are reserved for internal usage.");
            }
          }

          var source = JSXAttribute(JSXIdentifier("__source"), JSXExpressionContainer(makeSource(path, state)));
          var self = JSXAttribute(JSXIdentifier("__self"), JSXExpressionContainer(ThisExpression()));
          path.pushContainer("attributes", [source, self]);
        }
      };
      return {
        JSXNamespacedName: function JSXNamespacedName(path, state) {
          var throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;

          if (throwIfNamespace) {
            throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
          }
        },
        JSXSpreadChild: function JSXSpreadChild(path) {
          throw path.buildCodeFrameError("Spread children are not supported in React.");
        },
        JSXElement: {
          exit: function exit(path, file) {
            var callExpr;

            if (file.get("@babel/plugin-react-jsx/runtime") === "classic" || shouldUseCreateElement(path)) {
              callExpr = buildCreateElementCall(path, file);
            } else {
              callExpr = buildJSXElementCall(path, file);
            }

            path.replaceWith(inherits(callExpr, path.node));
          }
        },
        JSXFragment: {
          exit: function exit(path, file) {
            var callExpr;

            if (file.get("@babel/plugin-react-jsx/runtime") === "classic") {
              callExpr = buildCreateElementFragmentCall(path, file);
            } else {
              callExpr = buildJSXFragmentCall(path, file);
            }

            path.replaceWith(inherits(callExpr, path.node));
          }
        },
        JSXAttribute: function JSXAttribute(path) {
          if (isJSXElement(path.node.value)) {
            path.node.value = JSXExpressionContainer(path.node.value);
          }
        },
        Program: {
          enter: function enter(path, state) {
            if (hasJSX(path)) {
              var file = state.file;
              var runtime = RUNTIME_DEFAULT;
              var source = IMPORT_SOURCE_DEFAULT;
              var sourceSet = !!options.importSource;
              var pragma = PRAGMA_DEFAULT;
              var pragmaFrag = PRAGMA_FRAG_DEFAULT;
              var pragmaSet = !!options.pragma;
              var pragmaFragSet = !!options.pragmaFrag;

              if (file.ast.comments) {
                for (var _i = 0, _arr = file.ast.comments; _i < _arr.length; _i++) {
                  var comment = _arr[_i];
                  var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

                  if (sourceMatches) {
                    source = sourceMatches[1];
                    sourceSet = true;
                  }

                  var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

                  if (runtimeMatches) {
                    runtime = runtimeMatches[1];
                  }

                  var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxMatches) {
                    pragma = jsxMatches[1];
                    pragmaSet = true;
                  }

                  var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxFragMatches) {
                    pragmaFrag = jsxFragMatches[1];
                    pragmaFragSet = true;
                  }
                }
              }

              state.set("@babel/plugin-react-jsx/runtime", runtime);

              if (runtime === "classic") {
                if (sourceSet) {
                  throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
                }

                state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(pragma));
                state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(pragmaFrag));
                state.set("@babel/plugin-react-jsx/usedFragment", false);
                state.set("@babel/plugin-react-jsx/pragmaSet", pragma !== DEFAULT$1.pragma);
                state.set("@babel/plugin-react-jsx/pragmaFragSet", pragmaFrag !== DEFAULT$1.pragmaFrag);
              } else if (runtime === "automatic") {
                if (pragmaSet || pragmaFragSet) {
                  throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
                }

                var importName = addAutoImports(path, Object.assign({}, state.opts, {
                  source: source
                }));
                state.set("@babel/plugin-react-jsx/jsxIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsx", importName)));
                state.set("@babel/plugin-react-jsx/jsxStaticIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsxs", importName)));
                state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(createIdentifierName(path, "createElement", importName)));
                state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(createIdentifierName(path, "Fragment", importName)));
                state.set("@babel/plugin-react-jsx/importSourceSet", source !== DEFAULT$1.importSource);
              } else {
                throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
              }

              if (options.development) {
                path.traverse(injectMetaPropertiesVisitor, state);
              }
            }
          },
          exit: function exit(path, state) {
            if (state.get("@babel/plugin-react-jsx/runtime") === "classic" && state.get("@babel/plugin-react-jsx/pragmaSet") && state.get("@babel/plugin-react-jsx/usedFragment") && !state.get("@babel/plugin-react-jsx/pragmaFragSet")) {
              throw new Error("transform-react-jsx: pragma has been set but " + "pragmaFrag has not been set");
            }
          }
        }
      };

      function shouldUseCreateElement(path) {
        var openingPath = path.get("openingElement");
        var attributes = openingPath.node.attributes;
        var seenPropsSpread = false;

        for (var i = 0; i < attributes.length; i++) {
          var attr = attributes[i];

          if (seenPropsSpread && isJSXAttribute(attr) && attr.name.name === "key") {
            return true;
          } else if (isJSXSpreadAttribute(attr)) {
            seenPropsSpread = true;
          }
        }

        return false;
      }

      function createIdentifierName(path, name, importName) {
        if (isModule(path)) {
          var identifierName = "" + importName[name];
          return identifierName;
        } else {
          return importName[name] + "." + name;
        }
      }

      function getImportNames(parentPath) {
        var imports = new Set();
        parentPath.traverse({
          "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
            if (path.type === "JSXFragment") imports.add("Fragment");
            var openingPath = path.get("openingElement");
            var validChildren = react.buildChildren(openingPath.parent);
            var importName;

            if (path.type === "JSXElement" && shouldUseCreateElement(path)) {
              importName = "createElement";
            } else if (options.development) {
              importName = "jsxDEV";
            } else if (validChildren.length > 1) {
              importName = "jsxs";
            } else {
              importName = "jsx";
            }

            imports.add(importName);

            if (imports.size === IMPORT_NAME_SIZE) {
              path.stop();
            }
          }
        });
        return imports;
      }

      function hasJSX(parentPath) {
        var fileHasJSX = false;
        parentPath.traverse({
          "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
            fileHasJSX = true;
            path.stop();
          }
        });
        return fileHasJSX;
      }

      function getSource(source, importName) {
        switch (importName) {
          case "Fragment":
            return source + "/" + (options.development ? "jsx-dev-runtime" : "jsx-runtime");

          case "jsxDEV":
            return source + "/jsx-dev-runtime";

          case "jsx":
          case "jsxs":
            return source + "/jsx-runtime";

          case "createElement":
            return source;
        }
      }

      function addAutoImports(path, state) {
        var imports = getImportNames(path);

        if (isModule(path)) {
          var importMap = {};
          imports.forEach(function (importName) {
            if (!importMap[importName]) {
              importMap[importName] = addNamed(path, importName, getSource(state.source, importName), {
                importedInterop: "uncompiled",
                ensureLiveReference: true
              }).name;
            }
          });
          return importMap;
        } else {
          var _importMap = {};
          var sourceMap = {};
          imports.forEach(function (importName) {
            var source = getSource(state.source, importName);

            if (!_importMap[importName]) {
              if (!sourceMap[source]) {
                sourceMap[source] = addNamespace(path, source, {
                  importedInterop: "uncompiled",
                  ensureLiveReference: true
                }).name;
              }

              _importMap[importName] = sourceMap[source];
            }
          });
          return _importMap;
        }
      }

      function createIdentifierParser(id) {
        return function () {
          return id.split(".").map(function (name) {
            return Identifier(name);
          }).reduce(function (object, property) {
            return MemberExpression(object, property);
          });
        };
      }

      function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
        var fileLineLiteral = lineNumber != null ? NumericLiteral(lineNumber) : NullLiteral();
        var fileColumnLiteral = column0Based != null ? NumericLiteral(column0Based + 1) : NullLiteral();
        var fileNameProperty = ObjectProperty(Identifier("fileName"), fileNameIdentifier);
        var lineNumberProperty = ObjectProperty(Identifier("lineNumber"), fileLineLiteral);
        var columnNumberProperty = ObjectProperty(Identifier("columnNumber"), fileColumnLiteral);
        return ObjectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
      }

      function makeSource(path, state) {
        var location = path.node.loc;

        if (!location) {
          return;
        }

        if (!state.fileNameIdentifier) {
          var _state$filename = state.filename,
              filename = _state$filename === void 0 ? "" : _state$filename;
          var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
          var scope = path.hub.getScope();

          if (scope) {
            scope.push({
              id: fileNameIdentifier,
              init: StringLiteral(filename)
            });
          }

          state.fileNameIdentifier = fileNameIdentifier;
        }

        return makeTrace(state.fileNameIdentifier, location.start.line, location.start.column);
      }

      function convertJSXIdentifier(node, parent) {
        if (isJSXIdentifier(node)) {
          if (node.name === "this" && isReferenced(node, parent)) {
            return ThisExpression();
          } else if (isValidIdentifier(node.name, false)) {
            node.type = "Identifier";
          } else {
            return StringLiteral(node.name);
          }
        } else if (isJSXMemberExpression(node)) {
          return MemberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
        } else if (isJSXNamespacedName(node)) {
          return StringLiteral(node.namespace.name + ":" + node.name.name);
        }

        return node;
      }

      function convertAttributeValue(node) {
        if (isJSXExpressionContainer(node)) {
          return node.expression;
        } else {
          return node;
        }
      }

      function convertAttribute(node) {
        var value = convertAttributeValue(node.value || BooleanLiteral(true));

        if (isJSXSpreadAttribute(node)) {
          return SpreadElement(node.argument);
        }

        if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
          value.value = value.value.replace(/\n\s+/g, " ");

          if (value.extra && value.extra.raw) {
            delete value.extra.raw;
          }
        }

        if (isJSXNamespacedName(node.name)) {
          node.name = StringLiteral(node.name.namespace.name + ":" + node.name.name.name);
        } else if (isValidIdentifier(node.name.name, false)) {
          node.name.type = "Identifier";
        } else {
          node.name = StringLiteral(node.name.name);
        }

        return inherits(ObjectProperty(node.name, value), node);
      }

      function buildJSXElementCall(path, file) {
        var openingPath = path.get("openingElement");
        openingPath.parent.children = react.buildChildren(openingPath.parent);
        var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
        var args = [];
        var tagName;

        if (isIdentifier(tagExpr)) {
          tagName = tagExpr.name;
        } else if (isLiteral(tagExpr)) {
          tagName = tagExpr.value;
        }

        var state = {
          tagExpr: tagExpr,
          tagName: tagName,
          args: args,
          pure: false
        };

        if (options.pre) {
          options.pre(state, file);
        }

        var attribs = [];
        var extracted = Object.create(null);

        for (var _iterator2 = _createForOfIteratorHelperLoose(openingPath.get("attributes")), _step2; !(_step2 = _iterator2()).done;) {
          var attr = _step2.value;

          if (attr.isJSXAttribute() && isJSXIdentifier(attr.node.name)) {
            var name = attr.node.name.name;

            switch (name) {
              case "__source":
              case "__self":
                if (extracted[name]) throw sourceSelfError(path, name);

              case "key":
                extracted[name] = convertAttributeValue(attr.node.value);
                break;

              default:
                attribs.push(attr.node);
            }
          } else {
            attribs.push(attr.node);
          }
        }

        if (attribs.length || path.node.children.length) {
          attribs = buildJSXOpeningElementAttributes(attribs, file, path.node.children);
        } else {
          attribs = ObjectExpression([]);
        }

        args.push(attribs);

        if (!options.development) {
          if (extracted.key !== undefined) {
            args.push(extracted.key);
          }
        } else {
          var _extracted$key, _extracted$__source, _extracted$__self;

          args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), BooleanLiteral(path.node.children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : ThisExpression());
        }

        if (options.post) {
          options.post(state, file);
        }

        var call = state.call || CallExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);
        if (state.pure) annotateAsPure(call);
        return call;
      }

      function buildJSXOpeningElementAttributes(attribs, file, children) {
        var props = attribs.map(convertAttribute);

        if (children && children.length > 0) {
          if (children.length === 1) {
            props.push(ObjectProperty(Identifier("children"), children[0]));
          } else {
            props.push(ObjectProperty(Identifier("children"), ArrayExpression(children)));
          }
        }

        return ObjectExpression(props);
      }

      function buildJSXFragmentCall(path, file) {
        var openingPath = path.get("openingElement");
        openingPath.parent.children = react.buildChildren(openingPath.parent);
        var args = [];
        var tagName = null;
        var tagExpr = file.get("@babel/plugin-react-jsx/jsxFragIdentifier")();
        var state = {
          tagExpr: tagExpr,
          tagName: tagName,
          args: args,
          pure: false
        };

        if (options.pre) {
          options.pre(state, file);
        }

        var childrenNode;

        if (path.node.children.length > 0) {
          if (path.node.children.length === 1) {
            childrenNode = path.node.children[0];
          } else {
            childrenNode = ArrayExpression(path.node.children);
          }
        }

        args.push(ObjectExpression(childrenNode !== undefined ? [ObjectProperty(Identifier("children"), childrenNode)] : []));

        if (options.development) {
          args.push(path.scope.buildUndefinedNode(), BooleanLiteral(path.node.children.length > 1));
        }

        if (options.post) {
          options.post(state, file);
        }

        var call = state.call || CallExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);
        if (state.pure) annotateAsPure(call);
        return call;
      }

      function buildCreateElementFragmentCall(path, file) {
        if (options.filter && !options.filter(path.node, file)) {
          return;
        }

        var openingPath = path.get("openingElement");
        openingPath.parent.children = react.buildChildren(openingPath.parent);
        var args = [];
        var tagName = null;
        var tagExpr = file.get("@babel/plugin-react-jsx/jsxFragIdentifier")();
        var state = {
          tagExpr: tagExpr,
          tagName: tagName,
          args: args,
          pure: false
        };

        if (options.pre) {
          options.pre(state, file);
        }

        args.push.apply(args, [NullLiteral()].concat(path.node.children));

        if (options.post) {
          options.post(state, file);
        }

        file.set("@babel/plugin-react-jsx/usedFragment", true);
        var call = state.call || CallExpression(state.createElementCallee, args);
        if (state.pure) annotateAsPure(call);
        return call;
      }

      function buildCreateElementCall(path, file) {
        var openingPath = path.get("openingElement");
        openingPath.parent.children = react.buildChildren(openingPath.parent);
        var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
        var args = [];
        var tagName;

        if (isIdentifier(tagExpr)) {
          tagName = tagExpr.name;
        } else if (isLiteral(tagExpr)) {
          tagName = tagExpr.value;
        }

        var state = {
          tagExpr: tagExpr,
          tagName: tagName,
          args: args,
          pure: false
        };

        if (options.pre) {
          options.pre(state, file);
        }

        var attribs = buildCreateElementOpeningElementAttributes(path, openingPath.node.attributes);
        args.push.apply(args, [attribs].concat(path.node.children));

        if (options.post) {
          options.post(state, file);
        }

        var call = state.call || CallExpression(state.createElementCallee, args);
        if (state.pure) annotateAsPure(call);
        return call;
      }

      function buildCreateElementOpeningElementAttributes(path, attribs) {
        var props = [];
        var found = Object.create(null);

        for (var _iterator3 = _createForOfIteratorHelperLoose(attribs), _step3; !(_step3 = _iterator3()).done;) {
          var attr = _step3.value;
          var name = isJSXAttribute(attr) && isJSXIdentifier(attr.name) && attr.name.name;

          if (name === "__source" || name === "__self") {
            if (found[name]) throw sourceSelfError(path, name);
            found[name] = true;
            if (!options.development) continue;
          }

          props.push(convertAttribute(attr));
        }

        return props.length > 0 ? ObjectExpression(props) : NullLiteral();
      }

      function sourceSelfError(path, name) {
        var pluginName = "transform-react-jsx-" + name.slice(2);
        return path.buildCodeFrameError("Duplicate " + name + " prop found. You are most likely using the deprecated " + pluginName + " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.");
      }
    }

    var transformAutomatic = declare(function (api, options) {
      var PURE_ANNOTATION = options.pure;
      var visitor = helper$3(api, Object.assign({
        pre: function pre(state) {
          var tagName = state.tagName;
          var args = state.args;

          if (react.isCompatTag(tagName)) {
            args.push(StringLiteral(tagName));
          } else {
            args.push(state.tagExpr);
          }
        },
        post: function post(state, pass) {
          if (pass.get("@babel/plugin-react-jsx/runtime") === "classic") {
            state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
            state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/pragmaSet");
          } else {
            state.jsxCallee = pass.get("@babel/plugin-react-jsx/jsxIdentifier")();
            state.jsxStaticCallee = pass.get("@babel/plugin-react-jsx/jsxStaticIdentifier")();
            state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
            state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/importSourceSet");
          }
        }
      }, options, {
        development: false
      }));
      return {
        name: "transform-react-jsx",
        inherits: syntaxJsx,
        visitor: visitor
      };
    });

    var transformReactJSX = declare(function (api, options) {
      var _options$runtime = options.runtime,
          runtime = _options$runtime === void 0 ? "classic" : _options$runtime;

      if (runtime === "classic") {
        return transformClassic(api, options);
      } else {
        return transformAutomatic(api, options);
      }
    });

    var transformReactJsxCompat = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-react-jsx-compat",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("jsx");
        },
        visitor: helper$2({
          pre: function pre(state) {
            state.callee = state.tagExpr;
          },
          post: function post(state) {
            if (react.isCompatTag(state.tagName)) {
              state.call = CallExpression(MemberExpression(MemberExpression(Identifier("React"), Identifier("DOM")), state.tagExpr, isLiteral(state.tagExpr)), state.args);
            }
          },
          compat: true
        })
      };
    });

    var transformReactJSXDevelopment = declare(function (api, options) {
      var PURE_ANNOTATION = options.pure;
      var visitor = helper$3(api, Object.assign({
        pre: function pre(state) {
          var tagName = state.tagName;
          var args = state.args;

          if (react.isCompatTag(tagName)) {
            args.push(StringLiteral(tagName));
          } else {
            args.push(state.tagExpr);
          }
        },
        post: function post(state, pass) {
          if (pass.get("@babel/plugin-react-jsx/runtime") === "classic") {
            state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
            state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/pragmaSet");
          } else {
            state.jsxCallee = pass.get("@babel/plugin-react-jsx/jsxIdentifier")();
            state.jsxStaticCallee = pass.get("@babel/plugin-react-jsx/jsxStaticIdentifier")();
            state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
            state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/importSourceSet");
          }
        }
      }, options, {
        development: true
      }));
      return {
        name: "transform-react-jsx",
        inherits: syntaxJsx,
        visitor: visitor
      };
    });

    var TRACE_ID = "__self";
    var transformReactJSXSelf = declare(function (api) {
      api.assertVersion(7);
      var visitor = {
        JSXOpeningElement: function JSXOpeningElement(_ref) {
          var node = _ref.node;
          var id = JSXIdentifier(TRACE_ID);
          var trace = ThisExpression();
          node.attributes.push(JSXAttribute(id, JSXExpressionContainer(trace)));
        }
      };
      return {
        name: "transform-react-jsx-self",
        visitor: {
          Program: function Program(path) {
            path.traverse(visitor);
          }
        }
      };
    });

    var TRACE_ID$1 = "__source";
    var FILE_NAME_VAR = "_jsxFileName";
    var transformReactJSXSource = declare(function (api) {
      api.assertVersion(7);

      function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
        var fileLineLiteral = lineNumber != null ? NumericLiteral(lineNumber) : NullLiteral();
        var fileColumnLiteral = column0Based != null ? NumericLiteral(column0Based + 1) : NullLiteral();
        var fileNameProperty = ObjectProperty(Identifier("fileName"), fileNameIdentifier);
        var lineNumberProperty = ObjectProperty(Identifier("lineNumber"), fileLineLiteral);
        var columnNumberProperty = ObjectProperty(Identifier("columnNumber"), fileColumnLiteral);
        return ObjectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
      }

      var visitor = {
        JSXOpeningElement: function JSXOpeningElement(path, state) {
          var id = JSXIdentifier(TRACE_ID$1);
          var location = path.container.openingElement.loc;

          if (!location) {
            return;
          }

          var attributes = path.container.openingElement.attributes;

          for (var i = 0; i < attributes.length; i++) {
            var name = attributes[i].name;

            if (name && name.name === TRACE_ID$1) {
              return;
            }
          }

          if (!state.fileNameIdentifier) {
            var fileName = state.filename || "";
            var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
            var scope = path.hub.getScope();

            if (scope) {
              scope.push({
                id: fileNameIdentifier,
                init: StringLiteral(fileName)
              });
            }

            state.fileNameIdentifier = fileNameIdentifier;
          }

          var trace = makeTrace(state.fileNameIdentifier, location.start.line, location.start.column);
          attributes.push(JSXAttribute(id, JSXExpressionContainer(trace)));
        }
      };
      return {
        name: "transform-react-jsx-source",
        visitor: visitor
      };
    });

    var transformReservedWords = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-reserved-words",
        visitor: {
          "BindingIdentifier|ReferencedIdentifier": function BindingIdentifierReferencedIdentifier(path) {
            if (!isValidES3Identifier(path.node.name)) {
              path.scope.rename(path.node.name);
            }
          }
        }
      };
    });

    function hasMinVersion(minVersion, runtimeVersion) {
      if (!runtimeVersion) return true;
      if (semver.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
      return !semver.intersects("<" + minVersion, runtimeVersion) && !semver.intersects(">=8.0.0", runtimeVersion);
    }
    function typeAnnotationToString(node) {
      switch (node.type) {
        case "GenericTypeAnnotation":
          if (isIdentifier(node.id, {
            name: "Array"
          })) return "array";
          break;

        case "StringTypeAnnotation":
          return "string";
      }
    }

    var getCoreJS2Definitions = (function (runtimeVersion) {
      var includeMathModule = hasMinVersion("7.0.1", runtimeVersion);
      return {
        BuiltIns: {
          Symbol: {
            stable: true,
            path: "symbol"
          },
          Promise: {
            stable: true,
            path: "promise"
          },
          Map: {
            stable: true,
            path: "map"
          },
          WeakMap: {
            stable: true,
            path: "weak-map"
          },
          Set: {
            stable: true,
            path: "set"
          },
          WeakSet: {
            stable: true,
            path: "weak-set"
          },
          setImmediate: {
            stable: true,
            path: "set-immediate"
          },
          clearImmediate: {
            stable: true,
            path: "clear-immediate"
          },
          parseFloat: {
            stable: true,
            path: "parse-float"
          },
          parseInt: {
            stable: true,
            path: "parse-int"
          }
        },
        StaticProperties: Object.assign({
          Array: {
            from: {
              stable: true,
              path: "array/from"
            },
            isArray: {
              stable: true,
              path: "array/is-array"
            },
            of: {
              stable: true,
              path: "array/of"
            }
          },
          JSON: {
            stringify: {
              stable: true,
              path: "json/stringify"
            }
          },
          Object: {
            assign: {
              stable: true,
              path: "object/assign"
            },
            create: {
              stable: true,
              path: "object/create"
            },
            defineProperties: {
              stable: true,
              path: "object/define-properties"
            },
            defineProperty: {
              stable: true,
              path: "object/define-property"
            },
            entries: {
              stable: true,
              path: "object/entries"
            },
            freeze: {
              stable: true,
              path: "object/freeze"
            },
            getOwnPropertyDescriptor: {
              stable: true,
              path: "object/get-own-property-descriptor"
            },
            getOwnPropertyDescriptors: {
              stable: true,
              path: "object/get-own-property-descriptors"
            },
            getOwnPropertyNames: {
              stable: true,
              path: "object/get-own-property-names"
            },
            getOwnPropertySymbols: {
              stable: true,
              path: "object/get-own-property-symbols"
            },
            getPrototypeOf: {
              stable: true,
              path: "object/get-prototype-of"
            },
            isExtensible: {
              stable: true,
              path: "object/is-extensible"
            },
            isFrozen: {
              stable: true,
              path: "object/is-frozen"
            },
            isSealed: {
              stable: true,
              path: "object/is-sealed"
            },
            is: {
              stable: true,
              path: "object/is"
            },
            keys: {
              stable: true,
              path: "object/keys"
            },
            preventExtensions: {
              stable: true,
              path: "object/prevent-extensions"
            },
            seal: {
              stable: true,
              path: "object/seal"
            },
            setPrototypeOf: {
              stable: true,
              path: "object/set-prototype-of"
            },
            values: {
              stable: true,
              path: "object/values"
            }
          }
        }, includeMathModule ? {
          Math: {
            acosh: {
              stable: true,
              path: "math/acosh"
            },
            asinh: {
              stable: true,
              path: "math/asinh"
            },
            atanh: {
              stable: true,
              path: "math/atanh"
            },
            cbrt: {
              stable: true,
              path: "math/cbrt"
            },
            clz32: {
              stable: true,
              path: "math/clz32"
            },
            cosh: {
              stable: true,
              path: "math/cosh"
            },
            expm1: {
              stable: true,
              path: "math/expm1"
            },
            fround: {
              stable: true,
              path: "math/fround"
            },
            hypot: {
              stable: true,
              path: "math/hypot"
            },
            imul: {
              stable: true,
              path: "math/imul"
            },
            log10: {
              stable: true,
              path: "math/log10"
            },
            log1p: {
              stable: true,
              path: "math/log1p"
            },
            log2: {
              stable: true,
              path: "math/log2"
            },
            sign: {
              stable: true,
              path: "math/sign"
            },
            sinh: {
              stable: true,
              path: "math/sinh"
            },
            tanh: {
              stable: true,
              path: "math/tanh"
            },
            trunc: {
              stable: true,
              path: "math/trunc"
            }
          }
        } : {}, {
          Symbol: {
            "for": {
              stable: true,
              path: "symbol/for"
            },
            hasInstance: {
              stable: true,
              path: "symbol/has-instance"
            },
            isConcatSpreadable: {
              stable: true,
              path: "symbol/is-concat-spreadable"
            },
            iterator: {
              stable: true,
              path: "symbol/iterator"
            },
            keyFor: {
              stable: true,
              path: "symbol/key-for"
            },
            match: {
              stable: true,
              path: "symbol/match"
            },
            replace: {
              stable: true,
              path: "symbol/replace"
            },
            search: {
              stable: true,
              path: "symbol/search"
            },
            species: {
              stable: true,
              path: "symbol/species"
            },
            split: {
              stable: true,
              path: "symbol/split"
            },
            toPrimitive: {
              stable: true,
              path: "symbol/to-primitive"
            },
            toStringTag: {
              stable: true,
              path: "symbol/to-string-tag"
            },
            unscopables: {
              stable: true,
              path: "symbol/unscopables"
            }
          },
          String: {
            at: {
              stable: true,
              path: "string/at"
            },
            fromCodePoint: {
              stable: true,
              path: "string/from-code-point"
            },
            raw: {
              stable: true,
              path: "string/raw"
            }
          },
          Number: {
            EPSILON: {
              stable: true,
              path: "number/epsilon"
            },
            isFinite: {
              stable: true,
              path: "number/is-finite"
            },
            isInteger: {
              stable: true,
              path: "number/is-integer"
            },
            isNaN: {
              stable: true,
              path: "number/is-nan"
            },
            isSafeInteger: {
              stable: true,
              path: "number/is-safe-integer"
            },
            MAX_SAFE_INTEGER: {
              stable: true,
              path: "number/max-safe-integer"
            },
            MIN_SAFE_INTEGER: {
              stable: true,
              path: "number/min-safe-integer"
            },
            parseFloat: {
              stable: true,
              path: "number/parse-float"
            },
            parseInt: {
              stable: true,
              path: "number/parse-int"
            }
          },
          Reflect: {
            apply: {
              stable: true,
              path: "reflect/apply"
            },
            construct: {
              stable: true,
              path: "reflect/construct"
            },
            defineProperty: {
              stable: true,
              path: "reflect/define-property"
            },
            deleteProperty: {
              stable: true,
              path: "reflect/delete-property"
            },
            getOwnPropertyDescriptor: {
              stable: true,
              path: "reflect/get-own-property-descriptor"
            },
            getPrototypeOf: {
              stable: true,
              path: "reflect/get-prototype-of"
            },
            get: {
              stable: true,
              path: "reflect/get"
            },
            has: {
              stable: true,
              path: "reflect/has"
            },
            isExtensible: {
              stable: true,
              path: "reflect/is-extensible"
            },
            ownKeys: {
              stable: true,
              path: "reflect/own-keys"
            },
            preventExtensions: {
              stable: true,
              path: "reflect/prevent-extensions"
            },
            setPrototypeOf: {
              stable: true,
              path: "reflect/set-prototype-of"
            },
            set: {
              stable: true,
              path: "reflect/set"
            }
          },
          Date: {
            now: {
              stable: true,
              path: "date/now"
            }
          }
        })
      };
    });

    var getCoreJS3Definitions = (function () {
      return {
        BuiltIns: {
          AggregateError: {
            stable: false,
            path: "aggregate-error"
          },
          Map: {
            stable: true,
            path: "map"
          },
          Observable: {
            stable: false,
            path: "observable"
          },
          Promise: {
            stable: true,
            path: "promise"
          },
          Set: {
            stable: true,
            path: "set"
          },
          Symbol: {
            stable: true,
            path: "symbol"
          },
          URL: {
            stable: true,
            path: "url"
          },
          URLSearchParams: {
            stable: true,
            path: "url-search-params"
          },
          WeakMap: {
            stable: true,
            path: "weak-map"
          },
          WeakSet: {
            stable: true,
            path: "weak-set"
          },
          clearImmediate: {
            stable: true,
            path: "clear-immediate"
          },
          compositeKey: {
            stable: false,
            path: "composite-key"
          },
          compositeSymbol: {
            stable: false,
            path: "composite-symbol"
          },
          globalThis: {
            stable: false,
            path: "global-this"
          },
          parseFloat: {
            stable: true,
            path: "parse-float"
          },
          parseInt: {
            stable: true,
            path: "parse-int"
          },
          queueMicrotask: {
            stable: true,
            path: "queue-microtask"
          },
          setImmediate: {
            stable: true,
            path: "set-immediate"
          },
          setInterval: {
            stable: true,
            path: "set-interval"
          },
          setTimeout: {
            stable: true,
            path: "set-timeout"
          }
        },
        StaticProperties: {
          Array: {
            from: {
              stable: true,
              path: "array/from"
            },
            isArray: {
              stable: true,
              path: "array/is-array"
            },
            of: {
              stable: true,
              path: "array/of"
            }
          },
          Date: {
            now: {
              stable: true,
              path: "date/now"
            }
          },
          JSON: {
            stringify: {
              stable: true,
              path: "json/stringify"
            }
          },
          Math: {
            DEG_PER_RAD: {
              stable: false,
              path: "math/deg-per-rad"
            },
            RAD_PER_DEG: {
              stable: false,
              path: "math/rad-per-deg"
            },
            acosh: {
              stable: true,
              path: "math/acosh"
            },
            asinh: {
              stable: true,
              path: "math/asinh"
            },
            atanh: {
              stable: true,
              path: "math/atanh"
            },
            cbrt: {
              stable: true,
              path: "math/cbrt"
            },
            clamp: {
              stable: false,
              path: "math/clamp"
            },
            clz32: {
              stable: true,
              path: "math/clz32"
            },
            cosh: {
              stable: true,
              path: "math/cosh"
            },
            degrees: {
              stable: false,
              path: "math/degrees"
            },
            expm1: {
              stable: true,
              path: "math/expm1"
            },
            fround: {
              stable: true,
              path: "math/fround"
            },
            fscale: {
              stable: false,
              path: "math/fscale"
            },
            hypot: {
              stable: true,
              path: "math/hypot"
            },
            iaddh: {
              stable: false,
              path: "math/iaddh"
            },
            imul: {
              stable: true,
              path: "math/imul"
            },
            imulh: {
              stable: false,
              path: "math/imulh"
            },
            isubh: {
              stable: false,
              path: "math/isubh"
            },
            log10: {
              stable: true,
              path: "math/log10"
            },
            log1p: {
              stable: true,
              path: "math/log1p"
            },
            log2: {
              stable: true,
              path: "math/log2"
            },
            radians: {
              stable: false,
              path: "math/radians"
            },
            scale: {
              stable: false,
              path: "math/scale"
            },
            seededPRNG: {
              stable: false,
              path: "math/seeded-prng"
            },
            sign: {
              stable: true,
              path: "math/sign"
            },
            signbit: {
              stable: false,
              path: "math/signbit"
            },
            sinh: {
              stable: true,
              path: "math/sinh"
            },
            tanh: {
              stable: true,
              path: "math/tanh"
            },
            trunc: {
              stable: true,
              path: "math/trunc"
            },
            umulh: {
              stable: false,
              path: "math/umulh"
            }
          },
          Number: {
            EPSILON: {
              stable: true,
              path: "number/epsilon"
            },
            MAX_SAFE_INTEGER: {
              stable: true,
              path: "number/max-safe-integer"
            },
            MIN_SAFE_INTEGER: {
              stable: true,
              path: "number/min-safe-integer"
            },
            fromString: {
              stable: false,
              path: "number/from-string"
            },
            isFinite: {
              stable: true,
              path: "number/is-finite"
            },
            isInteger: {
              stable: true,
              path: "number/is-integer"
            },
            isNaN: {
              stable: true,
              path: "number/is-nan"
            },
            isSafeInteger: {
              stable: true,
              path: "number/is-safe-integer"
            },
            parseFloat: {
              stable: true,
              path: "number/parse-float"
            },
            parseInt: {
              stable: true,
              path: "number/parse-int"
            }
          },
          Object: {
            assign: {
              stable: true,
              path: "object/assign"
            },
            create: {
              stable: true,
              path: "object/create"
            },
            defineProperties: {
              stable: true,
              path: "object/define-properties"
            },
            defineProperty: {
              stable: true,
              path: "object/define-property"
            },
            entries: {
              stable: true,
              path: "object/entries"
            },
            freeze: {
              stable: true,
              path: "object/freeze"
            },
            fromEntries: {
              stable: true,
              path: "object/from-entries"
            },
            getOwnPropertyDescriptor: {
              stable: true,
              path: "object/get-own-property-descriptor"
            },
            getOwnPropertyDescriptors: {
              stable: true,
              path: "object/get-own-property-descriptors"
            },
            getOwnPropertyNames: {
              stable: true,
              path: "object/get-own-property-names"
            },
            getOwnPropertySymbols: {
              stable: true,
              path: "object/get-own-property-symbols"
            },
            getPrototypeOf: {
              stable: true,
              path: "object/get-prototype-of"
            },
            isExtensible: {
              stable: true,
              path: "object/is-extensible"
            },
            isFrozen: {
              stable: true,
              path: "object/is-frozen"
            },
            isSealed: {
              stable: true,
              path: "object/is-sealed"
            },
            is: {
              stable: true,
              path: "object/is"
            },
            keys: {
              stable: true,
              path: "object/keys"
            },
            preventExtensions: {
              stable: true,
              path: "object/prevent-extensions"
            },
            seal: {
              stable: true,
              path: "object/seal"
            },
            setPrototypeOf: {
              stable: true,
              path: "object/set-prototype-of"
            },
            values: {
              stable: true,
              path: "object/values"
            }
          },
          Reflect: {
            apply: {
              stable: true,
              path: "reflect/apply"
            },
            construct: {
              stable: true,
              path: "reflect/construct"
            },
            defineMetadata: {
              stable: false,
              path: "reflect/define-metadata"
            },
            defineProperty: {
              stable: true,
              path: "reflect/define-property"
            },
            deleteMetadata: {
              stable: false,
              path: "reflect/delete-metadata"
            },
            deleteProperty: {
              stable: true,
              path: "reflect/delete-property"
            },
            getMetadata: {
              stable: false,
              path: "reflect/get-metadata"
            },
            getMetadataKeys: {
              stable: false,
              path: "reflect/get-metadata-keys"
            },
            getOwnMetadata: {
              stable: false,
              path: "reflect/get-own-metadata"
            },
            getOwnMetadataKeys: {
              stable: false,
              path: "reflect/get-own-metadata-keys"
            },
            getOwnPropertyDescriptor: {
              stable: true,
              path: "reflect/get-own-property-descriptor"
            },
            getPrototypeOf: {
              stable: true,
              path: "reflect/get-prototype-of"
            },
            get: {
              stable: true,
              path: "reflect/get"
            },
            has: {
              stable: true,
              path: "reflect/has"
            },
            hasMetadata: {
              stable: false,
              path: "reflect/has-metadata"
            },
            hasOwnMetadata: {
              stable: false,
              path: "reflect/has-own-metadata"
            },
            isExtensible: {
              stable: true,
              path: "reflect/is-extensible"
            },
            metadata: {
              stable: false,
              path: "reflect/metadata"
            },
            ownKeys: {
              stable: true,
              path: "reflect/own-keys"
            },
            preventExtensions: {
              stable: true,
              path: "reflect/prevent-extensions"
            },
            set: {
              stable: true,
              path: "reflect/set"
            },
            setPrototypeOf: {
              stable: true,
              path: "reflect/set-prototype-of"
            }
          },
          String: {
            fromCodePoint: {
              stable: true,
              path: "string/from-code-point"
            },
            raw: {
              stable: true,
              path: "string/raw"
            }
          },
          Symbol: {
            asyncIterator: {
              stable: true,
              path: "symbol/async-iterator"
            },
            dispose: {
              stable: false,
              path: "symbol/dispose"
            },
            "for": {
              stable: true,
              path: "symbol/for"
            },
            hasInstance: {
              stable: true,
              path: "symbol/has-instance"
            },
            isConcatSpreadable: {
              stable: true,
              path: "symbol/is-concat-spreadable"
            },
            iterator: {
              stable: true,
              path: "symbol/iterator"
            },
            keyFor: {
              stable: true,
              path: "symbol/key-for"
            },
            match: {
              stable: true,
              path: "symbol/match"
            },
            observable: {
              stable: false,
              path: "symbol/observable"
            },
            patternMatch: {
              stable: false,
              path: "symbol/pattern-match"
            },
            replace: {
              stable: true,
              path: "symbol/replace"
            },
            search: {
              stable: true,
              path: "symbol/search"
            },
            species: {
              stable: true,
              path: "symbol/species"
            },
            split: {
              stable: true,
              path: "symbol/split"
            },
            toPrimitive: {
              stable: true,
              path: "symbol/to-primitive"
            },
            toStringTag: {
              stable: true,
              path: "symbol/to-string-tag"
            },
            unscopables: {
              stable: true,
              path: "symbol/unscopables"
            }
          }
        },
        InstanceProperties: {
          at: {
            stable: false,
            path: "at"
          },
          bind: {
            stable: true,
            path: "bind"
          },
          codePointAt: {
            stable: true,
            path: "code-point-at"
          },
          codePoints: {
            stable: false,
            path: "code-points"
          },
          concat: {
            stable: true,
            path: "concat",
            types: ["array"]
          },
          copyWithin: {
            stable: true,
            path: "copy-within"
          },
          endsWith: {
            stable: true,
            path: "ends-with"
          },
          entries: {
            stable: true,
            path: "entries"
          },
          every: {
            stable: true,
            path: "every"
          },
          fill: {
            stable: true,
            path: "fill"
          },
          filter: {
            stable: true,
            path: "filter"
          },
          find: {
            stable: true,
            path: "find"
          },
          findIndex: {
            stable: true,
            path: "find-index"
          },
          flags: {
            stable: true,
            path: "flags"
          },
          flatMap: {
            stable: true,
            path: "flat-map"
          },
          flat: {
            stable: true,
            path: "flat"
          },
          forEach: {
            stable: true,
            path: "for-each"
          },
          includes: {
            stable: true,
            path: "includes"
          },
          indexOf: {
            stable: true,
            path: "index-of"
          },
          keys: {
            stable: true,
            path: "keys"
          },
          lastIndexOf: {
            stable: true,
            path: "last-index-of"
          },
          map: {
            stable: true,
            path: "map"
          },
          matchAll: {
            stable: false,
            path: "match-all"
          },
          padEnd: {
            stable: true,
            path: "pad-end"
          },
          padStart: {
            stable: true,
            path: "pad-start"
          },
          reduce: {
            stable: true,
            path: "reduce"
          },
          reduceRight: {
            stable: true,
            path: "reduce-right"
          },
          repeat: {
            stable: true,
            path: "repeat"
          },
          replaceAll: {
            stable: false,
            path: "replace-all"
          },
          reverse: {
            stable: true,
            path: "reverse"
          },
          slice: {
            stable: true,
            path: "slice"
          },
          some: {
            stable: true,
            path: "some"
          },
          sort: {
            stable: true,
            path: "sort"
          },
          splice: {
            stable: true,
            path: "splice"
          },
          startsWith: {
            stable: true,
            path: "starts-with"
          },
          trim: {
            stable: true,
            path: "trim"
          },
          trimEnd: {
            stable: true,
            path: "trim-end"
          },
          trimLeft: {
            stable: true,
            path: "trim-left"
          },
          trimRight: {
            stable: true,
            path: "trim-right"
          },
          trimStart: {
            stable: true,
            path: "trim-start"
          },
          values: {
            stable: true,
            path: "values"
          }
        }
      };
    });

    function getRuntimePath (moduleName, dirname, absoluteRuntime) {
      if (absoluteRuntime === false) return moduleName;
      throw new Error("The 'absoluteRuntime' option is not supported when using @babel/standalone.");
    }

    function supportsStaticESM(caller) {
      return !!(caller && caller.supportsStaticESM);
    }

    var transformRuntime = declare(function (api, options, dirname) {
      api.assertVersion(7);
      var corejs = options.corejs,
          _options$helpers = options.helpers,
          useRuntimeHelpers = _options$helpers === void 0 ? true : _options$helpers,
          _options$regenerator = options.regenerator,
          useRuntimeRegenerator = _options$regenerator === void 0 ? true : _options$regenerator,
          _options$useESModules = options.useESModules,
          useESModules = _options$useESModules === void 0 ? false : _options$useESModules,
          _options$version = options.version,
          runtimeVersion = _options$version === void 0 ? "7.0.0-beta.0" : _options$version,
          _options$absoluteRunt = options.absoluteRuntime,
          absoluteRuntime = _options$absoluteRunt === void 0 ? false : _options$absoluteRunt;
      var proposals = false;
      var rawVersion;

      if (typeof corejs === "object" && corejs !== null) {
        rawVersion = corejs.version;
        proposals = Boolean(corejs.proposals);
      } else {
        rawVersion = corejs;
      }

      var corejsVersion = rawVersion ? Number(rawVersion) : false;

      if (![false, 2, 3].includes(corejsVersion)) {
        throw new Error("The `core-js` version must be false, 2 or 3, but got " + JSON.stringify(rawVersion) + ".");
      }

      if (proposals && (!corejsVersion || corejsVersion < 3)) {
        throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
      }

      if (typeof useRuntimeRegenerator !== "boolean") {
        throw new Error("The 'regenerator' option must be undefined, or a boolean.");
      }

      if (typeof useRuntimeHelpers !== "boolean") {
        throw new Error("The 'helpers' option must be undefined, or a boolean.");
      }

      if (typeof useESModules !== "boolean" && useESModules !== "auto") {
        throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
      }

      if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
        throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
      }

      if (typeof runtimeVersion !== "string") {
        throw new Error("The 'version' option must be a version string.");
      }

      function has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }

      function hasMapping(methods, name) {
        return has(methods, name) && (proposals || methods[name].stable);
      }

      function hasStaticMapping(object, method) {
        return has(StaticProperties, object) && hasMapping(StaticProperties[object], method);
      }

      function isNamespaced(path) {
        var binding = path.scope.getBinding(path.node.name);
        if (!binding) return false;
        return binding.path.isImportNamespaceSpecifier();
      }

      function maybeNeedsPolyfill(path, methods, name) {
        if (isNamespaced(path.get("object"))) return false;
        if (!methods[name].types) return true;
        var typeAnnotation = path.get("object").getTypeAnnotation();
        var type = typeAnnotationToString(typeAnnotation);
        if (!type) return true;
        return methods[name].types.some(function (name) {
          return name === type;
        });
      }

      function resolvePropertyName(path, computed) {
        var node = path.node;
        if (!computed) return node.name;
        if (path.isStringLiteral()) return node.value;
        var result = path.evaluate();
        return result.value;
      }

      if (has(options, "useBuiltIns")) {
        if (options.useBuiltIns) {
          throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
        } else {
          throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
        }
      }

      if (has(options, "polyfill")) {
        if (options.polyfill === false) {
          throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
        } else {
          throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
        }
      }

      if (has(options, "moduleName")) {
        throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
      }

      var esModules = useESModules === "auto" ? api.caller(supportsStaticESM) : useESModules;
      var injectCoreJS2 = corejsVersion === 2;
      var injectCoreJS3 = corejsVersion === 3;
      var injectCoreJS = corejsVersion !== false;
      var moduleName = injectCoreJS3 ? "@babel/runtime-corejs3" : injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
      var corejsRoot = injectCoreJS3 && !proposals ? "core-js-stable" : "core-js";

      var _ref = (injectCoreJS2 ? getCoreJS2Definitions : getCoreJS3Definitions)(runtimeVersion),
          BuiltIns = _ref.BuiltIns,
          StaticProperties = _ref.StaticProperties,
          InstanceProperties = _ref.InstanceProperties;

      var HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
      var modulePath = getRuntimePath(moduleName, dirname, absoluteRuntime);
      return {
        name: "transform-runtime",
        pre: function pre(file) {
          var _this = this;

          if (useRuntimeHelpers) {
            file.set("helperGenerator", function (name) {
              if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
                return;
              }

              var isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
              var blockHoist = isInteropHelper && !isModule(file.path) ? 4 : undefined;
              var helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
              return _this.addDefaultImport(modulePath + "/" + helpersDir + "/" + name, name, blockHoist);
            });
          }

          var cache = new Map();

          this.addDefaultImport = function (source, nameHint, blockHoist) {
            var cacheKey = isModule(file.path);
            var key = source + ":" + nameHint + ":" + (cacheKey || "");
            var cached = cache.get(key);

            if (cached) {
              cached = cloneNode(cached);
            } else {
              cached = addDefault(file.path, source, {
                importedInterop: "uncompiled",
                nameHint: nameHint,
                blockHoist: blockHoist
              });
              cache.set(key, cached);
            }

            return cached;
          };
        },
        visitor: {
          ReferencedIdentifier: function ReferencedIdentifier(path) {
            var node = path.node,
                parent = path.parent,
                scope = path.scope;
            var name = node.name;

            if (name === "regeneratorRuntime" && useRuntimeRegenerator) {
              path.replaceWith(this.addDefaultImport(modulePath + "/regenerator", "regeneratorRuntime"));
              return;
            }

            if (!injectCoreJS) return;
            if (isMemberExpression(parent)) return;
            if (!hasMapping(BuiltIns, name)) return;
            if (scope.getBindingIdentifier(name)) return;
            path.replaceWith(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + BuiltIns[name].path, name));
          },
          CallExpression: function CallExpression$1(path) {
            if (!injectCoreJS) return;
            var node = path.node;
            var callee = node.callee;
            if (!isMemberExpression(callee)) return;
            var object = callee.object;
            var propertyName = resolvePropertyName(path.get("callee.property"), callee.computed);

            if (injectCoreJS3 && !hasStaticMapping(object.name, propertyName)) {
              if (hasMapping(InstanceProperties, propertyName) && maybeNeedsPolyfill(path.get("callee"), InstanceProperties, propertyName)) {
                var context1, context2;

                if (isIdentifier(object)) {
                  context1 = object;
                  context2 = cloneNode(object);
                } else {
                  context1 = path.scope.generateDeclaredUidIdentifier("context");
                  context2 = AssignmentExpression("=", context1, object);
                }

                node.callee = MemberExpression(CallExpression(this.addDefaultImport(moduleName + "/" + corejsRoot + "/instance/" + InstanceProperties[propertyName].path, propertyName + "InstanceProperty"), [context2]), Identifier("call"));
                node.arguments.unshift(context1);
                return;
              }
            }

            if (node.arguments.length) return;
            if (!callee.computed) return;

            if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
              return;
            }

            path.replaceWith(CallExpression(this.addDefaultImport(modulePath + "/core-js/get-iterator", "getIterator"), [object]));
          },
          BinaryExpression: function BinaryExpression(path) {
            if (!injectCoreJS) return;
            if (path.node.operator !== "in") return;
            if (!path.get("left").matchesPattern("Symbol.iterator")) return;
            path.replaceWith(CallExpression(this.addDefaultImport(modulePath + "/core-js/is-iterable", "isIterable"), [path.node.right]));
          },
          MemberExpression: {
            enter: function enter(path) {
              if (!injectCoreJS) return;
              if (!path.isReferenced()) return;
              var node = path.node;
              var object = node.object;
              if (!isReferenced(object, node)) return;

              if (!injectCoreJS2 && node.computed && path.get("property").matchesPattern("Symbol.iterator")) {
                path.replaceWith(CallExpression(this.addDefaultImport(moduleName + "/core-js/get-iterator-method", "getIteratorMethod"), [object]));
                return;
              }

              var objectName = object.name;
              var propertyName = resolvePropertyName(path.get("property"), node.computed);

              if (path.scope.getBindingIdentifier(objectName) || !hasStaticMapping(objectName, propertyName)) {
                if (injectCoreJS3 && hasMapping(InstanceProperties, propertyName) && maybeNeedsPolyfill(path, InstanceProperties, propertyName)) {
                  path.replaceWith(CallExpression(this.addDefaultImport(moduleName + "/" + corejsRoot + "/instance/" + InstanceProperties[propertyName].path, propertyName + "InstanceProperty"), [object]));
                }

                return;
              }

              path.replaceWith(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + StaticProperties[objectName][propertyName].path, objectName + "$" + propertyName));
            },
            exit: function exit(path) {
              if (!injectCoreJS) return;
              if (!path.isReferenced()) return;
              if (path.node.computed) return;
              var node = path.node;
              var object = node.object;
              var name = object.name;
              if (!hasMapping(BuiltIns, name)) return;
              if (path.scope.getBindingIdentifier(name)) return;
              path.replaceWith(MemberExpression(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + BuiltIns[name].path, name), node.property));
            }
          }
        }
      };
    });

    var transformShorthandProperties = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-shorthand-properties",
        visitor: {
          ObjectMethod: function ObjectMethod(path) {
            var node = path.node;

            if (node.kind === "method") {
              var func = FunctionExpression(null, node.params, node.body, node.generator, node.async);
              func.returnType = node.returnType;
              path.replaceWith(ObjectProperty(node.key, func, node.computed));
            }
          },
          ObjectProperty: function ObjectProperty(_ref) {
            var node = _ref.node;

            if (node.shorthand) {
              node.shorthand = false;
            }
          }
        }
      };
    });

    var transformSpread = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose;

      function getSpreadLiteral(spread, scope) {
        if (loose && !isIdentifier(spread.argument, {
          name: "arguments"
        })) {
          return spread.argument;
        } else {
          return scope.toArray(spread.argument, true);
        }
      }

      function hasSpread(nodes) {
        for (var i = 0; i < nodes.length; i++) {
          if (isSpreadElement(nodes[i])) {
            return true;
          }
        }

        return false;
      }

      function push(_props, nodes) {
        if (!_props.length) return _props;
        nodes.push(ArrayExpression(_props));
        return [];
      }

      function build(props, scope) {
        var nodes = [];
        var _props = [];

        for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
          var prop = _step.value;

          if (isSpreadElement(prop)) {
            _props = push(_props, nodes);
            nodes.push(getSpreadLiteral(prop, scope));
          } else {
            _props.push(prop);
          }
        }

        push(_props, nodes);
        return nodes;
      }

      return {
        name: "transform-spread",
        visitor: {
          ArrayExpression: function ArrayExpression$1(path) {
            var node = path.node,
                scope = path.scope;
            var elements = node.elements;
            if (!hasSpread(elements)) return;
            var nodes = build(elements, scope);
            var first = nodes[0];

            if (nodes.length === 1 && first !== elements[0].argument) {
              path.replaceWith(first);
              return;
            }

            if (!isArrayExpression(first)) {
              first = ArrayExpression([]);
            } else {
              nodes.shift();
            }

            path.replaceWith(CallExpression(MemberExpression(first, Identifier("concat")), nodes));
          },
          CallExpression: function CallExpression$1(path) {
            var node = path.node,
                scope = path.scope;
            var args = node.arguments;
            if (!hasSpread(args)) return;
            var calleePath = path.get("callee");
            if (calleePath.isSuper()) return;
            var contextLiteral = scope.buildUndefinedNode();
            node.arguments = [];
            var nodes;

            if (args.length === 1 && args[0].argument.name === "arguments") {
              nodes = [args[0].argument];
            } else {
              nodes = build(args, scope);
            }

            var first = nodes.shift();

            if (nodes.length) {
              node.arguments.push(CallExpression(MemberExpression(first, Identifier("concat")), nodes));
            } else {
              node.arguments.push(first);
            }

            var callee = node.callee;

            if (calleePath.isMemberExpression()) {
              var temp = scope.maybeGenerateMemoised(callee.object);

              if (temp) {
                callee.object = AssignmentExpression("=", temp, callee.object);
                contextLiteral = temp;
              } else {
                contextLiteral = cloneNode(callee.object);
              }

              appendToMemberExpression(callee, Identifier("apply"));
            } else {
              node.callee = MemberExpression(node.callee, Identifier("apply"));
            }

            if (isSuper(contextLiteral)) {
              contextLiteral = ThisExpression();
            }

            node.arguments.unshift(cloneNode(contextLiteral));
          },
          NewExpression: function NewExpression(path) {
            var node = path.node,
                scope = path.scope;
            var args = node.arguments;
            if (!hasSpread(args)) return;
            var nodes = build(args, scope);
            var first = nodes.shift();

            if (nodes.length) {
              args = CallExpression(MemberExpression(first, Identifier("concat")), nodes);
            } else {
              args = first;
            }

            path.replaceWith(CallExpression(path.hub.addHelper("construct"), [node.callee, args]));
          }
        }
      };
    });

    var transformStickyRegex = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-sticky-regex",
        visitor: {
          RegExpLiteral: function RegExpLiteral(path) {
            var node = path.node;
            if (!is$2(node, "y")) return;
            path.replaceWith(NewExpression(Identifier("RegExp"), [StringLiteral(node.pattern), StringLiteral(node.flags)]));
          }
        }
      };
    });

    var transformStrictMode = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-strict-mode",
        visitor: {
          Program: function Program(path) {
            var node = path.node;

            for (var _i = 0, _arr = node.directives; _i < _arr.length; _i++) {
              var directive = _arr[_i];
              if (directive.value.value === "use strict") return;
            }

            path.unshiftContainer("directives", Directive(DirectiveLiteral("use strict")));
          }
        }
      };
    });

    function _templateObject$c() {
      var data = _taggedTemplateLiteralLoose(["\n          function ", "() {\n            const data = ", ";\n            ", " = function() { return data };\n            return data;\n          } \n        "]);

      _templateObject$c = function _templateObject() {
        return data;
      };

      return data;
    }
    var transformTemplateLiterals = declare(function (api, options) {
      api.assertVersion(7);
      var loose = options.loose;
      var helperName = "taggedTemplateLiteral";
      if (loose) helperName += "Loose";

      function buildConcatCallExpressions(items) {
        var avail = true;
        return items.reduce(function (left, right) {
          var canBeInserted = isLiteral(right);

          if (!canBeInserted && avail) {
            canBeInserted = true;
            avail = false;
          }

          if (canBeInserted && isCallExpression(left)) {
            left.arguments.push(right);
            return left;
          }

          return CallExpression(MemberExpression(left, Identifier("concat")), [right]);
        });
      }

      return {
        name: "transform-template-literals",
        visitor: {
          TaggedTemplateExpression: function TaggedTemplateExpression(path) {
            var node = path.node;
            var quasi = node.quasi;
            var strings = [];
            var raws = [];
            var isStringsRawEqual = true;

            for (var _i = 0, _arr = quasi.quasis; _i < _arr.length; _i++) {
              var elem = _arr[_i];
              var _elem$value = elem.value,
                  raw = _elem$value.raw,
                  cooked = _elem$value.cooked;
              var value = cooked == null ? path.scope.buildUndefinedNode() : StringLiteral(cooked);
              strings.push(value);
              raws.push(StringLiteral(raw));

              if (raw !== cooked) {
                isStringsRawEqual = false;
              }
            }

            var scope = path.scope.getProgramParent();
            var templateObject = scope.generateUidIdentifier("templateObject");
            var helperId = this.addHelper(helperName);
            var callExpressionInput = [ArrayExpression(strings)];

            if (!isStringsRawEqual) {
              callExpressionInput.push(ArrayExpression(raws));
            }

            var lazyLoad = template.ast(_templateObject$c(), templateObject, CallExpression(helperId, callExpressionInput), templateObject);
            scope.path.unshiftContainer("body", lazyLoad);
            path.replaceWith(CallExpression(node.tag, [CallExpression(cloneNode(templateObject), [])].concat(quasi.expressions)));
          },
          TemplateLiteral: function TemplateLiteral(path) {
            var nodes = [];
            var expressions = path.get("expressions");
            var index = 0;

            for (var _i2 = 0, _arr2 = path.node.quasis; _i2 < _arr2.length; _i2++) {
              var elem = _arr2[_i2];

              if (elem.value.cooked) {
                nodes.push(StringLiteral(elem.value.cooked));
              }

              if (index < expressions.length) {
                var expr = expressions[index++];
                var node = expr.node;

                if (!isStringLiteral(node, {
                  value: ""
                })) {
                  nodes.push(node);
                }
              }
            }

            var considerSecondNode = !loose || !isStringLiteral(nodes[1]);

            if (!isStringLiteral(nodes[0]) && considerSecondNode) {
              nodes.unshift(StringLiteral(""));
            }

            var root = nodes[0];

            if (loose) {
              for (var i = 1; i < nodes.length; i++) {
                root = BinaryExpression("+", root, nodes[i]);
              }
            } else if (nodes.length > 1) {
              root = buildConcatCallExpressions(nodes);
            }

            path.replaceWith(root);
          }
        }
      };
    });

    var transformTypeofSymbol = declare(function (api) {
      api.assertVersion(7);
      return {
        name: "transform-typeof-symbol",
        visitor: {
          Scope: function Scope(_ref) {
            var scope = _ref.scope;

            if (!scope.getBinding("Symbol")) {
              return;
            }

            scope.rename("Symbol");
          },
          UnaryExpression: function UnaryExpression$1(path) {
            var node = path.node,
                parent = path.parent;
            if (node.operator !== "typeof") return;

            if (path.parentPath.isBinaryExpression() && EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
              var opposite = path.getOpposite();

              if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
                return;
              }
            }

            var isUnderHelper = path.findParent(function (path) {
              if (path.isFunction()) {
                var _path$get;

                return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
              }
            });
            if (isUnderHelper) return;
            var helper = this.addHelper("typeof");
            isUnderHelper = path.findParent(function (path) {
              return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
            });

            if (isUnderHelper) {
              return;
            }

            var call = CallExpression(helper, [node.argument]);
            var arg = path.get("argument");

            if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
              var unary = UnaryExpression("typeof", cloneNode(node.argument));
              path.replaceWith(ConditionalExpression(BinaryExpression("===", unary, StringLiteral("undefined")), StringLiteral("undefined"), call));
            } else {
              path.replaceWith(call);
            }
          }
        }
      };
    });

    function transpileEnum(path, t) {
      var node = path.node;

      if (node["const"]) {
        throw path.buildCodeFrameError("'const' enums are not supported.");
      }

      if (node.declare) {
        path.remove();
        return;
      }

      var name = node.id.name;
      var fill = enumFill(path, t, node.id);

      switch (path.parent.type) {
        case "BlockStatement":
        case "ExportNamedDeclaration":
        case "Program":
          {
            path.insertAfter(fill);

            if (seen(path.parentPath)) {
              path.remove();
            } else {
              var isGlobal = t.isProgram(path.parent);
              path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? "var" : "let"))[0]);
            }

            break;
          }

        default:
          throw new Error("Unexpected enum parent '" + path.parent.type);
      }

      function seen(parentPath) {
        if (parentPath.isExportDeclaration()) {
          return seen(parentPath.parentPath);
        }

        if (parentPath.getData(name)) {
          return true;
        } else {
          parentPath.setData(name, true);
          return false;
        }
      }
    }

    function makeVar(id, t, kind) {
      return t.variableDeclaration(kind, [t.variableDeclarator(id)]);
    }

    var buildEnumWrapper = template("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");
    var buildStringAssignment = template("\n  ENUM[\"NAME\"] = VALUE;\n");
    var buildNumericAssignment = template("\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n");

    var buildEnumMember = function buildEnumMember(isString, options) {
      return (isString ? buildStringAssignment : buildNumericAssignment)(options);
    };

    function enumFill(path, t, id) {
      var x = translateEnumValues(path, t);
      var assignments = x.map(function (_ref) {
        var memberName = _ref[0],
            memberValue = _ref[1];
        return buildEnumMember(t.isStringLiteral(memberValue), {
          ENUM: t.cloneNode(id),
          NAME: memberName,
          VALUE: memberValue
        });
      });
      return buildEnumWrapper({
        ID: t.cloneNode(id),
        ASSIGNMENTS: assignments
      });
    }

    function translateEnumValues(path, t) {
      var seen = Object.create(null);
      var prev = -1;
      return path.node.members.map(function (member) {
        var name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
        var initializer = member.initializer;
        var value;

        if (initializer) {
          var constValue = evaluate$1(initializer, seen);

          if (constValue !== undefined) {
            seen[name] = constValue;

            if (typeof constValue === "number") {
              value = t.numericLiteral(constValue);
              prev = constValue;
            } else {
              assert$2(typeof constValue === "string");
              value = t.stringLiteral(constValue);
              prev = undefined;
            }
          } else {
            value = initializer;
            prev = undefined;
          }
        } else {
          if (prev !== undefined) {
            prev++;
            value = t.numericLiteral(prev);
            seen[name] = prev;
          } else {
            throw path.buildCodeFrameError("Enum member must have initializer.");
          }
        }

        return [name, value];
      });
    }

    function evaluate$1(expr, seen) {
      return evalConstant(expr);

      function evalConstant(expr) {
        switch (expr.type) {
          case "StringLiteral":
            return expr.value;

          case "UnaryExpression":
            return evalUnaryExpression(expr);

          case "BinaryExpression":
            return evalBinaryExpression(expr);

          case "NumericLiteral":
            return expr.value;

          case "ParenthesizedExpression":
            return evalConstant(expr.expression);

          case "Identifier":
            return seen[expr.name];

          case "TemplateLiteral":
            if (expr.quasis.length === 1) {
              return expr.quasis[0].value.cooked;
            }

          default:
            return undefined;
        }
      }

      function evalUnaryExpression(_ref2) {
        var argument = _ref2.argument,
            operator = _ref2.operator;
        var value = evalConstant(argument);

        if (value === undefined) {
          return undefined;
        }

        switch (operator) {
          case "+":
            return value;

          case "-":
            return -value;

          case "~":
            return ~value;

          default:
            return undefined;
        }
      }

      function evalBinaryExpression(expr) {
        var left = evalConstant(expr.left);

        if (left === undefined) {
          return undefined;
        }

        var right = evalConstant(expr.right);

        if (right === undefined) {
          return undefined;
        }

        switch (expr.operator) {
          case "|":
            return left | right;

          case "&":
            return left & right;

          case ">>":
            return left >> right;

          case ">>>":
            return left >>> right;

          case "<<":
            return left << right;

          case "^":
            return left ^ right;

          case "*":
            return left * right;

          case "/":
            return left / right;

          case "+":
            return left + right;

          case "-":
            return left - right;

          case "%":
            return left % right;

          default:
            return undefined;
        }
      }
    }

    function _templateObject2$5() {
      var data = _taggedTemplateLiteralLoose(["\n    (function (", ") {\n      ", "\n    })(", " || (", " = ", "));\n  "]);

      _templateObject2$5 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$d() {
      var data = _taggedTemplateLiteralLoose(["\n      ", ".", " || (\n        ", ".", " = ", "\n      )\n    "]);

      _templateObject$d = function _templateObject() {
        return data;
      };

      return data;
    }
    function transpileNamespace(path, t, allowNamespaces) {
      if (path.node.declare || path.node.id.type === "StringLiteral") {
        path.remove();
        return;
      }

      if (!allowNamespaces) {
        throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
      }

      var name = path.node.id.name;
      var value = handleNested(path, t, t.cloneDeep(path.node));
      var bound = path.scope.hasOwnBinding(name);

      if (path.parent.type === "ExportNamedDeclaration") {
        if (!bound) {
          path.parentPath.insertAfter(value);
          path.replaceWith(getDeclaration(t, name));
          path.scope.registerDeclaration(path.parentPath);
        } else {
          path.parentPath.replaceWith(value);
        }
      } else if (bound) {
        path.replaceWith(value);
      } else {
        path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
      }
    }

    function getDeclaration(t, name) {
      return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
    }

    function getMemberExpression(t, name, itemName) {
      return t.memberExpression(t.identifier(name), t.identifier(itemName));
    }

    function handleNested(path, t, node, parentExport) {
      var names = new Set();
      var realName = node.id;
      var name = path.scope.generateUid(realName.name);
      var namespaceTopLevel = node.body.body;

      for (var i = 0; i < namespaceTopLevel.length; i++) {
        var subNode = namespaceTopLevel[i];

        switch (subNode.type) {
          case "TSModuleDeclaration":
            {
              var transformed = handleNested(path, t, subNode);
              var moduleName = subNode.id.name;

              if (names.has(moduleName)) {
                namespaceTopLevel[i] = transformed;
              } else {
                names.add(moduleName);
                namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);
              }

              continue;
            }

          case "TSEnumDeclaration":
          case "FunctionDeclaration":
          case "ClassDeclaration":
            names.add(subNode.id.name);
            continue;

          case "VariableDeclaration":
            for (var _iterator = _createForOfIteratorHelperLoose(subNode.declarations), _step; !(_step = _iterator()).done;) {
              var variable = _step.value;
              names.add(variable.id.name);
            }

            continue;

          default:
            continue;

          case "ExportNamedDeclaration":
        }

        switch (subNode.declaration.type) {
          case "TSEnumDeclaration":
          case "FunctionDeclaration":
          case "ClassDeclaration":
            {
              var itemName = subNode.declaration.id.name;
              names.add(itemName);
              namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
              break;
            }

          case "VariableDeclaration":
            if (subNode.declaration.kind !== "const") {
              throw path.hub.file.buildCodeFrameError(subNode.declaration, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
            }

            for (var _iterator2 = _createForOfIteratorHelperLoose(subNode.declaration.declarations), _step2; !(_step2 = _iterator2()).done;) {
              var _variable = _step2.value;
              _variable.init = t.assignmentExpression("=", getMemberExpression(t, name, _variable.id.name), _variable.init);
            }

            namespaceTopLevel[i] = subNode.declaration;
            break;

          case "TSModuleDeclaration":
            {
              var _transformed = handleNested(path, t, subNode.declaration, t.identifier(name));

              var _moduleName = subNode.declaration.id.name;

              if (names.has(_moduleName)) {
                namespaceTopLevel[i] = _transformed;
              } else {
                names.add(_moduleName);
                namespaceTopLevel.splice(i++, 1, getDeclaration(t, _moduleName), _transformed);
              }
            }
        }
      }

      var fallthroughValue = t.objectExpression([]);

      if (parentExport) {
        fallthroughValue = template.expression.ast(_templateObject$d(), parentExport, realName, parentExport, realName, fallthroughValue);
      }

      return template.statement.ast(_templateObject2$5(), t.identifier(name), namespaceTopLevel, realName, realName, fallthroughValue);
    }

    function _templateObject$e() {
      var data = _taggedTemplateLiteralLoose(["this.", " = ", ""]);

      _templateObject$e = function _templateObject() {
        return data;
      };

      return data;
    }

    function isInType(path) {
      switch (path.parent.type) {
        case "TSTypeReference":
        case "TSQualifiedName":
        case "TSExpressionWithTypeArguments":
        case "TSTypeQuery":
          return true;

        default:
          return false;
      }
    }

    var PARSED_PARAMS = new WeakSet();
    var GLOBAL_TYPES = new WeakMap();

    function isGlobalType(path, name) {
      var program = path.find(function (path) {
        return path.isProgram();
      }).node;
      if (path.scope.hasOwnBinding(name)) return false;
      if (GLOBAL_TYPES.get(program).has(name)) return true;
      console.warn("The exported identifier \"" + name + "\" is not declared in Babel's scope tracker\n" + "as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\n" + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + ("\"" + name + "\" without registering it in the scope tracker. If you are the author\n") + " of that plugin, please use \"scope.registerDeclaration(declarationPath)\".");
      return false;
    }

    function registerGlobalType(programScope, name) {
      GLOBAL_TYPES.get(programScope.path.node).add(name);
    }

    var transformTypeScript = declare(function (api, _ref) {
      var _ref$jsxPragma = _ref.jsxPragma,
          jsxPragma = _ref$jsxPragma === void 0 ? "React" : _ref$jsxPragma,
          _ref$allowNamespaces = _ref.allowNamespaces,
          allowNamespaces = _ref$allowNamespaces === void 0 ? false : _ref$allowNamespaces,
          _ref$allowDeclareFiel = _ref.allowDeclareFields,
          allowDeclareFields = _ref$allowDeclareFiel === void 0 ? false : _ref$allowDeclareFiel,
          _ref$onlyRemoveTypeIm = _ref.onlyRemoveTypeImports,
          onlyRemoveTypeImports = _ref$onlyRemoveTypeIm === void 0 ? false : _ref$onlyRemoveTypeIm;
      api.assertVersion(7);
      var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
      var classMemberVisitors = {
        field: function field(path) {
          var node = path.node;

          if (!allowDeclareFields && node.declare) {
            throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
          }

          if (node.definite || node.declare) {
            if (node.value) {
              throw path.buildCodeFrameError("Definietly assigned fields and fields with the 'declare' modifier cannot" + " be initialized here, but only in the constructor");
            }

            if (!node.decorators) {
              path.remove();
            }
          } else if (!allowDeclareFields && !node.value && !node.decorators && !isClassPrivateProperty(node)) {
            path.remove();
          }

          if (node.accessibility) node.accessibility = null;
          if (node["abstract"]) node["abstract"] = null;
          if (node.readonly) node.readonly = null;
          if (node.optional) node.optional = null;
          if (node.typeAnnotation) node.typeAnnotation = null;
          if (node.definite) node.definite = null;
        },
        method: function method(_ref2) {
          var node = _ref2.node;
          if (node.accessibility) node.accessibility = null;
          if (node["abstract"]) node["abstract"] = null;
          if (node.optional) node.optional = null;
        },
        constructor: function constructor(path, classPath) {
          if (path.node.accessibility) path.node.accessibility = null;
          var parameterProperties = [];

          for (var _iterator = _createForOfIteratorHelperLoose(path.node.params), _step; !(_step = _iterator()).done;) {
            var param = _step.value;

            if (param.type === "TSParameterProperty" && !PARSED_PARAMS.has(param.parameter)) {
              PARSED_PARAMS.add(param.parameter);
              parameterProperties.push(param.parameter);
            }
          }

          if (parameterProperties.length) {
            var assigns = parameterProperties.map(function (p) {
              var id;

              if (isIdentifier(p)) {
                id = p;
              } else if (isAssignmentPattern(p) && isIdentifier(p.left)) {
                id = p.left;
              } else {
                throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
              }

              return template.statement.ast(_templateObject$e(), id, id);
            });
            injectInitialization(classPath, path, assigns);
          }
        }
      };
      return {
        name: "transform-typescript",
        inherits: syntaxTypescript,
        visitor: {
          Pattern: visitPattern,
          Identifier: visitPattern,
          RestElement: visitPattern,
          Program: function Program(path, state) {
            var file = state.file;
            var fileJsxPragma = null;

            if (!GLOBAL_TYPES.has(path.node)) {
              GLOBAL_TYPES.set(path.node, new Set());
            }

            if (file.ast.comments) {
              for (var _i = 0, _arr = file.ast.comments; _i < _arr.length; _i++) {
                var comment = _arr[_i];
                var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                if (jsxMatches) {
                  fileJsxPragma = jsxMatches[1];
                }
              }
            }

            for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("body")), _step2; !(_step2 = _iterator2()).done;) {
              var stmt = _step2.value;

              if (isImportDeclaration(stmt)) {
                if (stmt.node.importKind === "type") {
                  stmt.remove();
                  continue;
                }

                if (!onlyRemoveTypeImports) {
                  if (stmt.node.specifiers.length === 0) {
                    continue;
                  }

                  var allElided = true;
                  var importsToRemove = [];

                  for (var _iterator3 = _createForOfIteratorHelperLoose(stmt.node.specifiers), _step3; !(_step3 = _iterator3()).done;) {
                    var specifier = _step3.value;
                    var binding = stmt.scope.getBinding(specifier.local.name);

                    if (binding && isImportTypeOnly({
                      binding: binding,
                      programPath: path,
                      jsxPragma: fileJsxPragma || jsxPragma
                    })) {
                      importsToRemove.push(binding.path);
                    } else {
                      allElided = false;
                    }
                  }

                  if (allElided) {
                    stmt.remove();
                  } else {
                    for (var _iterator4 = _createForOfIteratorHelperLoose(importsToRemove), _step4; !(_step4 = _iterator4()).done;) {
                      var importPath = _step4.value;
                      importPath.remove();
                    }
                  }
                }

                continue;
              }

              if (stmt.isExportDeclaration()) {
                stmt = stmt.get("declaration");
              }

              if (stmt.isVariableDeclaration({
                declare: true
              })) {
                for (var _i2 = 0, _Object$keys = Object.keys(stmt.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
                  var name = _Object$keys[_i2];
                  registerGlobalType(path.scope, name);
                }
              } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
                declare: true
              }) || stmt.isTSEnumDeclaration({
                declare: true
              }) || stmt.isTSModuleDeclaration({
                declare: true
              }) && stmt.get("id").isIdentifier()) {
                registerGlobalType(path.scope, stmt.node.id.name);
              }
            }
          },
          ExportNamedDeclaration: function ExportNamedDeclaration(path) {
            if (path.node.exportKind === "type") {
              path.remove();
              return;
            }

            if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (_ref3) {
              var local = _ref3.local;
              return isGlobalType(path, local.name);
            })) {
              path.remove();
            }
          },
          ExportSpecifier: function ExportSpecifier(path) {
            if (!path.parent.source && isGlobalType(path, path.node.local.name)) {
              path.remove();
            }
          },
          ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
            if (isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {
              path.remove();
            }
          },
          TSDeclareFunction: function TSDeclareFunction(path) {
            path.remove();
          },
          TSDeclareMethod: function TSDeclareMethod(path) {
            path.remove();
          },
          VariableDeclaration: function VariableDeclaration(path) {
            if (path.node.declare) {
              path.remove();
            }
          },
          VariableDeclarator: function VariableDeclarator(_ref4) {
            var node = _ref4.node;
            if (node.definite) node.definite = null;
          },
          TSIndexSignature: function TSIndexSignature(path) {
            path.remove();
          },
          ClassDeclaration: function ClassDeclaration(path) {
            var node = path.node;

            if (node.declare) {
              path.remove();
              return;
            }
          },
          Class: function Class(path) {
            var node = path.node;
            if (node.typeParameters) node.typeParameters = null;
            if (node.superTypeParameters) node.superTypeParameters = null;
            if (node["implements"]) node["implements"] = null;
            if (node["abstract"]) node["abstract"] = null;
            path.get("body.body").forEach(function (child) {
              if (child.isClassMethod() || child.isClassPrivateMethod()) {
                if (child.node.kind === "constructor") {
                  classMemberVisitors.constructor(child, path);
                } else {
                  classMemberVisitors.method(child, path);
                }
              } else if (child.isClassProperty() || child.isClassPrivateProperty()) {
                classMemberVisitors.field(child, path);
              }
            });
          },
          Function: function Function(_ref5) {
            var node = _ref5.node;
            if (node.typeParameters) node.typeParameters = null;
            if (node.returnType) node.returnType = null;
            var p0 = node.params[0];

            if (p0 && isIdentifier(p0) && p0.name === "this") {
              node.params.shift();
            }

            node.params = node.params.map(function (p) {
              return p.type === "TSParameterProperty" ? p.parameter : p;
            });
          },
          TSModuleDeclaration: function TSModuleDeclaration(path) {
            transpileNamespace(path, t, allowNamespaces);
          },
          TSInterfaceDeclaration: function TSInterfaceDeclaration(path) {
            path.remove();
          },
          TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
            path.remove();
          },
          TSEnumDeclaration: function TSEnumDeclaration(path) {
            transpileEnum(path, t);
          },
          TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
            throw path.buildCodeFrameError("`import =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using " + "`import <moduleName> from '<moduleName>';` alongside " + "Typescript's --allowSyntheticDefaultImports option.");
          },
          TSExportAssignment: function TSExportAssignment(path) {
            throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using `export <value>;`.");
          },
          TSTypeAssertion: function TSTypeAssertion(path) {
            path.replaceWith(path.node.expression);
          },
          TSAsExpression: function TSAsExpression(path) {
            var node = path.node;

            do {
              node = node.expression;
            } while (isTSAsExpression(node));

            path.replaceWith(node);
          },
          TSNonNullExpression: function TSNonNullExpression(path) {
            path.replaceWith(path.node.expression);
          },
          CallExpression: function CallExpression(path) {
            path.node.typeParameters = null;
          },
          NewExpression: function NewExpression(path) {
            path.node.typeParameters = null;
          },
          JSXOpeningElement: function JSXOpeningElement(path) {
            path.node.typeParameters = null;
          },
          TaggedTemplateExpression: function TaggedTemplateExpression(path) {
            path.node.typeParameters = null;
          }
        }
      };

      function visitPattern(_ref6) {
        var node = _ref6.node;
        if (node.typeAnnotation) node.typeAnnotation = null;
        if (isIdentifier(node) && node.optional) node.optional = null;
      }

      function isImportTypeOnly(_ref7) {
        var binding = _ref7.binding,
            programPath = _ref7.programPath,
            jsxPragma = _ref7.jsxPragma;

        for (var _iterator5 = _createForOfIteratorHelperLoose(binding.referencePaths), _step5; !(_step5 = _iterator5()).done;) {
          var path = _step5.value;

          if (!isInType(path)) {
            return false;
          }
        }

        if (binding.identifier.name !== jsxPragma) {
          return true;
        }

        var sourceFileHasJsx = false;
        programPath.traverse({
          JSXElement: function JSXElement() {
            sourceFileHasJsx = true;
          },
          JSXFragment: function JSXFragment() {
            sourceFileHasJsx = true;
          }
        });
        return !sourceFileHasJsx;
      }
    });

    var transformUnicodeRegex = declare(function (api) {
      api.assertVersion(7);
      return createRegExpFeaturePlugin({
        name: "transform-unicode-regex",
        feature: "unicodeFlag"
      });
    });

    var all = {
      "external-helpers": externalHelpers,
      "syntax-async-generators": syntaxAsyncGenerators,
      "syntax-class-properties": syntaxClassProperties,
      "syntax-decorators": syntaxDecorators,
      "syntax-do-expressions": syntaxDoExpressions,
      "syntax-eventual-send": syntaxEventualSend,
      "syntax-export-default-from": syntaxExportDefaultFrom,
      "syntax-flow": syntaxFlow,
      "syntax-function-bind": syntaxFunctionBind,
      "syntax-function-sent": syntaxFunctionSent,
      "syntax-import-meta": syntaxImportMeta,
      "syntax-jsx": syntaxJsx,
      "syntax-object-rest-spread": syntaxObjectRestSpread,
      "syntax-optional-catch-binding": syntaxOptionalCatchBinding,
      "syntax-pipeline-operator": syntaxPipelineOperator,
      "syntax-record-and-tuple": syntaxRecordAndTuple,
      "syntax-top-level-await": syntaxTopLevelAwait,
      "syntax-typescript": syntaxTypescript,
      "proposal-async-generator-functions": proposalAsyncGeneratorFunctions,
      "proposal-class-properties": proposalClassProperties,
      "proposal-decorators": proposalDecorators,
      "proposal-do-expressions": proposalDoExpressions,
      "proposal-dynamic-import": proposalDynamicImport,
      "proposal-eventual-send": proposalEventualSend,
      "proposal-export-default-from": proposalExportDefaultFrom,
      "proposal-export-namespace-from": proposalExportNamespaceFrom,
      "proposal-function-bind": proposalFunctionBind,
      "proposal-function-sent": proposalFunctionSent,
      "proposal-json-strings": proposalJsonStrings,
      "proposal-logical-assignment-operators": proposalLogicalAssignmentOperators,
      "proposal-nullish-coalescing-operator": proposalNullishCoalescingOperator,
      "proposal-numeric-separator": proposalNumericSeparator,
      "proposal-object-rest-spread": proposalObjectRestSpread,
      "proposal-optional-catch-binding": proposalOptionalCatchBinding,
      "proposal-optional-chaining": proposalOptionalChaining,
      "proposal-pipeline-operator": proposalPipelineOperator,
      "proposal-private-methods": proposalPrivateMethods,
      "proposal-throw-expressions": proposalThrowExpressions,
      "proposal-unicode-property-regex": proposalUnicodePropertyRegex,
      "transform-async-to-generator": transformAsyncToGenerator,
      "transform-arrow-functions": transformArrowFunctions,
      "transform-block-scoped-functions": transformBlockScopedFunctions,
      "transform-block-scoping": transformBlockScoping,
      "transform-classes": transformClasses,
      "transform-computed-properties": transformComputedProperties,
      "transform-destructuring": transformDestructuring,
      "transform-dotall-regex": transformDotallRegex,
      "transform-duplicate-keys": transformDuplicateKeys,
      "transform-exponentiation-operator": transformExponentialOperator,
      "transform-flow-comments": transformFlowComments,
      "transform-flow-strip-types": transformFlowStripTypes,
      "transform-for-of": transformForOf,
      "transform-function-name": transformFunctionName,
      "transform-instanceof": transformInstanceof,
      "transform-jscript": transformJscript,
      "transform-literals": transformLiterals,
      "transform-member-expression-literals": transformMemberExpressionLiterals,
      "transform-modules-amd": transformModulesAmd,
      "transform-modules-commonjs": transformModulesCommonjs,
      "transform-modules-systemjs": transformModulesSystemjs,
      "transform-modules-umd": transformModulesUmd,
      "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
      "transform-new-target": transformNewTarget,
      "transform-object-assign": transformObjectAssign,
      "transform-object-super": transformObjectSuper,
      "transform-object-set-prototype-of-to-assign": transformObjectSetPrototypeOfToAssign,
      "transform-parameters": transformParameters,
      "transform-property-literals": transformPropertyLiterals,
      "transform-property-mutators": transformPropertyMutators,
      "transform-proto-to-assign": transformProtoToAssign,
      "transform-react-constant-elements": transformReactConstantElements,
      "transform-react-display-name": transformReactDisplayName,
      "transform-react-inline-elements": transformReactInlineElements,
      "transform-react-jsx": transformReactJSX,
      "transform-react-jsx-compat": transformReactJsxCompat,
      "transform-react-jsx-development": transformReactJSXDevelopment,
      "transform-react-jsx-self": transformReactJSXSelf,
      "transform-react-jsx-source": transformReactJSXSource,
      "transform-reserved-words": transformReservedWords,
      "transform-runtime": transformRuntime,
      "transform-shorthand-properties": transformShorthandProperties,
      "transform-spread": transformSpread,
      "transform-sticky-regex": transformStickyRegex,
      "transform-strict-mode": transformStrictMode,
      "transform-template-literals": transformTemplateLiterals,
      "transform-typeof-symbol": transformTypeofSymbol,
      "transform-typescript": transformTypeScript,
      "transform-unicode-regex": transformUnicodeRegex
    };

    var preset2015 = (function (_, opts) {
      var loose = false;
      var modules = "commonjs";
      var spec = false;

      if (opts !== undefined) {
        if (opts.loose !== undefined) loose = opts.loose;
        if (opts.modules !== undefined) modules = opts.modules;
        if (opts.spec !== undefined) spec = opts.spec;
      }

      var optsLoose = {
        loose: loose
      };
      return {
        plugins: [[transformTemplateLiterals, {
          loose: loose,
          spec: spec
        }], transformLiterals, transformFunctionName, [transformArrowFunctions, {
          spec: spec
        }], transformBlockScopedFunctions, [transformClasses, optsLoose], transformObjectSuper, transformShorthandProperties, transformDuplicateKeys, [transformComputedProperties, optsLoose], [transformForOf, optsLoose], transformStickyRegex, transformUnicodeRegex, [transformSpread, optsLoose], [transformParameters, optsLoose], [transformDestructuring, optsLoose], transformBlockScoping, transformTypeofSymbol, transformInstanceof, (modules === "commonjs" || modules === "cjs") && [transformModulesCommonjs, optsLoose], modules === "systemjs" && [transformModulesSystemjs, optsLoose], modules === "amd" && [transformModulesAmd, optsLoose], modules === "umd" && [transformModulesUmd, optsLoose]].filter(Boolean)
      };
    });

    var presetStage3 = (function (_, opts) {
      var loose = false;

      if (opts !== undefined) {
        if (opts.loose !== undefined) loose = opts.loose;
      }

      return {
        plugins: [syntaxImportMeta, syntaxTopLevelAwait, proposalExportNamespaceFrom, proposalLogicalAssignmentOperators, [proposalOptionalChaining, {
          loose: loose
        }], [proposalNullishCoalescingOperator, {
          loose: loose
        }], [proposalClassProperties, {
          loose: loose
        }], proposalJsonStrings, proposalNumericSeparator, [proposalPrivateMethods, {
          loose: loose
        }]]
      };
    });

    var presetStage2 = (function (_, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts = opts,
          _opts$loose = _opts.loose,
          loose = _opts$loose === void 0 ? false : _opts$loose,
          _opts$useBuiltIns = _opts.useBuiltIns,
          useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
          _opts$decoratorsLegac = _opts.decoratorsLegacy,
          decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
          decoratorsBeforeExport = _opts.decoratorsBeforeExport;
      return {
        presets: [[presetStage3, {
          loose: loose,
          useBuiltIns: useBuiltIns
        }]],
        plugins: [[proposalDecorators, {
          legacy: decoratorsLegacy,
          decoratorsBeforeExport: decoratorsBeforeExport
        }], proposalFunctionSent, proposalThrowExpressions]
      };
    });

    var presetStage1 = (function (_, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts = opts,
          _opts$loose = _opts.loose,
          loose = _opts$loose === void 0 ? false : _opts$loose,
          _opts$useBuiltIns = _opts.useBuiltIns,
          useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
          _opts$decoratorsLegac = _opts.decoratorsLegacy,
          decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
          decoratorsBeforeExport = _opts.decoratorsBeforeExport,
          _opts$pipelineProposa = _opts.pipelineProposal,
          pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa,
          _opts$eventualSendTar = _opts.eventualSendTargetGlobal,
          eventualSendTargetGlobal = _opts$eventualSendTar === void 0 ? "HandledPromise" : _opts$eventualSendTar,
          _opts$recordAndTupleS = _opts.recordAndTupleSyntax,
          recordAndTupleSyntax = _opts$recordAndTupleS === void 0 ? "hash" : _opts$recordAndTupleS;
      return {
        presets: [[presetStage2, {
          loose: loose,
          useBuiltIns: useBuiltIns,
          decoratorsLegacy: decoratorsLegacy,
          decoratorsBeforeExport: decoratorsBeforeExport
        }]],
        plugins: [[syntaxRecordAndTuple, {
          syntaxType: recordAndTupleSyntax
        }], proposalExportDefaultFrom, [proposalPipelineOperator, {
          proposal: pipelineProposal
        }], [proposalEventualSend, {
          targetGlobal: eventualSendTargetGlobal
        }], proposalDoExpressions]
      };
    });

    var presetStage0 = (function (_, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts = opts,
          _opts$loose = _opts.loose,
          loose = _opts$loose === void 0 ? false : _opts$loose,
          _opts$useBuiltIns = _opts.useBuiltIns,
          useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
          _opts$decoratorsLegac = _opts.decoratorsLegacy,
          decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
          decoratorsBeforeExport = _opts.decoratorsBeforeExport,
          _opts$pipelineProposa = _opts.pipelineProposal,
          pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa;
      return {
        presets: [[presetStage1, {
          loose: loose,
          useBuiltIns: useBuiltIns,
          decoratorsLegacy: decoratorsLegacy,
          decoratorsBeforeExport: decoratorsBeforeExport,
          pipelineProposal: pipelineProposal
        }]],
        plugins: [proposalFunctionBind]
      };
    });

    var envs = [
    	{
    		name: "nodejs",
    		version: "0.2.0",
    		date: "2011-08-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.3.0",
    		date: "2011-08-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.4.0",
    		date: "2011-08-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.5.0",
    		date: "2011-08-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.6.0",
    		date: "2011-11-04",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.7.0",
    		date: "2012-01-17",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.8.0",
    		date: "2012-06-22",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.9.0",
    		date: "2012-07-20",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.10.0",
    		date: "2013-03-11",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.11.0",
    		date: "2013-03-28",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "0.12.0",
    		date: "2015-02-06",
    		lts: false,
    		security: false
    	},
    	{
    		name: "iojs",
    		version: "1.0.0",
    		date: "2015-01-14"
    	},
    	{
    		name: "iojs",
    		version: "1.1.0",
    		date: "2015-02-03"
    	},
    	{
    		name: "iojs",
    		version: "1.2.0",
    		date: "2015-02-11"
    	},
    	{
    		name: "iojs",
    		version: "1.3.0",
    		date: "2015-02-20"
    	},
    	{
    		name: "iojs",
    		version: "1.5.0",
    		date: "2015-03-06"
    	},
    	{
    		name: "iojs",
    		version: "1.6.0",
    		date: "2015-03-20"
    	},
    	{
    		name: "iojs",
    		version: "2.0.0",
    		date: "2015-05-04"
    	},
    	{
    		name: "iojs",
    		version: "2.1.0",
    		date: "2015-05-24"
    	},
    	{
    		name: "iojs",
    		version: "2.2.0",
    		date: "2015-06-01"
    	},
    	{
    		name: "iojs",
    		version: "2.3.0",
    		date: "2015-06-13"
    	},
    	{
    		name: "iojs",
    		version: "2.4.0",
    		date: "2015-07-17"
    	},
    	{
    		name: "iojs",
    		version: "2.5.0",
    		date: "2015-07-28"
    	},
    	{
    		name: "iojs",
    		version: "3.0.0",
    		date: "2015-08-04"
    	},
    	{
    		name: "iojs",
    		version: "3.1.0",
    		date: "2015-08-19"
    	},
    	{
    		name: "iojs",
    		version: "3.2.0",
    		date: "2015-08-25"
    	},
    	{
    		name: "iojs",
    		version: "3.3.0",
    		date: "2015-09-02"
    	},
    	{
    		name: "nodejs",
    		version: "4.0.0",
    		date: "2015-09-08",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.1.0",
    		date: "2015-09-17",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.2.0",
    		date: "2015-10-12",
    		lts: "Argon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.3.0",
    		date: "2016-02-09",
    		lts: "Argon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.4.0",
    		date: "2016-03-08",
    		lts: "Argon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.5.0",
    		date: "2016-08-16",
    		lts: "Argon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.6.0",
    		date: "2016-09-27",
    		lts: "Argon",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "4.7.0",
    		date: "2016-12-06",
    		lts: "Argon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.8.0",
    		date: "2017-02-21",
    		lts: "Argon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "4.9.0",
    		date: "2018-03-28",
    		lts: "Argon",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "5.0.0",
    		date: "2015-10-29",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.1.0",
    		date: "2015-11-17",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.2.0",
    		date: "2015-12-09",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.3.0",
    		date: "2015-12-15",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.4.0",
    		date: "2016-01-06",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.5.0",
    		date: "2016-01-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.6.0",
    		date: "2016-02-09",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.7.0",
    		date: "2016-02-23",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.8.0",
    		date: "2016-03-09",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.9.0",
    		date: "2016-03-16",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.10.0",
    		date: "2016-04-01",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.11.0",
    		date: "2016-04-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "5.12.0",
    		date: "2016-06-23",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.0.0",
    		date: "2016-04-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.1.0",
    		date: "2016-05-05",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.2.0",
    		date: "2016-05-17",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.3.0",
    		date: "2016-07-06",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.4.0",
    		date: "2016-08-12",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.5.0",
    		date: "2016-08-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.6.0",
    		date: "2016-09-14",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.7.0",
    		date: "2016-09-27",
    		lts: false,
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "6.8.0",
    		date: "2016-10-12",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.9.0",
    		date: "2016-10-18",
    		lts: "Boron",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.10.0",
    		date: "2017-02-21",
    		lts: "Boron",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.11.0",
    		date: "2017-06-06",
    		lts: "Boron",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.12.0",
    		date: "2017-11-06",
    		lts: "Boron",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.13.0",
    		date: "2018-02-10",
    		lts: "Boron",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.14.0",
    		date: "2018-03-28",
    		lts: "Boron",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "6.15.0",
    		date: "2018-11-27",
    		lts: "Boron",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "6.16.0",
    		date: "2018-12-26",
    		lts: "Boron",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "6.17.0",
    		date: "2019-02-28",
    		lts: "Boron",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "7.0.0",
    		date: "2016-10-25",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.1.0",
    		date: "2016-11-08",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.2.0",
    		date: "2016-11-22",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.3.0",
    		date: "2016-12-20",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.4.0",
    		date: "2017-01-04",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.5.0",
    		date: "2017-01-31",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.6.0",
    		date: "2017-02-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.7.0",
    		date: "2017-02-28",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.8.0",
    		date: "2017-03-29",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.9.0",
    		date: "2017-04-11",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "7.10.0",
    		date: "2017-05-02",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.0.0",
    		date: "2017-05-30",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.1.0",
    		date: "2017-06-08",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.2.0",
    		date: "2017-07-19",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.3.0",
    		date: "2017-08-08",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.4.0",
    		date: "2017-08-15",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.5.0",
    		date: "2017-09-12",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.6.0",
    		date: "2017-09-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.7.0",
    		date: "2017-10-11",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.8.0",
    		date: "2017-10-24",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.9.0",
    		date: "2017-10-31",
    		lts: "Carbon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.10.0",
    		date: "2018-03-06",
    		lts: "Carbon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.11.0",
    		date: "2018-03-28",
    		lts: "Carbon",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "8.12.0",
    		date: "2018-09-10",
    		lts: "Carbon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.13.0",
    		date: "2018-11-20",
    		lts: "Carbon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.14.0",
    		date: "2018-11-27",
    		lts: "Carbon",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "8.15.0",
    		date: "2018-12-26",
    		lts: "Carbon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.16.0",
    		date: "2019-04-16",
    		lts: "Carbon",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "8.17.0",
    		date: "2019-12-17",
    		lts: "Carbon",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "9.0.0",
    		date: "2017-10-31",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.1.0",
    		date: "2017-11-07",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.2.0",
    		date: "2017-11-14",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.3.0",
    		date: "2017-12-12",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.4.0",
    		date: "2018-01-10",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.5.0",
    		date: "2018-01-31",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.6.0",
    		date: "2018-02-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.7.0",
    		date: "2018-03-01",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.8.0",
    		date: "2018-03-07",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.9.0",
    		date: "2018-03-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "9.10.0",
    		date: "2018-03-28",
    		lts: false,
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "9.11.0",
    		date: "2018-04-04",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.0.0",
    		date: "2018-04-24",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.1.0",
    		date: "2018-05-08",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.2.0",
    		date: "2018-05-23",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.3.0",
    		date: "2018-05-29",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.4.0",
    		date: "2018-06-06",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.5.0",
    		date: "2018-06-20",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.6.0",
    		date: "2018-07-04",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.7.0",
    		date: "2018-07-18",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.8.0",
    		date: "2018-08-01",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.9.0",
    		date: "2018-08-15",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.10.0",
    		date: "2018-09-06",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.11.0",
    		date: "2018-09-19",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.12.0",
    		date: "2018-10-10",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.13.0",
    		date: "2018-10-30",
    		lts: "Dubnium",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.14.0",
    		date: "2018-11-27",
    		lts: "Dubnium",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "10.15.0",
    		date: "2018-12-26",
    		lts: "Dubnium",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.16.0",
    		date: "2019-05-28",
    		lts: "Dubnium",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.17.0",
    		date: "2019-10-21",
    		lts: "Dubnium",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "10.18.0",
    		date: "2019-12-16",
    		lts: "Dubnium",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "10.19.0",
    		date: "2020-02-05",
    		lts: "Dubnium",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "11.0.0",
    		date: "2018-10-23",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.1.0",
    		date: "2018-10-30",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.2.0",
    		date: "2018-11-15",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.3.0",
    		date: "2018-11-27",
    		lts: false,
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "11.4.0",
    		date: "2018-12-07",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.5.0",
    		date: "2018-12-18",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.6.0",
    		date: "2018-12-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.7.0",
    		date: "2019-01-17",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.8.0",
    		date: "2019-01-24",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.9.0",
    		date: "2019-01-30",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.10.0",
    		date: "2019-02-14",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.11.0",
    		date: "2019-03-05",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.12.0",
    		date: "2019-03-14",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.13.0",
    		date: "2019-03-28",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.14.0",
    		date: "2019-04-10",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "11.15.0",
    		date: "2019-04-30",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.0.0",
    		date: "2019-04-23",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.1.0",
    		date: "2019-04-29",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.2.0",
    		date: "2019-05-07",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.3.0",
    		date: "2019-05-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.4.0",
    		date: "2019-06-04",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.5.0",
    		date: "2019-06-26",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.6.0",
    		date: "2019-07-03",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.7.0",
    		date: "2019-07-23",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.8.0",
    		date: "2019-08-06",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.9.0",
    		date: "2019-08-20",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.10.0",
    		date: "2019-09-04",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.11.0",
    		date: "2019-09-25",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.12.0",
    		date: "2019-10-11",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.13.0",
    		date: "2019-10-21",
    		lts: "Erbium",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "12.14.0",
    		date: "2019-12-16",
    		lts: "Erbium",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "12.15.0",
    		date: "2020-02-05",
    		lts: "Erbium",
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "12.16.0",
    		date: "2020-02-11",
    		lts: "Erbium",
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.0.0",
    		date: "2019-10-10",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.1.0",
    		date: "2019-11-05",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.2.0",
    		date: "2019-11-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.3.0",
    		date: "2019-12-03",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.4.0",
    		date: "2019-12-17",
    		lts: false,
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "13.5.0",
    		date: "2019-12-18",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.6.0",
    		date: "2020-01-07",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.7.0",
    		date: "2020-01-21",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.8.0",
    		date: "2020-02-05",
    		lts: false,
    		security: true
    	},
    	{
    		name: "nodejs",
    		version: "13.9.0",
    		date: "2020-02-18",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.10.0",
    		date: "2020-03-03",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.11.0",
    		date: "2020-03-12",
    		lts: false,
    		security: false
    	},
    	{
    		name: "nodejs",
    		version: "13.12.0",
    		date: "2020-03-26",
    		lts: false,
    		security: false
    	}
    ];

    var envs$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': envs
    });

    var browsers = {
      A: "ie",
      B: "edge",
      C: "firefox",
      D: "chrome",
      E: "safari",
      F: "opera",
      G: "ios_saf",
      H: "op_mini",
      I: "android",
      J: "bb",
      K: "op_mob",
      L: "and_chr",
      M: "and_ff",
      N: "ie_mob",
      O: "and_uc",
      P: "samsung",
      Q: "and_qq",
      R: "baidu",
      S: "kaios"
    };

    var browsers_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var browsers$1 = exports.browsers = browsers;
    });

    unwrapExports(browsers_1);
    var browsers_2 = browsers_1.browsers;

    var browserVersions = {
      "0": "50",
      "1": "51",
      "2": "52",
      "3": "53",
      "4": "54",
      "5": "55",
      "6": "56",
      "7": "57",
      "8": "58",
      "9": "65",
      A: "10",
      B: "11",
      C: "12",
      D: "9",
      E: "8",
      F: "7",
      G: "4",
      H: "16",
      I: "6",
      J: "17",
      K: "18",
      L: "11.1",
      M: "68",
      N: "81",
      O: "13",
      P: "15",
      Q: "46",
      R: "67",
      S: "12.1",
      T: "14",
      U: "5",
      V: "19",
      W: "20",
      X: "21",
      Y: "22",
      Z: "23",
      a: "24",
      b: "25",
      c: "26",
      d: "27",
      e: "28",
      f: "29",
      g: "30",
      h: "31",
      i: "32",
      j: "33",
      k: "34",
      l: "35",
      m: "36",
      n: "37",
      o: "38",
      p: "39",
      q: "40",
      r: "41",
      s: "42",
      t: "43",
      u: "44",
      v: "45",
      w: "66",
      x: "47",
      y: "48",
      z: "49",
      AB: "60",
      BB: "64",
      CB: "62",
      DB: "63",
      EB: "11.5",
      FB: "61",
      GB: "3",
      HB: "4.2-4.3",
      IB: "80",
      JB: "69",
      KB: "70",
      LB: "71",
      MB: "72",
      NB: "73",
      OB: "74",
      PB: "75",
      QB: "76",
      RB: "77",
      SB: "59",
      TB: "79",
      UB: "10.1",
      VB: "3.2",
      WB: "9.3",
      XB: "84",
      YB: "3.1",
      ZB: "83",
      aB: "5.1",
      bB: "6.1",
      cB: "7.1",
      dB: "9.1",
      eB: "78",
      fB: "3.6",
      gB: "5.5",
      hB: "13.1",
      iB: "TP",
      jB: "9.5-9.6",
      kB: "10.0-10.1",
      lB: "10.5",
      mB: "10.6",
      nB: "3.5",
      oB: "11.6",
      pB: "4.0-4.1",
      qB: "2",
      rB: "5.0-5.1",
      sB: "6.0-6.1",
      tB: "7.0-7.1",
      uB: "8.1-8.4",
      vB: "9.0-9.2",
      wB: "85",
      xB: "10.0-10.2",
      yB: "10.3",
      zB: "11.0-11.2",
      "0B": "11.3-11.4",
      "1B": "12.0-12.1",
      "2B": "12.2-12.4",
      "3B": "13.0-13.1",
      "4B": "13.2",
      "5B": "13.3",
      "6B": "13.4",
      "7B": "all",
      "8B": "2.1",
      "9B": "2.2",
      AC: "2.3",
      BC: "4.1",
      CC: "4.4",
      DC: "4.4.3-4.4.4",
      EC: "12.12",
      FC: "5.0-5.4",
      GC: "6.2-6.4",
      HC: "7.2-7.4",
      IC: "8.2",
      JC: "9.2",
      KC: "1.2",
      LC: "7.12",
      MC: "2.5"
    };

    var browserVersions_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var browserVersions$1 = exports.browserVersions = browserVersions;
    });

    unwrapExports(browserVersions_1);
    var browserVersions_2 = browserVersions_1.browserVersions;

    var agents = {
      A: {
        A: {
          I: 0.0108864,
          F: 0.0108864,
          E: 0.190512,
          D: 0.326591,
          A: 0.0653182,
          B: 1.44244,
          gB: 0.009298
        },
        B: "ms",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gB", "I", "F", "E", "D", "A", "B", "", "", ""],
        E: "IE",
        F: {
          gB: 962323200,
          I: 998870400,
          F: 1161129600,
          E: 1237420800,
          D: 1300060800,
          A: 1346716800,
          B: 1381968000
        }
      },
      B: {
        A: {
          C: 0.009076,
          O: 0.009076,
          T: 0.013614,
          P: 0.013614,
          H: 0.031766,
          J: 0.104374,
          K: 1.94226,
          TB: 0,
          IB: 0,
          N: 0
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "O", "T", "P", "H", "J", "K", "TB", "IB", "N", "", "", ""],
        E: "Edge",
        F: {
          C: 1438128000,
          O: 1447286400,
          T: 1470096000,
          P: 1491868800,
          H: 1508198400,
          J: 1525046400,
          K: 1542067200,
          TB: 1579046400,
          IB: 1581033600,
          N: 1586736000
        },
        D: {
          C: "ms",
          O: "ms",
          T: "ms",
          P: "ms",
          H: "ms",
          J: "ms",
          K: "ms"
        }
      },
      C: {
        A: {
          "0": 0.009076,
          "1": 0.009076,
          "2": 0.122526,
          "3": 0.009076,
          "4": 0.009076,
          "5": 0.009076,
          "6": 0.02269,
          "7": 0.009076,
          "8": 0.004538,
          "9": 0.040842,
          qB: 0.004827,
          GB: 0.004538,
          G: 0.00974,
          U: 0.004879,
          I: 0.020136,
          F: 0.005725,
          E: 0.004525,
          D: 0.00533,
          A: 0.004283,
          B: 0.009042,
          C: 0.004471,
          O: 0.004486,
          T: 0.00453,
          P: 0.004465,
          H: 0.004417,
          J: 0.008922,
          K: 0.004393,
          V: 0.004443,
          W: 0.004283,
          X: 0.013596,
          Y: 0.013698,
          Z: 0.013614,
          a: 0.008786,
          b: 0.004403,
          c: 0.004317,
          d: 0.004393,
          e: 0.004418,
          f: 0.008834,
          g: 0.004403,
          h: 0.008928,
          i: 0.004471,
          j: 0.009076,
          k: 0.004707,
          l: 0.009076,
          m: 0.004465,
          n: 0.004783,
          o: 0.018152,
          p: 0.004783,
          q: 0.00487,
          r: 0.005029,
          s: 0.0047,
          t: 0.009076,
          u: 0.009076,
          v: 0.009076,
          Q: 0.004525,
          x: 0.013614,
          y: 0.02269,
          z: 0.004538,
          SB: 0.009076,
          AB: 0.02269,
          FB: 0.009076,
          CB: 0.004538,
          DB: 0.013614,
          BB: 0.013614,
          w: 0.036304,
          R: 0.013614,
          M: 0.11345,
          JB: 0.02269,
          KB: 0.027228,
          LB: 0.027228,
          MB: 0.122526,
          NB: 1.33871,
          OB: 1.94226,
          PB: 0.040842,
          QB: 0,
          RB: 0,
          nB: 0.008786,
          fB: 0.00487
        },
        B: "moz",
        C: ["", "", "qB", "GB", "nB", "fB", "G", "U", "I", "F", "E", "D", "A", "B", "C", "O", "T", "P", "H", "J", "K", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "Q", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "SB", "AB", "FB", "CB", "DB", "BB", "9", "w", "R", "M", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", ""],
        E: "Firefox",
        F: {
          "0": 1479168000,
          "1": 1485216000,
          "2": 1488844800,
          "3": 1492560000,
          "4": 1497312000,
          "5": 1502150400,
          "6": 1506556800,
          "7": 1510617600,
          "8": 1516665600,
          "9": 1548720000,
          qB: 1161648000,
          GB: 1213660800,
          nB: 1246320000,
          fB: 1264032000,
          G: 1300752000,
          U: 1308614400,
          I: 1313452800,
          F: 1317081600,
          E: 1317081600,
          D: 1320710400,
          A: 1324339200,
          B: 1327968000,
          C: 1331596800,
          O: 1335225600,
          T: 1338854400,
          P: 1342483200,
          H: 1346112000,
          J: 1349740800,
          K: 1353628800,
          V: 1357603200,
          W: 1361232000,
          X: 1364860800,
          Y: 1368489600,
          Z: 1372118400,
          a: 1375747200,
          b: 1379376000,
          c: 1386633600,
          d: 1391472000,
          e: 1395100800,
          f: 1398729600,
          g: 1402358400,
          h: 1405987200,
          i: 1409616000,
          j: 1413244800,
          k: 1417392000,
          l: 1421107200,
          m: 1424736000,
          n: 1428278400,
          o: 1431475200,
          p: 1435881600,
          q: 1439251200,
          r: 1442880000,
          s: 1446508800,
          t: 1450137600,
          u: 1453852800,
          v: 1457395200,
          Q: 1461628800,
          x: 1465257600,
          y: 1470096000,
          z: 1474329600,
          SB: 1520985600,
          AB: 1525824000,
          FB: 1529971200,
          CB: 1536105600,
          DB: 1540252800,
          BB: 1544486400,
          w: 1552953600,
          R: 1558396800,
          M: 1562630400,
          JB: 1567468800,
          KB: 1571788800,
          LB: 1575331200,
          MB: 1578355200,
          NB: 1581379200,
          OB: 1583798400,
          PB: 1586304000,
          QB: null,
          RB: null
        }
      },
      D: {
        A: {
          "0": 0.004538,
          "1": 0.009076,
          "2": 0.004403,
          "3": 0.031766,
          "4": 0.013614,
          "5": 0.018152,
          "6": 0.027228,
          "7": 0.02269,
          "8": 0.027228,
          "9": 0.049918,
          G: 0.004706,
          U: 0.004879,
          I: 0.004879,
          F: 0.005591,
          E: 0.005591,
          D: 0.005591,
          A: 0.004534,
          B: 0.004464,
          C: 0.010424,
          O: 0.009076,
          T: 0.004706,
          P: 0.015087,
          H: 0.004393,
          J: 0.004393,
          K: 0.008652,
          V: 0.004418,
          W: 0.004393,
          X: 0.004317,
          Y: 0.009076,
          Z: 0.008786,
          a: 0.004538,
          b: 0.004461,
          c: 0.004538,
          d: 0.004326,
          e: 0.0047,
          f: 0.004538,
          g: 0.004403,
          h: 0.009076,
          i: 0.004566,
          j: 0.009076,
          k: 0.009076,
          l: 0.004538,
          m: 0.009076,
          n: 0.004464,
          o: 0.02269,
          p: 0.004464,
          q: 0.013614,
          r: 0.009076,
          s: 0.004403,
          t: 0.013614,
          u: 0.004465,
          v: 0.009076,
          Q: 0.004538,
          x: 0.009076,
          y: 0.058994,
          z: 0.403882,
          SB: 0.009076,
          AB: 0.018152,
          FB: 0.02269,
          CB: 0.018152,
          DB: 0.11345,
          BB: 0.018152,
          w: 0.031766,
          R: 0.054456,
          M: 0.027228,
          JB: 0.122526,
          KB: 0.095298,
          LB: 0.122526,
          MB: 0.131602,
          NB: 0.127064,
          OB: 0.149754,
          PB: 0.172444,
          QB: 0.15883,
          RB: 0.167906,
          eB: 0.290432,
          TB: 1.25249,
          IB: 26.1933,
          N: 0.063532,
          ZB: 0.009076,
          XB: 0,
          wB: 0
        },
        B: "webkit",
        C: ["G", "U", "I", "F", "E", "D", "A", "B", "C", "O", "T", "P", "H", "J", "K", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "Q", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "SB", "AB", "FB", "CB", "DB", "BB", "9", "w", "R", "M", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "eB", "TB", "IB", "N", "ZB", "XB", "wB"],
        E: "Chrome",
        F: {
          "0": 1460592000,
          "1": 1464134400,
          "2": 1469059200,
          "3": 1472601600,
          "4": 1476230400,
          "5": 1480550400,
          "6": 1485302400,
          "7": 1489017600,
          "8": 1492560000,
          "9": 1520294400,
          G: 1264377600,
          U: 1274745600,
          I: 1283385600,
          F: 1287619200,
          E: 1291248000,
          D: 1296777600,
          A: 1299542400,
          B: 1303862400,
          C: 1307404800,
          O: 1312243200,
          T: 1316131200,
          P: 1316131200,
          H: 1319500800,
          J: 1323734400,
          K: 1328659200,
          V: 1332892800,
          W: 1337040000,
          X: 1340668800,
          Y: 1343692800,
          Z: 1348531200,
          a: 1352246400,
          b: 1357862400,
          c: 1361404800,
          d: 1364428800,
          e: 1369094400,
          f: 1374105600,
          g: 1376956800,
          h: 1384214400,
          i: 1389657600,
          j: 1392940800,
          k: 1397001600,
          l: 1400544000,
          m: 1405468800,
          n: 1409011200,
          o: 1412640000,
          p: 1416268800,
          q: 1421798400,
          r: 1425513600,
          s: 1429401600,
          t: 1432080000,
          u: 1437523200,
          v: 1441152000,
          Q: 1444780800,
          x: 1449014400,
          y: 1453248000,
          z: 1456963200,
          SB: 1496707200,
          AB: 1500940800,
          FB: 1504569600,
          CB: 1508198400,
          DB: 1512518400,
          BB: 1516752000,
          w: 1523923200,
          R: 1527552000,
          M: 1532390400,
          JB: 1536019200,
          KB: 1539648000,
          LB: 1543968000,
          MB: 1548720000,
          NB: 1552348800,
          OB: 1555977600,
          PB: 1559606400,
          QB: 1564444800,
          RB: 1568073600,
          eB: 1571702400,
          TB: 1575936000,
          IB: 1580860800,
          N: 1586304000,
          ZB: null,
          XB: null,
          wB: null
        }
      },
      E: {
        A: {
          G: 0.009076,
          U: 0.004566,
          I: 0.004538,
          F: 0.004465,
          E: 0.018152,
          D: 0.009076,
          A: 0.013614,
          B: 0.031766,
          C: 0.104374,
          O: 2.9134,
          YB: 0,
          VB: 0.008692,
          aB: 0.081684,
          bB: 0.00456,
          cB: 0.004283,
          dB: 0.04538,
          UB: 0.086222,
          L: 0.18152,
          S: 0.367578,
          hB: 0.145216,
          iB: 0
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "YB", "VB", "G", "U", "aB", "I", "bB", "F", "cB", "E", "D", "dB", "A", "UB", "B", "L", "C", "S", "O", "hB", "iB", ""],
        E: "Safari",
        F: {
          YB: 1205798400,
          VB: 1226534400,
          G: 1244419200,
          U: 1275868800,
          aB: 1311120000,
          I: 1343174400,
          bB: 1382400000,
          F: 1382400000,
          cB: 1410998400,
          E: 1413417600,
          D: 1443657600,
          dB: 1458518400,
          A: 1474329600,
          UB: 1490572800,
          B: 1505779200,
          L: 1522281600,
          C: 1537142400,
          S: 1553472000,
          O: 1568851200,
          hB: null,
          iB: null
        }
      },
      F: {
        A: {
          "0": 0.004707,
          "1": 0.004707,
          "2": 0.004326,
          "3": 0.008922,
          "4": 0.014349,
          "5": 0.004725,
          "6": 0.004566,
          "7": 0.004538,
          "8": 0.004538,
          "9": 0.009076,
          D: 0.0082,
          B: 0.016581,
          C: 0.004317,
          P: 0.00685,
          H: 0.00685,
          J: 0.00685,
          K: 0.005014,
          V: 0.006015,
          W: 0.004879,
          X: 0.006597,
          Y: 0.006597,
          Z: 0.013434,
          a: 0.006702,
          b: 0.006015,
          c: 0.005595,
          d: 0.004393,
          e: 0.008652,
          f: 0.004879,
          g: 0.004879,
          h: 0.009132,
          i: 0.005152,
          j: 0.005014,
          k: 0.009758,
          l: 0.004879,
          m: 0.009076,
          n: 0.004283,
          o: 0.004367,
          p: 0.004534,
          q: 0.004367,
          r: 0.004227,
          s: 0.004418,
          t: 0.009042,
          u: 0.004227,
          v: 0.004725,
          Q: 0.004417,
          x: 0.008942,
          y: 0.004707,
          z: 0.004827,
          AB: 0.004403,
          CB: 0.004532,
          DB: 0.004566,
          BB: 0.02283,
          w: 0.335812,
          R: 0,
          M: 0,
          jB: 0.00685,
          kB: 0,
          lB: 0.008392,
          mB: 0.004706,
          L: 0.006229,
          EB: 0.004879,
          oB: 0.008786,
          S: 0.004538
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "jB", "kB", "lB", "mB", "B", "L", "EB", "oB", "C", "S", "P", "H", "J", "K", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "Q", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "AB", "CB", "DB", "BB", "9", "w", "R", "M", "", "", ""],
        E: "Opera",
        F: {
          "0": 1515024000,
          "1": 1517961600,
          "2": 1521676800,
          "3": 1525910400,
          "4": 1530144000,
          "5": 1534982400,
          "6": 1537833600,
          "7": 1543363200,
          "8": 1548201600,
          "9": 1573689600,
          D: 1150761600,
          jB: 1223424000,
          kB: 1251763200,
          lB: 1267488000,
          mB: 1277942400,
          B: 1292457600,
          L: 1302566400,
          EB: 1309219200,
          oB: 1323129600,
          C: 1323129600,
          S: 1352073600,
          P: 1372723200,
          H: 1377561600,
          J: 1381104000,
          K: 1386288000,
          V: 1390867200,
          W: 1393891200,
          X: 1399334400,
          Y: 1401753600,
          Z: 1405987200,
          a: 1409616000,
          b: 1413331200,
          c: 1417132800,
          d: 1422316800,
          e: 1425945600,
          f: 1430179200,
          g: 1433808000,
          h: 1438646400,
          i: 1442448000,
          j: 1445904000,
          k: 1449100800,
          l: 1454371200,
          m: 1457308800,
          n: 1462320000,
          o: 1465344000,
          p: 1470096000,
          q: 1474329600,
          r: 1477267200,
          s: 1481587200,
          t: 1486425600,
          u: 1490054400,
          v: 1494374400,
          Q: 1498003200,
          x: 1502236800,
          y: 1506470400,
          z: 1510099200,
          AB: 1554768000,
          CB: 1561593600,
          DB: 1566259200,
          BB: 1570406400,
          w: 1578441600,
          R: 1583971200,
          M: 1587513600
        },
        D: {
          D: "o",
          B: "o",
          C: "o",
          jB: "o",
          kB: "o",
          lB: "o",
          mB: "o",
          L: "o",
          EB: "o",
          oB: "o",
          S: "o"
        }
      },
      G: {
        A: {
          E: 0,
          VB: 0.00272636,
          pB: 0.00136318,
          HB: 0,
          rB: 0.0109054,
          sB: 0.00545271,
          tB: 0.0245372,
          uB: 0.0204477,
          vB: 0.0177213,
          WB: 0.17585,
          xB: 0.0477112,
          yB: 0.169034,
          zB: 0.126776,
          "0B": 0.194934,
          "1B": 0.260367,
          "2B": 1.55811,
          "3B": 0.399411,
          "4B": 0.182666,
          "5B": 10.2811,
          "6B": 0.148586
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "VB", "pB", "HB", "rB", "sB", "tB", "E", "uB", "vB", "WB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "", ""],
        E: "iOS Safari",
        F: {
          VB: 1270252800,
          pB: 1283904000,
          HB: 1299628800,
          rB: 1331078400,
          sB: 1359331200,
          tB: 1394409600,
          E: 1410912000,
          uB: 1413763200,
          vB: 1442361600,
          WB: 1458518400,
          xB: 1473724800,
          yB: 1490572800,
          zB: 1505779200,
          "0B": 1522281600,
          "1B": 1537142400,
          "2B": 1553472000,
          "3B": 1568851200,
          "4B": 1572220800,
          "5B": 1580169600,
          "6B": null
        }
      },
      H: {
        A: {
          "7B": 0.548133
        },
        B: "o",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "7B", "", "", ""],
        E: "Opera Mini",
        F: {
          "7B": 1426464000
        }
      },
      I: {
        A: {
          GB: 0.000813822,
          G: 0.00813822,
          N: 0,
          "8B": 0,
          "9B": 0.00325529,
          AC: 0.000813822,
          BC: 0.0130212,
          HB: 0.0374358,
          CC: 0,
          DC: 0.220546
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "8B", "9B", "AC", "GB", "G", "BC", "HB", "CC", "DC", "N", "", "", ""],
        E: "Android Browser",
        F: {
          "8B": 1256515200,
          "9B": 1274313600,
          AC: 1291593600,
          GB: 1298332800,
          G: 1318896000,
          BC: 1341792000,
          HB: 1374624000,
          CC: 1386547200,
          DC: 1401667200,
          N: 1587427200
        }
      },
      J: {
        A: {
          F: 0,
          A: 0.005462
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "A", "", "", ""],
        E: "Blackberry Browser",
        F: {
          F: 1325376000,
          A: 1359504000
        }
      },
      K: {
        A: {
          A: 0,
          B: 0,
          C: 0,
          Q: 0.0111391,
          L: 0,
          EB: 0,
          S: 0
        },
        B: "o",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "L", "EB", "C", "S", "Q", "", "", ""],
        E: "Opera Mobile",
        F: {
          A: 1287100800,
          B: 1300752000,
          L: 1314835200,
          EB: 1318291200,
          C: 1330300800,
          S: 1349740800,
          Q: 1474588800
        },
        D: {
          Q: "webkit"
        }
      },
      L: {
        A: {
          N: 34.1649
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "N", "", "", ""],
        E: "Chrome for Android",
        F: {
          N: 1587427200
        }
      },
      M: {
        A: {
          M: 0.223942
        },
        B: "moz",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "M", "", "", ""],
        E: "Firefox for Android",
        F: {
          M: 1567468800
        }
      },
      N: {
        A: {
          A: 0.0115934,
          B: 0.043696
        },
        B: "ms",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
        E: "IE Mobile",
        F: {
          A: 1340150400,
          B: 1353456000
        }
      },
      O: {
        A: {
          EC: 1.98817
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "", "", ""],
        E: "UC Browser for Android",
        F: {
          EC: 1471392000
        },
        D: {
          EC: "webkit"
        }
      },
      P: {
        A: {
          G: 0.288483,
          FC: 0.0206059,
          GC: 0.0206059,
          HC: 0.0927266,
          IC: 0.0309089,
          JC: 0.226665,
          UB: 0.679995,
          L: 2.17392
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "G", "FC", "GC", "HC", "IC", "JC", "UB", "L", "", "", ""],
        E: "Samsung Internet",
        F: {
          G: 1461024000,
          FC: 1481846400,
          GC: 1509408000,
          HC: 1528329600,
          IC: 1546128000,
          JC: 1554163200,
          UB: 1567900800,
          L: 1582588800
        }
      },
      Q: {
        A: {
          KC: 0.229404
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "", "", ""],
        E: "QQ Browser",
        F: {
          KC: 1483228800
        }
      },
      R: {
        A: {
          LC: 0
        },
        B: "webkit",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "LC", "", "", ""],
        E: "Baidu Browser",
        F: {
          LC: 1491004800
        }
      },
      S: {
        A: {
          MC: 0.174784
        },
        B: "moz",
        C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "MC", "", "", ""],
        E: "KaiOS Browser",
        F: {
          MC: 1527811200
        }
      }
    };

    var agents_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.agents = undefined;







    function unpackBrowserVersions(versionsData) {
      return Object.keys(versionsData).reduce(function (usage, version) {
        usage[browserVersions_1.browserVersions[version]] = versionsData[version];
        return usage;
      }, {});
    }

    var agents$1 = exports.agents = Object.keys(agents).reduce(function (map, key) {
      var versionsData = agents[key];
      map[browsers_1.browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
        if (entry === 'A') {
          data.usage_global = unpackBrowserVersions(versionsData[entry]);
        } else if (entry === 'C') {
          data.versions = versionsData[entry].reduce(function (list, version) {
            if (version === '') {
              list.push(null);
            } else {
              list.push(browserVersions_1.browserVersions[version]);
            }

            return list;
          }, []);
        } else if (entry === 'D') {
          data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
        } else if (entry === 'E') {
          data.browser = versionsData[entry];
        } else if (entry === 'F') {
          data.release_date = Object.keys(versionsData[entry]).reduce(function (map, key) {
            map[browserVersions_1.browserVersions[key]] = versionsData[entry][key];
            return map;
          }, {});
        } else {
          data.prefix = versionsData[entry];
        }

        return data;
      }, {});
      return map;
    }, {});
    });

    unwrapExports(agents_1);
    var agents_2 = agents_1.agents;

    var v4 = {
    	start: "2015-09-08",
    	lts: "2015-10-12",
    	maintenance: "2017-04-01",
    	end: "2018-04-30",
    	codename: "Argon"
    };
    var v5 = {
    	start: "2015-10-29",
    	maintenance: "2016-04-30",
    	end: "2016-06-30"
    };
    var v6 = {
    	start: "2016-04-26",
    	lts: "2016-10-18",
    	maintenance: "2018-04-30",
    	end: "2019-04-30",
    	codename: "Boron"
    };
    var v7 = {
    	start: "2016-10-25",
    	maintenance: "2017-04-30",
    	end: "2017-06-30"
    };
    var v8 = {
    	start: "2017-05-30",
    	lts: "2017-10-31",
    	maintenance: "2019-01-01",
    	end: "2019-12-31",
    	codename: "Carbon"
    };
    var v9 = {
    	start: "2017-10-01",
    	maintenance: "2018-04-01",
    	end: "2018-06-30"
    };
    var v10 = {
    	start: "2018-04-24",
    	lts: "2018-10-30",
    	maintenance: "2020-04-30",
    	end: "2021-04-30",
    	codename: "Dubnium"
    };
    var v11 = {
    	start: "2018-10-23",
    	maintenance: "2019-04-22",
    	end: "2019-06-01"
    };
    var v12 = {
    	start: "2019-04-23",
    	lts: "2019-10-21",
    	maintenance: "2020-10-20",
    	end: "2022-04-30",
    	codename: "Erbium"
    };
    var v13 = {
    	start: "2019-10-22",
    	maintenance: "2020-04-01",
    	end: "2020-06-01"
    };
    var v14 = {
    	start: "2020-04-21",
    	lts: "2020-10-20",
    	maintenance: "2021-10-19",
    	end: "2023-04-30",
    	codename: ""
    };
    var releaseSchedule = {
    	"v0.10": {
    	start: "2013-03-11",
    	end: "2016-10-31"
    },
    	"v0.12": {
    	start: "2015-02-06",
    	end: "2016-12-31"
    },
    	v4: v4,
    	v5: v5,
    	v6: v6,
    	v7: v7,
    	v8: v8,
    	v9: v9,
    	v10: v10,
    	v11: v11,
    	v12: v12,
    	v13: v13,
    	v14: v14
    };

    var releaseSchedule$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      v4: v4,
      v5: v5,
      v6: v6,
      v7: v7,
      v8: v8,
      v9: v9,
      v10: v10,
      v11: v11,
      v12: v12,
      v13: v13,
      v14: v14,
      'default': releaseSchedule
    });

    var versions$1 = {
      "9.0": "82",
      "8.2": "80",
      "8.1": "80",
      "8.0": "79",
      "7.2": "78",
      "7.1": "78",
      "7.0": "78",
      "6.1": "76",
      "6.0": "76",
      "5.0": "72",
      "4.2": "69",
      "4.1": "69",
      "4.0": "69",
      "3.1": "66",
      "3.0": "66",
      "2.1": "61",
      "2.0": "61",
      "1.8": "59",
      "1.7": "58",
      "1.6": "56",
      "1.5": "54",
      "1.4": "53",
      "1.3": "52",
      "1.2": "51",
      "1.1": "50",
      "1.0": "49",
      "0.37": "49",
      "0.36": "47",
      "0.35": "45",
      "0.34": "45",
      "0.33": "45",
      "0.32": "45",
      "0.31": "44",
      "0.30": "44",
      "0.29": "43",
      "0.28": "43",
      "0.27": "42",
      "0.26": "42",
      "0.25": "42",
      "0.24": "41",
      "0.23": "41",
      "0.22": "41",
      "0.21": "40",
      "0.20": "39"
    };

    function BrowserslistError(message) {
      this.name = 'BrowserslistError';
      this.message = message;
      this.browserslist = true;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, BrowserslistError);
      }
    }

    BrowserslistError.prototype = Error.prototype;
    var error = BrowserslistError;

    function noop$2() {}

    var browser$6 = {
      loadQueries: function loadQueries() {
        throw new error('Sharable configs are not supported in client-side build of Browserslist');
      },
      getStat: function getStat(opts) {
        return opts.stats;
      },
      loadConfig: function loadConfig(opts) {
        if (opts.config) {
          throw new error('Browserslist config are not supported in client-side build');
        }
      },
      loadCountry: function loadCountry() {
        throw new error('Country statistics is not supported ' + 'in client-side build of Browserslist');
      },
      currentNode: function currentNode(resolve, context) {
        return resolve(['maintained node versions'], context)[0];
      },
      parseConfig: noop$2,
      readConfig: noop$2,
      findConfig: noop$2,
      clearCaches: noop$2,
      oldDataWarning: noop$2
    };

    var jsReleases = getCjsExportFromNamespace(envs$1);

    var jsEOL = getCjsExportFromNamespace(releaseSchedule$1);

    var agents$1 = agents_1.agents;











    var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
    var ANDROID_EVERGREEN_FIRST = 37;
    var QUERY_OR = 1;
    var QUERY_AND = 2;

    function isVersionsMatch(versionA, versionB) {
      return (versionA + '.').indexOf(versionB + '.') === 0;
    }

    function isEolReleased(name) {
      var version = name.slice(1);
      return jsReleases.some(function (i) {
        return isVersionsMatch(i.version, version);
      });
    }

    function normalize$1(versions) {
      return versions.filter(function (version) {
        return typeof version === 'string';
      });
    }

    function normalizeElectron(version) {
      var versionToUse = version;

      if (version.split('.').length === 3) {
        versionToUse = version.split('.').slice(0, -1).join('.');
      }

      return versionToUse;
    }

    function nameMapper(name) {
      return function mapName(version) {
        return name + ' ' + version;
      };
    }

    function getMajor(version) {
      return parseInt(version.split('.')[0]);
    }

    function getMajorVersions(released, number) {
      if (released.length === 0) return [];
      var majorVersions = uniq$1(released.map(getMajor));
      var minimum = majorVersions[majorVersions.length - number];

      if (!minimum) {
        return released;
      }

      var selected = [];

      for (var i = released.length - 1; i >= 0; i--) {
        if (minimum > getMajor(released[i])) break;
        selected.unshift(released[i]);
      }

      return selected;
    }

    function uniq$1(array) {
      var filtered = [];

      for (var i = 0; i < array.length; i++) {
        if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
      }

      return filtered;
    }

    function fillUsage(result, name, data) {
      for (var i in data) {
        result[name + ' ' + i] = data[i];
      }
    }

    function generateFilter(sign, version) {
      version = parseFloat(version);

      if (sign === '>') {
        return function (v) {
          return parseFloat(v) > version;
        };
      } else if (sign === '>=') {
        return function (v) {
          return parseFloat(v) >= version;
        };
      } else if (sign === '<') {
        return function (v) {
          return parseFloat(v) < version;
        };
      } else {
        return function (v) {
          return parseFloat(v) <= version;
        };
      }
    }

    function generateSemverFilter(sign, version) {
      version = version.split('.').map(parseSimpleInt);
      version[1] = version[1] || 0;
      version[2] = version[2] || 0;

      if (sign === '>') {
        return function (v) {
          v = v.split('.').map(parseSimpleInt);
          return compareSemver(v, version) > 0;
        };
      } else if (sign === '>=') {
        return function (v) {
          v = v.split('.').map(parseSimpleInt);
          return compareSemver(v, version) >= 0;
        };
      } else if (sign === '<') {
        return function (v) {
          v = v.split('.').map(parseSimpleInt);
          return compareSemver(version, v) > 0;
        };
      } else {
        return function (v) {
          v = v.split('.').map(parseSimpleInt);
          return compareSemver(version, v) >= 0;
        };
      }
    }

    function parseSimpleInt(x) {
      return parseInt(x);
    }

    function compare$1(a, b) {
      if (a < b) return -1;
      if (a > b) return +1;
      return 0;
    }

    function compareSemver(a, b) {
      return compare$1(parseInt(a[0]), parseInt(b[0])) || compare$1(parseInt(a[1] || '0'), parseInt(b[1] || '0')) || compare$1(parseInt(a[2] || '0'), parseInt(b[2] || '0'));
    }

    function semverFilterLoose(operator, range) {
      range = range.split('.').map(parseSimpleInt);

      if (typeof range[1] === 'undefined') {
        range[1] = 'x';
      }

      switch (operator) {
        case '<=':
          return function (version) {
            version = version.split('.').map(parseSimpleInt);
            return compareSemverLoose(version, range) <= 0;
          };

        default:
        case '>=':
          return function (version) {
            version = version.split('.').map(parseSimpleInt);
            return compareSemverLoose(version, range) >= 0;
          };
      }
    }

    function compareSemverLoose(version, range) {
      if (version[0] !== range[0]) {
        return version[0] < range[0] ? -1 : +1;
      }

      if (range[1] === 'x') {
        return 0;
      }

      if (version[1] !== range[1]) {
        return version[1] < range[1] ? -1 : +1;
      }

      return 0;
    }

    function resolveVersion(data, version) {
      if (data.versions.indexOf(version) !== -1) {
        return version;
      } else if (browserslist.versionAliases[data.name][version]) {
        return browserslist.versionAliases[data.name][version];
      } else {
        return false;
      }
    }

    function normalizeVersion(data, version) {
      var resolved = resolveVersion(data, version);

      if (resolved) {
        return resolved;
      } else if (data.versions.length === 1) {
        return data.versions[0];
      } else {
        return false;
      }
    }

    function filterByYear(since, context) {
      since = since / 1000;
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var versions = Object.keys(data.releaseDate).filter(function (v) {
          return data.releaseDate[v] >= since;
        });
        return selected.concat(versions.map(nameMapper(data.name)));
      }, []);
    }

    function cloneData(data) {
      return {
        name: data.name,
        versions: data.versions,
        released: data.released,
        releaseDate: data.releaseDate
      };
    }

    function mapVersions(data, map) {
      data.versions = data.versions.map(function (i) {
        return map[i] || i;
      });
      data.released = data.versions.map(function (i) {
        return map[i] || i;
      });
      var fixedDate = {};

      for (var i in data.releaseDate) {
        fixedDate[map[i] || i] = data.releaseDate[i];
      }

      data.releaseDate = fixedDate;
      return data;
    }

    function byName(name, context) {
      name = name.toLowerCase();
      name = browserslist.aliases[name] || name;

      if (context.mobileToDesktop && browserslist.desktopNames[name]) {
        var desktop = browserslist.data[browserslist.desktopNames[name]];

        if (name === 'android') {
          return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
        } else {
          var cloned = cloneData(desktop);
          cloned.name = name;

          if (name === 'op_mob') {
            cloned = mapVersions(cloned, {
              '10.0-10.1': '10'
            });
          }

          return cloned;
        }
      }

      return browserslist.data[name];
    }

    function normalizeAndroidVersions(androidVersions, chromeVersions) {
      var firstEvergreen = ANDROID_EVERGREEN_FIRST;
      var last = chromeVersions[chromeVersions.length - 1];
      return androidVersions.filter(function (version) {
        return /^(?:[2-4]\.|[34]$)/.test(version);
      }).concat(chromeVersions.slice(firstEvergreen - last - 1));
    }

    function normalizeAndroidData(android, chrome) {
      android.released = normalizeAndroidVersions(android.released, chrome.released);
      android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
      return android;
    }

    function checkName(name, context) {
      var data = byName(name, context);
      if (!data) throw new error('Unknown browser ' + name);
      return data;
    }

    function unknownQuery(query) {
      return new error('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
    }

    function filterAndroid(list, versions, context) {
      if (context.mobileToDesktop) return list;
      var released = browserslist.data.android.released;
      var last = released[released.length - 1];
      var diff = last - ANDROID_EVERGREEN_FIRST - versions;

      if (diff > 0) {
        return list.slice(-1);
      } else {
        return list.slice(diff - 1);
      }
    }

    function resolve$2(queries, context) {
      if (Array.isArray(queries)) {
        queries = flatten(queries.map(parse$5));
      } else {
        queries = parse$5(queries);
      }

      return queries.reduce(function (result, query, index) {
        var selection = query.queryString;
        var isExclude = selection.indexOf('not ') === 0;

        if (isExclude) {
          if (index === 0) {
            throw new error('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
          }

          selection = selection.slice(4);
        }

        for (var i = 0; i < QUERIES.length; i++) {
          var type = QUERIES[i];
          var match = selection.match(type.regexp);

          if (match) {
            var args = [context].concat(match.slice(1));
            var array = type.select.apply(browserslist, args).map(function (j) {
              var parts = j.split(' ');

              if (parts[1] === '0') {
                return parts[0] + ' ' + byName(parts[0], context).versions[0];
              } else {
                return j;
              }
            });

            switch (query.type) {
              case QUERY_AND:
                if (isExclude) {
                  return result.filter(function (j) {
                    return array.indexOf(j) === -1;
                  });
                } else {
                  return result.filter(function (j) {
                    return array.indexOf(j) !== -1;
                  });
                }

              case QUERY_OR:
              default:
                if (isExclude) {
                  var filter = {};
                  array.forEach(function (j) {
                    filter[j] = true;
                  });
                  return result.filter(function (j) {
                    return !filter[j];
                  });
                }

                return result.concat(array);
            }
          }
        }

        throw unknownQuery(selection);
      }, []);
    }

    var cache$1 = {};

    function browserslist(queries, opts) {
      if (typeof opts === 'undefined') opts = {};

      if (typeof opts.path === 'undefined') {
        opts.path = path$2.resolve ? path$2.resolve('.') : '.';
      }

      if (typeof queries === 'undefined' || queries === null) {
        var config = browserslist.loadConfig(opts);

        if (config) {
          queries = config;
        } else {
          queries = browserslist.defaults;
        }
      }

      if (!(typeof queries === 'string' || Array.isArray(queries))) {
        throw new error('Browser queries must be an array or string. Got ' + typeof queries + '.');
      }

      var context = {
        ignoreUnknownVersions: opts.ignoreUnknownVersions,
        dangerousExtend: opts.dangerousExtend,
        mobileToDesktop: opts.mobileToDesktop,
        env: opts.env
      };
      browser$6.oldDataWarning(browserslist.data);
      var stats = browser$6.getStat(opts, browserslist.data);

      if (stats) {
        context.customUsage = {};

        for (var browser in stats) {
          fillUsage(context.customUsage, browser, stats[browser]);
        }
      }

      var cacheKey = JSON.stringify([queries, context]);
      if (cache$1[cacheKey]) return cache$1[cacheKey];
      var result = uniq$1(resolve$2(queries, context)).sort(function (name1, name2) {
        name1 = name1.split(' ');
        name2 = name2.split(' ');

        if (name1[0] === name2[0]) {
          var version1 = name1[1].split('-')[0];
          var version2 = name2[1].split('-')[0];
          return compareSemver(version2.split('.'), version1.split('.'));
        } else {
          return compare$1(name1[0], name2[0]);
        }
      });

      if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
        cache$1[cacheKey] = result;
      }

      return result;
    }

    function parse$5(queries) {
      var qs = [];

      do {
        queries = doMatch(queries, qs);
      } while (queries);

      return qs;
    }

    function doMatch(string, qs) {
      var or = /^(?:,\s*|\s+or\s+)(.*)/i;
      var and = /^\s+and\s+(.*)/i;
      return find$2(string, function (parsed, n, max) {
        if (and.test(parsed)) {
          qs.unshift({
            type: QUERY_AND,
            queryString: parsed.match(and)[1]
          });
          return true;
        } else if (or.test(parsed)) {
          qs.unshift({
            type: QUERY_OR,
            queryString: parsed.match(or)[1]
          });
          return true;
        } else if (n === max) {
          qs.unshift({
            type: QUERY_OR,
            queryString: parsed.trim()
          });
          return true;
        }

        return false;
      });
    }

    function find$2(string, predicate) {
      for (var n = 1, max = string.length; n <= max; n++) {
        var parsed = string.substr(-n, n);

        if (predicate(parsed, n, max)) {
          return string.slice(0, -n);
        }
      }

      return '';
    }

    function flatten(array) {
      if (!Array.isArray(array)) return [array];
      return array.reduce(function (a, b) {
        return a.concat(flatten(b));
      }, []);
    }

    browserslist.data = {};
    browserslist.usage = {
      global: {},
      custom: null
    };
    browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead'];
    browserslist.aliases = {
      fx: 'firefox',
      ff: 'firefox',
      ios: 'ios_saf',
      explorer: 'ie',
      blackberry: 'bb',
      explorermobile: 'ie_mob',
      operamini: 'op_mini',
      operamobile: 'op_mob',
      chromeandroid: 'and_chr',
      firefoxandroid: 'and_ff',
      ucandroid: 'and_uc',
      qqandroid: 'and_qq'
    };
    browserslist.desktopNames = {
      and_chr: 'chrome',
      and_ff: 'firefox',
      ie_mob: 'ie',
      op_mob: 'opera',
      android: 'chrome'
    };
    browserslist.versionAliases = {};
    browserslist.clearCaches = browser$6.clearCaches;
    browserslist.parseConfig = browser$6.parseConfig;
    browserslist.readConfig = browser$6.readConfig;
    browserslist.findConfig = browser$6.findConfig;
    browserslist.loadConfig = browser$6.loadConfig;

    browserslist.coverage = function (browsers, stats) {
      var data;

      if (typeof stats === 'undefined') {
        data = browserslist.usage.global;
      } else if (stats === 'my stats') {
        var opts = {};
        opts.path = path$2.resolve ? path$2.resolve('.') : '.';
        var customStats = browser$6.getStat(opts);

        if (!customStats) {
          throw new error('Custom usage statistics was not provided');
        }

        data = {};

        for (var browser in customStats) {
          fillUsage(data, browser, customStats[browser]);
        }
      } else if (typeof stats === 'string') {
        if (stats.length > 2) {
          stats = stats.toLowerCase();
        } else {
          stats = stats.toUpperCase();
        }

        browser$6.loadCountry(browserslist.usage, stats, browserslist.data);
        data = browserslist.usage[stats];
      } else {
        if ('dataByBrowser' in stats) {
          stats = stats.dataByBrowser;
        }

        data = {};

        for (var name in stats) {
          for (var version in stats[name]) {
            data[name + ' ' + version] = stats[name][version];
          }
        }
      }

      return browsers.reduce(function (all, i) {
        var usage = data[i];

        if (usage === undefined) {
          usage = data[i.replace(/ \S+$/, ' 0')];
        }

        return all + (usage || 0);
      }, 0);
    };

    var QUERIES = [{
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: function select(context, versions) {
        return Object.keys(agents$1).reduce(function (selected, name) {
          var data = byName(name, context);
          if (!data) return selected;
          var list = getMajorVersions(data.released, versions);
          list = list.map(nameMapper(data.name));

          if (data.name === 'android') {
            list = filterAndroid(list, versions, context);
          }

          return selected.concat(list);
        }, []);
      }
    }, {
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: function select(context, versions) {
        return Object.keys(agents$1).reduce(function (selected, name) {
          var data = byName(name, context);
          if (!data) return selected;
          var list = data.released.slice(-versions);
          list = list.map(nameMapper(data.name));

          if (data.name === 'android') {
            list = filterAndroid(list, versions, context);
          }

          return selected.concat(list);
        }, []);
      }
    }, {
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: function select(context, versions) {
        var validVersions = getMajorVersions(Object.keys(versions$1).reverse(), versions);
        return validVersions.map(function (i) {
          return 'chrome ' + versions$1[i];
        });
      }
    }, {
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: function select(context, versions, name) {
        var data = checkName(name, context);
        var validVersions = getMajorVersions(data.released, versions);
        var list = validVersions.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return list;
      }
    }, {
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: function select(context, versions) {
        return Object.keys(versions$1).reverse().slice(-versions).map(function (i) {
          return 'chrome ' + versions$1[i];
        });
      }
    }, {
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: function select(context, versions, name) {
        var data = checkName(name, context);
        var list = data.released.slice(-versions).map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return list;
      }
    }, {
      regexp: /^unreleased\s+versions$/i,
      select: function select(context) {
        return Object.keys(agents$1).reduce(function (selected, name) {
          var data = byName(name, context);
          if (!data) return selected;
          var list = data.versions.filter(function (v) {
            return data.released.indexOf(v) === -1;
          });
          list = list.map(nameMapper(data.name));
          return selected.concat(list);
        }, []);
      }
    }, {
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: function select() {
        return [];
      }
    }, {
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: function select(context, name) {
        var data = checkName(name, context);
        return data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1;
        }).map(nameMapper(data.name));
      }
    }, {
      regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
      select: function select(context, years) {
        return filterByYear(Date.now() - YEAR * years, context);
      }
    }, {
      regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
      select: function select(context, year, month, date) {
        year = parseInt(year);
        month = parseInt(month || '01') - 1;
        date = parseInt(date || '01');
        return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context);
      }
    }, {
      regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
      select: function select(context, sign, popularity) {
        popularity = parseFloat(popularity);
        var usage = browserslist.usage.global;
        return Object.keys(usage).reduce(function (result, version) {
          if (sign === '>') {
            if (usage[version] > popularity) {
              result.push(version);
            }
          } else if (sign === '<') {
            if (usage[version] < popularity) {
              result.push(version);
            }
          } else if (sign === '<=') {
            if (usage[version] <= popularity) {
              result.push(version);
            }
          } else if (usage[version] >= popularity) {
            result.push(version);
          }

          return result;
        }, []);
      }
    }, {
      regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
      select: function select(context, sign, popularity) {
        popularity = parseFloat(popularity);

        if (!context.customUsage) {
          throw new error('Custom usage statistics was not provided');
        }

        var usage = context.customUsage;
        return Object.keys(usage).reduce(function (result, version) {
          if (sign === '>') {
            if (usage[version] > popularity) {
              result.push(version);
            }
          } else if (sign === '<') {
            if (usage[version] < popularity) {
              result.push(version);
            }
          } else if (sign === '<=') {
            if (usage[version] <= popularity) {
              result.push(version);
            }
          } else if (usage[version] >= popularity) {
            result.push(version);
          }

          return result;
        }, []);
      }
    }, {
      regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+(\S+)\s+stats$/,
      select: function select(context, sign, popularity, name) {
        popularity = parseFloat(popularity);
        var stats = browser$6.loadStat(context, name, browserslist.data);

        if (stats) {
          context.customUsage = {};

          for (var browser in stats) {
            fillUsage(context.customUsage, browser, stats[browser]);
          }
        }

        if (!context.customUsage) {
          throw new error('Custom usage statistics was not provided');
        }

        var usage = context.customUsage;
        return Object.keys(usage).reduce(function (result, version) {
          if (sign === '>') {
            if (usage[version] > popularity) {
              result.push(version);
            }
          } else if (sign === '<') {
            if (usage[version] < popularity) {
              result.push(version);
            }
          } else if (sign === '<=') {
            if (usage[version] <= popularity) {
              result.push(version);
            }
          } else if (usage[version] >= popularity) {
            result.push(version);
          }

          return result;
        }, []);
      }
    }, {
      regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: function select(context, sign, popularity, place) {
        popularity = parseFloat(popularity);

        if (place.length === 2) {
          place = place.toUpperCase();
        } else {
          place = place.toLowerCase();
        }

        browser$6.loadCountry(browserslist.usage, place, browserslist.data);
        var usage = browserslist.usage[place];
        return Object.keys(usage).reduce(function (result, version) {
          if (sign === '>') {
            if (usage[version] > popularity) {
              result.push(version);
            }
          } else if (sign === '<') {
            if (usage[version] < popularity) {
              result.push(version);
            }
          } else if (sign === '<=') {
            if (usage[version] <= popularity) {
              result.push(version);
            }
          } else if (usage[version] >= popularity) {
            result.push(version);
          }

          return result;
        }, []);
      }
    }, {
      regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
      select: function select(context, coverage, statMode) {
        coverage = parseFloat(coverage);
        var usage = browserslist.usage.global;

        if (statMode) {
          if (statMode.match(/^\s+in\s+my\s+stats$/)) {
            if (!context.customUsage) {
              throw new error('Custom usage statistics was not provided');
            }

            usage = context.customUsage;
          } else {
            var match = statMode.match(/\s+in\s+((alt-)?\w\w)/);
            var place = match[1];

            if (place.length === 2) {
              place = place.toUpperCase();
            } else {
              place = place.toLowerCase();
            }

            browser$6.loadCountry(browserslist.usage, place, browserslist.data);
            usage = browserslist.usage[place];
          }
        }

        var versions = Object.keys(usage).sort(function (a, b) {
          return usage[b] - usage[a];
        });
        var coveraged = 0;
        var result = [];
        var version;

        for (var i = 0; i <= versions.length; i++) {
          version = versions[i];
          if (usage[version] === 0) break;
          coveraged += usage[version];
          result.push(version);
          if (coveraged >= coverage) break;
        }

        return result;
      }
    }, {
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function select(context, from, to) {
        var fromToUse = normalizeElectron(from);
        var toToUse = normalizeElectron(to);

        if (!versions$1[fromToUse]) {
          throw new error('Unknown version ' + from + ' of electron');
        }

        if (!versions$1[toToUse]) {
          throw new error('Unknown version ' + to + ' of electron');
        }

        from = parseFloat(from);
        to = parseFloat(to);
        return Object.keys(versions$1).filter(function (i) {
          var parsed = parseFloat(i);
          return parsed >= from && parsed <= to;
        }).map(function (i) {
          return 'chrome ' + versions$1[i];
        });
      }
    }, {
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function select(context, from, to) {
        var nodeVersions = jsReleases.filter(function (i) {
          return i.name === 'nodejs';
        }).map(function (i) {
          return i.version;
        });
        var semverRegExp = /^(0|[1-9]\d*)(\.(0|[1-9]\d*)){0,2}$/;

        if (!semverRegExp.test(from)) {
          throw new error('Unknown version ' + from + ' of Node.js');
        }

        if (!semverRegExp.test(to)) {
          throw new error('Unknown version ' + to + ' of Node.js');
        }

        return nodeVersions.filter(semverFilterLoose('>=', from)).filter(semverFilterLoose('<=', to)).map(function (v) {
          return 'node ' + v;
        });
      }
    }, {
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function select(context, name, from, to) {
        var data = checkName(name, context);
        from = parseFloat(normalizeVersion(data, from) || from);
        to = parseFloat(normalizeVersion(data, to) || to);

        function filter(v) {
          var parsed = parseFloat(v);
          return parsed >= from && parsed <= to;
        }

        return data.released.filter(filter).map(nameMapper(data.name));
      }
    }, {
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: function select(context, sign, version) {
        var versionToUse = normalizeElectron(version);
        return Object.keys(versions$1).filter(generateFilter(sign, versionToUse)).map(function (i) {
          return 'chrome ' + versions$1[i];
        });
      }
    }, {
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: function select(context, sign, version) {
        var nodeVersions = jsReleases.filter(function (i) {
          return i.name === 'nodejs';
        }).map(function (i) {
          return i.version;
        });
        return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
          return 'node ' + v;
        });
      }
    }, {
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: function select(context, name, sign, version) {
        var data = checkName(name, context);
        var alias = browserslist.versionAliases[data.name][version];

        if (alias) {
          version = alias;
        }

        return data.released.filter(generateFilter(sign, version)).map(function (v) {
          return data.name + ' ' + v;
        });
      }
    }, {
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: function select() {
        return ['firefox 68'];
      }
    }, {
      regexp: /(operamini|op_mini)\s+all/i,
      select: function select() {
        return ['op_mini all'];
      }
    }, {
      regexp: /^electron\s+([\d.]+)$/i,
      select: function select(context, version) {
        var versionToUse = normalizeElectron(version);
        var chrome = versions$1[versionToUse];

        if (!chrome) {
          throw new error('Unknown version ' + version + ' of electron');
        }

        return ['chrome ' + chrome];
      }
    }, {
      regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
      select: function select(context, version) {
        var nodeReleases = jsReleases.filter(function (i) {
          return i.name === 'nodejs';
        });
        var matched = nodeReleases.filter(function (i) {
          return isVersionsMatch(i.version, version);
        });

        if (matched.length === 0) {
          if (context.ignoreUnknownVersions) {
            return [];
          } else {
            throw new error('Unknown version ' + version + ' of Node.js');
          }
        }

        return ['node ' + matched[matched.length - 1].version];
      }
    }, {
      regexp: /^current\s+node$/i,
      select: function select(context) {
        return [browser$6.currentNode(resolve$2, context)];
      }
    }, {
      regexp: /^maintained\s+node\s+versions$/i,
      select: function select(context) {
        var now = Date.now();
        var queries = Object.keys(jsEOL).filter(function (key) {
          return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
        }).map(function (key) {
          return 'node ' + key.slice(1);
        });
        return resolve$2(queries, context);
      }
    }, {
      regexp: /^phantomjs\s+1.9$/i,
      select: function select() {
        return ['safari 5'];
      }
    }, {
      regexp: /^phantomjs\s+2.1$/i,
      select: function select() {
        return ['safari 6'];
      }
    }, {
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: function select(context, name, version) {
        if (/^tp$/i.test(version)) version = 'TP';
        var data = checkName(name, context);
        var alias = normalizeVersion(data, version);

        if (alias) {
          version = alias;
        } else {
          if (version.indexOf('.') === -1) {
            alias = version + '.0';
          } else {
            alias = version.replace(/\.0$/, '');
          }

          alias = normalizeVersion(data, alias);

          if (alias) {
            version = alias;
          } else if (context.ignoreUnknownVersions) {
            return [];
          } else {
            throw new error('Unknown version ' + version + ' of ' + name);
          }
        }

        return [data.name + ' ' + version];
      }
    }, {
      regexp: /^extends (.+)$/i,
      select: function select(context, name) {
        return resolve$2(browser$6.loadQueries(context, name), context);
      }
    }, {
      regexp: /^defaults$/i,
      select: function select(context) {
        return resolve$2(browserslist.defaults, context);
      }
    }, {
      regexp: /^dead$/i,
      select: function select(context) {
        var dead = ['ie <= 10', 'ie_mob <= 11', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
        return resolve$2(dead, context);
      }
    }, {
      regexp: /^(\w+)$/i,
      select: function select(context, name) {
        if (byName(name, context)) {
          throw new error('Specify versions in Browserslist query for browser ' + name);
        } else {
          throw unknownQuery(name);
        }
      }
    }];

    (function () {
      for (var name in agents$1) {
        var browser = agents$1[name];
        browserslist.data[name] = {
          name: name,
          versions: normalize$1(agents$1[name].versions),
          released: normalize$1(agents$1[name].versions.slice(0, -3)),
          releaseDate: agents$1[name].release_date
        };
        fillUsage(browserslist.usage.global, name, browser.usage_global);
        browserslist.versionAliases[name] = {};

        for (var i = 0; i < browser.versions.length; i++) {
          var full = browser.versions[i];
          if (!full) continue;

          if (full.indexOf('-') !== -1) {
            var interval = full.split('-');

            for (var j = 0; j < interval.length; j++) {
              browserslist.versionAliases[name][interval[j]] = full;
            }
          }
        }
      }
    })();

    var browserslist_1 = browserslist;

    var leven_1 = createCommonjsModule(function (module) {

    var array = [];
    var charCodeCache = [];

    var leven = function leven(left, right) {
      if (left === right) {
        return 0;
      }

      var swap = left;

      if (left.length > right.length) {
        left = right;
        right = swap;
      }

      var leftLength = left.length;
      var rightLength = right.length;

      while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
        leftLength--;
        rightLength--;
      }

      var start = 0;

      while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
        start++;
      }

      leftLength -= start;
      rightLength -= start;

      if (leftLength === 0) {
        return rightLength;
      }

      var bCharCode;
      var result;
      var temp;
      var temp2;
      var i = 0;
      var j = 0;

      while (i < leftLength) {
        charCodeCache[i] = left.charCodeAt(start + i);
        array[i] = ++i;
      }

      while (j < rightLength) {
        bCharCode = right.charCodeAt(start + j);
        temp = j++;
        result = j;

        for (i = 0; i < leftLength; i++) {
          temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
          temp = array[i];
          result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
        }
      }

      return result;
    };

    module.exports = leven;
    module.exports["default"] = leven;
    });

    function levenArray(str, array) {
      var minLeven = Number.POSITIVE_INFINITY;
      var result = undefined;

      for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
        var item = _step.value;
        var distance = leven_1(str, item);

        if (distance < minLeven) {
          minLeven = distance;
          result = item;
        }
      }

      return result;
    }

    var invariant = function invariant(condition, format, a, b, c, d, e, f) {
      {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }

      if (!condition) {
        var error;

        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }

        error.framesToPop = 1;
        throw error;
      }
    };

    var browser$7 = invariant;

    var nativeModules = {
    	"es6.module": {
    	edge: "16",
    	firefox: "60",
    	chrome: "61",
    	safari: "10.1",
    	opera: "48",
    	ios_saf: "10.3",
    	android: "61",
    	op_mob: "48",
    	and_chr: "61",
    	and_ff: "60",
    	samsung: "8.2"
    }
    };

    var nativeModules$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': nativeModules
    });

    var require$$0$3 = getCjsExportFromNamespace(nativeModules$1);

    var nativeModules$2 = require$$0$3;

    var unreleasedLabels = {
      safari: "tp"
    };
    var browserNameMap = {
      and_chr: "chrome",
      and_ff: "firefox",
      android: "android",
      chrome: "chrome",
      edge: "edge",
      firefox: "firefox",
      ie: "ie",
      ie_mob: "ie",
      ios_saf: "ios",
      node: "node",
      op_mob: "opera",
      opera: "opera",
      safari: "safari",
      samsung: "samsung"
    };

    var versionRegExp = /^(\d+|\d+.\d+)$/;
    function semverMin(first, second) {
      return first && semver.lt(first, second) ? first : second;
    }
    function semverify(version) {
      if (typeof version === "string" && semver.valid(version)) {
        return version;
      }

      browser$7(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), "'" + version + "' is not a valid version");
      var split = version.toString().split(".");

      while (split.length < 3) {
        split.push("0");
      }

      return split.join(".");
    }
    function isUnreleasedVersion(version, env) {
      var unreleasedLabel = unreleasedLabels[env];
      return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
    }
    function getLowestUnreleased(a, b, env) {
      var unreleasedLabel = unreleasedLabels[env];
      var hasUnreleased = [a, b].some(function (item) {
        return item === unreleasedLabel;
      });

      if (hasUnreleased) {
        return a === hasUnreleased ? b : a || b;
      }

      return semverMin(a, b);
    }
    function getLowestImplementedVersion(plugin, environment) {
      var result = plugin[environment];

      if (!result && environment === "android") {
        return plugin.chrome;
      }

      return result;
    }

    var TargetNames = {
      esmodules: "esmodules",
      node: "node",
      browsers: "browsers",
      chrome: "chrome",
      opera: "opera",
      edge: "edge",
      firefox: "firefox",
      safari: "safari",
      ie: "ie",
      ios: "ios",
      android: "android",
      electron: "electron",
      samsung: "samsung",
      uglify: "uglify"
    };

    function prettifyVersion(version) {
      if (typeof version !== "string") {
        return version;
      }

      var parts = [semver.major(version)];
      var minor = semver.minor(version);
      var patch = semver.patch(version);

      if (minor || patch) {
        parts.push(minor);
      }

      if (patch) {
        parts.push(patch);
      }

      return parts.join(".");
    }
    function prettifyTargets(targets) {
      return Object.keys(targets).reduce(function (results, target) {
        var value = targets[target];
        var unreleasedLabel = unreleasedLabels[target];

        if (typeof value === "string" && unreleasedLabel !== value) {
          value = prettifyVersion(value);
        }

        results[target] = value;
        return results;
      }, {});
    }

    function getInclusionReasons(item, targetVersions, list) {
      var minVersions = list[item] || {};
      return Object.keys(targetVersions).reduce(function (result, env) {
        var minVersion = getLowestImplementedVersion(minVersions, env);
        var targetVersion = targetVersions[env];

        if (!minVersion) {
          result[env] = prettifyVersion(targetVersion);
        } else {
          var minIsUnreleased = isUnreleasedVersion(minVersion, env);
          var targetIsUnreleased = isUnreleasedVersion(targetVersion, env);

          if (!targetIsUnreleased && (minIsUnreleased || semver.lt(targetVersion.toString(), semverify(minVersion)))) {
            result[env] = prettifyVersion(targetVersion);
          }
        }

        return result;
      }, {});
    }

    var plugins = {
    	"proposal-numeric-separator": {
    	chrome: "75",
    	opera: "62",
    	edge: "79",
    	firefox: "70",
    	safari: "13",
    	node: "12.5",
    	ios: "13",
    	electron: "6.1"
    },
    	"proposal-nullish-coalescing-operator": {
    	chrome: "80",
    	opera: "67",
    	edge: "80",
    	firefox: "72",
    	safari: "13.1",
    	node: "14",
    	electron: "8.1"
    },
    	"proposal-optional-chaining": {
    	chrome: "80",
    	opera: "67",
    	edge: "80",
    	firefox: "74",
    	safari: "13.1",
    	node: "14",
    	electron: "8.1"
    },
    	"proposal-json-strings": {
    	chrome: "66",
    	opera: "53",
    	edge: "79",
    	firefox: "62",
    	safari: "12",
    	node: "10",
    	ios: "12",
    	samsung: "9",
    	electron: "3.1"
    },
    	"proposal-optional-catch-binding": {
    	chrome: "66",
    	opera: "53",
    	edge: "79",
    	firefox: "58",
    	safari: "11.1",
    	node: "10",
    	ios: "11.3",
    	samsung: "9",
    	electron: "3.1"
    },
    	"transform-parameters": {
    	chrome: "49",
    	opera: "36",
    	edge: "18",
    	firefox: "53",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"proposal-async-generator-functions": {
    	chrome: "63",
    	opera: "50",
    	edge: "79",
    	firefox: "57",
    	safari: "12",
    	node: "10",
    	ios: "12",
    	samsung: "8",
    	electron: "3.1"
    },
    	"proposal-object-rest-spread": {
    	chrome: "60",
    	opera: "47",
    	edge: "79",
    	firefox: "55",
    	safari: "11.1",
    	node: "8.3",
    	ios: "11.3",
    	samsung: "8",
    	electron: "2.1"
    },
    	"transform-dotall-regex": {
    	chrome: "62",
    	opera: "49",
    	edge: "79",
    	safari: "11.1",
    	node: "8.10",
    	ios: "11.3",
    	samsung: "8",
    	electron: "3.1"
    },
    	"proposal-unicode-property-regex": {
    	chrome: "64",
    	opera: "51",
    	edge: "79",
    	safari: "11.1",
    	node: "10",
    	ios: "11.3",
    	samsung: "9",
    	electron: "3.1"
    },
    	"transform-named-capturing-groups-regex": {
    	chrome: "64",
    	opera: "51",
    	edge: "79",
    	safari: "11.1",
    	node: "10",
    	ios: "11.3",
    	samsung: "9",
    	electron: "3.1"
    },
    	"transform-async-to-generator": {
    	chrome: "55",
    	opera: "42",
    	edge: "15",
    	firefox: "52",
    	safari: "11",
    	node: "7.6",
    	ios: "11",
    	samsung: "6",
    	electron: "1.6"
    },
    	"transform-exponentiation-operator": {
    	chrome: "52",
    	opera: "39",
    	edge: "14",
    	firefox: "52",
    	safari: "10.1",
    	node: "7",
    	ios: "10.3",
    	samsung: "6",
    	electron: "1.3"
    },
    	"transform-template-literals": {
    	chrome: "41",
    	opera: "28",
    	edge: "13",
    	firefox: "34",
    	safari: "13",
    	node: "4",
    	ios: "13",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"transform-literals": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "53",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"transform-function-name": {
    	chrome: "51",
    	opera: "38",
    	edge: "79",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"transform-arrow-functions": {
    	chrome: "47",
    	opera: "34",
    	edge: "13",
    	firefox: "45",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"transform-block-scoped-functions": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "46",
    	safari: "10",
    	node: "4",
    	ie: "11",
    	ios: "10",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"transform-classes": {
    	chrome: "46",
    	opera: "33",
    	edge: "13",
    	firefox: "45",
    	safari: "10",
    	node: "5",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"transform-object-super": {
    	chrome: "46",
    	opera: "33",
    	edge: "13",
    	firefox: "45",
    	safari: "10",
    	node: "5",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"transform-shorthand-properties": {
    	chrome: "43",
    	opera: "30",
    	edge: "12",
    	firefox: "33",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.29"
    },
    	"transform-duplicate-keys": {
    	chrome: "42",
    	opera: "29",
    	edge: "12",
    	firefox: "34",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.27"
    },
    	"transform-computed-properties": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "34",
    	safari: "7.1",
    	node: "4",
    	ios: "8",
    	samsung: "4",
    	electron: "0.31"
    },
    	"transform-for-of": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"transform-sticky-regex": {
    	chrome: "49",
    	opera: "36",
    	edge: "13",
    	firefox: "3",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"transform-unicode-regex": {
    	chrome: "50",
    	opera: "37",
    	edge: "13",
    	firefox: "46",
    	safari: "12",
    	node: "6",
    	ios: "12",
    	samsung: "5",
    	electron: "1.1"
    },
    	"transform-spread": {
    	chrome: "46",
    	opera: "33",
    	edge: "13",
    	firefox: "36",
    	safari: "10",
    	node: "5",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"transform-destructuring": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"transform-block-scoping": {
    	chrome: "49",
    	opera: "36",
    	edge: "14",
    	firefox: "51",
    	safari: "11",
    	node: "6",
    	ios: "11",
    	samsung: "5",
    	electron: "1"
    },
    	"transform-typeof-symbol": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "36",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "3",
    	electron: "0.2"
    },
    	"transform-new-target": {
    	chrome: "46",
    	opera: "33",
    	edge: "14",
    	firefox: "41",
    	safari: "10",
    	node: "5",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"transform-regenerator": {
    	chrome: "50",
    	opera: "37",
    	edge: "13",
    	firefox: "53",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"transform-member-expression-literals": {
    	chrome: "7",
    	opera: "12",
    	edge: "12",
    	firefox: "2",
    	safari: "5.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "5"
    },
    	"transform-property-literals": {
    	chrome: "7",
    	opera: "12",
    	edge: "12",
    	firefox: "2",
    	safari: "5.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "5"
    },
    	"transform-reserved-words": {
    	chrome: "13",
    	opera: "10.50",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4.4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "0.2"
    }
    };

    var plugins$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': plugins
    });

    var require$$0$4 = getCjsExportFromNamespace(plugins$1);

    var plugins$2 = require$$0$4;

    function targetsSupported(target, support) {
      var targetEnvironments = Object.keys(target);

      if (targetEnvironments.length === 0) {
        return false;
      }

      var unsupportedEnvironments = targetEnvironments.filter(function (environment) {
        var lowestImplementedVersion = getLowestImplementedVersion(support, environment);

        if (!lowestImplementedVersion) {
          return true;
        }

        var lowestTargetedVersion = target[environment];

        if (isUnreleasedVersion(lowestTargetedVersion, environment)) {
          return false;
        }

        if (isUnreleasedVersion(lowestImplementedVersion, environment)) {
          return true;
        }

        if (!semver.valid(lowestTargetedVersion.toString())) {
          throw new Error("Invalid version passed for target \"" + environment + "\": \"" + lowestTargetedVersion + "\". " + "Versions must be in semver format (major.minor.patch)");
        }

        return semver.gt(semverify(lowestImplementedVersion), lowestTargetedVersion.toString());
      });
      return unsupportedEnvironments.length === 0;
    }
    function isRequired(name, targets, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$compatData = _ref.compatData,
          compatData = _ref$compatData === void 0 ? plugins$2 : _ref$compatData,
          includes = _ref.includes,
          excludes = _ref.excludes;

      if (excludes && excludes.has(name)) return false;
      if (includes && includes.has(name)) return true;
      return !targetsSupported(targets, compatData[name]);
    }
    function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
      var result = new Set();
      var options = {
        compatData: list,
        includes: includes,
        excludes: excludes
      };

      for (var item in list) {
        if (isRequired(item, targets, options)) {
          result.add(item);
        } else if (pluginSyntaxMap) {
          var shippedProposalsSyntax = pluginSyntaxMap.get(item);

          if (shippedProposalsSyntax) {
            result.add(shippedProposalsSyntax);
          }
        }
      }

      if (defaultIncludes) {
        defaultIncludes.forEach(function (item) {
          return !excludes.has(item) && result.add(item);
        });
      }

      if (defaultExcludes) {
        defaultExcludes.forEach(function (item) {
          return !includes.has(item) && result["delete"](item);
        });
      }

      return result;
    }

    var browserslistDefaults = browserslist_1.defaults;
    var validBrowserslistTargets = [].concat(Object.keys(browserslist_1.data), Object.keys(browserslist_1.aliases));

    function objectToBrowserslist(object) {
      return Object.keys(object).reduce(function (list, targetName) {
        if (validBrowserslistTargets.indexOf(targetName) >= 0) {
          var targetVersion = object[targetName];
          return list.concat(targetName + " " + targetVersion);
        }

        return list;
      }, []);
    }

    function validateTargetNames(targets) {
      var validTargets = Object.keys(TargetNames);

      for (var target in targets) {
        if (!TargetNames[target]) {
          throw new Error("Invalid Option: '" + target + "' is not a valid target\n        Maybe you meant to use '" + levenArray(target, validTargets) + "'?");
        }
      }
    }

    function isBrowsersQueryValid(browsers) {
      return typeof browsers === "string" || Array.isArray(browsers);
    }

    function validateBrowsers(browsers) {
      browser$7(typeof browsers === "undefined" || isBrowsersQueryValid(browsers), "Invalid Option: '" + browsers + "' is not a valid browserslist query");
      return browsers;
    }

    function mergeBrowsers(fromQuery, fromTarget) {
      return Object.keys(fromTarget).reduce(function (queryObj, targKey) {
        if (targKey !== TargetNames.browsers) {
          queryObj[targKey] = fromTarget[targKey];
        }

        return queryObj;
      }, fromQuery);
    }

    function getLowestVersions(browsers) {
      return browsers.reduce(function (all, browser) {
        var _browser$split = browser.split(" "),
            browserName = _browser$split[0],
            browserVersion = _browser$split[1];

        var normalizedBrowserName = browserNameMap[browserName];

        if (!normalizedBrowserName) {
          return all;
        }

        try {
          var splitVersion = browserVersion.split("-")[0].toLowerCase();
          var isSplitUnreleased = isUnreleasedVersion(splitVersion, browserName);

          if (!all[normalizedBrowserName]) {
            all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : semverify(splitVersion);
            return all;
          }

          var version = all[normalizedBrowserName];
          var isUnreleased = isUnreleasedVersion(version, browserName);

          if (isUnreleased && isSplitUnreleased) {
            all[normalizedBrowserName] = getLowestUnreleased(version, splitVersion, browserName);
          } else if (isUnreleased) {
            all[normalizedBrowserName] = semverify(splitVersion);
          } else if (!isUnreleased && !isSplitUnreleased) {
            var parsedBrowserVersion = semverify(splitVersion);
            all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
          }
        } catch (e) {}

        return all;
      }, {});
    }

    function outputDecimalWarning(decimalTargets) {
      if (!decimalTargets || !decimalTargets.length) {
        return;
      }

      console.log("Warning, the following targets are using a decimal version:");
      console.log("");
      decimalTargets.forEach(function (_ref) {
        var target = _ref.target,
            value = _ref.value;
        return console.log("  " + target + ": " + value);
      });
      console.log("");
      console.log("We recommend using a string for minor/patch versions to avoid numbers like 6.10");
      console.log("getting parsed as 6.1, which can lead to unexpected behavior.");
      console.log("");
    }

    function semverifyTarget(target, value) {
      try {
        return semverify(value);
      } catch (error) {
        throw new Error("Invalid Option: '" + value + "' is not a valid value for 'targets." + target + "'.");
      }
    }

    var targetParserMap = {
      __default: function __default(target, value) {
        var version = isUnreleasedVersion(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
        return [target, version];
      },
      node: function node(target, value) {
        var parsed = value === true || value === "current" ? process.versions.node : semverifyTarget(target, value);
        return [target, parsed];
      }
    };
    function getTargets(targets, options) {
      if (targets === void 0) {
        targets = {};
      }

      if (options === void 0) {
        options = {};
      }

      var targetOpts = {};
      validateTargetNames(targets);

      if (targets.esmodules) {
        var supportsESModules = nativeModules$2["es6.module"];
        targets.browsers = Object.keys(supportsESModules).map(function (browser) {
          return browser + " " + supportsESModules[browser];
        }).join(", ");
      }

      delete targets.esmodules;
      var browsersquery = validateBrowsers(targets.browsers);
      var hasTargets = Object.keys(targets).length > 0;
      var shouldParseBrowsers = !!targets.browsers;
      var shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

      if (shouldParseBrowsers || shouldSearchForConfig) {
        if (!hasTargets) {
          browserslist_1.defaults = objectToBrowserslist(targets);
        }

        var browsers = browserslist_1(browsersquery, {
          path: options.configPath,
          mobileToDesktop: true
        });
        var queryBrowsers = getLowestVersions(browsers);
        targets = mergeBrowsers(queryBrowsers, targets);
        browserslist_1.defaults = browserslistDefaults;
      }

      var parsed = Object.keys(targets).filter(function (value) {
        return value !== TargetNames.esmodules;
      }).sort().reduce(function (results, target) {
        if (target !== TargetNames.browsers) {
          var value = targets[target];

          if (typeof value === "number" && value % 1 !== 0) {
            results.decimalWarnings.push({
              target: target,
              value: value
            });
          }

          var parser = targetParserMap[target] || targetParserMap.__default;

          var _parser = parser(target, value),
              parsedTarget = _parser[0],
              parsedValue = _parser[1];

          if (parsedValue) {
            results.targets[parsedTarget] = parsedValue;
          }
        }

        return results;
      }, {
        targets: targetOpts,
        decimalWarnings: []
      });
      outputDecimalWarning(parsed.decimalWarnings);
      return parsed.targets;
    }

    var wordEnds = function wordEnds(size) {
      return size > 1 ? "s" : "";
    };

    var logPluginOrPolyfill = function logPluginOrPolyfill(item, targetVersions, list) {
      var filteredList = getInclusionReasons(item, targetVersions, list);
      var formattedTargets = JSON.stringify(filteredList).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
      console.log("  " + item + " " + formattedTargets);
    };
    var logEntryPolyfills = function logEntryPolyfills(polyfillName, importPolyfillIncluded, polyfills, filename, polyfillTargets, allBuiltInsList) {
      if (process.env.BABEL_ENV === "test") {
        filename = filename.replace(/\\/g, "/");
      }

      if (!importPolyfillIncluded) {
        console.log("\n[" + filename + "] Import of " + polyfillName + " was not found.");
        return;
      }

      if (!polyfills.size) {
        console.log("\n[" + filename + "] Based on your targets, polyfills were not added.");
        return;
      }

      console.log("\n[" + filename + "] Replaced " + polyfillName + " entries with the following polyfill" + wordEnds(polyfills.size) + ":");

      for (var _iterator = _createForOfIteratorHelperLoose(polyfills), _step; !(_step = _iterator()).done;) {
        var polyfill = _step.value;
        logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
      }
    };
    var logUsagePolyfills = function logUsagePolyfills(polyfills, filename, polyfillTargets, allBuiltInsList) {
      if (process.env.BABEL_ENV === "test") {
        filename = filename.replace(/\\/g, "/");
      }

      if (!polyfills.size) {
        console.log("\n[" + filename + "] Based on your code and targets, core-js polyfills were not added.");
        return;
      }

      console.log("\n[" + filename + "] Added following core-js polyfill" + wordEnds(polyfills.size) + ":");

      for (var _iterator2 = _createForOfIteratorHelperLoose(polyfills), _step2; !(_step2 = _iterator2()).done;) {
        var polyfill = _step2.value;
        logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
      }
    };

    var defaultExcludesForLooseMode = ["transform-typeof-symbol"];
    function getOptionSpecificExcludesFor (_ref) {
      var loose = _ref.loose;
      return loose ? defaultExcludesForLooseMode : null;
    }

    function removeUnnecessaryItems(items, overlapping) {
      items.forEach(function (item) {
        var _overlapping$item;

        (_overlapping$item = overlapping[item]) == null ? void 0 : _overlapping$item.forEach(function (name) {
          return items["delete"](name);
        });
      });
    }

    var moduleTransformations = {
      auto: "transform-modules-commonjs",
      amd: "transform-modules-amd",
      commonjs: "transform-modules-commonjs",
      cjs: "transform-modules-commonjs",
      systemjs: "transform-modules-systemjs",
      umd: "transform-modules-umd"
    };

    var corejs3Polyfills = {
    	"es.symbol": {
    	chrome: "49",
    	edge: "15",
    	electron: "0.37",
    	firefox: "51",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.description": {
    	chrome: "70",
    	edge: "74",
    	electron: "5.0",
    	firefox: "63",
    	ios: "12.2",
    	node: "11.0",
    	opera: "57",
    	opera_mobile: "49",
    	safari: "12.1",
    	samsung: "10.0"
    },
    	"es.symbol.async-iterator": {
    	chrome: "63",
    	edge: "74",
    	electron: "3.0",
    	firefox: "55",
    	ios: "12.0",
    	node: "10.0",
    	opera: "50",
    	opera_mobile: "46",
    	safari: "12.0",
    	samsung: "8.0"
    },
    	"es.symbol.has-instance": {
    	chrome: "50",
    	edge: "15",
    	electron: "1.1",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.is-concat-spreadable": {
    	chrome: "48",
    	edge: "15",
    	electron: "0.37",
    	firefox: "48",
    	ios: "10.0",
    	node: "6.0",
    	opera: "35",
    	opera_mobile: "35",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.iterator": {
    	chrome: "39",
    	edge: "13",
    	electron: "0.20",
    	firefox: "36",
    	ios: "9.0",
    	node: "1.0",
    	opera: "26",
    	opera_mobile: "26",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.symbol.match": {
    	chrome: "50",
    	edge: "74",
    	electron: "1.1",
    	firefox: "40",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.match-all": {
    	chrome: "73",
    	edge: "74",
    	electron: "5.0",
    	firefox: "67",
    	ios: "13.0",
    	node: "12.0",
    	opera: "60",
    	opera_mobile: "52",
    	safari: "13",
    	samsung: "11.0"
    },
    	"es.symbol.replace": {
    	chrome: "50",
    	edge: "74",
    	electron: "1.1",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.search": {
    	chrome: "50",
    	edge: "74",
    	electron: "1.1",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.species": {
    	chrome: "51",
    	edge: "13",
    	electron: "1.2",
    	firefox: "41",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.split": {
    	chrome: "50",
    	edge: "74",
    	electron: "1.1",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.to-primitive": {
    	chrome: "47",
    	edge: "15",
    	electron: "0.36",
    	firefox: "44",
    	ios: "10.0",
    	node: "6.0",
    	opera: "34",
    	opera_mobile: "34",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.to-string-tag": {
    	chrome: "49",
    	edge: "15",
    	electron: "0.37",
    	firefox: "51",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.symbol.unscopables": {
    	chrome: "39",
    	edge: "13",
    	electron: "0.20",
    	firefox: "48",
    	ios: "9.0",
    	node: "1.0",
    	opera: "26",
    	opera_mobile: "26",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.array.concat": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "48",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.array.copy-within": {
    	chrome: "45",
    	edge: "12",
    	electron: "0.31",
    	firefox: "48",
    	ios: "9.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.every": {
    	chrome: "48",
    	edge: "15",
    	electron: "0.37",
    	firefox: "50",
    	ios: "9.0",
    	node: "6.0",
    	opera: "35",
    	opera_mobile: "35",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.fill": {
    	chrome: "45",
    	edge: "12",
    	electron: "0.31",
    	firefox: "48",
    	ios: "9.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.filter": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "48",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.array.find": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "48",
    	ios: "9.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.find-index": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "48",
    	ios: "9.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.flat": {
    	chrome: "69",
    	edge: "74",
    	electron: "4.0",
    	firefox: "62",
    	ios: "12.0",
    	node: "11.0",
    	opera: "56",
    	opera_mobile: "48",
    	safari: "12.0",
    	samsung: "10.0"
    },
    	"es.array.flat-map": {
    	chrome: "69",
    	edge: "74",
    	electron: "4.0",
    	firefox: "62",
    	ios: "12.0",
    	node: "11.0",
    	opera: "56",
    	opera_mobile: "48",
    	safari: "12.0",
    	samsung: "10.0"
    },
    	"es.array.for-each": {
    	chrome: "48",
    	edge: "15",
    	electron: "0.37",
    	firefox: "50",
    	ios: "9.0",
    	node: "6.0",
    	opera: "35",
    	opera_mobile: "35",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.from": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "53",
    	ios: "9.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.includes": {
    	chrome: "53",
    	edge: "15",
    	electron: "1.4",
    	firefox: "48",
    	ios: "10.0",
    	node: "7.0",
    	opera: "40",
    	opera_mobile: "40",
    	safari: "10.0",
    	samsung: "6.0"
    },
    	"es.array.index-of": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "50",
    	ios: "11.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "11.0",
    	samsung: "5.0"
    },
    	"es.array.is-array": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "9",
    	ios: "3.2",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "4.0",
    	samsung: "1.0"
    },
    	"es.array.iterator": {
    	chrome: "66",
    	edge: "15",
    	electron: "3.0",
    	firefox: "60",
    	ios: "10.0",
    	node: "10.0",
    	opera: "53",
    	opera_mobile: "47",
    	safari: "10.0",
    	samsung: "9.0"
    },
    	"es.array.join": {
    	android: "4.4",
    	chrome: "26",
    	edge: "13",
    	electron: "0.20",
    	firefox: "4",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.array.last-index-of": {
    	chrome: "51",
    	edge: "13",
    	electron: "1.2",
    	firefox: "50",
    	ios: "11.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "11.0",
    	samsung: "5.0"
    },
    	"es.array.map": {
    	chrome: "51",
    	edge: "13",
    	electron: "1.2",
    	firefox: "50",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.array.of": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "25",
    	ios: "9.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.reduce": {
    	chrome: "48",
    	edge: "15",
    	electron: "0.37",
    	firefox: "50",
    	ios: "9.0",
    	node: "6.0",
    	opera: "35",
    	opera_mobile: "35",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.reduce-right": {
    	chrome: "48",
    	edge: "15",
    	electron: "0.37",
    	firefox: "50",
    	ios: "9.0",
    	node: "6.0",
    	opera: "35",
    	opera_mobile: "35",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.reverse": {
    	android: "3.0",
    	chrome: "1",
    	edge: "12",
    	electron: "0.20",
    	firefox: "1",
    	ie: "5.5",
    	ios: "12.2",
    	node: "0.0.3",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	safari: "12.0.2",
    	samsung: "1.0"
    },
    	"es.array.slice": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "48",
    	ios: "11.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "11.0",
    	samsung: "5.0"
    },
    	"es.array.some": {
    	chrome: "48",
    	edge: "15",
    	electron: "0.37",
    	firefox: "50",
    	ios: "9.0",
    	node: "6.0",
    	opera: "35",
    	opera_mobile: "35",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.array.sort": {
    	chrome: "63",
    	edge: "12",
    	electron: "3.0",
    	firefox: "4",
    	ie: "9",
    	ios: "12.0",
    	node: "10.0",
    	opera: "50",
    	opera_mobile: "46",
    	safari: "12.0",
    	samsung: "8.0"
    },
    	"es.array.species": {
    	chrome: "51",
    	edge: "13",
    	electron: "1.2",
    	firefox: "48",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.array.splice": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "49",
    	ios: "11.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "11.0",
    	samsung: "5.0"
    },
    	"es.array.unscopables.flat": {
    	chrome: "73",
    	edge: "74",
    	electron: "5.0",
    	firefox: "67",
    	ios: "13.0",
    	node: "12.0",
    	opera: "60",
    	opera_mobile: "52",
    	safari: "13",
    	samsung: "11.0"
    },
    	"es.array.unscopables.flat-map": {
    	chrome: "73",
    	edge: "74",
    	electron: "5.0",
    	firefox: "67",
    	ios: "13.0",
    	node: "12.0",
    	opera: "60",
    	opera_mobile: "52",
    	safari: "13",
    	samsung: "11.0"
    },
    	"es.array-buffer.constructor": {
    	android: "4.4",
    	chrome: "26",
    	edge: "14",
    	electron: "0.20",
    	firefox: "44",
    	ios: "12.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "12.0",
    	samsung: "1.5"
    },
    	"es.array-buffer.is-view": {
    	android: "4.4.3",
    	chrome: "32",
    	edge: "12",
    	electron: "0.20",
    	firefox: "29",
    	ie: "11",
    	ios: "8.0",
    	node: "0.11.9",
    	opera: "19",
    	opera_mobile: "19",
    	safari: "7.1",
    	samsung: "2.0"
    },
    	"es.array-buffer.slice": {
    	android: "4.4.3",
    	chrome: "31",
    	edge: "12",
    	electron: "0.20",
    	firefox: "46",
    	ie: "11",
    	ios: "12.2",
    	node: "0.11.8",
    	opera: "18",
    	opera_mobile: "18",
    	safari: "12.1",
    	samsung: "2.0"
    },
    	"es.data-view": {
    	android: "4.4",
    	chrome: "26",
    	edge: "12",
    	electron: "0.20",
    	firefox: "15",
    	ie: "10",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.date.now": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ie: "9",
    	ios: "3.2",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "4.0",
    	samsung: "1.0"
    },
    	"es.date.to-iso-string": {
    	android: "4.4",
    	chrome: "26",
    	edge: "12",
    	electron: "0.20",
    	firefox: "7",
    	ie: "9",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.date.to-json": {
    	android: "4.4",
    	chrome: "26",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "9",
    	ios: "10.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "10.0",
    	samsung: "1.5"
    },
    	"es.date.to-primitive": {
    	chrome: "47",
    	edge: "15",
    	electron: "0.36",
    	firefox: "44",
    	ios: "10.0",
    	node: "6.0",
    	opera: "34",
    	opera_mobile: "34",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.date.to-string": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ie: "9",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.function.bind": {
    	android: "3.0",
    	chrome: "7",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "9",
    	ios: "5.1",
    	node: "0.1.101",
    	opera: "12",
    	opera_mobile: "12",
    	phantom: "2.0",
    	safari: "5.1",
    	samsung: "1.0"
    },
    	"es.function.has-instance": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "50",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.function.name": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "3.2",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "4.0",
    	samsung: "1.0"
    },
    	"es.global-this": {
    	chrome: "71",
    	edge: "74",
    	electron: "5.0",
    	firefox: "65",
    	ios: "12.2",
    	node: "12.0",
    	opera: "58",
    	opera_mobile: "50",
    	safari: "12.1",
    	samsung: "10.0"
    },
    	"es.json.stringify": {
    	chrome: "72",
    	edge: "74",
    	electron: "5.0",
    	firefox: "64",
    	ios: "12.2",
    	node: "12.0",
    	opera: "59",
    	opera_mobile: "51",
    	safari: "12.1",
    	samsung: "11.0"
    },
    	"es.json.to-string-tag": {
    	chrome: "50",
    	edge: "15",
    	electron: "1.1",
    	firefox: "51",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.map": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "53",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.math.acosh": {
    	chrome: "54",
    	edge: "13",
    	electron: "1.4",
    	firefox: "25",
    	ios: "8.0",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	safari: "7.1",
    	samsung: "6.0"
    },
    	"es.math.asinh": {
    	chrome: "38",
    	edge: "13",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.atanh": {
    	chrome: "38",
    	edge: "13",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.cbrt": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.clz32": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "31",
    	ios: "9.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "9.0",
    	samsung: "3.0"
    },
    	"es.math.cosh": {
    	chrome: "39",
    	edge: "13",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "1.0",
    	opera: "26",
    	opera_mobile: "26",
    	safari: "7.1",
    	samsung: "3.4"
    },
    	"es.math.expm1": {
    	chrome: "39",
    	edge: "13",
    	electron: "0.20",
    	firefox: "46",
    	ios: "8.0",
    	node: "1.0",
    	opera: "26",
    	opera_mobile: "26",
    	safari: "7.1",
    	samsung: "3.4"
    },
    	"es.math.fround": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "26",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.hypot": {
    	chrome: "78",
    	edge: "12",
    	electron: "7.0",
    	firefox: "27",
    	ios: "8.0",
    	node: "13.0",
    	opera: "65",
    	safari: "7.1"
    },
    	"es.math.imul": {
    	android: "4.4",
    	chrome: "28",
    	edge: "13",
    	electron: "0.20",
    	firefox: "20",
    	ios: "9.0",
    	node: "0.11.1",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "9.0",
    	samsung: "1.5"
    },
    	"es.math.log10": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.log1p": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.log2": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.sign": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "9.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "9.0",
    	samsung: "3.0"
    },
    	"es.math.sinh": {
    	chrome: "39",
    	edge: "13",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "1.0",
    	opera: "26",
    	opera_mobile: "26",
    	safari: "7.1",
    	samsung: "3.4"
    },
    	"es.math.tanh": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.math.to-string-tag": {
    	chrome: "50",
    	edge: "15",
    	electron: "1.1",
    	firefox: "51",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.math.trunc": {
    	chrome: "38",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "8.0",
    	node: "0.11.15",
    	opera: "25",
    	opera_mobile: "25",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.number.constructor": {
    	chrome: "41",
    	edge: "13",
    	electron: "0.21",
    	firefox: "46",
    	ios: "9.0",
    	node: "1.0",
    	opera: "28",
    	opera_mobile: "28",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.number.epsilon": {
    	chrome: "34",
    	edge: "12",
    	electron: "0.20",
    	firefox: "25",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "21",
    	opera_mobile: "21",
    	safari: "9.0",
    	samsung: "2.0"
    },
    	"es.number.is-finite": {
    	android: "4.1",
    	chrome: "19",
    	edge: "12",
    	electron: "0.20",
    	firefox: "16",
    	ios: "9.0",
    	node: "0.7.3",
    	opera: "15",
    	opera_mobile: "15",
    	safari: "9.0",
    	samsung: "1.5"
    },
    	"es.number.is-integer": {
    	chrome: "34",
    	edge: "12",
    	electron: "0.20",
    	firefox: "16",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "21",
    	opera_mobile: "21",
    	safari: "9.0",
    	samsung: "2.0"
    },
    	"es.number.is-nan": {
    	android: "4.1",
    	chrome: "19",
    	edge: "12",
    	electron: "0.20",
    	firefox: "15",
    	ios: "9.0",
    	node: "0.7.3",
    	opera: "15",
    	opera_mobile: "15",
    	safari: "9.0",
    	samsung: "1.5"
    },
    	"es.number.is-safe-integer": {
    	chrome: "34",
    	edge: "12",
    	electron: "0.20",
    	firefox: "32",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "21",
    	opera_mobile: "21",
    	safari: "9.0",
    	samsung: "2.0"
    },
    	"es.number.max-safe-integer": {
    	chrome: "34",
    	edge: "12",
    	electron: "0.20",
    	firefox: "31",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "21",
    	opera_mobile: "21",
    	safari: "9.0",
    	samsung: "2.0"
    },
    	"es.number.min-safe-integer": {
    	chrome: "34",
    	edge: "12",
    	electron: "0.20",
    	firefox: "31",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "21",
    	opera_mobile: "21",
    	safari: "9.0",
    	samsung: "2.0"
    },
    	"es.number.parse-float": {
    	chrome: "35",
    	edge: "13",
    	electron: "0.20",
    	firefox: "39",
    	ios: "11.0",
    	node: "0.11.13",
    	opera: "22",
    	opera_mobile: "22",
    	safari: "11.0",
    	samsung: "3.0"
    },
    	"es.number.parse-int": {
    	chrome: "35",
    	edge: "13",
    	electron: "0.20",
    	firefox: "39",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "22",
    	opera_mobile: "22",
    	safari: "9.0",
    	samsung: "3.0"
    },
    	"es.number.to-fixed": {
    	android: "4.4",
    	chrome: "26",
    	edge: "74",
    	electron: "0.20",
    	firefox: "4",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.number.to-precision": {
    	android: "4.4",
    	chrome: "26",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "8",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.object.assign": {
    	chrome: "49",
    	edge: "74",
    	electron: "0.37",
    	firefox: "36",
    	ios: "9.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.object.create": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "9",
    	ios: "3.2",
    	node: "0.1.27",
    	opera: "12",
    	opera_mobile: "12",
    	phantom: "1.9",
    	safari: "4.0",
    	samsung: "1.0"
    },
    	"es.object.define-getter": {
    	chrome: "62",
    	edge: "16",
    	electron: "3.0",
    	firefox: "48",
    	ios: "8.0",
    	node: "8.10",
    	opera: "49",
    	opera_mobile: "46",
    	safari: "7.1",
    	samsung: "8.0"
    },
    	"es.object.define-properties": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "9",
    	ios: "5.1",
    	node: "0.1.27",
    	opera: "12",
    	opera_mobile: "12",
    	phantom: "2.0",
    	safari: "5.1",
    	samsung: "1.0"
    },
    	"es.object.define-property": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "4",
    	ie: "9",
    	ios: "5.1",
    	node: "0.1.27",
    	opera: "12",
    	opera_mobile: "12",
    	phantom: "2.0",
    	safari: "5.1",
    	samsung: "1.0"
    },
    	"es.object.define-setter": {
    	chrome: "62",
    	edge: "16",
    	electron: "3.0",
    	firefox: "48",
    	ios: "8.0",
    	node: "8.10",
    	opera: "49",
    	opera_mobile: "46",
    	safari: "7.1",
    	samsung: "8.0"
    },
    	"es.object.entries": {
    	chrome: "54",
    	edge: "14",
    	electron: "1.4",
    	firefox: "47",
    	ios: "10.3",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	safari: "10.1",
    	samsung: "6.0"
    },
    	"es.object.freeze": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.from-entries": {
    	chrome: "73",
    	edge: "74",
    	electron: "5.0",
    	firefox: "63",
    	ios: "12.2",
    	node: "12.0",
    	opera: "60",
    	opera_mobile: "52",
    	safari: "12.1",
    	samsung: "11.0"
    },
    	"es.object.get-own-property-descriptor": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.get-own-property-descriptors": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "50",
    	ios: "10.0",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	safari: "10.0",
    	samsung: "6.0"
    },
    	"es.object.get-own-property-names": {
    	chrome: "40",
    	edge: "13",
    	electron: "0.21",
    	firefox: "34",
    	ios: "9.0",
    	node: "1.0",
    	opera: "27",
    	opera_mobile: "27",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.object.get-prototype-of": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.is": {
    	android: "4.1",
    	chrome: "19",
    	edge: "12",
    	electron: "0.20",
    	firefox: "22",
    	ios: "9.0",
    	node: "0.7.3",
    	opera: "15",
    	opera_mobile: "15",
    	safari: "9.0",
    	samsung: "1.5"
    },
    	"es.object.is-extensible": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.is-frozen": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.is-sealed": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.keys": {
    	chrome: "40",
    	edge: "13",
    	electron: "0.21",
    	firefox: "35",
    	ios: "9.0",
    	node: "1.0",
    	opera: "27",
    	opera_mobile: "27",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.object.lookup-getter": {
    	chrome: "62",
    	edge: "16",
    	electron: "3.0",
    	firefox: "48",
    	ios: "8.0",
    	node: "8.10",
    	opera: "49",
    	opera_mobile: "46",
    	safari: "7.1",
    	samsung: "8.0"
    },
    	"es.object.lookup-setter": {
    	chrome: "62",
    	edge: "16",
    	electron: "3.0",
    	firefox: "48",
    	ios: "8.0",
    	node: "8.10",
    	opera: "49",
    	opera_mobile: "46",
    	safari: "7.1",
    	samsung: "8.0"
    },
    	"es.object.prevent-extensions": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.seal": {
    	chrome: "44",
    	edge: "13",
    	electron: "0.30",
    	firefox: "35",
    	ios: "9.0",
    	node: "3.0",
    	opera: "31",
    	opera_mobile: "31",
    	safari: "9.0",
    	samsung: "4.0"
    },
    	"es.object.set-prototype-of": {
    	chrome: "34",
    	edge: "12",
    	electron: "0.20",
    	firefox: "31",
    	ie: "11",
    	ios: "9.0",
    	node: "0.11.13",
    	opera: "21",
    	opera_mobile: "21",
    	safari: "9.0",
    	samsung: "2.0"
    },
    	"es.object.to-string": {
    	chrome: "49",
    	edge: "15",
    	electron: "0.37",
    	firefox: "51",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.object.values": {
    	chrome: "54",
    	edge: "14",
    	electron: "1.4",
    	firefox: "47",
    	ios: "10.3",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	safari: "10.1",
    	samsung: "6.0"
    },
    	"es.parse-float": {
    	chrome: "35",
    	edge: "12",
    	electron: "0.20",
    	firefox: "8",
    	ie: "8",
    	ios: "8.0",
    	node: "0.11.13",
    	opera: "22",
    	opera_mobile: "22",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.parse-int": {
    	chrome: "35",
    	edge: "12",
    	electron: "0.20",
    	firefox: "21",
    	ie: "9",
    	ios: "8.0",
    	node: "0.11.13",
    	opera: "22",
    	opera_mobile: "22",
    	safari: "7.1",
    	samsung: "3.0"
    },
    	"es.promise": {
    	chrome: "67",
    	edge: "74",
    	electron: "4.0",
    	firefox: "69",
    	ios: "11.0",
    	node: "10.4",
    	opera: "54",
    	opera_mobile: "48",
    	safari: "11.0",
    	samsung: "9.0"
    },
    	"es.promise.all-settled": {
    	chrome: "76",
    	edge: "76",
    	electron: "6.0",
    	firefox: "71",
    	ios: "13.0",
    	node: "12.9",
    	opera: "63",
    	opera_mobile: "54",
    	safari: "13"
    },
    	"es.promise.finally": {
    	chrome: "67",
    	edge: "74",
    	electron: "4.0",
    	firefox: "69",
    	ios: "13.2.3",
    	node: "10.4",
    	opera: "54",
    	opera_mobile: "48",
    	safari: "13.0.3",
    	samsung: "9.0"
    },
    	"es.reflect.apply": {
    	chrome: "49",
    	edge: "15",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.construct": {
    	chrome: "49",
    	edge: "15",
    	electron: "0.37",
    	firefox: "44",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.define-property": {
    	chrome: "49",
    	edge: "13",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.delete-property": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.get": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.get-own-property-descriptor": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.get-prototype-of": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.has": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.is-extensible": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.own-keys": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.prevent-extensions": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.set": {
    	chrome: "49",
    	edge: "74",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.reflect.set-prototype-of": {
    	chrome: "49",
    	edge: "12",
    	electron: "0.37",
    	firefox: "42",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.regexp.constructor": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.regexp.exec": {
    	android: "4.4",
    	chrome: "26",
    	edge: "13",
    	electron: "0.20",
    	firefox: "44",
    	ios: "10.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "10.0",
    	samsung: "1.5"
    },
    	"es.regexp.flags": {
    	chrome: "49",
    	edge: "74",
    	electron: "0.37",
    	firefox: "37",
    	ios: "9.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "9.0",
    	samsung: "5.0"
    },
    	"es.regexp.sticky": {
    	chrome: "49",
    	edge: "13",
    	electron: "0.37",
    	firefox: "3",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.regexp.test": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "46",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.regexp.to-string": {
    	chrome: "50",
    	edge: "74",
    	electron: "1.1",
    	firefox: "46",
    	ios: "10.0",
    	node: "6.0",
    	opera: "37",
    	opera_mobile: "37",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.set": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "53",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.string.code-point-at": {
    	chrome: "41",
    	edge: "13",
    	electron: "0.21",
    	firefox: "29",
    	ios: "9.0",
    	node: "1.0",
    	opera: "28",
    	opera_mobile: "28",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.string.ends-with": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "40",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.string.from-code-point": {
    	chrome: "41",
    	edge: "13",
    	electron: "0.21",
    	firefox: "29",
    	ios: "9.0",
    	node: "1.0",
    	opera: "28",
    	opera_mobile: "28",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.string.includes": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "40",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.string.iterator": {
    	chrome: "39",
    	edge: "13",
    	electron: "0.20",
    	firefox: "36",
    	ios: "9.0",
    	node: "1.0",
    	opera: "26",
    	opera_mobile: "26",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.string.match": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.string.match-all": {
    	chrome: "80",
    	edge: "80",
    	electron: "8.0",
    	firefox: "73",
    	opera: "67",
    	safari: "13.1"
    },
    	"es.string.pad-end": {
    	chrome: "57",
    	edge: "15",
    	electron: "1.7",
    	firefox: "48",
    	ios: "11.0",
    	node: "8.0",
    	opera: "44",
    	opera_mobile: "43",
    	safari: "11.0",
    	samsung: "7.0"
    },
    	"es.string.pad-start": {
    	chrome: "57",
    	edge: "15",
    	electron: "1.7",
    	firefox: "48",
    	ios: "11.0",
    	node: "8.0",
    	opera: "44",
    	opera_mobile: "43",
    	safari: "11.0",
    	samsung: "7.0"
    },
    	"es.string.raw": {
    	chrome: "41",
    	edge: "13",
    	electron: "0.21",
    	firefox: "34",
    	ios: "9.0",
    	node: "1.0",
    	opera: "28",
    	opera_mobile: "28",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.string.repeat": {
    	chrome: "41",
    	edge: "13",
    	electron: "0.21",
    	firefox: "24",
    	ios: "9.0",
    	node: "1.0",
    	opera: "28",
    	opera_mobile: "28",
    	safari: "9.0",
    	samsung: "3.4"
    },
    	"es.string.replace": {
    	chrome: "64",
    	edge: "74",
    	electron: "3.0",
    	node: "10.0",
    	opera: "51",
    	opera_mobile: "47",
    	samsung: "9.0"
    },
    	"es.string.search": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "49",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.string.split": {
    	chrome: "54",
    	edge: "74",
    	electron: "1.4",
    	firefox: "49",
    	ios: "10.0",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	safari: "10.0",
    	samsung: "6.0"
    },
    	"es.string.starts-with": {
    	chrome: "51",
    	edge: "74",
    	electron: "1.2",
    	firefox: "40",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.string.trim": {
    	chrome: "59",
    	edge: "15",
    	electron: "1.8",
    	firefox: "52",
    	ios: "12.2",
    	node: "8.3",
    	opera: "46",
    	opera_mobile: "43",
    	safari: "12.1",
    	samsung: "7.0"
    },
    	"es.string.trim-end": {
    	chrome: "66",
    	edge: "74",
    	electron: "3.0",
    	firefox: "61",
    	ios: "12.2",
    	node: "10.0",
    	opera: "53",
    	opera_mobile: "47",
    	safari: "12.1",
    	samsung: "9.0"
    },
    	"es.string.trim-start": {
    	chrome: "66",
    	edge: "74",
    	electron: "3.0",
    	firefox: "61",
    	ios: "12.0",
    	node: "10.0",
    	opera: "53",
    	opera_mobile: "47",
    	safari: "12.0",
    	samsung: "9.0"
    },
    	"es.string.anchor": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "17",
    	ios: "6.0",
    	node: "0.1.27",
    	opera: "15",
    	opera_mobile: "15",
    	phantom: "2.0",
    	safari: "6.0",
    	samsung: "1.0"
    },
    	"es.string.big": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.blink": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.bold": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.fixed": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.fontcolor": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "17",
    	ios: "6.0",
    	node: "0.1.27",
    	opera: "15",
    	opera_mobile: "15",
    	phantom: "2.0",
    	safari: "6.0",
    	samsung: "1.0"
    },
    	"es.string.fontsize": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "17",
    	ios: "6.0",
    	node: "0.1.27",
    	opera: "15",
    	opera_mobile: "15",
    	phantom: "2.0",
    	safari: "6.0",
    	samsung: "1.0"
    },
    	"es.string.italics": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.link": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "17",
    	ios: "6.0",
    	node: "0.1.27",
    	opera: "15",
    	opera_mobile: "15",
    	phantom: "2.0",
    	safari: "6.0",
    	samsung: "1.0"
    },
    	"es.string.small": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.strike": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.sub": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.string.sup": {
    	android: "3.0",
    	chrome: "5",
    	edge: "12",
    	electron: "0.20",
    	firefox: "2",
    	ios: "2.0",
    	node: "0.1.27",
    	opera: "10.50",
    	opera_mobile: "10.50",
    	phantom: "1.9",
    	safari: "3.1",
    	samsung: "1.0"
    },
    	"es.typed-array.float32-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.float64-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.int8-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.int16-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.int32-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.uint8-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.uint8-clamped-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.uint16-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.uint32-array": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.copy-within": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "34",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.every": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.fill": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.filter": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "38",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.find": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.find-index": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.for-each": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "38",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.from": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.includes": {
    	chrome: "49",
    	edge: "14",
    	electron: "0.37",
    	firefox: "43",
    	ios: "10.0",
    	node: "6.0",
    	opera: "36",
    	opera_mobile: "36",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.index-of": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.iterator": {
    	chrome: "47",
    	edge: "13",
    	electron: "0.36",
    	firefox: "37",
    	ios: "10.0",
    	node: "6.0",
    	opera: "34",
    	opera_mobile: "34",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.join": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.last-index-of": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.map": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "38",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.of": {
    	chrome: "54",
    	edge: "15",
    	electron: "1.4",
    	firefox: "55",
    	node: "7.0",
    	opera: "41",
    	opera_mobile: "41",
    	samsung: "6.0"
    },
    	"es.typed-array.reduce": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.reduce-right": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.reverse": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.set": {
    	android: "4.4",
    	chrome: "26",
    	edge: "13",
    	electron: "0.20",
    	firefox: "15",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.typed-array.slice": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "38",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.some": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "37",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.sort": {
    	chrome: "45",
    	edge: "13",
    	electron: "0.31",
    	firefox: "46",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.subarray": {
    	android: "4.4",
    	chrome: "26",
    	edge: "13",
    	electron: "0.20",
    	firefox: "15",
    	ios: "8.0",
    	node: "0.11.0",
    	opera: "16",
    	opera_mobile: "16",
    	safari: "7.1",
    	samsung: "1.5"
    },
    	"es.typed-array.to-locale-string": {
    	chrome: "45",
    	edge: "74",
    	electron: "0.31",
    	firefox: "51",
    	ios: "10.0",
    	node: "4.0",
    	opera: "32",
    	opera_mobile: "32",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.typed-array.to-string": {
    	chrome: "51",
    	edge: "13",
    	electron: "1.2",
    	firefox: "51",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.weak-map": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "53",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"es.weak-set": {
    	chrome: "51",
    	edge: "15",
    	electron: "1.2",
    	firefox: "53",
    	ios: "10.0",
    	node: "6.5",
    	opera: "38",
    	opera_mobile: "38",
    	safari: "10.0",
    	samsung: "5.0"
    },
    	"esnext.aggregate-error": {
    },
    	"esnext.array.is-template-object": {
    },
    	"esnext.array.last-index": {
    },
    	"esnext.array.last-item": {
    },
    	"esnext.async-iterator.constructor": {
    },
    	"esnext.async-iterator.as-indexed-pairs": {
    },
    	"esnext.async-iterator.drop": {
    },
    	"esnext.async-iterator.every": {
    },
    	"esnext.async-iterator.filter": {
    },
    	"esnext.async-iterator.find": {
    },
    	"esnext.async-iterator.flat-map": {
    },
    	"esnext.async-iterator.for-each": {
    },
    	"esnext.async-iterator.from": {
    },
    	"esnext.async-iterator.map": {
    },
    	"esnext.async-iterator.reduce": {
    },
    	"esnext.async-iterator.some": {
    },
    	"esnext.async-iterator.take": {
    },
    	"esnext.async-iterator.to-array": {
    },
    	"esnext.composite-key": {
    },
    	"esnext.composite-symbol": {
    },
    	"esnext.global-this": {
    	chrome: "71",
    	edge: "74",
    	electron: "5.0",
    	firefox: "65",
    	ios: "12.2",
    	node: "12.0",
    	opera: "58",
    	opera_mobile: "50",
    	safari: "12.1",
    	samsung: "10.0"
    },
    	"esnext.iterator.constructor": {
    },
    	"esnext.iterator.as-indexed-pairs": {
    },
    	"esnext.iterator.drop": {
    },
    	"esnext.iterator.every": {
    },
    	"esnext.iterator.filter": {
    },
    	"esnext.iterator.find": {
    },
    	"esnext.iterator.flat-map": {
    },
    	"esnext.iterator.for-each": {
    },
    	"esnext.iterator.from": {
    },
    	"esnext.iterator.map": {
    },
    	"esnext.iterator.reduce": {
    },
    	"esnext.iterator.some": {
    },
    	"esnext.iterator.take": {
    },
    	"esnext.iterator.to-array": {
    },
    	"esnext.map.delete-all": {
    },
    	"esnext.map.every": {
    },
    	"esnext.map.filter": {
    },
    	"esnext.map.find": {
    },
    	"esnext.map.find-key": {
    },
    	"esnext.map.from": {
    },
    	"esnext.map.group-by": {
    },
    	"esnext.map.includes": {
    },
    	"esnext.map.key-by": {
    },
    	"esnext.map.key-of": {
    },
    	"esnext.map.map-keys": {
    },
    	"esnext.map.map-values": {
    },
    	"esnext.map.merge": {
    },
    	"esnext.map.of": {
    },
    	"esnext.map.reduce": {
    },
    	"esnext.map.some": {
    },
    	"esnext.map.update": {
    },
    	"esnext.map.update-or-insert": {
    },
    	"esnext.map.upsert": {
    },
    	"esnext.math.clamp": {
    },
    	"esnext.math.deg-per-rad": {
    },
    	"esnext.math.degrees": {
    },
    	"esnext.math.fscale": {
    },
    	"esnext.math.iaddh": {
    },
    	"esnext.math.imulh": {
    },
    	"esnext.math.isubh": {
    },
    	"esnext.math.rad-per-deg": {
    },
    	"esnext.math.radians": {
    },
    	"esnext.math.scale": {
    },
    	"esnext.math.seeded-prng": {
    },
    	"esnext.math.signbit": {
    },
    	"esnext.math.umulh": {
    },
    	"esnext.number.from-string": {
    },
    	"esnext.object.iterate-entries": {
    },
    	"esnext.object.iterate-keys": {
    },
    	"esnext.object.iterate-values": {
    },
    	"esnext.observable": {
    },
    	"esnext.promise.all-settled": {
    	chrome: "76",
    	edge: "76",
    	electron: "6.0",
    	firefox: "71",
    	ios: "13.0",
    	node: "12.9",
    	opera: "63",
    	opera_mobile: "54",
    	safari: "13"
    },
    	"esnext.promise.any": {
    },
    	"esnext.promise.try": {
    },
    	"esnext.reflect.define-metadata": {
    },
    	"esnext.reflect.delete-metadata": {
    },
    	"esnext.reflect.get-metadata": {
    },
    	"esnext.reflect.get-metadata-keys": {
    },
    	"esnext.reflect.get-own-metadata": {
    },
    	"esnext.reflect.get-own-metadata-keys": {
    },
    	"esnext.reflect.has-metadata": {
    },
    	"esnext.reflect.has-own-metadata": {
    },
    	"esnext.reflect.metadata": {
    },
    	"esnext.set.add-all": {
    },
    	"esnext.set.delete-all": {
    },
    	"esnext.set.difference": {
    },
    	"esnext.set.every": {
    },
    	"esnext.set.filter": {
    },
    	"esnext.set.find": {
    },
    	"esnext.set.from": {
    },
    	"esnext.set.intersection": {
    },
    	"esnext.set.is-disjoint-from": {
    },
    	"esnext.set.is-subset-of": {
    },
    	"esnext.set.is-superset-of": {
    },
    	"esnext.set.join": {
    },
    	"esnext.set.map": {
    },
    	"esnext.set.of": {
    },
    	"esnext.set.reduce": {
    },
    	"esnext.set.some": {
    },
    	"esnext.set.symmetric-difference": {
    },
    	"esnext.set.union": {
    },
    	"esnext.string.at": {
    },
    	"esnext.string.code-points": {
    },
    	"esnext.string.match-all": {
    	chrome: "80",
    	edge: "80",
    	electron: "8.0",
    	firefox: "73",
    	opera: "67",
    	safari: "13.1"
    },
    	"esnext.string.replace-all": {
    },
    	"esnext.symbol.async-dispose": {
    },
    	"esnext.symbol.dispose": {
    },
    	"esnext.symbol.observable": {
    },
    	"esnext.symbol.pattern-match": {
    },
    	"esnext.symbol.replace-all": {
    },
    	"esnext.weak-map.delete-all": {
    },
    	"esnext.weak-map.from": {
    },
    	"esnext.weak-map.of": {
    },
    	"esnext.weak-map.upsert": {
    },
    	"esnext.weak-set.add-all": {
    },
    	"esnext.weak-set.delete-all": {
    },
    	"esnext.weak-set.from": {
    },
    	"esnext.weak-set.of": {
    },
    	"web.dom-collections.for-each": {
    	chrome: "58",
    	edge: "16",
    	electron: "1.7",
    	firefox: "50",
    	ios: "10.0",
    	node: "0.0.1",
    	opera: "45",
    	opera_mobile: "43",
    	safari: "10.0",
    	samsung: "7.0"
    },
    	"web.dom-collections.iterator": {
    	chrome: "66",
    	edge: "74",
    	electron: "3.0",
    	firefox: "60",
    	node: "0.0.1",
    	opera: "53",
    	opera_mobile: "47",
    	safari: "13.1",
    	samsung: "9.0"
    },
    	"web.immediate": {
    	ie: "10",
    	node: "0.9.1"
    },
    	"web.queue-microtask": {
    	chrome: "71",
    	edge: "74",
    	electron: "5.0",
    	firefox: "69",
    	ios: "12.2",
    	node: "12.0",
    	opera: "58",
    	opera_mobile: "50",
    	safari: "12.1",
    	samsung: "10.0"
    },
    	"web.timers": {
    	android: "1.5",
    	chrome: "1",
    	edge: "12",
    	electron: "0.20",
    	firefox: "1",
    	ie: "10",
    	ios: "1.0",
    	node: "0.0.1",
    	opera: "7",
    	opera_mobile: "7",
    	phantom: "1.9",
    	safari: "1.0",
    	samsung: "1.0"
    },
    	"web.url": {
    	chrome: "67",
    	edge: "74",
    	electron: "4.0",
    	firefox: "57",
    	node: "10.0",
    	opera: "54",
    	opera_mobile: "48",
    	samsung: "9.0"
    },
    	"web.url.to-json": {
    	chrome: "71",
    	edge: "74",
    	electron: "5.0",
    	firefox: "57",
    	node: "10.0",
    	opera: "58",
    	opera_mobile: "50",
    	samsung: "10.0"
    },
    	"web.url-search-params": {
    	chrome: "67",
    	edge: "74",
    	electron: "4.0",
    	firefox: "57",
    	node: "10.0",
    	opera: "54",
    	opera_mobile: "48",
    	samsung: "9.0"
    }
    };

    var leven_1$1 = createCommonjsModule(function (module) {

    var array = [];
    var charCodeCache = [];

    var leven = function leven(left, right) {
      if (left === right) {
        return 0;
      }

      var swap = left;

      if (left.length > right.length) {
        left = right;
        right = swap;
      }

      var leftLength = left.length;
      var rightLength = right.length;

      while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
        leftLength--;
        rightLength--;
      }

      var start = 0;

      while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
        start++;
      }

      leftLength -= start;
      rightLength -= start;

      if (leftLength === 0) {
        return rightLength;
      }

      var bCharCode;
      var result;
      var temp;
      var temp2;
      var i = 0;
      var j = 0;

      while (i < leftLength) {
        charCodeCache[i] = left.charCodeAt(start + i);
        array[i] = ++i;
      }

      while (j < rightLength) {
        bCharCode = right.charCodeAt(start + j);
        temp = j++;
        result = j;

        for (i = 0; i < leftLength; i++) {
          temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
          temp = array[i];
          result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
        }
      }

      return result;
    };

    module.exports = leven;
    module.exports["default"] = leven;
    });

    function levenArray$1(str, array) {
      var minLeven = Number.POSITIVE_INFINITY;
      var result = undefined;

      for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
        var item = _step.value;
        var distance = leven_1$1(str, item);

        if (distance < minLeven) {
          minLeven = distance;
          result = item;
        }
      }

      return result;
    }

    var invariant$1 = function invariant(condition, format, a, b, c, d, e, f) {
      {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }

      if (!condition) {
        var error;

        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }

        error.framesToPop = 1;
        throw error;
      }
    };

    var browser$8 = invariant$1;

    var corejs2BuiltIns = {
    	"es6.array.copy-within": {
    	chrome: "45",
    	opera: "32",
    	edge: "12",
    	firefox: "32",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "5",
    	electron: "0.35"
    },
    	"es6.array.every": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.fill": {
    	chrome: "45",
    	opera: "32",
    	edge: "12",
    	firefox: "31",
    	safari: "7.1",
    	node: "4",
    	ios: "8",
    	samsung: "5",
    	electron: "0.35"
    },
    	"es6.array.filter": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.find": {
    	chrome: "45",
    	opera: "32",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "4",
    	ios: "8",
    	samsung: "5",
    	electron: "0.35"
    },
    	"es6.array.find-index": {
    	chrome: "45",
    	opera: "32",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "4",
    	ios: "8",
    	samsung: "5",
    	electron: "0.35"
    },
    	"es7.array.flat-map": {
    	chrome: "69",
    	opera: "56",
    	edge: "79",
    	firefox: "62",
    	safari: "12",
    	node: "11",
    	ios: "12",
    	samsung: "10",
    	electron: "4.2"
    },
    	"es6.array.for-each": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.from": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "36",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es7.array.includes": {
    	chrome: "47",
    	opera: "34",
    	edge: "14",
    	firefox: "43",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"es6.array.index-of": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.is-array": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "4",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.iterator": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "28",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.array.last-index-of": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.map": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.of": {
    	chrome: "45",
    	opera: "32",
    	edge: "12",
    	firefox: "25",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "5",
    	electron: "0.35"
    },
    	"es6.array.reduce": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "3",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.reduce-right": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "3",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.some": {
    	chrome: "5",
    	opera: "10.10",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.array.sort": {
    	chrome: "63",
    	opera: "50",
    	edge: "12",
    	firefox: "5",
    	safari: "12",
    	node: "10",
    	ie: "9",
    	ios: "12",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es6.array.species": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.date.now": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "2",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.date.to-iso-string": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "3.5",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.date.to-json": {
    	chrome: "5",
    	opera: "12.10",
    	edge: "12",
    	firefox: "4",
    	safari: "10",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "10",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.date.to-primitive": {
    	chrome: "47",
    	opera: "34",
    	edge: "15",
    	firefox: "44",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "0.36"
    },
    	"es6.date.to-string": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "2",
    	safari: "3.1",
    	node: "0.10",
    	ie: "10",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.function.bind": {
    	chrome: "7",
    	opera: "12",
    	edge: "12",
    	firefox: "4",
    	safari: "5.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "5"
    },
    	"es6.function.has-instance": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "50",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.function.name": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "14",
    	firefox: "2",
    	safari: "4",
    	node: "0.10",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.map": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.math.acosh": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.asinh": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.atanh": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.cbrt": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.clz32": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "31",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.cosh": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.expm1": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.fround": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "26",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.hypot": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "27",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.imul": {
    	chrome: "30",
    	opera: "17",
    	edge: "12",
    	firefox: "23",
    	safari: "7",
    	node: "0.12",
    	android: "4.4",
    	ios: "7",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.math.log1p": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.log10": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.log2": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.sign": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.sinh": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.tanh": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.math.trunc": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "25",
    	safari: "7.1",
    	node: "0.12",
    	ios: "8",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.number.constructor": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "36",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.number.epsilon": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "25",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.number.is-finite": {
    	chrome: "19",
    	opera: "15",
    	edge: "12",
    	firefox: "16",
    	safari: "9",
    	node: "0.12",
    	android: "4.1",
    	ios: "9",
    	samsung: "1.5",
    	electron: "0.2"
    },
    	"es6.number.is-integer": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "16",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.number.is-nan": {
    	chrome: "19",
    	opera: "15",
    	edge: "12",
    	firefox: "15",
    	safari: "9",
    	node: "0.12",
    	android: "4.1",
    	ios: "9",
    	samsung: "1.5",
    	electron: "0.2"
    },
    	"es6.number.is-safe-integer": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "32",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.number.max-safe-integer": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "31",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.number.min-safe-integer": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "31",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.number.parse-float": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "25",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.number.parse-int": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "25",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es6.object.assign": {
    	chrome: "49",
    	opera: "36",
    	edge: "13",
    	firefox: "36",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.object.create": {
    	chrome: "5",
    	opera: "12",
    	edge: "12",
    	firefox: "4",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es7.object.define-getter": {
    	chrome: "62",
    	opera: "49",
    	edge: "16",
    	firefox: "48",
    	safari: "9",
    	node: "8.10",
    	ios: "9",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es7.object.define-setter": {
    	chrome: "62",
    	opera: "49",
    	edge: "16",
    	firefox: "48",
    	safari: "9",
    	node: "8.10",
    	ios: "9",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es6.object.define-property": {
    	chrome: "5",
    	opera: "12",
    	edge: "12",
    	firefox: "4",
    	safari: "5.1",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.object.define-properties": {
    	chrome: "5",
    	opera: "12",
    	edge: "12",
    	firefox: "4",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es7.object.entries": {
    	chrome: "54",
    	opera: "41",
    	edge: "14",
    	firefox: "47",
    	safari: "10.1",
    	node: "7",
    	ios: "10.3",
    	samsung: "6",
    	electron: "1.5"
    },
    	"es6.object.freeze": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es6.object.get-own-property-descriptor": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es7.object.get-own-property-descriptors": {
    	chrome: "54",
    	opera: "41",
    	edge: "15",
    	firefox: "50",
    	safari: "10.1",
    	node: "7",
    	ios: "10.3",
    	samsung: "6",
    	electron: "1.5"
    },
    	"es6.object.get-own-property-names": {
    	chrome: "40",
    	opera: "27",
    	edge: "12",
    	firefox: "33",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.21"
    },
    	"es6.object.get-prototype-of": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es7.object.lookup-getter": {
    	chrome: "62",
    	opera: "49",
    	edge: "79",
    	firefox: "36",
    	safari: "9",
    	node: "8.10",
    	ios: "9",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es7.object.lookup-setter": {
    	chrome: "62",
    	opera: "49",
    	edge: "79",
    	firefox: "36",
    	safari: "9",
    	node: "8.10",
    	ios: "9",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es6.object.prevent-extensions": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es6.object.to-string": {
    	chrome: "57",
    	opera: "44",
    	edge: "15",
    	firefox: "51",
    	safari: "10",
    	node: "8",
    	ios: "10",
    	samsung: "7",
    	electron: "1.7"
    },
    	"es6.object.is": {
    	chrome: "19",
    	opera: "15",
    	edge: "12",
    	firefox: "22",
    	safari: "9",
    	node: "0.12",
    	android: "4.1",
    	ios: "9",
    	samsung: "1.5",
    	electron: "0.2"
    },
    	"es6.object.is-frozen": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es6.object.is-sealed": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es6.object.is-extensible": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es6.object.keys": {
    	chrome: "40",
    	opera: "27",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.21"
    },
    	"es6.object.seal": {
    	chrome: "44",
    	opera: "31",
    	edge: "12",
    	firefox: "35",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "4",
    	electron: "0.31"
    },
    	"es6.object.set-prototype-of": {
    	chrome: "34",
    	opera: "21",
    	edge: "12",
    	firefox: "31",
    	safari: "9",
    	node: "0.12",
    	ie: "11",
    	ios: "9",
    	samsung: "2",
    	electron: "0.2"
    },
    	"es7.object.values": {
    	chrome: "54",
    	opera: "41",
    	edge: "14",
    	firefox: "47",
    	safari: "10.1",
    	node: "7",
    	ios: "10.3",
    	samsung: "6",
    	electron: "1.5"
    },
    	"es6.promise": {
    	chrome: "51",
    	opera: "38",
    	edge: "14",
    	firefox: "45",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es7.promise.finally": {
    	chrome: "63",
    	opera: "50",
    	edge: "18",
    	firefox: "58",
    	safari: "11.1",
    	node: "10",
    	ios: "11.3",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es6.reflect.apply": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.construct": {
    	chrome: "49",
    	opera: "36",
    	edge: "13",
    	firefox: "49",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.define-property": {
    	chrome: "49",
    	opera: "36",
    	edge: "13",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.delete-property": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.get": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.get-own-property-descriptor": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.get-prototype-of": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.has": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.is-extensible": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.own-keys": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.prevent-extensions": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.set": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.reflect.set-prototype-of": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "42",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.regexp.constructor": {
    	chrome: "50",
    	opera: "37",
    	edge: "79",
    	firefox: "40",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"es6.regexp.flags": {
    	chrome: "49",
    	opera: "36",
    	edge: "79",
    	firefox: "37",
    	safari: "9",
    	node: "6",
    	ios: "9",
    	samsung: "5",
    	electron: "1"
    },
    	"es6.regexp.match": {
    	chrome: "50",
    	opera: "37",
    	edge: "79",
    	firefox: "49",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"es6.regexp.replace": {
    	chrome: "50",
    	opera: "37",
    	edge: "79",
    	firefox: "49",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"es6.regexp.split": {
    	chrome: "50",
    	opera: "37",
    	edge: "79",
    	firefox: "49",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"es6.regexp.search": {
    	chrome: "50",
    	opera: "37",
    	edge: "79",
    	firefox: "49",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"es6.regexp.to-string": {
    	chrome: "50",
    	opera: "37",
    	edge: "79",
    	firefox: "39",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1.1"
    },
    	"es6.set": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.symbol": {
    	chrome: "51",
    	opera: "38",
    	edge: "79",
    	firefox: "51",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es7.symbol.async-iterator": {
    	chrome: "63",
    	opera: "50",
    	edge: "79",
    	firefox: "57",
    	safari: "12",
    	node: "10",
    	ios: "12",
    	samsung: "8",
    	electron: "3.1"
    },
    	"es6.string.anchor": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.big": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.blink": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.bold": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.code-point-at": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "29",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.ends-with": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "29",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.fixed": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.fontcolor": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.fontsize": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.from-code-point": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "29",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.includes": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "40",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.italics": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.iterator": {
    	chrome: "38",
    	opera: "25",
    	edge: "12",
    	firefox: "36",
    	safari: "9",
    	node: "0.12",
    	ios: "9",
    	samsung: "3",
    	electron: "0.2"
    },
    	"es6.string.link": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es7.string.pad-start": {
    	chrome: "57",
    	opera: "44",
    	edge: "15",
    	firefox: "48",
    	safari: "10",
    	node: "8",
    	ios: "10",
    	samsung: "7",
    	electron: "1.7"
    },
    	"es7.string.pad-end": {
    	chrome: "57",
    	opera: "44",
    	edge: "15",
    	firefox: "48",
    	safari: "10",
    	node: "8",
    	ios: "10",
    	samsung: "7",
    	electron: "1.7"
    },
    	"es6.string.raw": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "34",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.repeat": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "24",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.small": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.starts-with": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "29",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"es6.string.strike": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.sub": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.sup": {
    	chrome: "5",
    	opera: "15",
    	edge: "12",
    	firefox: "17",
    	safari: "6",
    	node: "0.10",
    	android: "4",
    	ios: "7",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.string.trim": {
    	chrome: "5",
    	opera: "10.50",
    	edge: "12",
    	firefox: "3.5",
    	safari: "4",
    	node: "0.10",
    	ie: "9",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es7.string.trim-left": {
    	chrome: "66",
    	opera: "53",
    	edge: "79",
    	firefox: "61",
    	safari: "12",
    	node: "10",
    	ios: "12",
    	samsung: "9",
    	electron: "3.1"
    },
    	"es7.string.trim-right": {
    	chrome: "66",
    	opera: "53",
    	edge: "79",
    	firefox: "61",
    	safari: "12",
    	node: "10",
    	ios: "12",
    	samsung: "9",
    	electron: "3.1"
    },
    	"es6.typed.array-buffer": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.data-view": {
    	chrome: "5",
    	opera: "12",
    	edge: "12",
    	firefox: "15",
    	safari: "5.1",
    	node: "0.10",
    	ie: "10",
    	android: "4",
    	ios: "6",
    	phantom: "2",
    	samsung: "1",
    	electron: "1.1"
    },
    	"es6.typed.int8-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.uint8-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.uint8-clamped-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.int16-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.uint16-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.int32-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.uint32-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.float32-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.typed.float64-array": {
    	chrome: "51",
    	opera: "38",
    	edge: "13",
    	firefox: "48",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.weak-map": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "53",
    	safari: "9",
    	node: "6.5",
    	ios: "9",
    	samsung: "5",
    	electron: "1.2"
    },
    	"es6.weak-set": {
    	chrome: "51",
    	opera: "38",
    	edge: "15",
    	firefox: "53",
    	safari: "9",
    	node: "6.5",
    	ios: "9",
    	samsung: "5",
    	electron: "1.2"
    }
    };

    var corejs2BuiltIns$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': corejs2BuiltIns
    });

    var require$$0$5 = getCjsExportFromNamespace(corejs2BuiltIns$1);

    var corejs2BuiltIns$2 = require$$0$5;

    var pluginBugfixes = {
    	"transform-async-to-generator": {
    	chrome: "55",
    	opera: "42",
    	edge: "15",
    	firefox: "52",
    	safari: "10.1",
    	node: "7.6",
    	ios: "10.3",
    	samsung: "6",
    	electron: "1.6"
    },
    	"bugfix/transform-async-arrows-in-class": {
    	chrome: "55",
    	opera: "42",
    	edge: "15",
    	firefox: "52",
    	safari: "11",
    	node: "7.6",
    	ios: "11",
    	samsung: "6",
    	electron: "1.6"
    },
    	"transform-parameters": {
    	chrome: "49",
    	opera: "36",
    	edge: "15",
    	firefox: "53",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"bugfix/transform-edge-default-parameters": {
    	chrome: "49",
    	opera: "36",
    	edge: "18",
    	firefox: "52",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"transform-function-name": {
    	chrome: "51",
    	opera: "38",
    	edge: "14",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"bugfix/transform-edge-function-name": {
    	chrome: "51",
    	opera: "38",
    	edge: "79",
    	firefox: "53",
    	safari: "10",
    	node: "6.5",
    	ios: "10",
    	samsung: "5",
    	electron: "1.2"
    },
    	"transform-block-scoping": {
    	chrome: "49",
    	opera: "36",
    	edge: "14",
    	firefox: "51",
    	safari: "10",
    	node: "6",
    	ios: "10",
    	samsung: "5",
    	electron: "1"
    },
    	"bugfix/transform-safari-block-shadowing": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "44",
    	safari: "11",
    	node: "6",
    	ie: "11",
    	ios: "11",
    	samsung: "5",
    	electron: "1"
    },
    	"bugfix/transform-safari-for-shadowing": {
    	chrome: "49",
    	opera: "36",
    	edge: "12",
    	firefox: "4",
    	safari: "11",
    	node: "6",
    	ie: "11",
    	ios: "11",
    	samsung: "5",
    	electron: "1"
    },
    	"transform-template-literals": {
    	chrome: "41",
    	opera: "28",
    	edge: "13",
    	firefox: "34",
    	safari: "9",
    	node: "4",
    	ios: "9",
    	samsung: "3.4",
    	electron: "0.24"
    },
    	"bugfix/transform-tagged-template-caching": {
    	chrome: "41",
    	opera: "28",
    	edge: "12",
    	firefox: "34",
    	safari: "13",
    	node: "4",
    	ios: "13",
    	samsung: "3.4",
    	electron: "0.24"
    }
    };

    var pluginBugfixes$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': pluginBugfixes
    });

    var require$$0$6 = getCjsExportFromNamespace(pluginBugfixes$1);

    var pluginBugfixes$2 = require$$0$6;

    var lib$b = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-async-generators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxAsyncGenerators$2 = unwrapExports(lib$b);

    var lib$c = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-dynamic-import",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("dynamicImport");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxDynamicImport$1 = unwrapExports(lib$c);

    var lib$d = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-json-strings",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("jsonStrings");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxJsonStrings$1 = unwrapExports(lib$d);

    var lib$e = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-nullish-coalescing-operator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxNullishCoalescingOperator$1 = unwrapExports(lib$e);

    var lib$f = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-object-rest-spread",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxObjectRestSpread$2 = unwrapExports(lib$f);

    var lib$g = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-catch-binding",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxOptionalCatchBinding$2 = unwrapExports(lib$g);

    var lib$h = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;



    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-chaining",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        }
      };
    });

    exports["default"] = _default;
    });

    var syntaxOptionalChaining$1 = unwrapExports(lib$h);

    var transformAsyncArrowsInClass = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;
    var OPTS = {
      allowInsertArrow: false,
      specCompliant: false
    };

    var _default = function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-async-arrows-in-class",
        visitor: {
          ArrowFunctionExpression: function ArrowFunctionExpression(path) {
            if (path.node.async && path.findParent(t.isClassMethod)) {
              path.arrowFunctionToExpression(OPTS);
            }
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
    });

    var bugfixAsyncArrowsInClass = unwrapExports(transformAsyncArrowsInClass);

    var transformEdgeDefaultParameters = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    var _default = function _default(_ref) {
      var t = _ref.types;

      var isArrowParent = function isArrowParent(p) {
        return p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
      };

      return {
        name: "transform-edge-default-parameters",
        visitor: {
          AssignmentPattern: function AssignmentPattern(path) {
            var arrowArgParent = path.find(isArrowParent);

            if (arrowArgParent && path.parent.shorthand) {
              path.parent.shorthand = false;
              (path.parent.extra || {}).shorthand = false;
              path.scope.rename(path.parent.key.name);
            }
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
    });

    var bugfixEdgeDefaultParameters = unwrapExports(transformEdgeDefaultParameters);

    var transformEdgeFunctionName = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    var _default = function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-edge-function-name",
        visitor: {
          FunctionExpression: {
            exit: function exit(path) {
              if (!path.node.id && t.isIdentifier(path.parent.id)) {
                var id = t.cloneNode(path.parent.id);
                var binding = path.scope.getBinding(id.name);

                if (binding.constantViolations.length) {
                  path.scope.rename(id.name);
                }

                path.node.id = id;
              }
            }
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
    });

    var bugfixEdgeFunctionName = unwrapExports(transformEdgeFunctionName);

    var transformTaggedTemplateCaching = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    var _default = function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-tagged-template-caching",
        visitor: {
          TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
            var processed = state.get("processed");

            if (!processed) {
              processed = new Map();
              state.set("processed", processed);
            }

            if (processed.has(path.node)) return path.skip();
            var expressions = path.node.quasi.expressions;
            var identity = state.get("identity");

            if (!identity) {
              identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
              state.set("identity", identity);
              var binding = path.scope.getBinding(identity.name);
              binding.path.get("init").replaceWith(t.arrowFunctionExpression([t.identifier("t")], t.identifier("t")));
            }

            var template = t.taggedTemplateExpression(identity, t.templateLiteral(path.node.quasi.quasis, expressions.map(function () {
              return t.numericLiteral(0);
            })));
            processed.set(template, true);
            var ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
            path.scope.getBinding(ident.name).path.parent.kind = "let";
            var inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", ident, template));
            var node = t.callExpression(path.node.tag, [inlineCache].concat(expressions));
            path.replaceWith(node);
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
    });

    var bugfixTaggedTemplateCaching = unwrapExports(transformTaggedTemplateCaching);

    var transformSafariBlockShadowing = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = _default;

    function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-safari-block-shadowing",
        visitor: {
          VariableDeclarator: function VariableDeclarator(path) {
            var kind = path.parent.kind;
            if (kind !== "let" && kind !== "const") return;
            var block = path.scope.block;
            if (t.isFunction(block) || t.isProgram(block)) return;
            var bindings = t.getOuterBindingIdentifiers(path.node.id);

            for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
              var name = _Object$keys[_i];
              var scope = path.scope;
              if (!scope.hasOwnBinding(name)) continue;

              while (scope = scope.parent) {
                if (scope.hasOwnBinding(name)) {
                  path.scope.rename(name);
                  break;
                }

                if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
                  break;
                }
              }
            }
          }
        }
      };
    }

    module.exports = exports["default"];
    });

    var bugfixSafariBlockShadowing = unwrapExports(transformSafariBlockShadowing);

    var transformSafariForShadowing = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    function handle(declaration) {
      if (!declaration.isVariableDeclaration()) return;
      var fn = declaration.getFunctionParent();
      var name = declaration.node.declarations[0].id.name;

      if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
        declaration.scope.rename(name);
      }
    }

    var _default = function _default() {
      return {
        name: "transform-safari-for-shadowing",
        visitor: {
          ForXStatement: function ForXStatement(path) {
            handle(path.get("left"));
          },
          ForStatement: function ForStatement(path) {
            handle(path.get("init"));
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
    });

    var bugfixSafariForShadowing = unwrapExports(transformSafariForShadowing);

    var availablePlugins = {
      "bugfix/transform-async-arrows-in-class": bugfixAsyncArrowsInClass,
      "bugfix/transform-edge-default-parameters": bugfixEdgeDefaultParameters,
      "bugfix/transform-edge-function-name": bugfixEdgeFunctionName,
      "bugfix/transform-safari-block-shadowing": bugfixSafariBlockShadowing,
      "bugfix/transform-safari-for-shadowing": bugfixSafariForShadowing,
      "bugfix/transform-tagged-template-caching": bugfixTaggedTemplateCaching,
      "proposal-async-generator-functions": proposalAsyncGeneratorFunctions,
      "proposal-dynamic-import": proposalDynamicImport,
      "proposal-json-strings": proposalJsonStrings,
      "proposal-nullish-coalescing-operator": proposalNullishCoalescingOperator,
      "proposal-numeric-separator": proposalNumericSeparator,
      "proposal-object-rest-spread": proposalObjectRestSpread,
      "proposal-optional-catch-binding": proposalOptionalCatchBinding,
      "proposal-optional-chaining": proposalOptionalChaining,
      "proposal-unicode-property-regex": proposalUnicodePropertyRegex,
      "syntax-async-generators": syntaxAsyncGenerators$2,
      "syntax-dynamic-import": syntaxDynamicImport$1,
      "syntax-json-strings": syntaxJsonStrings$1,
      "syntax-nullish-coalescing-operator": syntaxNullishCoalescingOperator$1,
      "syntax-numeric-separator": syntaxNumericSeparator,
      "syntax-object-rest-spread": syntaxObjectRestSpread$2,
      "syntax-optional-catch-binding": syntaxOptionalCatchBinding$2,
      "syntax-optional-chaining": syntaxOptionalChaining$1,
      "syntax-top-level-await": syntaxTopLevelAwait,
      "transform-arrow-functions": transformArrowFunctions,
      "transform-async-to-generator": transformAsyncToGenerator,
      "transform-block-scoped-functions": transformBlockScopedFunctions,
      "transform-block-scoping": transformBlockScoping,
      "transform-classes": transformClasses,
      "transform-computed-properties": transformComputedProperties,
      "transform-destructuring": transformDestructuring,
      "transform-dotall-regex": transformDotallRegex,
      "transform-duplicate-keys": transformDuplicateKeys,
      "transform-exponentiation-operator": transformExponentialOperator,
      "transform-for-of": transformForOf,
      "transform-function-name": transformFunctionName,
      "transform-literals": transformLiterals,
      "transform-member-expression-literals": transformMemberExpressionLiterals,
      "transform-modules-amd": transformModulesAmd,
      "transform-modules-commonjs": transformModulesCommonjs,
      "transform-modules-systemjs": transformModulesSystemjs,
      "transform-modules-umd": transformModulesUmd,
      "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
      "transform-new-target": transformNewTarget,
      "transform-object-super": transformObjectSuper,
      "transform-parameters": transformParameters,
      "transform-property-literals": transformPropertyLiterals,
      "transform-reserved-words": transformReservedWords,
      "transform-shorthand-properties": transformShorthandProperties,
      "transform-spread": transformSpread,
      "transform-sticky-regex": transformStickyRegex,
      "transform-template-literals": transformTemplateLiterals,
      "transform-typeof-symbol": transformTypeofSymbol,
      "transform-unicode-regex": transformUnicodeRegex
    };

    var pluginsFiltered = {};
    var bugfixPluginsFiltered = {};

    for (var _i$3 = 0, _Object$keys$1 = Object.keys(plugins$2); _i$3 < _Object$keys$1.length; _i$3++) {
      var plugin = _Object$keys$1[_i$3];

      if (Object.hasOwnProperty.call(availablePlugins, plugin)) {
        pluginsFiltered[plugin] = plugins$2[plugin];
      }
    }

    for (var _i2$1 = 0, _Object$keys2 = Object.keys(pluginBugfixes$2); _i2$1 < _Object$keys2.length; _i2$1++) {
      var _plugin = _Object$keys2[_i2$1];

      if (Object.hasOwnProperty.call(availablePlugins, _plugin)) {
        bugfixPluginsFiltered[_plugin] = pluginBugfixes$2[_plugin];
      }
    }

    var TopLevelOptions = {
      bugfixes: "bugfixes",
      configPath: "configPath",
      corejs: "corejs",
      debug: "debug",
      exclude: "exclude",
      forceAllTransforms: "forceAllTransforms",
      ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
      include: "include",
      loose: "loose",
      modules: "modules",
      shippedProposals: "shippedProposals",
      spec: "spec",
      targets: "targets",
      useBuiltIns: "useBuiltIns"
    };
    var ModulesOption = {
      "false": false,
      auto: "auto",
      amd: "amd",
      commonjs: "commonjs",
      cjs: "cjs",
      systemjs: "systemjs",
      umd: "umd"
    };
    var UseBuiltInsOption = {
      "false": false,
      entry: "entry",
      usage: "usage"
    };

    var defaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
    function getPlatformSpecificDefaultFor (targets) {
      var targetNames = Object.keys(targets);
      var isAnyTarget = !targetNames.length;
      var isWebTarget = targetNames.some(function (name) {
        return name !== "node";
      });
      return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
    }

    var validateTopLevelOptions = function validateTopLevelOptions(options) {
      var validOptions = Object.keys(TopLevelOptions);

      for (var option in options) {
        if (!TopLevelOptions[option]) {
          throw new Error("Invalid Option: " + option + " is not a valid top-level option.\n        Maybe you meant to use '" + levenArray$1(option, validOptions) + "'?");
        }
      }
    };

    var allPluginsList = Object.keys(pluginsFiltered);
    var modulePlugins = ["proposal-dynamic-import"].concat(Object.keys(moduleTransformations).map(function (m) {
      return moduleTransformations[m];
    }));

    var getValidIncludesAndExcludes = function getValidIncludesAndExcludes(type, corejs) {
      return new Set([].concat(allPluginsList, type === "exclude" ? modulePlugins : [], corejs ? corejs == 2 ? [].concat(Object.keys(corejs2BuiltIns$2), defaultWebIncludes) : Object.keys(corejs3Polyfills) : []));
    };

    var pluginToRegExp = function pluginToRegExp(plugin) {
      if (plugin instanceof RegExp) return plugin;

      try {
        return new RegExp("^" + normalizePluginName(plugin) + "$");
      } catch (e) {
        return null;
      }
    };

    var selectPlugins = function selectPlugins(regexp, type, corejs) {
      return Array.from(getValidIncludesAndExcludes(type, corejs)).filter(function (item) {
        return regexp instanceof RegExp && regexp.test(item);
      });
    };

    var flatten$1 = function flatten(array) {
      var _ref;

      return (_ref = []).concat.apply(_ref, array);
    };

    var expandIncludesAndExcludes = function expandIncludesAndExcludes(plugins, type, corejs) {
      if (plugins === void 0) {
        plugins = [];
      }

      if (plugins.length === 0) return [];
      var selectedPlugins = plugins.map(function (plugin) {
        return selectPlugins(pluginToRegExp(plugin), type, corejs);
      });
      var invalidRegExpList = plugins.filter(function (p, i) {
        return selectedPlugins[i].length === 0;
      });
      browser$8(invalidRegExpList.length === 0, "Invalid Option: The plugins/built-ins '" + invalidRegExpList.join(", ") + "' passed to the '" + type + "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env");
      return flatten$1(selectedPlugins);
    };

    var normalizePluginName = function normalizePluginName(plugin) {
      return plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
    };
    var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes(include, exclude) {
      if (include === void 0) {
        include = [];
      }

      if (exclude === void 0) {
        exclude = [];
      }

      var duplicates = include.filter(function (opt) {
        return exclude.indexOf(opt) >= 0;
      });
      browser$8(duplicates.length === 0, "Invalid Option: The plugins/built-ins '" + duplicates.join(", ") + "' were found in both the \"include\" and\n    \"exclude\" options.");
    };

    var normalizeTargets = function normalizeTargets(targets) {
      if (typeof targets === "string" || Array.isArray(targets)) {
        return {
          browsers: targets
        };
      }

      return Object.assign({}, targets);
    };

    var validateConfigPathOption = function validateConfigPathOption(configPath) {
      if (configPath === void 0) {
        configPath = process.cwd();
      }

      browser$8(typeof configPath === "string", "Invalid Option: The configPath option '" + configPath + "' is invalid, only strings are allowed.");
      return configPath;
    };
    var validateBoolOption = function validateBoolOption(name, value, defaultValue) {
      if (typeof value === "undefined") {
        value = defaultValue;
      }

      if (typeof value !== "boolean") {
        throw new Error("Preset env: '" + name + "' option must be a boolean.");
      }

      return value;
    };
    var validateIgnoreBrowserslistConfig = function validateIgnoreBrowserslistConfig(ignoreBrowserslistConfig) {
      return validateBoolOption(TopLevelOptions.ignoreBrowserslistConfig, ignoreBrowserslistConfig, false);
    };
    var validateModulesOption = function validateModulesOption(modulesOpt) {
      if (modulesOpt === void 0) {
        modulesOpt = ModulesOption.auto;
      }

      browser$8(ModulesOption[modulesOpt.toString()] || modulesOpt === ModulesOption["false"], "Invalid Option: The 'modules' option must be one of \n" + " - 'false' to indicate no module processing\n" + " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" + " - 'auto' (default) which will automatically select 'false' if the current\n" + "   process is known to support ES module syntax, or \"commonjs\" otherwise\n");
      return modulesOpt;
    };
    var validateUseBuiltInsOption = function validateUseBuiltInsOption(builtInsOpt) {
      if (builtInsOpt === void 0) {
        builtInsOpt = false;
      }

      browser$8(UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === UseBuiltInsOption["false"], "Invalid Option: The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file");
      return builtInsOpt;
    };
    function normalizeCoreJSOption(corejs, useBuiltIns) {
      var proposals = false;
      var rawVersion;

      if (useBuiltIns && corejs === undefined) {
        rawVersion = 2;
        console.warn("\nWARNING: We noticed you're using the `useBuiltIns` option without declaring a " + "core-js version. Currently, we assume version 2.x when no version " + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n");
      } else if (typeof corejs === "object" && corejs !== null) {
        rawVersion = corejs.version;
        proposals = Boolean(corejs.proposals);
      } else {
        rawVersion = corejs;
      }

      var version = rawVersion ? semver_42(String(rawVersion)) : false;

      if (!useBuiltIns && version) {
        console.log("\nThe `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
      }

      if (useBuiltIns && (!version || version.major < 2 || version.major > 3)) {
        throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
      }

      return {
        version: version,
        proposals: proposals
      };
    }
    function normalizeOptions$3(opts) {
      validateTopLevelOptions(opts);
      var useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
      var corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
      var include = expandIncludesAndExcludes(opts.include, TopLevelOptions.include, !!corejs.version && corejs.version.major);
      var exclude = expandIncludesAndExcludes(opts.exclude, TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
      checkDuplicateIncludeExcludes(include, exclude);
      var shippedProposals = validateBoolOption(TopLevelOptions.shippedProposals, opts.shippedProposals, false);
      return {
        bugfixes: validateBoolOption(TopLevelOptions.bugfixes, opts.bugfixes, false),
        configPath: validateConfigPathOption(opts.configPath),
        corejs: corejs,
        debug: validateBoolOption(TopLevelOptions.debug, opts.debug, false),
        include: include,
        exclude: exclude,
        forceAllTransforms: validateBoolOption(TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
        ignoreBrowserslistConfig: validateIgnoreBrowserslistConfig(opts.ignoreBrowserslistConfig),
        loose: validateBoolOption(TopLevelOptions.loose, opts.loose, false),
        modules: validateModulesOption(opts.modules),
        shippedProposals: shippedProposals,
        spec: validateBoolOption(TopLevelOptions.spec, opts.spec, false),
        targets: normalizeTargets(opts.targets),
        useBuiltIns: useBuiltIns
      };
    }

    var proposalPlugins = new Set(["proposal-numeric-separator"]);
    var pluginSyntaxObject = {
      "proposal-async-generator-functions": "syntax-async-generators",
      "proposal-json-strings": "syntax-json-strings",
      "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
      "proposal-numeric-separator": "syntax-numeric-separator",
      "proposal-object-rest-spread": "syntax-object-rest-spread",
      "proposal-optional-catch-binding": "syntax-optional-catch-binding",
      "proposal-optional-chaining": "syntax-optional-chaining",
      "proposal-unicode-property-regex": null
    };
    var pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function (key) {
      return [key, pluginSyntaxObject[key]];
    });
    var pluginSyntaxMap = new Map(pluginSyntaxEntries);
    var shippedProposals = {
      pluginSyntaxMap: pluginSyntaxMap,
      proposalPlugins: proposalPlugins
    };
    var shippedProposals_1 = shippedProposals.pluginSyntaxMap;
    var shippedProposals_2 = shippedProposals.proposalPlugins;

    var overlappingPlugins = {
    	"transform-async-to-generator": [
    	"bugfix/transform-async-arrows-in-class"
    ],
    	"transform-parameters": [
    	"bugfix/transform-edge-default-parameters"
    ],
    	"transform-function-name": [
    	"bugfix/transform-edge-function-name"
    ],
    	"transform-block-scoping": [
    	"bugfix/transform-safari-block-shadowing",
    	"bugfix/transform-safari-for-shadowing"
    ],
    	"transform-template-literals": [
    	"bugfix/transform-tagged-template-caching"
    ]
    };

    var overlappingPlugins$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': overlappingPlugins
    });

    var require$$0$7 = getCjsExportFromNamespace(overlappingPlugins$1);

    var overlappingPlugins$2 = require$$0$7;

    var ArrayNatureIterators = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
    var CommonIterators = ["es6.string.iterator"].concat(ArrayNatureIterators);
    var PromiseDependencies = ["es6.object.to-string", "es6.promise"];
    var BuiltIns = {
      DataView: "es6.typed.data-view",
      Float32Array: "es6.typed.float32-array",
      Float64Array: "es6.typed.float64-array",
      Int8Array: "es6.typed.int8-array",
      Int16Array: "es6.typed.int16-array",
      Int32Array: "es6.typed.int32-array",
      Map: ["es6.map"].concat(CommonIterators),
      Number: "es6.number.constructor",
      Promise: PromiseDependencies,
      RegExp: ["es6.regexp.constructor"],
      Set: ["es6.set"].concat(CommonIterators),
      Symbol: ["es6.symbol", "es7.symbol.async-iterator"],
      Uint8Array: "es6.typed.uint8-array",
      Uint8ClampedArray: "es6.typed.uint8-clamped-array",
      Uint16Array: "es6.typed.uint16-array",
      Uint32Array: "es6.typed.uint32-array",
      WeakMap: ["es6.weak-map"].concat(CommonIterators),
      WeakSet: ["es6.weak-set"].concat(CommonIterators)
    };
    var InstanceProperties = {
      __defineGetter__: ["es7.object.define-getter"],
      __defineSetter__: ["es7.object.define-setter"],
      __lookupGetter__: ["es7.object.lookup-getter"],
      __lookupSetter__: ["es7.object.lookup-setter"],
      anchor: ["es6.string.anchor"],
      big: ["es6.string.big"],
      bind: ["es6.function.bind"],
      blink: ["es6.string.blink"],
      bold: ["es6.string.bold"],
      codePointAt: ["es6.string.code-point-at"],
      copyWithin: ["es6.array.copy-within"],
      endsWith: ["es6.string.ends-with"],
      entries: ArrayNatureIterators,
      every: ["es6.array.is-array"],
      fill: ["es6.array.fill"],
      filter: ["es6.array.filter"],
      "finally": ["es7.promise.finally"].concat(PromiseDependencies),
      find: ["es6.array.find"],
      findIndex: ["es6.array.find-index"],
      fixed: ["es6.string.fixed"],
      flags: ["es6.regexp.flags"],
      flatMap: ["es7.array.flat-map"],
      fontcolor: ["es6.string.fontcolor"],
      fontsize: ["es6.string.fontsize"],
      forEach: ["es6.array.for-each"],
      includes: ["es6.string.includes", "es7.array.includes"],
      indexOf: ["es6.array.index-of"],
      italics: ["es6.string.italics"],
      keys: ArrayNatureIterators,
      lastIndexOf: ["es6.array.last-index-of"],
      link: ["es6.string.link"],
      map: ["es6.array.map"],
      match: ["es6.regexp.match"],
      name: ["es6.function.name"],
      padStart: ["es7.string.pad-start"],
      padEnd: ["es7.string.pad-end"],
      reduce: ["es6.array.reduce"],
      reduceRight: ["es6.array.reduce-right"],
      repeat: ["es6.string.repeat"],
      replace: ["es6.regexp.replace"],
      search: ["es6.regexp.search"],
      slice: ["es6.array.slice"],
      small: ["es6.string.small"],
      some: ["es6.array.some"],
      sort: ["es6.array.sort"],
      split: ["es6.regexp.split"],
      startsWith: ["es6.string.starts-with"],
      strike: ["es6.string.strike"],
      sub: ["es6.string.sub"],
      sup: ["es6.string.sup"],
      toISOString: ["es6.date.to-iso-string"],
      toJSON: ["es6.date.to-json"],
      toString: ["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"],
      trim: ["es6.string.trim"],
      trimEnd: ["es7.string.trim-right"],
      trimLeft: ["es7.string.trim-left"],
      trimRight: ["es7.string.trim-right"],
      trimStart: ["es7.string.trim-left"],
      values: ArrayNatureIterators
    };
    var StaticProperties = {
      Array: {
        from: ["es6.array.from", "es6.string.iterator"],
        isArray: "es6.array.is-array",
        of: "es6.array.of"
      },
      Date: {
        now: "es6.date.now"
      },
      Object: {
        assign: "es6.object.assign",
        create: "es6.object.create",
        defineProperty: "es6.object.define-property",
        defineProperties: "es6.object.define-properties",
        entries: "es7.object.entries",
        freeze: "es6.object.freeze",
        getOwnPropertyDescriptors: "es7.object.get-own-property-descriptors",
        getOwnPropertySymbols: "es6.symbol",
        is: "es6.object.is",
        isExtensible: "es6.object.is-extensible",
        isFrozen: "es6.object.is-frozen",
        isSealed: "es6.object.is-sealed",
        keys: "es6.object.keys",
        preventExtensions: "es6.object.prevent-extensions",
        seal: "es6.object.seal",
        setPrototypeOf: "es6.object.set-prototype-of",
        values: "es7.object.values"
      },
      Math: {
        acosh: "es6.math.acosh",
        asinh: "es6.math.asinh",
        atanh: "es6.math.atanh",
        cbrt: "es6.math.cbrt",
        clz32: "es6.math.clz32",
        cosh: "es6.math.cosh",
        expm1: "es6.math.expm1",
        fround: "es6.math.fround",
        hypot: "es6.math.hypot",
        imul: "es6.math.imul",
        log1p: "es6.math.log1p",
        log10: "es6.math.log10",
        log2: "es6.math.log2",
        sign: "es6.math.sign",
        sinh: "es6.math.sinh",
        tanh: "es6.math.tanh",
        trunc: "es6.math.trunc"
      },
      String: {
        fromCodePoint: "es6.string.from-code-point",
        raw: "es6.string.raw"
      },
      Number: {
        EPSILON: "es6.number.epsilon",
        MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
        MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
        isFinite: "es6.number.is-finite",
        isInteger: "es6.number.is-integer",
        isSafeInteger: "es6.number.is-safe-integer",
        isNaN: "es6.number.is-nan",
        parseFloat: "es6.number.parse-float",
        parseInt: "es6.number.parse-int"
      },
      Promise: {
        all: CommonIterators,
        race: CommonIterators
      },
      Reflect: {
        apply: "es6.reflect.apply",
        construct: "es6.reflect.construct",
        defineProperty: "es6.reflect.define-property",
        deleteProperty: "es6.reflect.delete-property",
        get: "es6.reflect.get",
        getOwnPropertyDescriptor: "es6.reflect.get-own-property-descriptor",
        getPrototypeOf: "es6.reflect.get-prototype-of",
        has: "es6.reflect.has",
        isExtensible: "es6.reflect.is-extensible",
        ownKeys: "es6.reflect.own-keys",
        preventExtensions: "es6.reflect.prevent-extensions",
        set: "es6.reflect.set",
        setPrototypeOf: "es6.reflect.set-prototype-of"
      }
    };

    var has$6 = Object.hasOwnProperty.call.bind(Object.hasOwnProperty);
    function getType$1(target) {
      return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
    }
    function intersection(first, second, third) {
      var result = new Set();

      for (var _iterator = _createForOfIteratorHelperLoose(first), _step; !(_step = _iterator()).done;) {
        var el = _step.value;
        if (second.has(el) && third.has(el)) result.add(el);
      }

      return result;
    }
    function filterStageFromList(list, stageList) {
      return Object.keys(list).reduce(function (result, item) {
        if (!stageList.has(item)) {
          result[item] = list[item];
        }

        return result;
      }, {});
    }
    function getImportSource(_ref) {
      var node = _ref.node;
      if (node.specifiers.length === 0) return node.source.value;
    }
    function getRequireSource(_ref2) {
      var node = _ref2.node;
      if (!isExpressionStatement(node)) return;
      var expression = node.expression;
      var isRequire = isCallExpression(expression) && isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && isStringLiteral(expression.arguments[0]);
      if (isRequire) return expression.arguments[0].value;
    }
    function isPolyfillSource(source) {
      return source === "@babel/polyfill" || source === "core-js";
    }
    var modulePathMap = {
      "regenerator-runtime": "regenerator-runtime/runtime"
    };
    function getModulePath(mod) {
      return modulePathMap[mod] || "core-js/modules/" + mod;
    }
    function createImport(path, mod) {
      return addSideEffect(path, getModulePath(mod));
    }
    function isNamespaced(path) {
      if (!path.node) return false;
      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return false;
      return binding.path.isImportNamespaceSpecifier();
    }

    var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `import '@babel/polyfill'` call or use `useBuiltIns: 'entry'` instead.";
    function addCoreJS2UsagePlugin (_ref, _ref2) {
      var t = _ref.types;
      var include = _ref2.include,
          exclude = _ref2.exclude,
          polyfillTargets = _ref2.polyfillTargets,
          debug = _ref2.debug;
      var polyfills = filterItems(corejs2BuiltIns$2, include, exclude, polyfillTargets, getPlatformSpecificDefaultFor(polyfillTargets));
      var addAndRemovePolyfillImports = {
        ImportDeclaration: function ImportDeclaration(path) {
          if (isPolyfillSource(getImportSource(path))) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT);
            path.remove();
          }
        },
        Program: function Program(path) {
          path.get("body").forEach(function (bodyPath) {
            if (isPolyfillSource(getRequireSource(bodyPath))) {
              console.warn(NO_DIRECT_POLYFILL_IMPORT);
              bodyPath.remove();
            }
          });
        },
        ReferencedIdentifier: function ReferencedIdentifier(_ref3) {
          var name = _ref3.node.name,
              parent = _ref3.parent,
              scope = _ref3.scope;
          if (t.isMemberExpression(parent)) return;
          if (!has$6(BuiltIns, name)) return;
          if (scope.getBindingIdentifier(name)) return;
          var BuiltInDependencies = BuiltIns[name];
          this.addUnsupported(BuiltInDependencies);
        },
        CallExpression: function CallExpression(path) {
          if (path.node.arguments.length) return;
          var callee = path.node.callee;
          if (!t.isMemberExpression(callee)) return;
          if (!callee.computed) return;

          if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
            return;
          }

          this.addImport("web.dom.iterable");
        },
        BinaryExpression: function BinaryExpression(path) {
          if (path.node.operator !== "in") return;
          if (!path.get("left").matchesPattern("Symbol.iterator")) return;
          this.addImport("web.dom.iterable");
        },
        YieldExpression: function YieldExpression(path) {
          if (path.node.delegate) {
            this.addImport("web.dom.iterable");
          }
        },
        MemberExpression: {
          enter: function enter(path) {
            var node = path.node;
            var object = node.object,
                property = node.property;
            if (isNamespaced(path.get("object"))) return;
            var evaluatedPropType = object.name;
            var propertyName = "";
            var instanceType = "";

            if (node.computed) {
              if (t.isStringLiteral(property)) {
                propertyName = property.value;
              } else {
                var result = path.get("property").evaluate();

                if (result.confident && result.value) {
                  propertyName = result.value;
                }
              }
            } else {
              propertyName = property.name;
            }

            if (path.scope.getBindingIdentifier(object.name)) {
              var _result = path.get("object").evaluate();

              if (_result.value) {
                instanceType = getType$1(_result.value);
              } else if (_result.deopt && _result.deopt.isIdentifier()) {
                evaluatedPropType = _result.deopt.node.name;
              }
            }

            if (has$6(StaticProperties, evaluatedPropType)) {
              var BuiltInProperties = StaticProperties[evaluatedPropType];

              if (has$6(BuiltInProperties, propertyName)) {
                var StaticPropertyDependencies = BuiltInProperties[propertyName];
                this.addUnsupported(StaticPropertyDependencies);
              }
            }

            if (has$6(InstanceProperties, propertyName)) {
              var InstancePropertyDependencies = InstanceProperties[propertyName];

              if (instanceType) {
                InstancePropertyDependencies = InstancePropertyDependencies.filter(function (module) {
                  return module.includes(instanceType);
                });
              }

              this.addUnsupported(InstancePropertyDependencies);
            }
          },
          exit: function exit(path) {
            var name = path.node.object.name;
            if (!has$6(BuiltIns, name)) return;
            if (path.scope.getBindingIdentifier(name)) return;
            var BuiltInDependencies = BuiltIns[name];
            this.addUnsupported(BuiltInDependencies);
          }
        },
        VariableDeclarator: function VariableDeclarator(path) {
          var node = path.node;
          var id = node.id,
              init = node.init;
          if (!t.isObjectPattern(id)) return;
          if (init && path.scope.getBindingIdentifier(init.name)) return;

          for (var _iterator = _createForOfIteratorHelperLoose(id.properties), _step; !(_step = _iterator()).done;) {
            var key = _step.value.key;

            if (!node.computed && t.isIdentifier(key) && has$6(InstanceProperties, key.name)) {
              var InstancePropertyDependencies = InstanceProperties[key.name];
              this.addUnsupported(InstancePropertyDependencies);
            }
          }
        }
      };
      return {
        name: "corejs2-usage",
        pre: function pre(_ref4) {
          var path = _ref4.path;
          this.polyfillsSet = new Set();

          this.addImport = function (builtIn) {
            if (!this.polyfillsSet.has(builtIn)) {
              this.polyfillsSet.add(builtIn);
              createImport(path, builtIn);
            }
          };

          this.addUnsupported = function (builtIn) {
            var modules = Array.isArray(builtIn) ? builtIn : [builtIn];

            for (var _iterator2 = _createForOfIteratorHelperLoose(modules), _step2; !(_step2 = _iterator2()).done;) {
              var module = _step2.value;

              if (polyfills.has(module)) {
                this.addImport(module);
              }
            }
          };
        },
        post: function post() {
          if (debug) {
            logUsagePolyfills(this.polyfillsSet, this.file.opts.filename, polyfillTargets, corejs2BuiltIns$2);
          }
        },
        visitor: addAndRemovePolyfillImports
      };
    }

    var corejs3ShippedProposals = [
    	"esnext.global-this",
    	"esnext.promise.all-settled",
    	"esnext.string.match-all"
    ];

    var corejs3ShippedProposals$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': corejs3ShippedProposals
    });

    var require$$0$8 = getCjsExportFromNamespace(corejs3ShippedProposals$1);

    var corejs3ShippedProposals$2 = require$$0$8;

    var debug$2 = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
    } : function () {};
    var debug_1 = debug$2;

    var SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var constants = {
      SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
      MAX_LENGTH: MAX_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
      MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
    };

    var re_1 = createCommonjsModule(function (module, exports) {
    var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;



    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;

    var createToken = function createToken(name, value, isGlobal) {
      var index = R++;
      debug_1(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    };

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
    createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
    createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
    createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
    createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
    createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
    createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
    createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
    createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
    createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
    createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
    createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
    createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
    createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
    createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
    createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
    createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
    createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
    createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
    exports.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
    createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
    createToken('STAR', '(<|>)?=?\\s*\\*');
    });
    var re_2 = re_1.re;
    var re_3 = re_1.src;
    var re_4 = re_1.t;
    var re_5 = re_1.tildeTrimReplace;
    var re_6 = re_1.caretTrimReplace;
    var re_7 = re_1.comparatorTrimReplace;

    var numeric = /^[0-9]+$/;

    var compareIdentifiers = function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };

    var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    };

    var identifiers = {
      compareIdentifiers: compareIdentifiers,
      rcompareIdentifiers: rcompareIdentifiers
    };

    var MAX_LENGTH$1 = constants.MAX_LENGTH,
        MAX_SAFE_INTEGER$4 = constants.MAX_SAFE_INTEGER;

    var re = re_1.re,
        t$1 = re_1.t;

    var compareIdentifiers$1 = identifiers.compareIdentifiers;

    var SemVer = function () {

      function SemVer(version, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== 'string') {
          throw new TypeError("Invalid Version: " + version);
        }

        if (version.length > MAX_LENGTH$1) {
          throw new TypeError("version is longer than " + MAX_LENGTH$1 + " characters");
        }

        debug_1('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        var m = version.trim().match(options.loose ? re[t$1.LOOSE] : re[t$1.FULL]);

        if (!m) {
          throw new TypeError("Invalid Version: " + version);
        }

        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];

        if (this.major > MAX_SAFE_INTEGER$4 || this.major < 0) {
          throw new TypeError('Invalid major version');
        }

        if (this.minor > MAX_SAFE_INTEGER$4 || this.minor < 0) {
          throw new TypeError('Invalid minor version');
        }

        if (this.patch > MAX_SAFE_INTEGER$4 || this.patch < 0) {
          throw new TypeError('Invalid patch version');
        }

        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map(function (id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id;

              if (num >= 0 && num < MAX_SAFE_INTEGER$4) {
                return num;
              }
            }

            return id;
          });
        }

        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }

      var _proto = SemVer.prototype;

      _proto.format = function format() {
        this.version = this.major + "." + this.minor + "." + this.patch;

        if (this.prerelease.length) {
          this.version += "-" + this.prerelease.join('.');
        }

        return this.version;
      };

      _proto.toString = function toString() {
        return this.version;
      };

      _proto.compare = function compare(other) {
        debug_1('SemVer.compare', this.version, this.options, other);

        if (!(other instanceof SemVer)) {
          if (typeof other === 'string' && other === this.version) {
            return 0;
          }

          other = new SemVer(other, this.options);
        }

        if (other.version === this.version) {
          return 0;
        }

        return this.compareMain(other) || this.comparePre(other);
      };

      _proto.compareMain = function compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        return compareIdentifiers$1(this.major, other.major) || compareIdentifiers$1(this.minor, other.minor) || compareIdentifiers$1(this.patch, other.patch);
      };

      _proto.comparePre = function comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }

        var i = 0;

        do {
          var a = this.prerelease[i];
          var b = other.prerelease[i];
          debug_1('prerelease compare', i, a, b);

          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers$1(a, b);
          }
        } while (++i);
      };

      _proto.compareBuild = function compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        var i = 0;

        do {
          var a = this.build[i];
          var b = other.build[i];
          debug_1('prerelease compare', i, a, b);

          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers$1(a, b);
          }
        } while (++i);
      };

      _proto.inc = function inc(release, identifier) {
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc('pre', identifier);
            break;

          case 'preminor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc('pre', identifier);
            break;

          case 'prepatch':
            this.prerelease.length = 0;
            this.inc('patch', identifier);
            this.inc('pre', identifier);
            break;

          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier);
            }

            this.inc('pre', identifier);
            break;

          case 'major':
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }

            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;

          case 'minor':
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }

            this.patch = 0;
            this.prerelease = [];
            break;

          case 'patch':
            if (this.prerelease.length === 0) {
              this.patch++;
            }

            this.prerelease = [];
            break;

          case 'pre':
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              var i = this.prerelease.length;

              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++;
                  i = -2;
                }
              }

              if (i === -1) {
                this.prerelease.push(0);
              }
            }

            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }

            break;

          default:
            throw new Error("invalid increment argument: " + release);
        }

        this.format();
        this.raw = this.version;
        return this;
      };

      return SemVer;
    }();

    var semver$1 = SemVer;

    var compare$2 = function compare(a, b, loose) {
      return new semver$1(a, loose).compare(new semver$1(b, loose));
    };

    var compare_1 = compare$2;

    var eq$1 = function eq(a, b, loose) {
      return compare_1(a, b, loose) === 0;
    };

    var eq_1$1 = eq$1;

    var neq = function neq(a, b, loose) {
      return compare_1(a, b, loose) !== 0;
    };

    var neq_1 = neq;

    var gt = function gt(a, b, loose) {
      return compare_1(a, b, loose) > 0;
    };

    var gt_1 = gt;

    var gte = function gte(a, b, loose) {
      return compare_1(a, b, loose) >= 0;
    };

    var gte_1 = gte;

    var lt = function lt(a, b, loose) {
      return compare_1(a, b, loose) < 0;
    };

    var lt_1 = lt;

    var lte = function lte(a, b, loose) {
      return compare_1(a, b, loose) <= 0;
    };

    var lte_1 = lte;

    var cmp = function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq_1$1(a, b, loose);

        case '!=':
          return neq_1(a, b, loose);

        case '>':
          return gt_1(a, b, loose);

        case '>=':
          return gte_1(a, b, loose);

        case '<':
          return lt_1(a, b, loose);

        case '<=':
          return lte_1(a, b, loose);

        default:
          throw new TypeError("Invalid operator: " + op);
      }
    };

    var cmp_1 = cmp;

    var MAX_LENGTH$2 = constants.MAX_LENGTH;

    var re$1 = re_1.re,
        t$2 = re_1.t;



    var parse$6 = function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof semver$1) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH$2) {
        return null;
      }

      var r = options.loose ? re$1[t$2.LOOSE] : re$1[t$2.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new semver$1(version, options);
      } catch (er) {
        return null;
      }
    };

    var parse_1 = parse$6;

    var re$2 = re_1.re,
        t$3 = re_1.t;

    var coerce = function coerce(version, options) {
      if (version instanceof semver$1) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re$2[t$3.COERCE]);
      } else {
        var next;

        while ((next = re$2[t$3.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re$2[t$3.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re$2[t$3.COERCERTL].lastIndex = -1;
      }

      if (match === null) return null;
      return parse_1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
    };

    var coerce_1 = coerce;

    var has$7 = Function.call.bind({}.hasOwnProperty);

    function compare$3(a, operator, b) {
      return cmp_1(coerce_1(a), operator, coerce_1(b));
    }

    function intersection$1(list, order) {
      var set = list instanceof Set ? list : new Set(list);
      return order.filter(function (name) {
        return set.has(name);
      });
    }

    function sortObjectByKey(object, fn) {
      return Object.keys(object).sort(fn).reduce(function (memo, key) {
        memo[key] = object[key];
        return memo;
      }, {});
    }

    var helpers$1 = {
      compare: compare$3,
      has: has$7,
      intersection: intersection$1,
      semver: coerce_1,
      sortObjectByKey: sortObjectByKey
    };

    var modulesByVersions = {
    	"3.0": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.data-view",
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string",
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name",
    	"es.json.to-string-tag",
    	"es.map",
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"es.parse-float",
    	"es.parse-int",
    	"es.promise",
    	"es.promise.finally",
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.to-string",
    	"es.set",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string",
    	"es.weak-map",
    	"es.weak-set",
    	"esnext.aggregate-error",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator",
    	"web.immediate",
    	"web.queue-microtask",
    	"web.timers",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"3.1": [
    	"es.string.match-all",
    	"es.symbol.match-all",
    	"esnext.symbol.replace-all"
    ],
    	"3.2": [
    	"es.promise.all-settled",
    	"esnext.array.is-template-object",
    	"esnext.map.update-or-insert",
    	"esnext.symbol.async-dispose"
    ],
    	"3.3": [
    	"es.global-this",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.upsert",
    	"esnext.weak-map.upsert"
    ],
    	"3.4": [
    	"es.json.stringify"
    ],
    	"3.5": [
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values"
    ],
    	"3.6": [
    	"es.regexp.sticky",
    	"es.regexp.test"
    ]
    };

    var modulesByVersions$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': modulesByVersions
    });

    var modules = [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.data-view",
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string",
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name",
    	"es.global-this",
    	"es.json.stringify",
    	"es.json.to-string-tag",
    	"es.map",
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"es.parse-float",
    	"es.parse-int",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.set",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string",
    	"es.weak-map",
    	"es.weak-set",
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator",
    	"web.immediate",
    	"web.queue-microtask",
    	"web.timers",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ];

    var modules$1 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      'default': modules
    });

    var modulesByVersions$2 = getCjsExportFromNamespace(modulesByVersions$1);

    var modules$2 = getCjsExportFromNamespace(modules$1);

    var compare$4 = helpers$1.compare,
        intersection$2 = helpers$1.intersection,
        semver$2 = helpers$1.semver;





    var getModulesListForTargetVersion = function (raw) {
      var corejs = semver$2(raw);

      if (corejs.major !== 3) {
        throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');
      }

      var result = [];

      for (var _i = 0, _Object$keys = Object.keys(modulesByVersions$2); _i < _Object$keys.length; _i++) {
        var version = _Object$keys[_i];

        if (compare$4(version, '<=', corejs)) {
          result.push.apply(result, modulesByVersions$2[version]);
        }
      }

      return intersection$2(result, modules$2);
    };

    var ArrayNatureIterators$1 = ["es.array.iterator", "web.dom-collections.iterator"];
    var CommonIterators$1 = ["es.string.iterator"].concat(ArrayNatureIterators$1);
    var ArrayNatureIteratorsWithTag = ["es.object.to-string"].concat(ArrayNatureIterators$1);
    var CommonIteratorsWithTag = ["es.object.to-string"].concat(CommonIterators$1);
    var TypedArrayDependencies = ["es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice"];
    var TypedArrayStaticMethods = {
      from: "es.typed-array.from",
      of: "es.typed-array.of"
    };
    var PromiseDependencies$1 = ["es.promise", "es.object.to-string"];
    var PromiseDependenciesWithIterators = [].concat(PromiseDependencies$1, CommonIterators$1);
    var SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
    var MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(CommonIteratorsWithTag);
    var SetDependencies = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(CommonIteratorsWithTag);
    var WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all"].concat(CommonIteratorsWithTag);
    var WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(CommonIteratorsWithTag);
    var URLSearchParamsDependencies = ["web.url"].concat(CommonIteratorsWithTag);
    var BuiltIns$1 = {
      AggregateError: ["esnext.aggregate-error"].concat(CommonIterators$1),
      ArrayBuffer: ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"],
      DataView: ["es.data-view", "es.array-buffer.slice", "es.object.to-string"],
      Date: ["es.date.to-string"],
      Float32Array: ["es.typed-array.float32-array"].concat(TypedArrayDependencies),
      Float64Array: ["es.typed-array.float64-array"].concat(TypedArrayDependencies),
      Int8Array: ["es.typed-array.int8-array"].concat(TypedArrayDependencies),
      Int16Array: ["es.typed-array.int16-array"].concat(TypedArrayDependencies),
      Int32Array: ["es.typed-array.int32-array"].concat(TypedArrayDependencies),
      Uint8Array: ["es.typed-array.uint8-array"].concat(TypedArrayDependencies),
      Uint8ClampedArray: ["es.typed-array.uint8-clamped-array"].concat(TypedArrayDependencies),
      Uint16Array: ["es.typed-array.uint16-array"].concat(TypedArrayDependencies),
      Uint32Array: ["es.typed-array.uint32-array"].concat(TypedArrayDependencies),
      Map: MapDependencies,
      Number: ["es.number.constructor"],
      Observable: ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(CommonIteratorsWithTag),
      Promise: PromiseDependencies$1,
      RegExp: ["es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string"],
      Set: SetDependencies,
      Symbol: SymbolDependencies,
      URL: ["web.url"].concat(URLSearchParamsDependencies),
      URLSearchParams: URLSearchParamsDependencies,
      WeakMap: WeakMapDependencies,
      WeakSet: WeakSetDependencies,
      clearImmediate: ["web.immediate"],
      compositeKey: ["esnext.composite-key"],
      compositeSymbol: ["esnext.composite-symbol"].concat(SymbolDependencies),
      fetch: PromiseDependencies$1,
      globalThis: ["es.global-this", "esnext.global-this"],
      parseFloat: ["es.parse-float"],
      parseInt: ["es.parse-int"],
      queueMicrotask: ["web.queue-microtask"],
      setTimeout: ["web.timers"],
      setInterval: ["web.timers"],
      setImmediate: ["web.immediate"]
    };
    var InstanceProperties$1 = {
      at: ["esnext.string.at"],
      anchor: ["es.string.anchor"],
      big: ["es.string.big"],
      bind: ["es.function.bind"],
      blink: ["es.string.blink"],
      bold: ["es.string.bold"],
      codePointAt: ["es.string.code-point-at"],
      codePoints: ["esnext.string.code-points"],
      concat: ["es.array.concat"],
      copyWithin: ["es.array.copy-within"],
      description: ["es.symbol", "es.symbol.description"],
      endsWith: ["es.string.ends-with"],
      entries: ArrayNatureIteratorsWithTag,
      every: ["es.array.every"],
      exec: ["es.regexp.exec"],
      fill: ["es.array.fill"],
      filter: ["es.array.filter"],
      "finally": ["es.promise.finally"].concat(PromiseDependencies$1),
      find: ["es.array.find"],
      findIndex: ["es.array.find-index"],
      fixed: ["es.string.fixed"],
      flags: ["es.regexp.flags"],
      flat: ["es.array.flat", "es.array.unscopables.flat"],
      flatMap: ["es.array.flat-map", "es.array.unscopables.flat-map"],
      fontcolor: ["es.string.fontcolor"],
      fontsize: ["es.string.fontsize"],
      forEach: ["es.array.for-each", "web.dom-collections.for-each"],
      includes: ["es.array.includes", "es.string.includes"],
      indexOf: ["es.array.index-of"],
      italics: ["es.string.italics"],
      join: ["es.array.join"],
      keys: ArrayNatureIteratorsWithTag,
      lastIndex: ["esnext.array.last-index"],
      lastIndexOf: ["es.array.last-index-of"],
      lastItem: ["esnext.array.last-item"],
      link: ["es.string.link"],
      match: ["es.string.match", "es.regexp.exec"],
      matchAll: ["es.string.match-all", "esnext.string.match-all"],
      map: ["es.array.map"],
      name: ["es.function.name"],
      padEnd: ["es.string.pad-end"],
      padStart: ["es.string.pad-start"],
      reduce: ["es.array.reduce"],
      reduceRight: ["es.array.reduce-right"],
      repeat: ["es.string.repeat"],
      replace: ["es.string.replace", "es.regexp.exec"],
      replaceAll: ["esnext.string.replace-all"],
      reverse: ["es.array.reverse"],
      search: ["es.string.search", "es.regexp.exec"],
      slice: ["es.array.slice"],
      small: ["es.string.small"],
      some: ["es.array.some"],
      sort: ["es.array.sort"],
      splice: ["es.array.splice"],
      split: ["es.string.split", "es.regexp.exec"],
      startsWith: ["es.string.starts-with"],
      strike: ["es.string.strike"],
      sub: ["es.string.sub"],
      sup: ["es.string.sup"],
      toFixed: ["es.number.to-fixed"],
      toISOString: ["es.date.to-iso-string"],
      toJSON: ["es.date.to-json", "web.url.to-json"],
      toPrecision: ["es.number.to-precision"],
      toString: ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"],
      trim: ["es.string.trim"],
      trimEnd: ["es.string.trim-end"],
      trimLeft: ["es.string.trim-start"],
      trimRight: ["es.string.trim-end"],
      trimStart: ["es.string.trim-start"],
      values: ArrayNatureIteratorsWithTag,
      __defineGetter__: ["es.object.define-getter"],
      __defineSetter__: ["es.object.define-setter"],
      __lookupGetter__: ["es.object.lookup-getter"],
      __lookupSetter__: ["es.object.lookup-setter"]
    };
    var StaticProperties$1 = {
      Array: {
        from: ["es.array.from", "es.string.iterator"],
        isArray: ["es.array.is-array"],
        of: ["es.array.of"]
      },
      Date: {
        now: "es.date.now"
      },
      Object: {
        assign: "es.object.assign",
        create: "es.object.create",
        defineProperty: "es.object.define-property",
        defineProperties: "es.object.define-properties",
        entries: "es.object.entries",
        freeze: "es.object.freeze",
        fromEntries: ["es.object.from-entries", "es.array.iterator"],
        getOwnPropertyDescriptor: "es.object.get-own-property-descriptor",
        getOwnPropertyDescriptors: "es.object.get-own-property-descriptors",
        getOwnPropertyNames: "es.object.get-own-property-names",
        getOwnPropertySymbols: "es.symbol",
        getPrototypeOf: "es.object.get-prototype-of",
        is: "es.object.is",
        isExtensible: "es.object.is-extensible",
        isFrozen: "es.object.is-frozen",
        isSealed: "es.object.is-sealed",
        keys: "es.object.keys",
        preventExtensions: "es.object.prevent-extensions",
        seal: "es.object.seal",
        setPrototypeOf: "es.object.set-prototype-of",
        values: "es.object.values"
      },
      Math: {
        DEG_PER_RAD: "esnext.math.deg-per-rad",
        RAD_PER_DEG: "esnext.math.rad-per-deg",
        acosh: "es.math.acosh",
        asinh: "es.math.asinh",
        atanh: "es.math.atanh",
        cbrt: "es.math.cbrt",
        clamp: "esnext.math.clamp",
        clz32: "es.math.clz32",
        cosh: "es.math.cosh",
        degrees: "esnext.math.degrees",
        expm1: "es.math.expm1",
        fround: "es.math.fround",
        fscale: "esnext.math.fscale",
        hypot: "es.math.hypot",
        iaddh: "esnext.math.iaddh",
        imul: "es.math.imul",
        imulh: "esnext.math.imulh",
        isubh: "esnext.math.isubh",
        log1p: "es.math.log1p",
        log10: "es.math.log10",
        log2: "es.math.log2",
        radians: "esnext.math.radians",
        scale: "esnext.math.scale",
        seededPRNG: "esnext.math.seeded-prng",
        sign: "es.math.sign",
        signbit: "esnext.math.signbit",
        sinh: "es.math.sinh",
        tanh: "es.math.tanh",
        trunc: "es.math.trunc",
        umulh: "esnext.math.umulh"
      },
      String: {
        fromCodePoint: "es.string.from-code-point",
        raw: "es.string.raw"
      },
      Number: {
        EPSILON: "es.number.epsilon",
        MIN_SAFE_INTEGER: "es.number.min-safe-integer",
        MAX_SAFE_INTEGER: "es.number.max-safe-integer",
        fromString: "esnext.number.from-string",
        isFinite: "es.number.is-finite",
        isInteger: "es.number.is-integer",
        isSafeInteger: "es.number.is-safe-integer",
        isNaN: "es.number.is-nan",
        parseFloat: "es.number.parse-float",
        parseInt: "es.number.parse-int"
      },
      Map: {
        from: ["esnext.map.from"].concat(MapDependencies),
        groupBy: ["esnext.map.group-by"].concat(MapDependencies),
        keyBy: ["esnext.map.key-by"].concat(MapDependencies),
        of: ["esnext.map.of"].concat(MapDependencies)
      },
      Set: {
        from: ["esnext.set.from"].concat(SetDependencies),
        of: ["esnext.set.of"].concat(SetDependencies)
      },
      WeakMap: {
        from: ["esnext.weak-map.from"].concat(WeakMapDependencies),
        of: ["esnext.weak-map.of"].concat(WeakMapDependencies)
      },
      WeakSet: {
        from: ["esnext.weak-set.from"].concat(WeakSetDependencies),
        of: ["esnext.weak-set.of"].concat(WeakSetDependencies)
      },
      Promise: {
        all: PromiseDependenciesWithIterators,
        allSettled: ["es.promise.all-settled", "esnext.promise.all-settled"].concat(PromiseDependenciesWithIterators),
        any: ["esnext.promise.any", "esnext.aggregate-error"].concat(PromiseDependenciesWithIterators),
        race: PromiseDependenciesWithIterators,
        "try": ["esnext.promise.try"].concat(PromiseDependenciesWithIterators)
      },
      Reflect: {
        apply: "es.reflect.apply",
        construct: "es.reflect.construct",
        defineMetadata: "esnext.reflect.define-metadata",
        defineProperty: "es.reflect.define-property",
        deleteMetadata: "esnext.reflect.delete-metadata",
        deleteProperty: "es.reflect.delete-property",
        get: "es.reflect.get",
        getMetadata: "esnext.reflect.get-metadata",
        getMetadataKeys: "esnext.reflect.get-metadata-keys",
        getOwnMetadata: "esnext.reflect.get-own-metadata",
        getOwnMetadataKeys: "esnext.reflect.get-own-metadata-keys",
        getOwnPropertyDescriptor: "es.reflect.get-own-property-descriptor",
        getPrototypeOf: "es.reflect.get-prototype-of",
        has: "es.reflect.has",
        hasMetadata: "esnext.reflect.has-metadata",
        hasOwnMetadata: "esnext.reflect.has-own-metadata",
        isExtensible: "es.reflect.is-extensible",
        metadata: "esnext.reflect.metadata",
        ownKeys: "es.reflect.own-keys",
        preventExtensions: "es.reflect.prevent-extensions",
        set: "es.reflect.set",
        setPrototypeOf: "es.reflect.set-prototype-of"
      },
      Symbol: {
        asyncIterator: ["es.symbol.async-iterator"],
        dispose: ["esnext.symbol.dispose"],
        hasInstance: ["es.symbol.has-instance", "es.function.has-instance"],
        isConcatSpreadable: ["es.symbol.is-concat-spreadable", "es.array.concat"],
        iterator: ["es.symbol.iterator"].concat(CommonIteratorsWithTag),
        match: ["es.symbol.match", "es.string.match"],
        observable: ["esnext.symbol.observable"],
        patternMatch: ["esnext.symbol.pattern-match"],
        replace: ["es.symbol.replace", "es.string.replace"],
        search: ["es.symbol.search", "es.string.search"],
        species: ["es.symbol.species", "es.array.species"],
        split: ["es.symbol.split", "es.string.split"],
        toPrimitive: ["es.symbol.to-primitive", "es.date.to-primitive"],
        toStringTag: ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"],
        unscopables: ["es.symbol.unscopables"]
      },
      ArrayBuffer: {
        isView: ["es.array-buffer.is-view"]
      },
      Int8Array: TypedArrayStaticMethods,
      Uint8Array: TypedArrayStaticMethods,
      Uint8ClampedArray: TypedArrayStaticMethods,
      Int16Array: TypedArrayStaticMethods,
      Uint16Array: TypedArrayStaticMethods,
      Int32Array: TypedArrayStaticMethods,
      Uint32Array: TypedArrayStaticMethods,
      Float32Array: TypedArrayStaticMethods,
      Float64Array: TypedArrayStaticMethods
    };
    var CommonInstanceDependencies = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);
    var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);

    var NO_DIRECT_POLYFILL_IMPORT$1 = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `core-js` or use `useBuiltIns: 'entry'` instead.";
    var corejs3PolyfillsWithoutProposals = Object.keys(corejs3Polyfills).filter(function (name) {
      return !name.startsWith("esnext.");
    }).reduce(function (memo, key) {
      memo[key] = corejs3Polyfills[key];
      return memo;
    }, {});
    var corejs3PolyfillsWithShippedProposals = corejs3ShippedProposals$2.reduce(function (memo, key) {
      memo[key] = corejs3Polyfills[key];
      return memo;
    }, Object.assign({}, corejs3PolyfillsWithoutProposals));
    function addCoreJS3UsagePlugin (_, _ref) {
      var corejs = _ref.corejs,
          include = _ref.include,
          exclude = _ref.exclude,
          polyfillTargets = _ref.polyfillTargets,
          proposals = _ref.proposals,
          shippedProposals = _ref.shippedProposals,
          debug = _ref.debug;
      var polyfills = filterItems(proposals ? corejs3Polyfills : shippedProposals ? corejs3PolyfillsWithShippedProposals : corejs3PolyfillsWithoutProposals, include, exclude, polyfillTargets, null);
      var available = new Set(getModulesListForTargetVersion(corejs.version));

      function resolveKey(path, computed) {
        var node = path.node,
            parent = path.parent,
            scope = path.scope;
        if (path.isStringLiteral()) return node.value;
        var name = node.name;
        var isIdentifier = path.isIdentifier();
        if (isIdentifier && !(computed || parent.computed)) return name;

        if (!isIdentifier || scope.getBindingIdentifier(name)) {
          var _path$evaluate = path.evaluate(),
              value = _path$evaluate.value;

          if (typeof value === "string") return value;
        }
      }

      function resolveSource(path) {
        var node = path.node,
            scope = path.scope;
        var builtIn, instanceType;

        if (node) {
          builtIn = node.name;

          if (!path.isIdentifier() || scope.getBindingIdentifier(builtIn)) {
            var _path$evaluate2 = path.evaluate(),
                deopt = _path$evaluate2.deopt,
                value = _path$evaluate2.value;

            if (value !== undefined) {
              instanceType = getType$1(value);
            } else if (deopt && deopt.isIdentifier()) {
              builtIn = deopt.node.name;
            }
          }
        }

        return {
          builtIn: builtIn,
          instanceType: instanceType,
          isNamespaced: isNamespaced(path)
        };
      }

      var addAndRemovePolyfillImports = {
        ImportDeclaration: function ImportDeclaration(path) {
          if (isPolyfillSource(getImportSource(path))) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT$1);
            path.remove();
          }
        },
        Program: {
          enter: function enter(path) {
            path.get("body").forEach(function (bodyPath) {
              if (isPolyfillSource(getRequireSource(bodyPath))) {
                console.warn(NO_DIRECT_POLYFILL_IMPORT$1);
                bodyPath.remove();
              }
            });
          },
          exit: function exit(path) {
            var _this = this;

            var filtered = intersection(polyfills, this.polyfillsSet, available);
            var reversed = Array.from(filtered).reverse();

            for (var _iterator = _createForOfIteratorHelperLoose(reversed), _step; !(_step = _iterator()).done;) {
              var module = _step.value;

              if (!this.injectedPolyfills.has(module)) {
                createImport(path, module);
              }
            }

            filtered.forEach(function (module) {
              return _this.injectedPolyfills.add(module);
            });
          }
        },
        Import: function Import() {
          this.addUnsupported(PromiseDependencies$1);
        },
        Function: function Function(_ref2) {
          var node = _ref2.node;

          if (node.async) {
            this.addUnsupported(PromiseDependencies$1);
          }
        },
        "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern() {
          this.addUnsupported(CommonIterators$1);
        },
        SpreadElement: function SpreadElement(_ref3) {
          var parentPath = _ref3.parentPath;

          if (!parentPath.isObjectExpression()) {
            this.addUnsupported(CommonIterators$1);
          }
        },
        YieldExpression: function YieldExpression(_ref4) {
          var node = _ref4.node;

          if (node.delegate) {
            this.addUnsupported(CommonIterators$1);
          }
        },
        ReferencedIdentifier: function ReferencedIdentifier(_ref5) {
          var name = _ref5.node.name,
              scope = _ref5.scope;
          if (scope.getBindingIdentifier(name)) return;
          this.addBuiltInDependencies(name);
        },
        MemberExpression: function MemberExpression(path) {
          var source = resolveSource(path.get("object"));
          var key = resolveKey(path.get("property"));
          this.addPropertyDependencies(source, key);
        },
        ObjectPattern: function ObjectPattern(path) {
          var parentPath = path.parentPath,
              parent = path.parent,
              key = path.key;
          var source;

          if (parentPath.isVariableDeclarator()) {
            source = resolveSource(parentPath.get("init"));
          } else if (parentPath.isAssignmentExpression()) {
            source = resolveSource(parentPath.get("right"));
          } else if (parentPath.isFunctionExpression()) {
            var grand = parentPath.parentPath;

            if (grand.isCallExpression() || grand.isNewExpression()) {
              if (grand.node.callee === parent) {
                source = resolveSource(grand.get("arguments")[key]);
              }
            }
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("properties")), _step2; !(_step2 = _iterator2()).done;) {
            var property = _step2.value;

            if (property.isObjectProperty()) {
              var _key = resolveKey(property.get("key"));

              this.addPropertyDependencies(source, _key);
            }
          }
        },
        BinaryExpression: function BinaryExpression(path) {
          if (path.node.operator !== "in") return;
          var source = resolveSource(path.get("right"));
          var key = resolveKey(path.get("left"), true);
          this.addPropertyDependencies(source, key);
        }
      };
      return {
        name: "corejs3-usage",
        pre: function pre() {
          this.injectedPolyfills = new Set();
          this.polyfillsSet = new Set();

          this.addUnsupported = function (builtIn) {
            var modules = Array.isArray(builtIn) ? builtIn : [builtIn];

            for (var _iterator3 = _createForOfIteratorHelperLoose(modules), _step3; !(_step3 = _iterator3()).done;) {
              var module = _step3.value;
              this.polyfillsSet.add(module);
            }
          };

          this.addBuiltInDependencies = function (builtIn) {
            if (has$6(BuiltIns$1, builtIn)) {
              var BuiltInDependencies = BuiltIns$1[builtIn];
              this.addUnsupported(BuiltInDependencies);
            }
          };

          this.addPropertyDependencies = function (source, key) {
            if (source === void 0) {
              source = {};
            }

            var _source = source,
                builtIn = _source.builtIn,
                instanceType = _source.instanceType,
                isNamespaced = _source.isNamespaced;
            if (isNamespaced) return;

            if (PossibleGlobalObjects.has(builtIn)) {
              this.addBuiltInDependencies(key);
            } else if (has$6(StaticProperties$1, builtIn)) {
              var BuiltInProperties = StaticProperties$1[builtIn];

              if (has$6(BuiltInProperties, key)) {
                var StaticPropertyDependencies = BuiltInProperties[key];
                return this.addUnsupported(StaticPropertyDependencies);
              }
            }

            if (!has$6(InstanceProperties$1, key)) return;
            var InstancePropertyDependencies = InstanceProperties$1[key];

            if (instanceType) {
              InstancePropertyDependencies = InstancePropertyDependencies.filter(function (m) {
                return m.includes(instanceType) || CommonInstanceDependencies.has(m);
              });
            }

            this.addUnsupported(InstancePropertyDependencies);
          };
        },
        post: function post() {
          if (debug) {
            logUsagePolyfills(this.injectedPolyfills, this.file.opts.filename, polyfillTargets, corejs3Polyfills);
          }
        },
        visitor: addAndRemovePolyfillImports
      };
    }

    function addRegeneratorUsagePlugin () {
      return {
        name: "regenerator-usage",
        pre: function pre() {
          this.usesRegenerator = false;
        },
        visitor: {
          Function: function Function(path) {
            var node = path.node;

            if (!this.usesRegenerator && (node.generator || node.async)) {
              this.usesRegenerator = true;
              createImport(path, "regenerator-runtime");
            }
          }
        },
        post: function post() {
          if (this.opts.debug && this.usesRegenerator) {
            var filename = this.file.opts.filename;

            if (process.env.BABEL_ENV === "test") {
              filename = filename.replace(/\\/g, "/");
            }

            console.log("\n[" + filename + "] Based on your code and targets, added regenerator-runtime.");
          }
        }
      };
    }

    function replaceCoreJS2EntryPlugin (_, _ref) {
      var include = _ref.include,
          exclude = _ref.exclude,
          polyfillTargets = _ref.polyfillTargets,
          regenerator = _ref.regenerator,
          debug = _ref.debug;
      var polyfills = filterItems(corejs2BuiltIns$2, include, exclude, polyfillTargets, getPlatformSpecificDefaultFor(polyfillTargets));
      var isPolyfillImport = {
        ImportDeclaration: function ImportDeclaration(path) {
          if (isPolyfillSource(getImportSource(path))) {
            this.replaceBySeparateModulesImport(path);
          }
        },
        Program: function Program(path) {
          var _this = this;

          path.get("body").forEach(function (bodyPath) {
            if (isPolyfillSource(getRequireSource(bodyPath))) {
              _this.replaceBySeparateModulesImport(bodyPath);
            }
          });
        }
      };
      return {
        name: "corejs2-entry",
        visitor: isPolyfillImport,
        pre: function pre() {
          this.importPolyfillIncluded = false;

          this.replaceBySeparateModulesImport = function (path) {
            this.importPolyfillIncluded = true;

            if (regenerator) {
              createImport(path, "regenerator-runtime");
            }

            var modules = Array.from(polyfills).reverse();

            for (var _iterator = _createForOfIteratorHelperLoose(modules), _step; !(_step = _iterator()).done;) {
              var module = _step.value;
              createImport(path, module);
            }

            path.remove();
          };
        },
        post: function post() {
          if (debug) {
            logEntryPolyfills("@babel/polyfill", this.importPolyfillIncluded, polyfills, this.file.opts.filename, polyfillTargets, corejs2BuiltIns$2);
          }
        }
      };
    }

    var corejsEntries = {
    	"core-js": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.data-view",
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string",
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name",
    	"es.global-this",
    	"es.json.stringify",
    	"es.json.to-string-tag",
    	"es.map",
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"es.parse-float",
    	"es.parse-int",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.set",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string",
    	"es.weak-map",
    	"es.weak-set",
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator",
    	"web.immediate",
    	"web.queue-microtask",
    	"web.timers",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/es": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.data-view",
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string",
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name",
    	"es.global-this",
    	"es.json.stringify",
    	"es.json.to-string-tag",
    	"es.map",
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"es.parse-float",
    	"es.parse-int",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.set",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string",
    	"es.weak-map",
    	"es.weak-set"
    ],
    	"core-js/es/array": [
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.string.iterator"
    ],
    	"core-js/es/array-buffer": [
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.object.to-string"
    ],
    	"core-js/es/array-buffer/constructor": [
    	"es.array-buffer.constructor",
    	"es.object.to-string"
    ],
    	"core-js/es/array-buffer/is-view": [
    	"es.array-buffer.is-view"
    ],
    	"core-js/es/array-buffer/slice": [
    	"es.array-buffer.slice"
    ],
    	"core-js/es/array/concat": [
    	"es.array.concat"
    ],
    	"core-js/es/array/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/es/array/entries": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/every": [
    	"es.array.every"
    ],
    	"core-js/es/array/fill": [
    	"es.array.fill"
    ],
    	"core-js/es/array/filter": [
    	"es.array.filter"
    ],
    	"core-js/es/array/find": [
    	"es.array.find"
    ],
    	"core-js/es/array/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/es/array/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/es/array/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/es/array/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/es/array/from": [
    	"es.array.from",
    	"es.string.iterator"
    ],
    	"core-js/es/array/includes": [
    	"es.array.includes"
    ],
    	"core-js/es/array/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/es/array/is-array": [
    	"es.array.is-array"
    ],
    	"core-js/es/array/iterator": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/join": [
    	"es.array.join"
    ],
    	"core-js/es/array/keys": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/es/array/map": [
    	"es.array.map"
    ],
    	"core-js/es/array/of": [
    	"es.array.of"
    ],
    	"core-js/es/array/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/es/array/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/es/array/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/es/array/slice": [
    	"es.array.slice"
    ],
    	"core-js/es/array/some": [
    	"es.array.some"
    ],
    	"core-js/es/array/sort": [
    	"es.array.sort"
    ],
    	"core-js/es/array/splice": [
    	"es.array.splice"
    ],
    	"core-js/es/array/values": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/virtual": [
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/es/array/virtual/concat": [
    	"es.array.concat"
    ],
    	"core-js/es/array/virtual/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/es/array/virtual/entries": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/virtual/every": [
    	"es.array.every"
    ],
    	"core-js/es/array/virtual/fill": [
    	"es.array.fill"
    ],
    	"core-js/es/array/virtual/filter": [
    	"es.array.filter"
    ],
    	"core-js/es/array/virtual/find": [
    	"es.array.find"
    ],
    	"core-js/es/array/virtual/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/es/array/virtual/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/es/array/virtual/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/es/array/virtual/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/es/array/virtual/includes": [
    	"es.array.includes"
    ],
    	"core-js/es/array/virtual/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/es/array/virtual/iterator": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/virtual/join": [
    	"es.array.join"
    ],
    	"core-js/es/array/virtual/keys": [
    	"es.array.iterator"
    ],
    	"core-js/es/array/virtual/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/es/array/virtual/map": [
    	"es.array.map"
    ],
    	"core-js/es/array/virtual/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/es/array/virtual/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/es/array/virtual/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/es/array/virtual/slice": [
    	"es.array.slice"
    ],
    	"core-js/es/array/virtual/some": [
    	"es.array.some"
    ],
    	"core-js/es/array/virtual/sort": [
    	"es.array.sort"
    ],
    	"core-js/es/array/virtual/splice": [
    	"es.array.splice"
    ],
    	"core-js/es/array/virtual/values": [
    	"es.array.iterator"
    ],
    	"core-js/es/data-view": [
    	"es.data-view",
    	"es.object.to-string"
    ],
    	"core-js/es/date": [
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string"
    ],
    	"core-js/es/date/now": [
    	"es.date.now"
    ],
    	"core-js/es/date/to-iso-string": [
    	"es.date.to-iso-string",
    	"es.date.to-json"
    ],
    	"core-js/es/date/to-json": [
    	"es.date.to-json"
    ],
    	"core-js/es/date/to-primitive": [
    	"es.date.to-primitive"
    ],
    	"core-js/es/date/to-string": [
    	"es.date.to-string"
    ],
    	"core-js/es/function": [
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name"
    ],
    	"core-js/es/function/bind": [
    	"es.function.bind"
    ],
    	"core-js/es/function/has-instance": [
    	"es.function.has-instance"
    ],
    	"core-js/es/function/name": [
    	"es.function.name"
    ],
    	"core-js/es/function/virtual": [
    	"es.function.bind"
    ],
    	"core-js/es/function/virtual/bind": [
    	"es.function.bind"
    ],
    	"core-js/es/global-this": [
    	"es.global-this"
    ],
    	"core-js/es/instance/bind": [
    	"es.function.bind"
    ],
    	"core-js/es/instance/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/es/instance/concat": [
    	"es.array.concat"
    ],
    	"core-js/es/instance/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/es/instance/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/es/instance/entries": [
    	"es.array.iterator"
    ],
    	"core-js/es/instance/every": [
    	"es.array.every"
    ],
    	"core-js/es/instance/fill": [
    	"es.array.fill"
    ],
    	"core-js/es/instance/filter": [
    	"es.array.filter"
    ],
    	"core-js/es/instance/find": [
    	"es.array.find"
    ],
    	"core-js/es/instance/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/es/instance/flags": [
    	"es.regexp.flags"
    ],
    	"core-js/es/instance/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/es/instance/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/es/instance/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/es/instance/includes": [
    	"es.array.includes",
    	"es.string.includes"
    ],
    	"core-js/es/instance/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/es/instance/keys": [
    	"es.array.iterator"
    ],
    	"core-js/es/instance/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/es/instance/map": [
    	"es.array.map"
    ],
    	"core-js/es/instance/match-all": [
    	"es.string.match-all"
    ],
    	"core-js/es/instance/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/es/instance/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/es/instance/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/es/instance/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/es/instance/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/es/instance/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/es/instance/slice": [
    	"es.array.slice"
    ],
    	"core-js/es/instance/some": [
    	"es.array.some"
    ],
    	"core-js/es/instance/sort": [
    	"es.array.sort"
    ],
    	"core-js/es/instance/splice": [
    	"es.array.splice"
    ],
    	"core-js/es/instance/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/es/instance/trim": [
    	"es.string.trim"
    ],
    	"core-js/es/instance/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/es/instance/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/es/instance/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/es/instance/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/es/instance/values": [
    	"es.array.iterator"
    ],
    	"core-js/es/json": [
    	"es.json.stringify",
    	"es.json.to-string-tag"
    ],
    	"core-js/es/json/stringify": [
    	"es.json.stringify"
    ],
    	"core-js/es/json/to-string-tag": [
    	"es.json.to-string-tag"
    ],
    	"core-js/es/map": [
    	"es.map",
    	"es.object.to-string",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/es/math": [
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc"
    ],
    	"core-js/es/math/acosh": [
    	"es.math.acosh"
    ],
    	"core-js/es/math/asinh": [
    	"es.math.asinh"
    ],
    	"core-js/es/math/atanh": [
    	"es.math.atanh"
    ],
    	"core-js/es/math/cbrt": [
    	"es.math.cbrt"
    ],
    	"core-js/es/math/clz32": [
    	"es.math.clz32"
    ],
    	"core-js/es/math/cosh": [
    	"es.math.cosh"
    ],
    	"core-js/es/math/expm1": [
    	"es.math.expm1"
    ],
    	"core-js/es/math/fround": [
    	"es.math.fround"
    ],
    	"core-js/es/math/hypot": [
    	"es.math.hypot"
    ],
    	"core-js/es/math/imul": [
    	"es.math.imul"
    ],
    	"core-js/es/math/log10": [
    	"es.math.log10"
    ],
    	"core-js/es/math/log1p": [
    	"es.math.log1p"
    ],
    	"core-js/es/math/log2": [
    	"es.math.log2"
    ],
    	"core-js/es/math/sign": [
    	"es.math.sign"
    ],
    	"core-js/es/math/sinh": [
    	"es.math.sinh"
    ],
    	"core-js/es/math/tanh": [
    	"es.math.tanh"
    ],
    	"core-js/es/math/to-string-tag": [
    	"es.math.to-string-tag"
    ],
    	"core-js/es/math/trunc": [
    	"es.math.trunc"
    ],
    	"core-js/es/number": [
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision"
    ],
    	"core-js/es/number/constructor": [
    	"es.number.constructor"
    ],
    	"core-js/es/number/epsilon": [
    	"es.number.epsilon"
    ],
    	"core-js/es/number/is-finite": [
    	"es.number.is-finite"
    ],
    	"core-js/es/number/is-integer": [
    	"es.number.is-integer"
    ],
    	"core-js/es/number/is-nan": [
    	"es.number.is-nan"
    ],
    	"core-js/es/number/is-safe-integer": [
    	"es.number.is-safe-integer"
    ],
    	"core-js/es/number/max-safe-integer": [
    	"es.number.max-safe-integer"
    ],
    	"core-js/es/number/min-safe-integer": [
    	"es.number.min-safe-integer"
    ],
    	"core-js/es/number/parse-float": [
    	"es.number.parse-float"
    ],
    	"core-js/es/number/parse-int": [
    	"es.number.parse-int"
    ],
    	"core-js/es/number/to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/es/number/to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/es/number/virtual": [
    	"es.number.to-fixed",
    	"es.number.to-precision"
    ],
    	"core-js/es/number/virtual/to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/es/number/virtual/to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/es/object": [
    	"es.symbol",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values"
    ],
    	"core-js/es/object/assign": [
    	"es.object.assign"
    ],
    	"core-js/es/object/create": [
    	"es.object.create"
    ],
    	"core-js/es/object/define-getter": [
    	"es.object.define-getter"
    ],
    	"core-js/es/object/define-properties": [
    	"es.object.define-properties"
    ],
    	"core-js/es/object/define-property": [
    	"es.object.define-property"
    ],
    	"core-js/es/object/define-setter": [
    	"es.object.define-setter"
    ],
    	"core-js/es/object/entries": [
    	"es.object.entries"
    ],
    	"core-js/es/object/freeze": [
    	"es.object.freeze"
    ],
    	"core-js/es/object/from-entries": [
    	"es.array.iterator",
    	"es.object.from-entries"
    ],
    	"core-js/es/object/get-own-property-descriptor": [
    	"es.object.get-own-property-descriptor"
    ],
    	"core-js/es/object/get-own-property-descriptors": [
    	"es.object.get-own-property-descriptors"
    ],
    	"core-js/es/object/get-own-property-names": [
    	"es.object.get-own-property-names"
    ],
    	"core-js/es/object/get-own-property-symbols": [
    	"es.symbol"
    ],
    	"core-js/es/object/get-prototype-of": [
    	"es.object.get-prototype-of"
    ],
    	"core-js/es/object/is": [
    	"es.object.is"
    ],
    	"core-js/es/object/is-extensible": [
    	"es.object.is-extensible"
    ],
    	"core-js/es/object/is-frozen": [
    	"es.object.is-frozen"
    ],
    	"core-js/es/object/is-sealed": [
    	"es.object.is-sealed"
    ],
    	"core-js/es/object/keys": [
    	"es.object.keys"
    ],
    	"core-js/es/object/lookup-getter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/es/object/lookup-setter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/es/object/prevent-extensions": [
    	"es.object.prevent-extensions"
    ],
    	"core-js/es/object/seal": [
    	"es.object.seal"
    ],
    	"core-js/es/object/set-prototype-of": [
    	"es.object.set-prototype-of"
    ],
    	"core-js/es/object/to-string": [
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/es/object/values": [
    	"es.object.values"
    ],
    	"core-js/es/parse-float": [
    	"es.parse-float"
    ],
    	"core-js/es/parse-int": [
    	"es.parse-int"
    ],
    	"core-js/es/promise": [
    	"es.object.to-string",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/es/promise/all-settled": [
    	"es.promise",
    	"es.promise.all-settled"
    ],
    	"core-js/es/promise/finally": [
    	"es.promise",
    	"es.promise.finally"
    ],
    	"core-js/es/reflect": [
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of"
    ],
    	"core-js/es/reflect/apply": [
    	"es.reflect.apply"
    ],
    	"core-js/es/reflect/construct": [
    	"es.reflect.construct"
    ],
    	"core-js/es/reflect/define-property": [
    	"es.reflect.define-property"
    ],
    	"core-js/es/reflect/delete-property": [
    	"es.reflect.delete-property"
    ],
    	"core-js/es/reflect/get": [
    	"es.reflect.get"
    ],
    	"core-js/es/reflect/get-own-property-descriptor": [
    	"es.reflect.get-own-property-descriptor"
    ],
    	"core-js/es/reflect/get-prototype-of": [
    	"es.reflect.get-prototype-of"
    ],
    	"core-js/es/reflect/has": [
    	"es.reflect.has"
    ],
    	"core-js/es/reflect/is-extensible": [
    	"es.reflect.is-extensible"
    ],
    	"core-js/es/reflect/own-keys": [
    	"es.reflect.own-keys"
    ],
    	"core-js/es/reflect/prevent-extensions": [
    	"es.reflect.prevent-extensions"
    ],
    	"core-js/es/reflect/set": [
    	"es.reflect.set"
    ],
    	"core-js/es/reflect/set-prototype-of": [
    	"es.reflect.set-prototype-of"
    ],
    	"core-js/es/regexp": [
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.string.match",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split"
    ],
    	"core-js/es/regexp/constructor": [
    	"es.regexp.constructor"
    ],
    	"core-js/es/regexp/flags": [
    	"es.regexp.flags"
    ],
    	"core-js/es/regexp/match": [
    	"es.string.match"
    ],
    	"core-js/es/regexp/replace": [
    	"es.string.replace"
    ],
    	"core-js/es/regexp/search": [
    	"es.string.search"
    ],
    	"core-js/es/regexp/split": [
    	"es.string.split"
    ],
    	"core-js/es/regexp/sticky": [
    	"es.regexp.sticky"
    ],
    	"core-js/es/regexp/test": [
    	"es.regexp.exec",
    	"es.regexp.test"
    ],
    	"core-js/es/regexp/to-string": [
    	"es.regexp.to-string"
    ],
    	"core-js/es/set": [
    	"es.object.to-string",
    	"es.set",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/es/string": [
    	"es.regexp.exec",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup"
    ],
    	"core-js/es/string/anchor": [
    	"es.string.anchor"
    ],
    	"core-js/es/string/big": [
    	"es.string.big"
    ],
    	"core-js/es/string/blink": [
    	"es.string.blink"
    ],
    	"core-js/es/string/bold": [
    	"es.string.bold"
    ],
    	"core-js/es/string/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/es/string/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/es/string/fixed": [
    	"es.string.fixed"
    ],
    	"core-js/es/string/fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/es/string/fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/es/string/from-code-point": [
    	"es.string.from-code-point"
    ],
    	"core-js/es/string/includes": [
    	"es.string.includes"
    ],
    	"core-js/es/string/italics": [
    	"es.string.italics"
    ],
    	"core-js/es/string/iterator": [
    	"es.string.iterator"
    ],
    	"core-js/es/string/link": [
    	"es.string.link"
    ],
    	"core-js/es/string/match": [
    	"es.regexp.exec",
    	"es.string.match"
    ],
    	"core-js/es/string/match-all": [
    	"es.string.match-all"
    ],
    	"core-js/es/string/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/es/string/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/es/string/raw": [
    	"es.string.raw"
    ],
    	"core-js/es/string/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/es/string/replace": [
    	"es.regexp.exec",
    	"es.string.replace"
    ],
    	"core-js/es/string/search": [
    	"es.regexp.exec",
    	"es.string.search"
    ],
    	"core-js/es/string/small": [
    	"es.string.small"
    ],
    	"core-js/es/string/split": [
    	"es.regexp.exec",
    	"es.string.split"
    ],
    	"core-js/es/string/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/es/string/strike": [
    	"es.string.strike"
    ],
    	"core-js/es/string/sub": [
    	"es.string.sub"
    ],
    	"core-js/es/string/sup": [
    	"es.string.sup"
    ],
    	"core-js/es/string/trim": [
    	"es.string.trim"
    ],
    	"core-js/es/string/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/es/string/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/es/string/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/es/string/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/es/string/virtual": [
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup"
    ],
    	"core-js/es/string/virtual/anchor": [
    	"es.string.anchor"
    ],
    	"core-js/es/string/virtual/big": [
    	"es.string.big"
    ],
    	"core-js/es/string/virtual/blink": [
    	"es.string.blink"
    ],
    	"core-js/es/string/virtual/bold": [
    	"es.string.bold"
    ],
    	"core-js/es/string/virtual/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/es/string/virtual/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/es/string/virtual/fixed": [
    	"es.string.fixed"
    ],
    	"core-js/es/string/virtual/fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/es/string/virtual/fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/es/string/virtual/includes": [
    	"es.string.includes"
    ],
    	"core-js/es/string/virtual/italics": [
    	"es.string.italics"
    ],
    	"core-js/es/string/virtual/iterator": [
    	"es.string.iterator"
    ],
    	"core-js/es/string/virtual/link": [
    	"es.string.link"
    ],
    	"core-js/es/string/virtual/match-all": [
    	"es.string.match-all"
    ],
    	"core-js/es/string/virtual/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/es/string/virtual/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/es/string/virtual/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/es/string/virtual/small": [
    	"es.string.small"
    ],
    	"core-js/es/string/virtual/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/es/string/virtual/strike": [
    	"es.string.strike"
    ],
    	"core-js/es/string/virtual/sub": [
    	"es.string.sub"
    ],
    	"core-js/es/string/virtual/sup": [
    	"es.string.sup"
    ],
    	"core-js/es/string/virtual/trim": [
    	"es.string.trim"
    ],
    	"core-js/es/string/virtual/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/es/string/virtual/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/es/string/virtual/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/es/string/virtual/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/es/symbol": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/es/symbol/async-iterator": [
    	"es.symbol.async-iterator"
    ],
    	"core-js/es/symbol/description": [
    	"es.symbol.description"
    ],
    	"core-js/es/symbol/for": [
    	"es.symbol"
    ],
    	"core-js/es/symbol/has-instance": [
    	"es.symbol.has-instance",
    	"es.function.has-instance"
    ],
    	"core-js/es/symbol/is-concat-spreadable": [
    	"es.symbol.is-concat-spreadable",
    	"es.array.concat"
    ],
    	"core-js/es/symbol/iterator": [
    	"es.symbol.iterator",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/es/symbol/key-for": [
    	"es.symbol"
    ],
    	"core-js/es/symbol/match": [
    	"es.symbol.match",
    	"es.string.match"
    ],
    	"core-js/es/symbol/match-all": [
    	"es.symbol.match-all",
    	"es.string.match-all"
    ],
    	"core-js/es/symbol/replace": [
    	"es.symbol.replace",
    	"es.string.replace"
    ],
    	"core-js/es/symbol/search": [
    	"es.symbol.search",
    	"es.string.search"
    ],
    	"core-js/es/symbol/species": [
    	"es.symbol.species"
    ],
    	"core-js/es/symbol/split": [
    	"es.symbol.split",
    	"es.string.split"
    ],
    	"core-js/es/symbol/to-primitive": [
    	"es.symbol.to-primitive"
    ],
    	"core-js/es/symbol/to-string-tag": [
    	"es.symbol.to-string-tag",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/es/symbol/unscopables": [
    	"es.symbol.unscopables"
    ],
    	"core-js/es/typed-array": [
    	"es.object.to-string",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/copy-within": [
    	"es.typed-array.copy-within"
    ],
    	"core-js/es/typed-array/entries": [
    	"es.typed-array.iterator"
    ],
    	"core-js/es/typed-array/every": [
    	"es.typed-array.every"
    ],
    	"core-js/es/typed-array/fill": [
    	"es.typed-array.fill"
    ],
    	"core-js/es/typed-array/filter": [
    	"es.typed-array.filter"
    ],
    	"core-js/es/typed-array/find": [
    	"es.typed-array.find"
    ],
    	"core-js/es/typed-array/find-index": [
    	"es.typed-array.find-index"
    ],
    	"core-js/es/typed-array/float32-array": [
    	"es.object.to-string",
    	"es.typed-array.float32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/float64-array": [
    	"es.object.to-string",
    	"es.typed-array.float64-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/for-each": [
    	"es.typed-array.for-each"
    ],
    	"core-js/es/typed-array/from": [
    	"es.typed-array.from"
    ],
    	"core-js/es/typed-array/includes": [
    	"es.typed-array.includes"
    ],
    	"core-js/es/typed-array/index-of": [
    	"es.typed-array.index-of"
    ],
    	"core-js/es/typed-array/int16-array": [
    	"es.object.to-string",
    	"es.typed-array.int16-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/int32-array": [
    	"es.object.to-string",
    	"es.typed-array.int32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/int8-array": [
    	"es.object.to-string",
    	"es.typed-array.int8-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/iterator": [
    	"es.typed-array.iterator"
    ],
    	"core-js/es/typed-array/join": [
    	"es.typed-array.join"
    ],
    	"core-js/es/typed-array/keys": [
    	"es.typed-array.iterator"
    ],
    	"core-js/es/typed-array/last-index-of": [
    	"es.typed-array.last-index-of"
    ],
    	"core-js/es/typed-array/map": [
    	"es.typed-array.map"
    ],
    	"core-js/es/typed-array/methods": [
    	"es.object.to-string",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/of": [
    	"es.typed-array.of"
    ],
    	"core-js/es/typed-array/reduce": [
    	"es.typed-array.reduce"
    ],
    	"core-js/es/typed-array/reduce-right": [
    	"es.typed-array.reduce-right"
    ],
    	"core-js/es/typed-array/reverse": [
    	"es.typed-array.reverse"
    ],
    	"core-js/es/typed-array/set": [
    	"es.typed-array.set"
    ],
    	"core-js/es/typed-array/slice": [
    	"es.typed-array.slice"
    ],
    	"core-js/es/typed-array/some": [
    	"es.typed-array.some"
    ],
    	"core-js/es/typed-array/sort": [
    	"es.typed-array.sort"
    ],
    	"core-js/es/typed-array/subarray": [
    	"es.typed-array.subarray"
    ],
    	"core-js/es/typed-array/to-locale-string": [
    	"es.typed-array.to-locale-string"
    ],
    	"core-js/es/typed-array/to-string": [
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/uint16-array": [
    	"es.object.to-string",
    	"es.typed-array.uint16-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/uint32-array": [
    	"es.object.to-string",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/uint8-array": [
    	"es.object.to-string",
    	"es.typed-array.uint8-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/uint8-clamped-array": [
    	"es.object.to-string",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/es/typed-array/values": [
    	"es.typed-array.iterator"
    ],
    	"core-js/es/weak-map": [
    	"es.object.to-string",
    	"es.weak-map",
    	"web.dom-collections.iterator"
    ],
    	"core-js/es/weak-set": [
    	"es.object.to-string",
    	"es.weak-set",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.data-view",
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string",
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name",
    	"es.global-this",
    	"es.json.stringify",
    	"es.json.to-string-tag",
    	"es.map",
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"es.parse-float",
    	"es.parse-int",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.set",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string",
    	"es.weak-map",
    	"es.weak-set",
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator",
    	"web.immediate",
    	"web.queue-microtask",
    	"web.timers",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/features/aggregate-error": [
    	"es.string.iterator",
    	"esnext.aggregate-error",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/array": [
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.string.iterator",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item"
    ],
    	"core-js/features/array-buffer": [
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.object.to-string"
    ],
    	"core-js/features/array-buffer/constructor": [
    	"es.array-buffer.constructor",
    	"es.object.to-string"
    ],
    	"core-js/features/array-buffer/is-view": [
    	"es.array-buffer.is-view"
    ],
    	"core-js/features/array-buffer/slice": [
    	"es.array-buffer.slice"
    ],
    	"core-js/features/array/concat": [
    	"es.array.concat"
    ],
    	"core-js/features/array/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/features/array/entries": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/every": [
    	"es.array.every"
    ],
    	"core-js/features/array/fill": [
    	"es.array.fill"
    ],
    	"core-js/features/array/filter": [
    	"es.array.filter"
    ],
    	"core-js/features/array/find": [
    	"es.array.find"
    ],
    	"core-js/features/array/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/features/array/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/features/array/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/features/array/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/features/array/from": [
    	"es.array.from",
    	"es.string.iterator"
    ],
    	"core-js/features/array/includes": [
    	"es.array.includes"
    ],
    	"core-js/features/array/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/features/array/is-array": [
    	"es.array.is-array"
    ],
    	"core-js/features/array/is-template-object": [
    	"esnext.array.is-template-object"
    ],
    	"core-js/features/array/iterator": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/join": [
    	"es.array.join"
    ],
    	"core-js/features/array/keys": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/last-index": [
    	"esnext.array.last-index"
    ],
    	"core-js/features/array/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/features/array/last-item": [
    	"esnext.array.last-item"
    ],
    	"core-js/features/array/map": [
    	"es.array.map"
    ],
    	"core-js/features/array/of": [
    	"es.array.of"
    ],
    	"core-js/features/array/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/features/array/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/features/array/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/features/array/slice": [
    	"es.array.slice"
    ],
    	"core-js/features/array/some": [
    	"es.array.some"
    ],
    	"core-js/features/array/sort": [
    	"es.array.sort"
    ],
    	"core-js/features/array/splice": [
    	"es.array.splice"
    ],
    	"core-js/features/array/values": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/virtual": [
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/features/array/virtual/concat": [
    	"es.array.concat"
    ],
    	"core-js/features/array/virtual/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/features/array/virtual/entries": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/virtual/every": [
    	"es.array.every"
    ],
    	"core-js/features/array/virtual/fill": [
    	"es.array.fill"
    ],
    	"core-js/features/array/virtual/filter": [
    	"es.array.filter"
    ],
    	"core-js/features/array/virtual/find": [
    	"es.array.find"
    ],
    	"core-js/features/array/virtual/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/features/array/virtual/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/features/array/virtual/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/features/array/virtual/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/features/array/virtual/includes": [
    	"es.array.includes"
    ],
    	"core-js/features/array/virtual/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/features/array/virtual/iterator": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/virtual/join": [
    	"es.array.join"
    ],
    	"core-js/features/array/virtual/keys": [
    	"es.array.iterator"
    ],
    	"core-js/features/array/virtual/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/features/array/virtual/map": [
    	"es.array.map"
    ],
    	"core-js/features/array/virtual/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/features/array/virtual/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/features/array/virtual/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/features/array/virtual/slice": [
    	"es.array.slice"
    ],
    	"core-js/features/array/virtual/some": [
    	"es.array.some"
    ],
    	"core-js/features/array/virtual/sort": [
    	"es.array.sort"
    ],
    	"core-js/features/array/virtual/splice": [
    	"es.array.splice"
    ],
    	"core-js/features/array/virtual/values": [
    	"es.array.iterator"
    ],
    	"core-js/features/async-iterator": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/as-indexed-pairs": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/drop": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.drop",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/every": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.every",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/filter": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.filter",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/find": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.find",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/flat-map": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.flat-map",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/for-each": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/from": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.from",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/map": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.map",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/reduce": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.reduce",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/some": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.some",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/take": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.take",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/async-iterator/to-array": [
    	"es.object.to-string",
    	"es.promise",
    	"es.string.iterator",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.to-array",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/clear-immediate": [
    	"web.immediate"
    ],
    	"core-js/features/composite-key": [
    	"esnext.composite-key"
    ],
    	"core-js/features/composite-symbol": [
    	"es.symbol",
    	"esnext.composite-symbol"
    ],
    	"core-js/features/data-view": [
    	"es.data-view",
    	"es.object.to-string"
    ],
    	"core-js/features/date": [
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string"
    ],
    	"core-js/features/date/now": [
    	"es.date.now"
    ],
    	"core-js/features/date/to-iso-string": [
    	"es.date.to-iso-string",
    	"es.date.to-json"
    ],
    	"core-js/features/date/to-json": [
    	"es.date.to-json"
    ],
    	"core-js/features/date/to-primitive": [
    	"es.date.to-primitive"
    ],
    	"core-js/features/date/to-string": [
    	"es.date.to-string"
    ],
    	"core-js/features/dom-collections": [
    	"es.array.iterator",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/dom-collections/for-each": [
    	"web.dom-collections.for-each"
    ],
    	"core-js/features/dom-collections/iterator": [
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/function": [
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name"
    ],
    	"core-js/features/function/bind": [
    	"es.function.bind"
    ],
    	"core-js/features/function/has-instance": [
    	"es.function.has-instance"
    ],
    	"core-js/features/function/name": [
    	"es.function.name"
    ],
    	"core-js/features/function/virtual": [
    	"es.function.bind"
    ],
    	"core-js/features/function/virtual/bind": [
    	"es.function.bind"
    ],
    	"core-js/features/get-iterator": [
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/get-iterator-method": [
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/global-this": [
    	"es.global-this",
    	"esnext.global-this"
    ],
    	"core-js/features/instance/at": [
    	"esnext.string.at"
    ],
    	"core-js/features/instance/bind": [
    	"es.function.bind"
    ],
    	"core-js/features/instance/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/features/instance/code-points": [
    	"esnext.string.code-points"
    ],
    	"core-js/features/instance/concat": [
    	"es.array.concat"
    ],
    	"core-js/features/instance/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/features/instance/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/features/instance/entries": [
    	"es.array.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/instance/every": [
    	"es.array.every"
    ],
    	"core-js/features/instance/fill": [
    	"es.array.fill"
    ],
    	"core-js/features/instance/filter": [
    	"es.array.filter"
    ],
    	"core-js/features/instance/find": [
    	"es.array.find"
    ],
    	"core-js/features/instance/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/features/instance/flags": [
    	"es.regexp.flags"
    ],
    	"core-js/features/instance/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/features/instance/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/features/instance/for-each": [
    	"es.array.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/instance/includes": [
    	"es.array.includes",
    	"es.string.includes"
    ],
    	"core-js/features/instance/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/features/instance/keys": [
    	"es.array.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/instance/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/features/instance/map": [
    	"es.array.map"
    ],
    	"core-js/features/instance/match-all": [
    	"es.string.match-all",
    	"esnext.string.match-all"
    ],
    	"core-js/features/instance/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/features/instance/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/features/instance/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/features/instance/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/features/instance/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/features/instance/replace-all": [
    	"esnext.string.replace-all"
    ],
    	"core-js/features/instance/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/features/instance/slice": [
    	"es.array.slice"
    ],
    	"core-js/features/instance/some": [
    	"es.array.some"
    ],
    	"core-js/features/instance/sort": [
    	"es.array.sort"
    ],
    	"core-js/features/instance/splice": [
    	"es.array.splice"
    ],
    	"core-js/features/instance/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/features/instance/trim": [
    	"es.string.trim"
    ],
    	"core-js/features/instance/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/features/instance/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/features/instance/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/features/instance/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/features/instance/values": [
    	"es.array.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/is-iterable": [
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/as-indexed-pairs": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/drop": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.drop",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/every": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.every",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/filter": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.filter",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/find": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.find",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/flat-map": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.flat-map",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/for-each": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/from": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.from",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/map": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.map",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/reduce": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.reduce",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/some": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.some",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/take": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.take",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/iterator/to-array": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.iterator.constructor",
    	"esnext.iterator.to-array",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/json": [
    	"es.json.stringify",
    	"es.json.to-string-tag"
    ],
    	"core-js/features/json/stringify": [
    	"es.json.stringify"
    ],
    	"core-js/features/json/to-string-tag": [
    	"es.json.to-string-tag"
    ],
    	"core-js/features/map": [
    	"es.map",
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/map/delete-all": [
    	"es.map",
    	"esnext.map.delete-all"
    ],
    	"core-js/features/map/every": [
    	"es.map",
    	"esnext.map.every"
    ],
    	"core-js/features/map/filter": [
    	"es.map",
    	"esnext.map.filter"
    ],
    	"core-js/features/map/find": [
    	"es.map",
    	"esnext.map.find"
    ],
    	"core-js/features/map/find-key": [
    	"es.map",
    	"esnext.map.find-key"
    ],
    	"core-js/features/map/from": [
    	"es.map",
    	"es.string.iterator",
    	"esnext.map.from",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/map/group-by": [
    	"es.map",
    	"esnext.map.group-by"
    ],
    	"core-js/features/map/includes": [
    	"es.map",
    	"esnext.map.includes"
    ],
    	"core-js/features/map/key-by": [
    	"es.map",
    	"esnext.map.key-by"
    ],
    	"core-js/features/map/key-of": [
    	"es.map",
    	"esnext.map.key-of"
    ],
    	"core-js/features/map/map-keys": [
    	"es.map",
    	"esnext.map.map-keys"
    ],
    	"core-js/features/map/map-values": [
    	"es.map",
    	"esnext.map.map-values"
    ],
    	"core-js/features/map/merge": [
    	"es.map",
    	"esnext.map.merge"
    ],
    	"core-js/features/map/of": [
    	"es.map",
    	"es.string.iterator",
    	"esnext.map.of",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/map/reduce": [
    	"es.map",
    	"esnext.map.reduce"
    ],
    	"core-js/features/map/some": [
    	"es.map",
    	"esnext.map.some"
    ],
    	"core-js/features/map/update": [
    	"es.map",
    	"esnext.map.update"
    ],
    	"core-js/features/map/update-or-insert": [
    	"es.map",
    	"esnext.map.update-or-insert"
    ],
    	"core-js/features/map/upsert": [
    	"es.map",
    	"esnext.map.upsert"
    ],
    	"core-js/features/math": [
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh"
    ],
    	"core-js/features/math/acosh": [
    	"es.math.acosh"
    ],
    	"core-js/features/math/asinh": [
    	"es.math.asinh"
    ],
    	"core-js/features/math/atanh": [
    	"es.math.atanh"
    ],
    	"core-js/features/math/cbrt": [
    	"es.math.cbrt"
    ],
    	"core-js/features/math/clamp": [
    	"esnext.math.clamp"
    ],
    	"core-js/features/math/clz32": [
    	"es.math.clz32"
    ],
    	"core-js/features/math/cosh": [
    	"es.math.cosh"
    ],
    	"core-js/features/math/deg-per-rad": [
    	"esnext.math.deg-per-rad"
    ],
    	"core-js/features/math/degrees": [
    	"esnext.math.degrees"
    ],
    	"core-js/features/math/expm1": [
    	"es.math.expm1"
    ],
    	"core-js/features/math/fround": [
    	"es.math.fround"
    ],
    	"core-js/features/math/fscale": [
    	"esnext.math.fscale"
    ],
    	"core-js/features/math/hypot": [
    	"es.math.hypot"
    ],
    	"core-js/features/math/iaddh": [
    	"esnext.math.iaddh"
    ],
    	"core-js/features/math/imul": [
    	"es.math.imul"
    ],
    	"core-js/features/math/imulh": [
    	"esnext.math.imulh"
    ],
    	"core-js/features/math/isubh": [
    	"esnext.math.isubh"
    ],
    	"core-js/features/math/log10": [
    	"es.math.log10"
    ],
    	"core-js/features/math/log1p": [
    	"es.math.log1p"
    ],
    	"core-js/features/math/log2": [
    	"es.math.log2"
    ],
    	"core-js/features/math/rad-per-deg": [
    	"esnext.math.rad-per-deg"
    ],
    	"core-js/features/math/radians": [
    	"esnext.math.radians"
    ],
    	"core-js/features/math/scale": [
    	"esnext.math.scale"
    ],
    	"core-js/features/math/seeded-prng": [
    	"esnext.math.seeded-prng"
    ],
    	"core-js/features/math/sign": [
    	"es.math.sign"
    ],
    	"core-js/features/math/signbit": [
    	"esnext.math.signbit"
    ],
    	"core-js/features/math/sinh": [
    	"es.math.sinh"
    ],
    	"core-js/features/math/tanh": [
    	"es.math.tanh"
    ],
    	"core-js/features/math/to-string-tag": [
    	"es.math.to-string-tag"
    ],
    	"core-js/features/math/trunc": [
    	"es.math.trunc"
    ],
    	"core-js/features/math/umulh": [
    	"esnext.math.umulh"
    ],
    	"core-js/features/number": [
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"esnext.number.from-string"
    ],
    	"core-js/features/number/constructor": [
    	"es.number.constructor"
    ],
    	"core-js/features/number/epsilon": [
    	"es.number.epsilon"
    ],
    	"core-js/features/number/from-string": [
    	"esnext.number.from-string"
    ],
    	"core-js/features/number/is-finite": [
    	"es.number.is-finite"
    ],
    	"core-js/features/number/is-integer": [
    	"es.number.is-integer"
    ],
    	"core-js/features/number/is-nan": [
    	"es.number.is-nan"
    ],
    	"core-js/features/number/is-safe-integer": [
    	"es.number.is-safe-integer"
    ],
    	"core-js/features/number/max-safe-integer": [
    	"es.number.max-safe-integer"
    ],
    	"core-js/features/number/min-safe-integer": [
    	"es.number.min-safe-integer"
    ],
    	"core-js/features/number/parse-float": [
    	"es.number.parse-float"
    ],
    	"core-js/features/number/parse-int": [
    	"es.number.parse-int"
    ],
    	"core-js/features/number/to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/features/number/to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/features/number/virtual": [
    	"es.number.to-fixed",
    	"es.number.to-precision"
    ],
    	"core-js/features/number/virtual/to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/features/number/virtual/to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/features/object": [
    	"es.symbol",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values"
    ],
    	"core-js/features/object/assign": [
    	"es.object.assign"
    ],
    	"core-js/features/object/create": [
    	"es.object.create"
    ],
    	"core-js/features/object/define-getter": [
    	"es.object.define-getter"
    ],
    	"core-js/features/object/define-properties": [
    	"es.object.define-properties"
    ],
    	"core-js/features/object/define-property": [
    	"es.object.define-property"
    ],
    	"core-js/features/object/define-setter": [
    	"es.object.define-setter"
    ],
    	"core-js/features/object/entries": [
    	"es.object.entries"
    ],
    	"core-js/features/object/freeze": [
    	"es.object.freeze"
    ],
    	"core-js/features/object/from-entries": [
    	"es.array.iterator",
    	"es.object.from-entries"
    ],
    	"core-js/features/object/get-own-property-descriptor": [
    	"es.object.get-own-property-descriptor"
    ],
    	"core-js/features/object/get-own-property-descriptors": [
    	"es.object.get-own-property-descriptors"
    ],
    	"core-js/features/object/get-own-property-names": [
    	"es.object.get-own-property-names"
    ],
    	"core-js/features/object/get-own-property-symbols": [
    	"es.symbol"
    ],
    	"core-js/features/object/get-prototype-of": [
    	"es.object.get-prototype-of"
    ],
    	"core-js/features/object/is": [
    	"es.object.is"
    ],
    	"core-js/features/object/is-extensible": [
    	"es.object.is-extensible"
    ],
    	"core-js/features/object/is-frozen": [
    	"es.object.is-frozen"
    ],
    	"core-js/features/object/is-sealed": [
    	"es.object.is-sealed"
    ],
    	"core-js/features/object/iterate-entries": [
    	"esnext.object.iterate-entries"
    ],
    	"core-js/features/object/iterate-keys": [
    	"esnext.object.iterate-keys"
    ],
    	"core-js/features/object/iterate-values": [
    	"esnext.object.iterate-values"
    ],
    	"core-js/features/object/keys": [
    	"es.object.keys"
    ],
    	"core-js/features/object/lookup-getter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/features/object/lookup-setter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/features/object/prevent-extensions": [
    	"es.object.prevent-extensions"
    ],
    	"core-js/features/object/seal": [
    	"es.object.seal"
    ],
    	"core-js/features/object/set-prototype-of": [
    	"es.object.set-prototype-of"
    ],
    	"core-js/features/object/to-string": [
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/features/object/values": [
    	"es.object.values"
    ],
    	"core-js/features/observable": [
    	"es.object.to-string",
    	"es.string.iterator",
    	"esnext.observable",
    	"esnext.symbol.observable",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/parse-float": [
    	"es.parse-float"
    ],
    	"core-js/features/parse-int": [
    	"es.parse-int"
    ],
    	"core-js/features/promise": [
    	"es.object.to-string",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.string.iterator",
    	"esnext.aggregate-error",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/promise/all-settled": [
    	"es.promise",
    	"es.promise.all-settled",
    	"esnext.promise.all-settled"
    ],
    	"core-js/features/promise/any": [
    	"es.promise",
    	"esnext.aggregate-error",
    	"esnext.promise.any"
    ],
    	"core-js/features/promise/finally": [
    	"es.promise",
    	"es.promise.finally"
    ],
    	"core-js/features/promise/try": [
    	"es.promise",
    	"esnext.promise.try"
    ],
    	"core-js/features/queue-microtask": [
    	"web.queue-microtask"
    ],
    	"core-js/features/reflect": [
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata"
    ],
    	"core-js/features/reflect/apply": [
    	"es.reflect.apply"
    ],
    	"core-js/features/reflect/construct": [
    	"es.reflect.construct"
    ],
    	"core-js/features/reflect/define-metadata": [
    	"esnext.reflect.define-metadata"
    ],
    	"core-js/features/reflect/define-property": [
    	"es.reflect.define-property"
    ],
    	"core-js/features/reflect/delete-metadata": [
    	"esnext.reflect.delete-metadata"
    ],
    	"core-js/features/reflect/delete-property": [
    	"es.reflect.delete-property"
    ],
    	"core-js/features/reflect/get": [
    	"es.reflect.get"
    ],
    	"core-js/features/reflect/get-metadata": [
    	"esnext.reflect.get-metadata"
    ],
    	"core-js/features/reflect/get-metadata-keys": [
    	"esnext.reflect.get-metadata-keys"
    ],
    	"core-js/features/reflect/get-own-metadata": [
    	"esnext.reflect.get-own-metadata"
    ],
    	"core-js/features/reflect/get-own-metadata-keys": [
    	"esnext.reflect.get-own-metadata-keys"
    ],
    	"core-js/features/reflect/get-own-property-descriptor": [
    	"es.reflect.get-own-property-descriptor"
    ],
    	"core-js/features/reflect/get-prototype-of": [
    	"es.reflect.get-prototype-of"
    ],
    	"core-js/features/reflect/has": [
    	"es.reflect.has"
    ],
    	"core-js/features/reflect/has-metadata": [
    	"esnext.reflect.has-metadata"
    ],
    	"core-js/features/reflect/has-own-metadata": [
    	"esnext.reflect.has-own-metadata"
    ],
    	"core-js/features/reflect/is-extensible": [
    	"es.reflect.is-extensible"
    ],
    	"core-js/features/reflect/metadata": [
    	"esnext.reflect.metadata"
    ],
    	"core-js/features/reflect/own-keys": [
    	"es.reflect.own-keys"
    ],
    	"core-js/features/reflect/prevent-extensions": [
    	"es.reflect.prevent-extensions"
    ],
    	"core-js/features/reflect/set": [
    	"es.reflect.set"
    ],
    	"core-js/features/reflect/set-prototype-of": [
    	"es.reflect.set-prototype-of"
    ],
    	"core-js/features/regexp": [
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.string.match",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split"
    ],
    	"core-js/features/regexp/constructor": [
    	"es.regexp.constructor"
    ],
    	"core-js/features/regexp/flags": [
    	"es.regexp.flags"
    ],
    	"core-js/features/regexp/match": [
    	"es.string.match"
    ],
    	"core-js/features/regexp/replace": [
    	"es.string.replace"
    ],
    	"core-js/features/regexp/search": [
    	"es.string.search"
    ],
    	"core-js/features/regexp/split": [
    	"es.string.split"
    ],
    	"core-js/features/regexp/sticky": [
    	"es.regexp.sticky"
    ],
    	"core-js/features/regexp/test": [
    	"es.regexp.exec",
    	"es.regexp.test"
    ],
    	"core-js/features/regexp/to-string": [
    	"es.regexp.to-string"
    ],
    	"core-js/features/set": [
    	"es.object.to-string",
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/set-immediate": [
    	"web.immediate"
    ],
    	"core-js/features/set-interval": [
    	"web.timers"
    ],
    	"core-js/features/set-timeout": [
    	"web.timers"
    ],
    	"core-js/features/set/add-all": [
    	"es.set",
    	"esnext.set.add-all"
    ],
    	"core-js/features/set/delete-all": [
    	"es.set",
    	"esnext.set.delete-all"
    ],
    	"core-js/features/set/difference": [
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.difference",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/set/every": [
    	"es.set",
    	"esnext.set.every"
    ],
    	"core-js/features/set/filter": [
    	"es.set",
    	"esnext.set.filter"
    ],
    	"core-js/features/set/find": [
    	"es.set",
    	"esnext.set.find"
    ],
    	"core-js/features/set/from": [
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.from",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/set/intersection": [
    	"es.set",
    	"esnext.set.intersection"
    ],
    	"core-js/features/set/is-disjoint-from": [
    	"es.set",
    	"esnext.set.is-disjoint-from"
    ],
    	"core-js/features/set/is-subset-of": [
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.is-subset-of",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/set/is-superset-of": [
    	"es.set",
    	"esnext.set.is-superset-of"
    ],
    	"core-js/features/set/join": [
    	"es.set",
    	"esnext.set.join"
    ],
    	"core-js/features/set/map": [
    	"es.set",
    	"esnext.set.map"
    ],
    	"core-js/features/set/of": [
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.of",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/set/reduce": [
    	"es.set",
    	"esnext.set.reduce"
    ],
    	"core-js/features/set/some": [
    	"es.set",
    	"esnext.set.some"
    ],
    	"core-js/features/set/symmetric-difference": [
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.symmetric-difference",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/set/union": [
    	"es.set",
    	"es.string.iterator",
    	"esnext.set.union",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/string": [
    	"es.regexp.exec",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all"
    ],
    	"core-js/features/string/anchor": [
    	"es.string.anchor"
    ],
    	"core-js/features/string/at": [
    	"esnext.string.at"
    ],
    	"core-js/features/string/big": [
    	"es.string.big"
    ],
    	"core-js/features/string/blink": [
    	"es.string.blink"
    ],
    	"core-js/features/string/bold": [
    	"es.string.bold"
    ],
    	"core-js/features/string/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/features/string/code-points": [
    	"esnext.string.code-points"
    ],
    	"core-js/features/string/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/features/string/fixed": [
    	"es.string.fixed"
    ],
    	"core-js/features/string/fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/features/string/fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/features/string/from-code-point": [
    	"es.string.from-code-point"
    ],
    	"core-js/features/string/includes": [
    	"es.string.includes"
    ],
    	"core-js/features/string/italics": [
    	"es.string.italics"
    ],
    	"core-js/features/string/iterator": [
    	"es.string.iterator"
    ],
    	"core-js/features/string/link": [
    	"es.string.link"
    ],
    	"core-js/features/string/match": [
    	"es.regexp.exec",
    	"es.string.match"
    ],
    	"core-js/features/string/match-all": [
    	"es.string.match-all",
    	"esnext.string.match-all"
    ],
    	"core-js/features/string/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/features/string/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/features/string/raw": [
    	"es.string.raw"
    ],
    	"core-js/features/string/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/features/string/replace": [
    	"es.regexp.exec",
    	"es.string.replace"
    ],
    	"core-js/features/string/replace-all": [
    	"esnext.string.replace-all"
    ],
    	"core-js/features/string/search": [
    	"es.regexp.exec",
    	"es.string.search"
    ],
    	"core-js/features/string/small": [
    	"es.string.small"
    ],
    	"core-js/features/string/split": [
    	"es.regexp.exec",
    	"es.string.split"
    ],
    	"core-js/features/string/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/features/string/strike": [
    	"es.string.strike"
    ],
    	"core-js/features/string/sub": [
    	"es.string.sub"
    ],
    	"core-js/features/string/sup": [
    	"es.string.sup"
    ],
    	"core-js/features/string/trim": [
    	"es.string.trim"
    ],
    	"core-js/features/string/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/features/string/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/features/string/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/features/string/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/features/string/virtual": [
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all"
    ],
    	"core-js/features/string/virtual/anchor": [
    	"es.string.anchor"
    ],
    	"core-js/features/string/virtual/at": [
    	"esnext.string.at"
    ],
    	"core-js/features/string/virtual/big": [
    	"es.string.big"
    ],
    	"core-js/features/string/virtual/blink": [
    	"es.string.blink"
    ],
    	"core-js/features/string/virtual/bold": [
    	"es.string.bold"
    ],
    	"core-js/features/string/virtual/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/features/string/virtual/code-points": [
    	"esnext.string.code-points"
    ],
    	"core-js/features/string/virtual/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/features/string/virtual/fixed": [
    	"es.string.fixed"
    ],
    	"core-js/features/string/virtual/fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/features/string/virtual/fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/features/string/virtual/includes": [
    	"es.string.includes"
    ],
    	"core-js/features/string/virtual/italics": [
    	"es.string.italics"
    ],
    	"core-js/features/string/virtual/iterator": [
    	"es.string.iterator"
    ],
    	"core-js/features/string/virtual/link": [
    	"es.string.link"
    ],
    	"core-js/features/string/virtual/match-all": [
    	"es.string.match-all",
    	"esnext.string.match-all"
    ],
    	"core-js/features/string/virtual/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/features/string/virtual/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/features/string/virtual/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/features/string/virtual/replace-all": [
    	"esnext.string.replace-all"
    ],
    	"core-js/features/string/virtual/small": [
    	"es.string.small"
    ],
    	"core-js/features/string/virtual/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/features/string/virtual/strike": [
    	"es.string.strike"
    ],
    	"core-js/features/string/virtual/sub": [
    	"es.string.sub"
    ],
    	"core-js/features/string/virtual/sup": [
    	"es.string.sup"
    ],
    	"core-js/features/string/virtual/trim": [
    	"es.string.trim"
    ],
    	"core-js/features/string/virtual/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/features/string/virtual/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/features/string/virtual/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/features/string/virtual/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/features/symbol": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all"
    ],
    	"core-js/features/symbol/async-dispose": [
    	"esnext.symbol.async-dispose"
    ],
    	"core-js/features/symbol/async-iterator": [
    	"es.symbol.async-iterator"
    ],
    	"core-js/features/symbol/description": [
    	"es.symbol.description"
    ],
    	"core-js/features/symbol/dispose": [
    	"esnext.symbol.dispose"
    ],
    	"core-js/features/symbol/for": [
    	"es.symbol"
    ],
    	"core-js/features/symbol/has-instance": [
    	"es.symbol.has-instance",
    	"es.function.has-instance"
    ],
    	"core-js/features/symbol/is-concat-spreadable": [
    	"es.symbol.is-concat-spreadable",
    	"es.array.concat"
    ],
    	"core-js/features/symbol/iterator": [
    	"es.symbol.iterator",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/symbol/key-for": [
    	"es.symbol"
    ],
    	"core-js/features/symbol/match": [
    	"es.symbol.match",
    	"es.string.match"
    ],
    	"core-js/features/symbol/match-all": [
    	"es.symbol.match-all",
    	"es.string.match-all"
    ],
    	"core-js/features/symbol/observable": [
    	"esnext.symbol.observable"
    ],
    	"core-js/features/symbol/pattern-match": [
    	"esnext.symbol.pattern-match"
    ],
    	"core-js/features/symbol/replace": [
    	"es.symbol.replace",
    	"es.string.replace"
    ],
    	"core-js/features/symbol/replace-all": [
    	"esnext.symbol.replace-all"
    ],
    	"core-js/features/symbol/search": [
    	"es.symbol.search",
    	"es.string.search"
    ],
    	"core-js/features/symbol/species": [
    	"es.symbol.species"
    ],
    	"core-js/features/symbol/split": [
    	"es.symbol.split",
    	"es.string.split"
    ],
    	"core-js/features/symbol/to-primitive": [
    	"es.symbol.to-primitive"
    ],
    	"core-js/features/symbol/to-string-tag": [
    	"es.symbol.to-string-tag",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/features/symbol/unscopables": [
    	"es.symbol.unscopables"
    ],
    	"core-js/features/typed-array": [
    	"es.object.to-string",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/copy-within": [
    	"es.typed-array.copy-within"
    ],
    	"core-js/features/typed-array/entries": [
    	"es.typed-array.iterator"
    ],
    	"core-js/features/typed-array/every": [
    	"es.typed-array.every"
    ],
    	"core-js/features/typed-array/fill": [
    	"es.typed-array.fill"
    ],
    	"core-js/features/typed-array/filter": [
    	"es.typed-array.filter"
    ],
    	"core-js/features/typed-array/find": [
    	"es.typed-array.find"
    ],
    	"core-js/features/typed-array/find-index": [
    	"es.typed-array.find-index"
    ],
    	"core-js/features/typed-array/float32-array": [
    	"es.object.to-string",
    	"es.typed-array.float32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/float64-array": [
    	"es.object.to-string",
    	"es.typed-array.float64-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/for-each": [
    	"es.typed-array.for-each"
    ],
    	"core-js/features/typed-array/from": [
    	"es.typed-array.from"
    ],
    	"core-js/features/typed-array/includes": [
    	"es.typed-array.includes"
    ],
    	"core-js/features/typed-array/index-of": [
    	"es.typed-array.index-of"
    ],
    	"core-js/features/typed-array/int16-array": [
    	"es.object.to-string",
    	"es.typed-array.int16-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/int32-array": [
    	"es.object.to-string",
    	"es.typed-array.int32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/int8-array": [
    	"es.object.to-string",
    	"es.typed-array.int8-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/iterator": [
    	"es.typed-array.iterator"
    ],
    	"core-js/features/typed-array/join": [
    	"es.typed-array.join"
    ],
    	"core-js/features/typed-array/keys": [
    	"es.typed-array.iterator"
    ],
    	"core-js/features/typed-array/last-index-of": [
    	"es.typed-array.last-index-of"
    ],
    	"core-js/features/typed-array/map": [
    	"es.typed-array.map"
    ],
    	"core-js/features/typed-array/of": [
    	"es.typed-array.of"
    ],
    	"core-js/features/typed-array/reduce": [
    	"es.typed-array.reduce"
    ],
    	"core-js/features/typed-array/reduce-right": [
    	"es.typed-array.reduce-right"
    ],
    	"core-js/features/typed-array/reverse": [
    	"es.typed-array.reverse"
    ],
    	"core-js/features/typed-array/set": [
    	"es.typed-array.set"
    ],
    	"core-js/features/typed-array/slice": [
    	"es.typed-array.slice"
    ],
    	"core-js/features/typed-array/some": [
    	"es.typed-array.some"
    ],
    	"core-js/features/typed-array/sort": [
    	"es.typed-array.sort"
    ],
    	"core-js/features/typed-array/subarray": [
    	"es.typed-array.subarray"
    ],
    	"core-js/features/typed-array/to-locale-string": [
    	"es.typed-array.to-locale-string"
    ],
    	"core-js/features/typed-array/to-string": [
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/uint16-array": [
    	"es.object.to-string",
    	"es.typed-array.uint16-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/uint32-array": [
    	"es.object.to-string",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/uint8-array": [
    	"es.object.to-string",
    	"es.typed-array.uint8-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/uint8-clamped-array": [
    	"es.object.to-string",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/features/typed-array/values": [
    	"es.typed-array.iterator"
    ],
    	"core-js/features/url": [
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/features/url-search-params": [
    	"web.url-search-params"
    ],
    	"core-js/features/url/to-json": [
    	"web.url.to-json"
    ],
    	"core-js/features/weak-map": [
    	"es.object.to-string",
    	"es.weak-map",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/weak-map/delete-all": [
    	"es.weak-map",
    	"esnext.weak-map.delete-all"
    ],
    	"core-js/features/weak-map/from": [
    	"es.string.iterator",
    	"es.weak-map",
    	"esnext.weak-map.from",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/weak-map/of": [
    	"es.string.iterator",
    	"es.weak-map",
    	"esnext.weak-map.of",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/weak-map/upsert": [
    	"es.weak-map",
    	"esnext.weak-map.upsert"
    ],
    	"core-js/features/weak-set": [
    	"es.object.to-string",
    	"es.weak-set",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/weak-set/add-all": [
    	"es.weak-set",
    	"esnext.weak-set.add-all"
    ],
    	"core-js/features/weak-set/delete-all": [
    	"es.weak-set",
    	"esnext.weak-set.delete-all"
    ],
    	"core-js/features/weak-set/from": [
    	"es.string.iterator",
    	"es.weak-set",
    	"esnext.weak-set.from",
    	"web.dom-collections.iterator"
    ],
    	"core-js/features/weak-set/of": [
    	"es.string.iterator",
    	"es.weak-set",
    	"esnext.weak-set.of",
    	"web.dom-collections.iterator"
    ],
    	"core-js/modules/es.array-buffer.constructor": [
    	"es.array-buffer.constructor"
    ],
    	"core-js/modules/es.array-buffer.is-view": [
    	"es.array-buffer.is-view"
    ],
    	"core-js/modules/es.array-buffer.slice": [
    	"es.array-buffer.slice"
    ],
    	"core-js/modules/es.array.concat": [
    	"es.array.concat"
    ],
    	"core-js/modules/es.array.copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/modules/es.array.every": [
    	"es.array.every"
    ],
    	"core-js/modules/es.array.fill": [
    	"es.array.fill"
    ],
    	"core-js/modules/es.array.filter": [
    	"es.array.filter"
    ],
    	"core-js/modules/es.array.find": [
    	"es.array.find"
    ],
    	"core-js/modules/es.array.find-index": [
    	"es.array.find-index"
    ],
    	"core-js/modules/es.array.flat": [
    	"es.array.flat"
    ],
    	"core-js/modules/es.array.flat-map": [
    	"es.array.flat-map"
    ],
    	"core-js/modules/es.array.for-each": [
    	"es.array.for-each"
    ],
    	"core-js/modules/es.array.from": [
    	"es.array.from"
    ],
    	"core-js/modules/es.array.includes": [
    	"es.array.includes"
    ],
    	"core-js/modules/es.array.index-of": [
    	"es.array.index-of"
    ],
    	"core-js/modules/es.array.is-array": [
    	"es.array.is-array"
    ],
    	"core-js/modules/es.array.iterator": [
    	"es.array.iterator"
    ],
    	"core-js/modules/es.array.join": [
    	"es.array.join"
    ],
    	"core-js/modules/es.array.last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/modules/es.array.map": [
    	"es.array.map"
    ],
    	"core-js/modules/es.array.of": [
    	"es.array.of"
    ],
    	"core-js/modules/es.array.reduce": [
    	"es.array.reduce"
    ],
    	"core-js/modules/es.array.reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/modules/es.array.reverse": [
    	"es.array.reverse"
    ],
    	"core-js/modules/es.array.slice": [
    	"es.array.slice"
    ],
    	"core-js/modules/es.array.some": [
    	"es.array.some"
    ],
    	"core-js/modules/es.array.sort": [
    	"es.array.sort"
    ],
    	"core-js/modules/es.array.species": [
    	"es.array.species"
    ],
    	"core-js/modules/es.array.splice": [
    	"es.array.splice"
    ],
    	"core-js/modules/es.array.unscopables.flat": [
    	"es.array.unscopables.flat"
    ],
    	"core-js/modules/es.array.unscopables.flat-map": [
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/modules/es.data-view": [
    	"es.data-view"
    ],
    	"core-js/modules/es.date.now": [
    	"es.date.now"
    ],
    	"core-js/modules/es.date.to-iso-string": [
    	"es.date.to-iso-string"
    ],
    	"core-js/modules/es.date.to-json": [
    	"es.date.to-json"
    ],
    	"core-js/modules/es.date.to-primitive": [
    	"es.date.to-primitive"
    ],
    	"core-js/modules/es.date.to-string": [
    	"es.date.to-string"
    ],
    	"core-js/modules/es.function.bind": [
    	"es.function.bind"
    ],
    	"core-js/modules/es.function.has-instance": [
    	"es.function.has-instance"
    ],
    	"core-js/modules/es.function.name": [
    	"es.function.name"
    ],
    	"core-js/modules/es.global-this": [
    	"es.global-this"
    ],
    	"core-js/modules/es.json.stringify": [
    	"es.json.stringify"
    ],
    	"core-js/modules/es.json.to-string-tag": [
    	"es.json.to-string-tag"
    ],
    	"core-js/modules/es.map": [
    	"es.map"
    ],
    	"core-js/modules/es.math.acosh": [
    	"es.math.acosh"
    ],
    	"core-js/modules/es.math.asinh": [
    	"es.math.asinh"
    ],
    	"core-js/modules/es.math.atanh": [
    	"es.math.atanh"
    ],
    	"core-js/modules/es.math.cbrt": [
    	"es.math.cbrt"
    ],
    	"core-js/modules/es.math.clz32": [
    	"es.math.clz32"
    ],
    	"core-js/modules/es.math.cosh": [
    	"es.math.cosh"
    ],
    	"core-js/modules/es.math.expm1": [
    	"es.math.expm1"
    ],
    	"core-js/modules/es.math.fround": [
    	"es.math.fround"
    ],
    	"core-js/modules/es.math.hypot": [
    	"es.math.hypot"
    ],
    	"core-js/modules/es.math.imul": [
    	"es.math.imul"
    ],
    	"core-js/modules/es.math.log10": [
    	"es.math.log10"
    ],
    	"core-js/modules/es.math.log1p": [
    	"es.math.log1p"
    ],
    	"core-js/modules/es.math.log2": [
    	"es.math.log2"
    ],
    	"core-js/modules/es.math.sign": [
    	"es.math.sign"
    ],
    	"core-js/modules/es.math.sinh": [
    	"es.math.sinh"
    ],
    	"core-js/modules/es.math.tanh": [
    	"es.math.tanh"
    ],
    	"core-js/modules/es.math.to-string-tag": [
    	"es.math.to-string-tag"
    ],
    	"core-js/modules/es.math.trunc": [
    	"es.math.trunc"
    ],
    	"core-js/modules/es.number.constructor": [
    	"es.number.constructor"
    ],
    	"core-js/modules/es.number.epsilon": [
    	"es.number.epsilon"
    ],
    	"core-js/modules/es.number.is-finite": [
    	"es.number.is-finite"
    ],
    	"core-js/modules/es.number.is-integer": [
    	"es.number.is-integer"
    ],
    	"core-js/modules/es.number.is-nan": [
    	"es.number.is-nan"
    ],
    	"core-js/modules/es.number.is-safe-integer": [
    	"es.number.is-safe-integer"
    ],
    	"core-js/modules/es.number.max-safe-integer": [
    	"es.number.max-safe-integer"
    ],
    	"core-js/modules/es.number.min-safe-integer": [
    	"es.number.min-safe-integer"
    ],
    	"core-js/modules/es.number.parse-float": [
    	"es.number.parse-float"
    ],
    	"core-js/modules/es.number.parse-int": [
    	"es.number.parse-int"
    ],
    	"core-js/modules/es.number.to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/modules/es.number.to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/modules/es.object.assign": [
    	"es.object.assign"
    ],
    	"core-js/modules/es.object.create": [
    	"es.object.create"
    ],
    	"core-js/modules/es.object.define-getter": [
    	"es.object.define-getter"
    ],
    	"core-js/modules/es.object.define-properties": [
    	"es.object.define-properties"
    ],
    	"core-js/modules/es.object.define-property": [
    	"es.object.define-property"
    ],
    	"core-js/modules/es.object.define-setter": [
    	"es.object.define-setter"
    ],
    	"core-js/modules/es.object.entries": [
    	"es.object.entries"
    ],
    	"core-js/modules/es.object.freeze": [
    	"es.object.freeze"
    ],
    	"core-js/modules/es.object.from-entries": [
    	"es.object.from-entries"
    ],
    	"core-js/modules/es.object.get-own-property-descriptor": [
    	"es.object.get-own-property-descriptor"
    ],
    	"core-js/modules/es.object.get-own-property-descriptors": [
    	"es.object.get-own-property-descriptors"
    ],
    	"core-js/modules/es.object.get-own-property-names": [
    	"es.object.get-own-property-names"
    ],
    	"core-js/modules/es.object.get-prototype-of": [
    	"es.object.get-prototype-of"
    ],
    	"core-js/modules/es.object.is": [
    	"es.object.is"
    ],
    	"core-js/modules/es.object.is-extensible": [
    	"es.object.is-extensible"
    ],
    	"core-js/modules/es.object.is-frozen": [
    	"es.object.is-frozen"
    ],
    	"core-js/modules/es.object.is-sealed": [
    	"es.object.is-sealed"
    ],
    	"core-js/modules/es.object.keys": [
    	"es.object.keys"
    ],
    	"core-js/modules/es.object.lookup-getter": [
    	"es.object.lookup-getter"
    ],
    	"core-js/modules/es.object.lookup-setter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/modules/es.object.prevent-extensions": [
    	"es.object.prevent-extensions"
    ],
    	"core-js/modules/es.object.seal": [
    	"es.object.seal"
    ],
    	"core-js/modules/es.object.set-prototype-of": [
    	"es.object.set-prototype-of"
    ],
    	"core-js/modules/es.object.to-string": [
    	"es.object.to-string"
    ],
    	"core-js/modules/es.object.values": [
    	"es.object.values"
    ],
    	"core-js/modules/es.parse-float": [
    	"es.parse-float"
    ],
    	"core-js/modules/es.parse-int": [
    	"es.parse-int"
    ],
    	"core-js/modules/es.promise": [
    	"es.promise"
    ],
    	"core-js/modules/es.promise.all-settled": [
    	"es.promise.all-settled"
    ],
    	"core-js/modules/es.promise.finally": [
    	"es.promise.finally"
    ],
    	"core-js/modules/es.reflect.apply": [
    	"es.reflect.apply"
    ],
    	"core-js/modules/es.reflect.construct": [
    	"es.reflect.construct"
    ],
    	"core-js/modules/es.reflect.define-property": [
    	"es.reflect.define-property"
    ],
    	"core-js/modules/es.reflect.delete-property": [
    	"es.reflect.delete-property"
    ],
    	"core-js/modules/es.reflect.get": [
    	"es.reflect.get"
    ],
    	"core-js/modules/es.reflect.get-own-property-descriptor": [
    	"es.reflect.get-own-property-descriptor"
    ],
    	"core-js/modules/es.reflect.get-prototype-of": [
    	"es.reflect.get-prototype-of"
    ],
    	"core-js/modules/es.reflect.has": [
    	"es.reflect.has"
    ],
    	"core-js/modules/es.reflect.is-extensible": [
    	"es.reflect.is-extensible"
    ],
    	"core-js/modules/es.reflect.own-keys": [
    	"es.reflect.own-keys"
    ],
    	"core-js/modules/es.reflect.prevent-extensions": [
    	"es.reflect.prevent-extensions"
    ],
    	"core-js/modules/es.reflect.set": [
    	"es.reflect.set"
    ],
    	"core-js/modules/es.reflect.set-prototype-of": [
    	"es.reflect.set-prototype-of"
    ],
    	"core-js/modules/es.regexp.constructor": [
    	"es.regexp.constructor"
    ],
    	"core-js/modules/es.regexp.exec": [
    	"es.regexp.exec"
    ],
    	"core-js/modules/es.regexp.flags": [
    	"es.regexp.flags"
    ],
    	"core-js/modules/es.regexp.sticky": [
    	"es.regexp.sticky"
    ],
    	"core-js/modules/es.regexp.test": [
    	"es.regexp.test"
    ],
    	"core-js/modules/es.regexp.to-string": [
    	"es.regexp.to-string"
    ],
    	"core-js/modules/es.set": [
    	"es.set"
    ],
    	"core-js/modules/es.string.anchor": [
    	"es.string.anchor"
    ],
    	"core-js/modules/es.string.big": [
    	"es.string.big"
    ],
    	"core-js/modules/es.string.blink": [
    	"es.string.blink"
    ],
    	"core-js/modules/es.string.bold": [
    	"es.string.bold"
    ],
    	"core-js/modules/es.string.code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/modules/es.string.ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/modules/es.string.fixed": [
    	"es.string.fixed"
    ],
    	"core-js/modules/es.string.fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/modules/es.string.fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/modules/es.string.from-code-point": [
    	"es.string.from-code-point"
    ],
    	"core-js/modules/es.string.includes": [
    	"es.string.includes"
    ],
    	"core-js/modules/es.string.italics": [
    	"es.string.italics"
    ],
    	"core-js/modules/es.string.iterator": [
    	"es.string.iterator"
    ],
    	"core-js/modules/es.string.link": [
    	"es.string.link"
    ],
    	"core-js/modules/es.string.match": [
    	"es.string.match"
    ],
    	"core-js/modules/es.string.match-all": [
    	"es.string.match-all"
    ],
    	"core-js/modules/es.string.pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/modules/es.string.pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/modules/es.string.raw": [
    	"es.string.raw"
    ],
    	"core-js/modules/es.string.repeat": [
    	"es.string.repeat"
    ],
    	"core-js/modules/es.string.replace": [
    	"es.string.replace"
    ],
    	"core-js/modules/es.string.search": [
    	"es.string.search"
    ],
    	"core-js/modules/es.string.small": [
    	"es.string.small"
    ],
    	"core-js/modules/es.string.split": [
    	"es.string.split"
    ],
    	"core-js/modules/es.string.starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/modules/es.string.strike": [
    	"es.string.strike"
    ],
    	"core-js/modules/es.string.sub": [
    	"es.string.sub"
    ],
    	"core-js/modules/es.string.sup": [
    	"es.string.sup"
    ],
    	"core-js/modules/es.string.trim": [
    	"es.string.trim"
    ],
    	"core-js/modules/es.string.trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/modules/es.string.trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/modules/es.symbol": [
    	"es.symbol"
    ],
    	"core-js/modules/es.symbol.async-iterator": [
    	"es.symbol.async-iterator"
    ],
    	"core-js/modules/es.symbol.description": [
    	"es.symbol.description"
    ],
    	"core-js/modules/es.symbol.has-instance": [
    	"es.symbol.has-instance"
    ],
    	"core-js/modules/es.symbol.is-concat-spreadable": [
    	"es.symbol.is-concat-spreadable"
    ],
    	"core-js/modules/es.symbol.iterator": [
    	"es.symbol.iterator"
    ],
    	"core-js/modules/es.symbol.match": [
    	"es.symbol.match"
    ],
    	"core-js/modules/es.symbol.match-all": [
    	"es.symbol.match-all"
    ],
    	"core-js/modules/es.symbol.replace": [
    	"es.symbol.replace"
    ],
    	"core-js/modules/es.symbol.search": [
    	"es.symbol.search"
    ],
    	"core-js/modules/es.symbol.species": [
    	"es.symbol.species"
    ],
    	"core-js/modules/es.symbol.split": [
    	"es.symbol.split"
    ],
    	"core-js/modules/es.symbol.to-primitive": [
    	"es.symbol.to-primitive"
    ],
    	"core-js/modules/es.symbol.to-string-tag": [
    	"es.symbol.to-string-tag"
    ],
    	"core-js/modules/es.symbol.unscopables": [
    	"es.symbol.unscopables"
    ],
    	"core-js/modules/es.typed-array.copy-within": [
    	"es.typed-array.copy-within"
    ],
    	"core-js/modules/es.typed-array.every": [
    	"es.typed-array.every"
    ],
    	"core-js/modules/es.typed-array.fill": [
    	"es.typed-array.fill"
    ],
    	"core-js/modules/es.typed-array.filter": [
    	"es.typed-array.filter"
    ],
    	"core-js/modules/es.typed-array.find": [
    	"es.typed-array.find"
    ],
    	"core-js/modules/es.typed-array.find-index": [
    	"es.typed-array.find-index"
    ],
    	"core-js/modules/es.typed-array.float32-array": [
    	"es.typed-array.float32-array"
    ],
    	"core-js/modules/es.typed-array.float64-array": [
    	"es.typed-array.float64-array"
    ],
    	"core-js/modules/es.typed-array.for-each": [
    	"es.typed-array.for-each"
    ],
    	"core-js/modules/es.typed-array.from": [
    	"es.typed-array.from"
    ],
    	"core-js/modules/es.typed-array.includes": [
    	"es.typed-array.includes"
    ],
    	"core-js/modules/es.typed-array.index-of": [
    	"es.typed-array.index-of"
    ],
    	"core-js/modules/es.typed-array.int16-array": [
    	"es.typed-array.int16-array"
    ],
    	"core-js/modules/es.typed-array.int32-array": [
    	"es.typed-array.int32-array"
    ],
    	"core-js/modules/es.typed-array.int8-array": [
    	"es.typed-array.int8-array"
    ],
    	"core-js/modules/es.typed-array.iterator": [
    	"es.typed-array.iterator"
    ],
    	"core-js/modules/es.typed-array.join": [
    	"es.typed-array.join"
    ],
    	"core-js/modules/es.typed-array.last-index-of": [
    	"es.typed-array.last-index-of"
    ],
    	"core-js/modules/es.typed-array.map": [
    	"es.typed-array.map"
    ],
    	"core-js/modules/es.typed-array.of": [
    	"es.typed-array.of"
    ],
    	"core-js/modules/es.typed-array.reduce": [
    	"es.typed-array.reduce"
    ],
    	"core-js/modules/es.typed-array.reduce-right": [
    	"es.typed-array.reduce-right"
    ],
    	"core-js/modules/es.typed-array.reverse": [
    	"es.typed-array.reverse"
    ],
    	"core-js/modules/es.typed-array.set": [
    	"es.typed-array.set"
    ],
    	"core-js/modules/es.typed-array.slice": [
    	"es.typed-array.slice"
    ],
    	"core-js/modules/es.typed-array.some": [
    	"es.typed-array.some"
    ],
    	"core-js/modules/es.typed-array.sort": [
    	"es.typed-array.sort"
    ],
    	"core-js/modules/es.typed-array.subarray": [
    	"es.typed-array.subarray"
    ],
    	"core-js/modules/es.typed-array.to-locale-string": [
    	"es.typed-array.to-locale-string"
    ],
    	"core-js/modules/es.typed-array.to-string": [
    	"es.typed-array.to-string"
    ],
    	"core-js/modules/es.typed-array.uint16-array": [
    	"es.typed-array.uint16-array"
    ],
    	"core-js/modules/es.typed-array.uint32-array": [
    	"es.typed-array.uint32-array"
    ],
    	"core-js/modules/es.typed-array.uint8-array": [
    	"es.typed-array.uint8-array"
    ],
    	"core-js/modules/es.typed-array.uint8-clamped-array": [
    	"es.typed-array.uint8-clamped-array"
    ],
    	"core-js/modules/es.weak-map": [
    	"es.weak-map"
    ],
    	"core-js/modules/es.weak-set": [
    	"es.weak-set"
    ],
    	"core-js/modules/esnext.aggregate-error": [
    	"esnext.aggregate-error"
    ],
    	"core-js/modules/esnext.array.is-template-object": [
    	"esnext.array.is-template-object"
    ],
    	"core-js/modules/esnext.array.last-index": [
    	"esnext.array.last-index"
    ],
    	"core-js/modules/esnext.array.last-item": [
    	"esnext.array.last-item"
    ],
    	"core-js/modules/esnext.async-iterator.as-indexed-pairs": [
    	"esnext.async-iterator.as-indexed-pairs"
    ],
    	"core-js/modules/esnext.async-iterator.constructor": [
    	"esnext.async-iterator.constructor"
    ],
    	"core-js/modules/esnext.async-iterator.drop": [
    	"esnext.async-iterator.drop"
    ],
    	"core-js/modules/esnext.async-iterator.every": [
    	"esnext.async-iterator.every"
    ],
    	"core-js/modules/esnext.async-iterator.filter": [
    	"esnext.async-iterator.filter"
    ],
    	"core-js/modules/esnext.async-iterator.find": [
    	"esnext.async-iterator.find"
    ],
    	"core-js/modules/esnext.async-iterator.flat-map": [
    	"esnext.async-iterator.flat-map"
    ],
    	"core-js/modules/esnext.async-iterator.for-each": [
    	"esnext.async-iterator.for-each"
    ],
    	"core-js/modules/esnext.async-iterator.from": [
    	"esnext.async-iterator.from"
    ],
    	"core-js/modules/esnext.async-iterator.map": [
    	"esnext.async-iterator.map"
    ],
    	"core-js/modules/esnext.async-iterator.reduce": [
    	"esnext.async-iterator.reduce"
    ],
    	"core-js/modules/esnext.async-iterator.some": [
    	"esnext.async-iterator.some"
    ],
    	"core-js/modules/esnext.async-iterator.take": [
    	"esnext.async-iterator.take"
    ],
    	"core-js/modules/esnext.async-iterator.to-array": [
    	"esnext.async-iterator.to-array"
    ],
    	"core-js/modules/esnext.composite-key": [
    	"esnext.composite-key"
    ],
    	"core-js/modules/esnext.composite-symbol": [
    	"esnext.composite-symbol"
    ],
    	"core-js/modules/esnext.global-this": [
    	"esnext.global-this"
    ],
    	"core-js/modules/esnext.iterator.as-indexed-pairs": [
    	"esnext.iterator.as-indexed-pairs"
    ],
    	"core-js/modules/esnext.iterator.constructor": [
    	"esnext.iterator.constructor"
    ],
    	"core-js/modules/esnext.iterator.drop": [
    	"esnext.iterator.drop"
    ],
    	"core-js/modules/esnext.iterator.every": [
    	"esnext.iterator.every"
    ],
    	"core-js/modules/esnext.iterator.filter": [
    	"esnext.iterator.filter"
    ],
    	"core-js/modules/esnext.iterator.find": [
    	"esnext.iterator.find"
    ],
    	"core-js/modules/esnext.iterator.flat-map": [
    	"esnext.iterator.flat-map"
    ],
    	"core-js/modules/esnext.iterator.for-each": [
    	"esnext.iterator.for-each"
    ],
    	"core-js/modules/esnext.iterator.from": [
    	"esnext.iterator.from"
    ],
    	"core-js/modules/esnext.iterator.map": [
    	"esnext.iterator.map"
    ],
    	"core-js/modules/esnext.iterator.reduce": [
    	"esnext.iterator.reduce"
    ],
    	"core-js/modules/esnext.iterator.some": [
    	"esnext.iterator.some"
    ],
    	"core-js/modules/esnext.iterator.take": [
    	"esnext.iterator.take"
    ],
    	"core-js/modules/esnext.iterator.to-array": [
    	"esnext.iterator.to-array"
    ],
    	"core-js/modules/esnext.map.delete-all": [
    	"esnext.map.delete-all"
    ],
    	"core-js/modules/esnext.map.every": [
    	"esnext.map.every"
    ],
    	"core-js/modules/esnext.map.filter": [
    	"esnext.map.filter"
    ],
    	"core-js/modules/esnext.map.find": [
    	"esnext.map.find"
    ],
    	"core-js/modules/esnext.map.find-key": [
    	"esnext.map.find-key"
    ],
    	"core-js/modules/esnext.map.from": [
    	"esnext.map.from"
    ],
    	"core-js/modules/esnext.map.group-by": [
    	"esnext.map.group-by"
    ],
    	"core-js/modules/esnext.map.includes": [
    	"esnext.map.includes"
    ],
    	"core-js/modules/esnext.map.key-by": [
    	"esnext.map.key-by"
    ],
    	"core-js/modules/esnext.map.key-of": [
    	"esnext.map.key-of"
    ],
    	"core-js/modules/esnext.map.map-keys": [
    	"esnext.map.map-keys"
    ],
    	"core-js/modules/esnext.map.map-values": [
    	"esnext.map.map-values"
    ],
    	"core-js/modules/esnext.map.merge": [
    	"esnext.map.merge"
    ],
    	"core-js/modules/esnext.map.of": [
    	"esnext.map.of"
    ],
    	"core-js/modules/esnext.map.reduce": [
    	"esnext.map.reduce"
    ],
    	"core-js/modules/esnext.map.some": [
    	"esnext.map.some"
    ],
    	"core-js/modules/esnext.map.update": [
    	"esnext.map.update"
    ],
    	"core-js/modules/esnext.map.update-or-insert": [
    	"esnext.map.update-or-insert"
    ],
    	"core-js/modules/esnext.map.upsert": [
    	"esnext.map.upsert"
    ],
    	"core-js/modules/esnext.math.clamp": [
    	"esnext.math.clamp"
    ],
    	"core-js/modules/esnext.math.deg-per-rad": [
    	"esnext.math.deg-per-rad"
    ],
    	"core-js/modules/esnext.math.degrees": [
    	"esnext.math.degrees"
    ],
    	"core-js/modules/esnext.math.fscale": [
    	"esnext.math.fscale"
    ],
    	"core-js/modules/esnext.math.iaddh": [
    	"esnext.math.iaddh"
    ],
    	"core-js/modules/esnext.math.imulh": [
    	"esnext.math.imulh"
    ],
    	"core-js/modules/esnext.math.isubh": [
    	"esnext.math.isubh"
    ],
    	"core-js/modules/esnext.math.rad-per-deg": [
    	"esnext.math.rad-per-deg"
    ],
    	"core-js/modules/esnext.math.radians": [
    	"esnext.math.radians"
    ],
    	"core-js/modules/esnext.math.scale": [
    	"esnext.math.scale"
    ],
    	"core-js/modules/esnext.math.seeded-prng": [
    	"esnext.math.seeded-prng"
    ],
    	"core-js/modules/esnext.math.signbit": [
    	"esnext.math.signbit"
    ],
    	"core-js/modules/esnext.math.umulh": [
    	"esnext.math.umulh"
    ],
    	"core-js/modules/esnext.number.from-string": [
    	"esnext.number.from-string"
    ],
    	"core-js/modules/esnext.object.iterate-entries": [
    	"esnext.object.iterate-entries"
    ],
    	"core-js/modules/esnext.object.iterate-keys": [
    	"esnext.object.iterate-keys"
    ],
    	"core-js/modules/esnext.object.iterate-values": [
    	"esnext.object.iterate-values"
    ],
    	"core-js/modules/esnext.observable": [
    	"esnext.observable"
    ],
    	"core-js/modules/esnext.promise.all-settled": [
    	"esnext.promise.all-settled"
    ],
    	"core-js/modules/esnext.promise.any": [
    	"esnext.promise.any"
    ],
    	"core-js/modules/esnext.promise.try": [
    	"esnext.promise.try"
    ],
    	"core-js/modules/esnext.reflect.define-metadata": [
    	"esnext.reflect.define-metadata"
    ],
    	"core-js/modules/esnext.reflect.delete-metadata": [
    	"esnext.reflect.delete-metadata"
    ],
    	"core-js/modules/esnext.reflect.get-metadata": [
    	"esnext.reflect.get-metadata"
    ],
    	"core-js/modules/esnext.reflect.get-metadata-keys": [
    	"esnext.reflect.get-metadata-keys"
    ],
    	"core-js/modules/esnext.reflect.get-own-metadata": [
    	"esnext.reflect.get-own-metadata"
    ],
    	"core-js/modules/esnext.reflect.get-own-metadata-keys": [
    	"esnext.reflect.get-own-metadata-keys"
    ],
    	"core-js/modules/esnext.reflect.has-metadata": [
    	"esnext.reflect.has-metadata"
    ],
    	"core-js/modules/esnext.reflect.has-own-metadata": [
    	"esnext.reflect.has-own-metadata"
    ],
    	"core-js/modules/esnext.reflect.metadata": [
    	"esnext.reflect.metadata"
    ],
    	"core-js/modules/esnext.set.add-all": [
    	"esnext.set.add-all"
    ],
    	"core-js/modules/esnext.set.delete-all": [
    	"esnext.set.delete-all"
    ],
    	"core-js/modules/esnext.set.difference": [
    	"esnext.set.difference"
    ],
    	"core-js/modules/esnext.set.every": [
    	"esnext.set.every"
    ],
    	"core-js/modules/esnext.set.filter": [
    	"esnext.set.filter"
    ],
    	"core-js/modules/esnext.set.find": [
    	"esnext.set.find"
    ],
    	"core-js/modules/esnext.set.from": [
    	"esnext.set.from"
    ],
    	"core-js/modules/esnext.set.intersection": [
    	"esnext.set.intersection"
    ],
    	"core-js/modules/esnext.set.is-disjoint-from": [
    	"esnext.set.is-disjoint-from"
    ],
    	"core-js/modules/esnext.set.is-subset-of": [
    	"esnext.set.is-subset-of"
    ],
    	"core-js/modules/esnext.set.is-superset-of": [
    	"esnext.set.is-superset-of"
    ],
    	"core-js/modules/esnext.set.join": [
    	"esnext.set.join"
    ],
    	"core-js/modules/esnext.set.map": [
    	"esnext.set.map"
    ],
    	"core-js/modules/esnext.set.of": [
    	"esnext.set.of"
    ],
    	"core-js/modules/esnext.set.reduce": [
    	"esnext.set.reduce"
    ],
    	"core-js/modules/esnext.set.some": [
    	"esnext.set.some"
    ],
    	"core-js/modules/esnext.set.symmetric-difference": [
    	"esnext.set.symmetric-difference"
    ],
    	"core-js/modules/esnext.set.union": [
    	"esnext.set.union"
    ],
    	"core-js/modules/esnext.string.at": [
    	"esnext.string.at"
    ],
    	"core-js/modules/esnext.string.code-points": [
    	"esnext.string.code-points"
    ],
    	"core-js/modules/esnext.string.match-all": [
    	"esnext.string.match-all"
    ],
    	"core-js/modules/esnext.string.replace-all": [
    	"esnext.string.replace-all"
    ],
    	"core-js/modules/esnext.symbol.async-dispose": [
    	"esnext.symbol.async-dispose"
    ],
    	"core-js/modules/esnext.symbol.dispose": [
    	"esnext.symbol.dispose"
    ],
    	"core-js/modules/esnext.symbol.observable": [
    	"esnext.symbol.observable"
    ],
    	"core-js/modules/esnext.symbol.pattern-match": [
    	"esnext.symbol.pattern-match"
    ],
    	"core-js/modules/esnext.symbol.replace-all": [
    	"esnext.symbol.replace-all"
    ],
    	"core-js/modules/esnext.weak-map.delete-all": [
    	"esnext.weak-map.delete-all"
    ],
    	"core-js/modules/esnext.weak-map.from": [
    	"esnext.weak-map.from"
    ],
    	"core-js/modules/esnext.weak-map.of": [
    	"esnext.weak-map.of"
    ],
    	"core-js/modules/esnext.weak-map.upsert": [
    	"esnext.weak-map.upsert"
    ],
    	"core-js/modules/esnext.weak-set.add-all": [
    	"esnext.weak-set.add-all"
    ],
    	"core-js/modules/esnext.weak-set.delete-all": [
    	"esnext.weak-set.delete-all"
    ],
    	"core-js/modules/esnext.weak-set.from": [
    	"esnext.weak-set.from"
    ],
    	"core-js/modules/esnext.weak-set.of": [
    	"esnext.weak-set.of"
    ],
    	"core-js/modules/web.dom-collections.for-each": [
    	"web.dom-collections.for-each"
    ],
    	"core-js/modules/web.dom-collections.iterator": [
    	"web.dom-collections.iterator"
    ],
    	"core-js/modules/web.immediate": [
    	"web.immediate"
    ],
    	"core-js/modules/web.queue-microtask": [
    	"web.queue-microtask"
    ],
    	"core-js/modules/web.timers": [
    	"web.timers"
    ],
    	"core-js/modules/web.url": [
    	"web.url"
    ],
    	"core-js/modules/web.url-search-params": [
    	"web.url-search-params"
    ],
    	"core-js/modules/web.url.to-json": [
    	"web.url.to-json"
    ],
    	"core-js/proposals": [
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/proposals/array-is-template-object": [
    	"esnext.array.is-template-object"
    ],
    	"core-js/proposals/array-last": [
    	"esnext.array.last-index",
    	"esnext.array.last-item"
    ],
    	"core-js/proposals/collection-methods": [
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all"
    ],
    	"core-js/proposals/collection-of-from": [
    	"esnext.map.from",
    	"esnext.map.of",
    	"esnext.set.from",
    	"esnext.set.of",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of"
    ],
    	"core-js/proposals/efficient-64-bit-arithmetic": [
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.umulh"
    ],
    	"core-js/proposals/global-this": [
    	"esnext.global-this"
    ],
    	"core-js/proposals/iterator-helpers": [
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array"
    ],
    	"core-js/proposals/keys-composition": [
    	"esnext.composite-key",
    	"esnext.composite-symbol"
    ],
    	"core-js/proposals/map-update-or-insert": [
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.weak-map.upsert"
    ],
    	"core-js/proposals/map-upsert": [
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.weak-map.upsert"
    ],
    	"core-js/proposals/math-extensions": [
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale"
    ],
    	"core-js/proposals/math-signbit": [
    	"esnext.math.signbit"
    ],
    	"core-js/proposals/number-from-string": [
    	"esnext.number.from-string"
    ],
    	"core-js/proposals/object-iteration": [
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values"
    ],
    	"core-js/proposals/observable": [
    	"esnext.observable",
    	"esnext.symbol.observable"
    ],
    	"core-js/proposals/pattern-matching": [
    	"esnext.symbol.pattern-match"
    ],
    	"core-js/proposals/promise-all-settled": [
    	"esnext.promise.all-settled"
    ],
    	"core-js/proposals/promise-any": [
    	"esnext.aggregate-error",
    	"esnext.promise.any"
    ],
    	"core-js/proposals/promise-try": [
    	"esnext.promise.try"
    ],
    	"core-js/proposals/reflect-metadata": [
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata"
    ],
    	"core-js/proposals/seeded-random": [
    	"esnext.math.seeded-prng"
    ],
    	"core-js/proposals/set-methods": [
    	"esnext.set.difference",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union"
    ],
    	"core-js/proposals/string-at": [
    	"esnext.string.at"
    ],
    	"core-js/proposals/string-code-points": [
    	"esnext.string.code-points"
    ],
    	"core-js/proposals/string-match-all": [
    	"esnext.string.match-all"
    ],
    	"core-js/proposals/string-replace-all": [
    	"esnext.string.replace-all",
    	"esnext.symbol.replace-all"
    ],
    	"core-js/proposals/url": [
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/proposals/using-statement": [
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose"
    ],
    	"core-js/stable": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.data-view",
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string",
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name",
    	"es.global-this",
    	"es.json.stringify",
    	"es.json.to-string-tag",
    	"es.map",
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc",
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values",
    	"es.parse-float",
    	"es.parse-int",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of",
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.set",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string",
    	"es.weak-map",
    	"es.weak-set",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator",
    	"web.immediate",
    	"web.queue-microtask",
    	"web.timers",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/stable/array": [
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.from",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.is-array",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.of",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map",
    	"es.string.iterator"
    ],
    	"core-js/stable/array-buffer": [
    	"es.array-buffer.constructor",
    	"es.array-buffer.is-view",
    	"es.array-buffer.slice",
    	"es.object.to-string"
    ],
    	"core-js/stable/array-buffer/constructor": [
    	"es.array-buffer.constructor",
    	"es.object.to-string"
    ],
    	"core-js/stable/array-buffer/is-view": [
    	"es.array-buffer.is-view"
    ],
    	"core-js/stable/array-buffer/slice": [
    	"es.array-buffer.slice"
    ],
    	"core-js/stable/array/concat": [
    	"es.array.concat"
    ],
    	"core-js/stable/array/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/stable/array/entries": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/every": [
    	"es.array.every"
    ],
    	"core-js/stable/array/fill": [
    	"es.array.fill"
    ],
    	"core-js/stable/array/filter": [
    	"es.array.filter"
    ],
    	"core-js/stable/array/find": [
    	"es.array.find"
    ],
    	"core-js/stable/array/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/stable/array/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/stable/array/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/stable/array/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/stable/array/from": [
    	"es.array.from",
    	"es.string.iterator"
    ],
    	"core-js/stable/array/includes": [
    	"es.array.includes"
    ],
    	"core-js/stable/array/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/stable/array/is-array": [
    	"es.array.is-array"
    ],
    	"core-js/stable/array/iterator": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/join": [
    	"es.array.join"
    ],
    	"core-js/stable/array/keys": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/stable/array/map": [
    	"es.array.map"
    ],
    	"core-js/stable/array/of": [
    	"es.array.of"
    ],
    	"core-js/stable/array/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/stable/array/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/stable/array/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/stable/array/slice": [
    	"es.array.slice"
    ],
    	"core-js/stable/array/some": [
    	"es.array.some"
    ],
    	"core-js/stable/array/sort": [
    	"es.array.sort"
    ],
    	"core-js/stable/array/splice": [
    	"es.array.splice"
    ],
    	"core-js/stable/array/values": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/virtual": [
    	"es.array.concat",
    	"es.array.copy-within",
    	"es.array.every",
    	"es.array.fill",
    	"es.array.filter",
    	"es.array.find",
    	"es.array.find-index",
    	"es.array.flat",
    	"es.array.flat-map",
    	"es.array.for-each",
    	"es.array.includes",
    	"es.array.index-of",
    	"es.array.iterator",
    	"es.array.join",
    	"es.array.last-index-of",
    	"es.array.map",
    	"es.array.reduce",
    	"es.array.reduce-right",
    	"es.array.reverse",
    	"es.array.slice",
    	"es.array.some",
    	"es.array.sort",
    	"es.array.species",
    	"es.array.splice",
    	"es.array.unscopables.flat",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/stable/array/virtual/concat": [
    	"es.array.concat"
    ],
    	"core-js/stable/array/virtual/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/stable/array/virtual/entries": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/virtual/every": [
    	"es.array.every"
    ],
    	"core-js/stable/array/virtual/fill": [
    	"es.array.fill"
    ],
    	"core-js/stable/array/virtual/filter": [
    	"es.array.filter"
    ],
    	"core-js/stable/array/virtual/find": [
    	"es.array.find"
    ],
    	"core-js/stable/array/virtual/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/stable/array/virtual/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/stable/array/virtual/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/stable/array/virtual/for-each": [
    	"es.array.for-each"
    ],
    	"core-js/stable/array/virtual/includes": [
    	"es.array.includes"
    ],
    	"core-js/stable/array/virtual/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/stable/array/virtual/iterator": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/virtual/join": [
    	"es.array.join"
    ],
    	"core-js/stable/array/virtual/keys": [
    	"es.array.iterator"
    ],
    	"core-js/stable/array/virtual/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/stable/array/virtual/map": [
    	"es.array.map"
    ],
    	"core-js/stable/array/virtual/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/stable/array/virtual/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/stable/array/virtual/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/stable/array/virtual/slice": [
    	"es.array.slice"
    ],
    	"core-js/stable/array/virtual/some": [
    	"es.array.some"
    ],
    	"core-js/stable/array/virtual/sort": [
    	"es.array.sort"
    ],
    	"core-js/stable/array/virtual/splice": [
    	"es.array.splice"
    ],
    	"core-js/stable/array/virtual/values": [
    	"es.array.iterator"
    ],
    	"core-js/stable/clear-immediate": [
    	"web.immediate"
    ],
    	"core-js/stable/data-view": [
    	"es.data-view",
    	"es.object.to-string"
    ],
    	"core-js/stable/date": [
    	"es.date.now",
    	"es.date.to-iso-string",
    	"es.date.to-json",
    	"es.date.to-primitive",
    	"es.date.to-string"
    ],
    	"core-js/stable/date/now": [
    	"es.date.now"
    ],
    	"core-js/stable/date/to-iso-string": [
    	"es.date.to-iso-string",
    	"es.date.to-json"
    ],
    	"core-js/stable/date/to-json": [
    	"es.date.to-json"
    ],
    	"core-js/stable/date/to-primitive": [
    	"es.date.to-primitive"
    ],
    	"core-js/stable/date/to-string": [
    	"es.date.to-string"
    ],
    	"core-js/stable/dom-collections": [
    	"es.array.iterator",
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/dom-collections/for-each": [
    	"web.dom-collections.for-each"
    ],
    	"core-js/stable/dom-collections/iterator": [
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/function": [
    	"es.function.bind",
    	"es.function.has-instance",
    	"es.function.name"
    ],
    	"core-js/stable/function/bind": [
    	"es.function.bind"
    ],
    	"core-js/stable/function/has-instance": [
    	"es.function.has-instance"
    ],
    	"core-js/stable/function/name": [
    	"es.function.name"
    ],
    	"core-js/stable/function/virtual": [
    	"es.function.bind"
    ],
    	"core-js/stable/function/virtual/bind": [
    	"es.function.bind"
    ],
    	"core-js/stable/global-this": [
    	"es.global-this"
    ],
    	"core-js/stable/instance/bind": [
    	"es.function.bind"
    ],
    	"core-js/stable/instance/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/stable/instance/concat": [
    	"es.array.concat"
    ],
    	"core-js/stable/instance/copy-within": [
    	"es.array.copy-within"
    ],
    	"core-js/stable/instance/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/stable/instance/entries": [
    	"es.array.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/instance/every": [
    	"es.array.every"
    ],
    	"core-js/stable/instance/fill": [
    	"es.array.fill"
    ],
    	"core-js/stable/instance/filter": [
    	"es.array.filter"
    ],
    	"core-js/stable/instance/find": [
    	"es.array.find"
    ],
    	"core-js/stable/instance/find-index": [
    	"es.array.find-index"
    ],
    	"core-js/stable/instance/flags": [
    	"es.regexp.flags"
    ],
    	"core-js/stable/instance/flat": [
    	"es.array.flat",
    	"es.array.unscopables.flat"
    ],
    	"core-js/stable/instance/flat-map": [
    	"es.array.flat-map",
    	"es.array.unscopables.flat-map"
    ],
    	"core-js/stable/instance/for-each": [
    	"es.array.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/instance/includes": [
    	"es.array.includes",
    	"es.string.includes"
    ],
    	"core-js/stable/instance/index-of": [
    	"es.array.index-of"
    ],
    	"core-js/stable/instance/keys": [
    	"es.array.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/instance/last-index-of": [
    	"es.array.last-index-of"
    ],
    	"core-js/stable/instance/map": [
    	"es.array.map"
    ],
    	"core-js/stable/instance/match-all": [
    	"es.string.match-all"
    ],
    	"core-js/stable/instance/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/stable/instance/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/stable/instance/reduce": [
    	"es.array.reduce"
    ],
    	"core-js/stable/instance/reduce-right": [
    	"es.array.reduce-right"
    ],
    	"core-js/stable/instance/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/stable/instance/reverse": [
    	"es.array.reverse"
    ],
    	"core-js/stable/instance/slice": [
    	"es.array.slice"
    ],
    	"core-js/stable/instance/some": [
    	"es.array.some"
    ],
    	"core-js/stable/instance/sort": [
    	"es.array.sort"
    ],
    	"core-js/stable/instance/splice": [
    	"es.array.splice"
    ],
    	"core-js/stable/instance/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/stable/instance/trim": [
    	"es.string.trim"
    ],
    	"core-js/stable/instance/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/stable/instance/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/stable/instance/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/stable/instance/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/stable/instance/values": [
    	"es.array.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/json": [
    	"es.json.stringify",
    	"es.json.to-string-tag"
    ],
    	"core-js/stable/json/stringify": [
    	"es.json.stringify"
    ],
    	"core-js/stable/json/to-string-tag": [
    	"es.json.to-string-tag"
    ],
    	"core-js/stable/map": [
    	"es.map",
    	"es.object.to-string",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/math": [
    	"es.math.acosh",
    	"es.math.asinh",
    	"es.math.atanh",
    	"es.math.cbrt",
    	"es.math.clz32",
    	"es.math.cosh",
    	"es.math.expm1",
    	"es.math.fround",
    	"es.math.hypot",
    	"es.math.imul",
    	"es.math.log10",
    	"es.math.log1p",
    	"es.math.log2",
    	"es.math.sign",
    	"es.math.sinh",
    	"es.math.tanh",
    	"es.math.to-string-tag",
    	"es.math.trunc"
    ],
    	"core-js/stable/math/acosh": [
    	"es.math.acosh"
    ],
    	"core-js/stable/math/asinh": [
    	"es.math.asinh"
    ],
    	"core-js/stable/math/atanh": [
    	"es.math.atanh"
    ],
    	"core-js/stable/math/cbrt": [
    	"es.math.cbrt"
    ],
    	"core-js/stable/math/clz32": [
    	"es.math.clz32"
    ],
    	"core-js/stable/math/cosh": [
    	"es.math.cosh"
    ],
    	"core-js/stable/math/expm1": [
    	"es.math.expm1"
    ],
    	"core-js/stable/math/fround": [
    	"es.math.fround"
    ],
    	"core-js/stable/math/hypot": [
    	"es.math.hypot"
    ],
    	"core-js/stable/math/imul": [
    	"es.math.imul"
    ],
    	"core-js/stable/math/log10": [
    	"es.math.log10"
    ],
    	"core-js/stable/math/log1p": [
    	"es.math.log1p"
    ],
    	"core-js/stable/math/log2": [
    	"es.math.log2"
    ],
    	"core-js/stable/math/sign": [
    	"es.math.sign"
    ],
    	"core-js/stable/math/sinh": [
    	"es.math.sinh"
    ],
    	"core-js/stable/math/tanh": [
    	"es.math.tanh"
    ],
    	"core-js/stable/math/to-string-tag": [
    	"es.math.to-string-tag"
    ],
    	"core-js/stable/math/trunc": [
    	"es.math.trunc"
    ],
    	"core-js/stable/number": [
    	"es.number.constructor",
    	"es.number.epsilon",
    	"es.number.is-finite",
    	"es.number.is-integer",
    	"es.number.is-nan",
    	"es.number.is-safe-integer",
    	"es.number.max-safe-integer",
    	"es.number.min-safe-integer",
    	"es.number.parse-float",
    	"es.number.parse-int",
    	"es.number.to-fixed",
    	"es.number.to-precision"
    ],
    	"core-js/stable/number/constructor": [
    	"es.number.constructor"
    ],
    	"core-js/stable/number/epsilon": [
    	"es.number.epsilon"
    ],
    	"core-js/stable/number/is-finite": [
    	"es.number.is-finite"
    ],
    	"core-js/stable/number/is-integer": [
    	"es.number.is-integer"
    ],
    	"core-js/stable/number/is-nan": [
    	"es.number.is-nan"
    ],
    	"core-js/stable/number/is-safe-integer": [
    	"es.number.is-safe-integer"
    ],
    	"core-js/stable/number/max-safe-integer": [
    	"es.number.max-safe-integer"
    ],
    	"core-js/stable/number/min-safe-integer": [
    	"es.number.min-safe-integer"
    ],
    	"core-js/stable/number/parse-float": [
    	"es.number.parse-float"
    ],
    	"core-js/stable/number/parse-int": [
    	"es.number.parse-int"
    ],
    	"core-js/stable/number/to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/stable/number/to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/stable/number/virtual": [
    	"es.number.to-fixed",
    	"es.number.to-precision"
    ],
    	"core-js/stable/number/virtual/to-fixed": [
    	"es.number.to-fixed"
    ],
    	"core-js/stable/number/virtual/to-precision": [
    	"es.number.to-precision"
    ],
    	"core-js/stable/object": [
    	"es.symbol",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.assign",
    	"es.object.create",
    	"es.object.define-getter",
    	"es.object.define-properties",
    	"es.object.define-property",
    	"es.object.define-setter",
    	"es.object.entries",
    	"es.object.freeze",
    	"es.object.from-entries",
    	"es.object.get-own-property-descriptor",
    	"es.object.get-own-property-descriptors",
    	"es.object.get-own-property-names",
    	"es.object.get-prototype-of",
    	"es.object.is",
    	"es.object.is-extensible",
    	"es.object.is-frozen",
    	"es.object.is-sealed",
    	"es.object.keys",
    	"es.object.lookup-getter",
    	"es.object.lookup-setter",
    	"es.object.prevent-extensions",
    	"es.object.seal",
    	"es.object.set-prototype-of",
    	"es.object.to-string",
    	"es.object.values"
    ],
    	"core-js/stable/object/assign": [
    	"es.object.assign"
    ],
    	"core-js/stable/object/create": [
    	"es.object.create"
    ],
    	"core-js/stable/object/define-getter": [
    	"es.object.define-getter"
    ],
    	"core-js/stable/object/define-properties": [
    	"es.object.define-properties"
    ],
    	"core-js/stable/object/define-property": [
    	"es.object.define-property"
    ],
    	"core-js/stable/object/define-setter": [
    	"es.object.define-setter"
    ],
    	"core-js/stable/object/entries": [
    	"es.object.entries"
    ],
    	"core-js/stable/object/freeze": [
    	"es.object.freeze"
    ],
    	"core-js/stable/object/from-entries": [
    	"es.array.iterator",
    	"es.object.from-entries"
    ],
    	"core-js/stable/object/get-own-property-descriptor": [
    	"es.object.get-own-property-descriptor"
    ],
    	"core-js/stable/object/get-own-property-descriptors": [
    	"es.object.get-own-property-descriptors"
    ],
    	"core-js/stable/object/get-own-property-names": [
    	"es.object.get-own-property-names"
    ],
    	"core-js/stable/object/get-own-property-symbols": [
    	"es.symbol"
    ],
    	"core-js/stable/object/get-prototype-of": [
    	"es.object.get-prototype-of"
    ],
    	"core-js/stable/object/is": [
    	"es.object.is"
    ],
    	"core-js/stable/object/is-extensible": [
    	"es.object.is-extensible"
    ],
    	"core-js/stable/object/is-frozen": [
    	"es.object.is-frozen"
    ],
    	"core-js/stable/object/is-sealed": [
    	"es.object.is-sealed"
    ],
    	"core-js/stable/object/keys": [
    	"es.object.keys"
    ],
    	"core-js/stable/object/lookup-getter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/stable/object/lookup-setter": [
    	"es.object.lookup-setter"
    ],
    	"core-js/stable/object/prevent-extensions": [
    	"es.object.prevent-extensions"
    ],
    	"core-js/stable/object/seal": [
    	"es.object.seal"
    ],
    	"core-js/stable/object/set-prototype-of": [
    	"es.object.set-prototype-of"
    ],
    	"core-js/stable/object/to-string": [
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/stable/object/values": [
    	"es.object.values"
    ],
    	"core-js/stable/parse-float": [
    	"es.parse-float"
    ],
    	"core-js/stable/parse-int": [
    	"es.parse-int"
    ],
    	"core-js/stable/promise": [
    	"es.object.to-string",
    	"es.promise",
    	"es.promise.all-settled",
    	"es.promise.finally",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/promise/all-settled": [
    	"es.promise",
    	"es.promise.all-settled"
    ],
    	"core-js/stable/promise/finally": [
    	"es.promise",
    	"es.promise.finally"
    ],
    	"core-js/stable/queue-microtask": [
    	"web.queue-microtask"
    ],
    	"core-js/stable/reflect": [
    	"es.reflect.apply",
    	"es.reflect.construct",
    	"es.reflect.define-property",
    	"es.reflect.delete-property",
    	"es.reflect.get",
    	"es.reflect.get-own-property-descriptor",
    	"es.reflect.get-prototype-of",
    	"es.reflect.has",
    	"es.reflect.is-extensible",
    	"es.reflect.own-keys",
    	"es.reflect.prevent-extensions",
    	"es.reflect.set",
    	"es.reflect.set-prototype-of"
    ],
    	"core-js/stable/reflect/apply": [
    	"es.reflect.apply"
    ],
    	"core-js/stable/reflect/construct": [
    	"es.reflect.construct"
    ],
    	"core-js/stable/reflect/define-property": [
    	"es.reflect.define-property"
    ],
    	"core-js/stable/reflect/delete-property": [
    	"es.reflect.delete-property"
    ],
    	"core-js/stable/reflect/get": [
    	"es.reflect.get"
    ],
    	"core-js/stable/reflect/get-own-property-descriptor": [
    	"es.reflect.get-own-property-descriptor"
    ],
    	"core-js/stable/reflect/get-prototype-of": [
    	"es.reflect.get-prototype-of"
    ],
    	"core-js/stable/reflect/has": [
    	"es.reflect.has"
    ],
    	"core-js/stable/reflect/is-extensible": [
    	"es.reflect.is-extensible"
    ],
    	"core-js/stable/reflect/own-keys": [
    	"es.reflect.own-keys"
    ],
    	"core-js/stable/reflect/prevent-extensions": [
    	"es.reflect.prevent-extensions"
    ],
    	"core-js/stable/reflect/set": [
    	"es.reflect.set"
    ],
    	"core-js/stable/reflect/set-prototype-of": [
    	"es.reflect.set-prototype-of"
    ],
    	"core-js/stable/regexp": [
    	"es.regexp.constructor",
    	"es.regexp.exec",
    	"es.regexp.flags",
    	"es.regexp.sticky",
    	"es.regexp.test",
    	"es.regexp.to-string",
    	"es.string.match",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split"
    ],
    	"core-js/stable/regexp/constructor": [
    	"es.regexp.constructor"
    ],
    	"core-js/stable/regexp/flags": [
    	"es.regexp.flags"
    ],
    	"core-js/stable/regexp/match": [
    	"es.string.match"
    ],
    	"core-js/stable/regexp/replace": [
    	"es.string.replace"
    ],
    	"core-js/stable/regexp/search": [
    	"es.string.search"
    ],
    	"core-js/stable/regexp/split": [
    	"es.string.split"
    ],
    	"core-js/stable/regexp/sticky": [
    	"es.regexp.sticky"
    ],
    	"core-js/stable/regexp/test": [
    	"es.regexp.exec",
    	"es.regexp.test"
    ],
    	"core-js/stable/regexp/to-string": [
    	"es.regexp.to-string"
    ],
    	"core-js/stable/set": [
    	"es.object.to-string",
    	"es.set",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/set-immediate": [
    	"web.immediate"
    ],
    	"core-js/stable/set-interval": [
    	"web.timers"
    ],
    	"core-js/stable/set-timeout": [
    	"web.timers"
    ],
    	"core-js/stable/string": [
    	"es.regexp.exec",
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.from-code-point",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.raw",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup"
    ],
    	"core-js/stable/string/anchor": [
    	"es.string.anchor"
    ],
    	"core-js/stable/string/big": [
    	"es.string.big"
    ],
    	"core-js/stable/string/blink": [
    	"es.string.blink"
    ],
    	"core-js/stable/string/bold": [
    	"es.string.bold"
    ],
    	"core-js/stable/string/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/stable/string/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/stable/string/fixed": [
    	"es.string.fixed"
    ],
    	"core-js/stable/string/fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/stable/string/fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/stable/string/from-code-point": [
    	"es.string.from-code-point"
    ],
    	"core-js/stable/string/includes": [
    	"es.string.includes"
    ],
    	"core-js/stable/string/italics": [
    	"es.string.italics"
    ],
    	"core-js/stable/string/iterator": [
    	"es.string.iterator"
    ],
    	"core-js/stable/string/link": [
    	"es.string.link"
    ],
    	"core-js/stable/string/match": [
    	"es.regexp.exec",
    	"es.string.match"
    ],
    	"core-js/stable/string/match-all": [
    	"es.string.match-all"
    ],
    	"core-js/stable/string/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/stable/string/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/stable/string/raw": [
    	"es.string.raw"
    ],
    	"core-js/stable/string/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/stable/string/replace": [
    	"es.regexp.exec",
    	"es.string.replace"
    ],
    	"core-js/stable/string/search": [
    	"es.regexp.exec",
    	"es.string.search"
    ],
    	"core-js/stable/string/small": [
    	"es.string.small"
    ],
    	"core-js/stable/string/split": [
    	"es.regexp.exec",
    	"es.string.split"
    ],
    	"core-js/stable/string/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/stable/string/strike": [
    	"es.string.strike"
    ],
    	"core-js/stable/string/sub": [
    	"es.string.sub"
    ],
    	"core-js/stable/string/sup": [
    	"es.string.sup"
    ],
    	"core-js/stable/string/trim": [
    	"es.string.trim"
    ],
    	"core-js/stable/string/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/stable/string/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/stable/string/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/stable/string/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/stable/string/virtual": [
    	"es.string.code-point-at",
    	"es.string.ends-with",
    	"es.string.includes",
    	"es.string.iterator",
    	"es.string.match",
    	"es.string.match-all",
    	"es.string.pad-end",
    	"es.string.pad-start",
    	"es.string.repeat",
    	"es.string.replace",
    	"es.string.search",
    	"es.string.split",
    	"es.string.starts-with",
    	"es.string.trim",
    	"es.string.trim-end",
    	"es.string.trim-start",
    	"es.string.anchor",
    	"es.string.big",
    	"es.string.blink",
    	"es.string.bold",
    	"es.string.fixed",
    	"es.string.fontcolor",
    	"es.string.fontsize",
    	"es.string.italics",
    	"es.string.link",
    	"es.string.small",
    	"es.string.strike",
    	"es.string.sub",
    	"es.string.sup"
    ],
    	"core-js/stable/string/virtual/anchor": [
    	"es.string.anchor"
    ],
    	"core-js/stable/string/virtual/big": [
    	"es.string.big"
    ],
    	"core-js/stable/string/virtual/blink": [
    	"es.string.blink"
    ],
    	"core-js/stable/string/virtual/bold": [
    	"es.string.bold"
    ],
    	"core-js/stable/string/virtual/code-point-at": [
    	"es.string.code-point-at"
    ],
    	"core-js/stable/string/virtual/ends-with": [
    	"es.string.ends-with"
    ],
    	"core-js/stable/string/virtual/fixed": [
    	"es.string.fixed"
    ],
    	"core-js/stable/string/virtual/fontcolor": [
    	"es.string.fontcolor"
    ],
    	"core-js/stable/string/virtual/fontsize": [
    	"es.string.fontsize"
    ],
    	"core-js/stable/string/virtual/includes": [
    	"es.string.includes"
    ],
    	"core-js/stable/string/virtual/italics": [
    	"es.string.italics"
    ],
    	"core-js/stable/string/virtual/iterator": [
    	"es.string.iterator"
    ],
    	"core-js/stable/string/virtual/link": [
    	"es.string.link"
    ],
    	"core-js/stable/string/virtual/match-all": [
    	"es.string.match-all"
    ],
    	"core-js/stable/string/virtual/pad-end": [
    	"es.string.pad-end"
    ],
    	"core-js/stable/string/virtual/pad-start": [
    	"es.string.pad-start"
    ],
    	"core-js/stable/string/virtual/repeat": [
    	"es.string.repeat"
    ],
    	"core-js/stable/string/virtual/small": [
    	"es.string.small"
    ],
    	"core-js/stable/string/virtual/starts-with": [
    	"es.string.starts-with"
    ],
    	"core-js/stable/string/virtual/strike": [
    	"es.string.strike"
    ],
    	"core-js/stable/string/virtual/sub": [
    	"es.string.sub"
    ],
    	"core-js/stable/string/virtual/sup": [
    	"es.string.sup"
    ],
    	"core-js/stable/string/virtual/trim": [
    	"es.string.trim"
    ],
    	"core-js/stable/string/virtual/trim-end": [
    	"es.string.trim-end"
    ],
    	"core-js/stable/string/virtual/trim-left": [
    	"es.string.trim-start"
    ],
    	"core-js/stable/string/virtual/trim-right": [
    	"es.string.trim-end"
    ],
    	"core-js/stable/string/virtual/trim-start": [
    	"es.string.trim-start"
    ],
    	"core-js/stable/symbol": [
    	"es.symbol",
    	"es.symbol.description",
    	"es.symbol.async-iterator",
    	"es.symbol.has-instance",
    	"es.symbol.is-concat-spreadable",
    	"es.symbol.iterator",
    	"es.symbol.match",
    	"es.symbol.match-all",
    	"es.symbol.replace",
    	"es.symbol.search",
    	"es.symbol.species",
    	"es.symbol.split",
    	"es.symbol.to-primitive",
    	"es.symbol.to-string-tag",
    	"es.symbol.unscopables",
    	"es.array.concat",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/stable/symbol/async-iterator": [
    	"es.symbol.async-iterator"
    ],
    	"core-js/stable/symbol/description": [
    	"es.symbol.description"
    ],
    	"core-js/stable/symbol/for": [
    	"es.symbol"
    ],
    	"core-js/stable/symbol/has-instance": [
    	"es.symbol.has-instance",
    	"es.function.has-instance"
    ],
    	"core-js/stable/symbol/is-concat-spreadable": [
    	"es.symbol.is-concat-spreadable",
    	"es.array.concat"
    ],
    	"core-js/stable/symbol/iterator": [
    	"es.symbol.iterator",
    	"es.string.iterator",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/symbol/key-for": [
    	"es.symbol"
    ],
    	"core-js/stable/symbol/match": [
    	"es.symbol.match",
    	"es.string.match"
    ],
    	"core-js/stable/symbol/match-all": [
    	"es.symbol.match-all",
    	"es.string.match-all"
    ],
    	"core-js/stable/symbol/replace": [
    	"es.symbol.replace",
    	"es.string.replace"
    ],
    	"core-js/stable/symbol/search": [
    	"es.symbol.search",
    	"es.string.search"
    ],
    	"core-js/stable/symbol/species": [
    	"es.symbol.species"
    ],
    	"core-js/stable/symbol/split": [
    	"es.symbol.split",
    	"es.string.split"
    ],
    	"core-js/stable/symbol/to-primitive": [
    	"es.symbol.to-primitive"
    ],
    	"core-js/stable/symbol/to-string-tag": [
    	"es.symbol.to-string-tag",
    	"es.json.to-string-tag",
    	"es.math.to-string-tag",
    	"es.object.to-string"
    ],
    	"core-js/stable/symbol/unscopables": [
    	"es.symbol.unscopables"
    ],
    	"core-js/stable/typed-array": [
    	"es.object.to-string",
    	"es.typed-array.float32-array",
    	"es.typed-array.float64-array",
    	"es.typed-array.int8-array",
    	"es.typed-array.int16-array",
    	"es.typed-array.int32-array",
    	"es.typed-array.uint8-array",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.uint16-array",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/copy-within": [
    	"es.typed-array.copy-within"
    ],
    	"core-js/stable/typed-array/entries": [
    	"es.typed-array.iterator"
    ],
    	"core-js/stable/typed-array/every": [
    	"es.typed-array.every"
    ],
    	"core-js/stable/typed-array/fill": [
    	"es.typed-array.fill"
    ],
    	"core-js/stable/typed-array/filter": [
    	"es.typed-array.filter"
    ],
    	"core-js/stable/typed-array/find": [
    	"es.typed-array.find"
    ],
    	"core-js/stable/typed-array/find-index": [
    	"es.typed-array.find-index"
    ],
    	"core-js/stable/typed-array/float32-array": [
    	"es.object.to-string",
    	"es.typed-array.float32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/float64-array": [
    	"es.object.to-string",
    	"es.typed-array.float64-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/for-each": [
    	"es.typed-array.for-each"
    ],
    	"core-js/stable/typed-array/from": [
    	"es.typed-array.from"
    ],
    	"core-js/stable/typed-array/includes": [
    	"es.typed-array.includes"
    ],
    	"core-js/stable/typed-array/index-of": [
    	"es.typed-array.index-of"
    ],
    	"core-js/stable/typed-array/int16-array": [
    	"es.object.to-string",
    	"es.typed-array.int16-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/int32-array": [
    	"es.object.to-string",
    	"es.typed-array.int32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/int8-array": [
    	"es.object.to-string",
    	"es.typed-array.int8-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/iterator": [
    	"es.typed-array.iterator"
    ],
    	"core-js/stable/typed-array/join": [
    	"es.typed-array.join"
    ],
    	"core-js/stable/typed-array/keys": [
    	"es.typed-array.iterator"
    ],
    	"core-js/stable/typed-array/last-index-of": [
    	"es.typed-array.last-index-of"
    ],
    	"core-js/stable/typed-array/map": [
    	"es.typed-array.map"
    ],
    	"core-js/stable/typed-array/of": [
    	"es.typed-array.of"
    ],
    	"core-js/stable/typed-array/reduce": [
    	"es.typed-array.reduce"
    ],
    	"core-js/stable/typed-array/reduce-right": [
    	"es.typed-array.reduce-right"
    ],
    	"core-js/stable/typed-array/reverse": [
    	"es.typed-array.reverse"
    ],
    	"core-js/stable/typed-array/set": [
    	"es.typed-array.set"
    ],
    	"core-js/stable/typed-array/slice": [
    	"es.typed-array.slice"
    ],
    	"core-js/stable/typed-array/some": [
    	"es.typed-array.some"
    ],
    	"core-js/stable/typed-array/sort": [
    	"es.typed-array.sort"
    ],
    	"core-js/stable/typed-array/subarray": [
    	"es.typed-array.subarray"
    ],
    	"core-js/stable/typed-array/to-locale-string": [
    	"es.typed-array.to-locale-string"
    ],
    	"core-js/stable/typed-array/to-string": [
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/uint16-array": [
    	"es.object.to-string",
    	"es.typed-array.uint16-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/uint32-array": [
    	"es.object.to-string",
    	"es.typed-array.uint32-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/uint8-array": [
    	"es.object.to-string",
    	"es.typed-array.uint8-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/uint8-clamped-array": [
    	"es.object.to-string",
    	"es.typed-array.uint8-clamped-array",
    	"es.typed-array.copy-within",
    	"es.typed-array.every",
    	"es.typed-array.fill",
    	"es.typed-array.filter",
    	"es.typed-array.find",
    	"es.typed-array.find-index",
    	"es.typed-array.for-each",
    	"es.typed-array.from",
    	"es.typed-array.includes",
    	"es.typed-array.index-of",
    	"es.typed-array.iterator",
    	"es.typed-array.join",
    	"es.typed-array.last-index-of",
    	"es.typed-array.map",
    	"es.typed-array.of",
    	"es.typed-array.reduce",
    	"es.typed-array.reduce-right",
    	"es.typed-array.reverse",
    	"es.typed-array.set",
    	"es.typed-array.slice",
    	"es.typed-array.some",
    	"es.typed-array.sort",
    	"es.typed-array.subarray",
    	"es.typed-array.to-locale-string",
    	"es.typed-array.to-string"
    ],
    	"core-js/stable/typed-array/values": [
    	"es.typed-array.iterator"
    ],
    	"core-js/stable/url": [
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/stable/url-search-params": [
    	"web.url-search-params"
    ],
    	"core-js/stable/url/to-json": [
    	"web.url.to-json"
    ],
    	"core-js/stable/weak-map": [
    	"es.object.to-string",
    	"es.weak-map",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stable/weak-set": [
    	"es.object.to-string",
    	"es.weak-set",
    	"web.dom-collections.iterator"
    ],
    	"core-js/stage": [
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/stage/0": [
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/stage/1": [
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of"
    ],
    	"core-js/stage/2": [
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.set.difference",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.upsert"
    ],
    	"core-js/stage/3": [
    	"esnext.aggregate-error",
    	"esnext.global-this",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.replace-all"
    ],
    	"core-js/stage/4": [
    	"esnext.global-this",
    	"esnext.promise.all-settled",
    	"esnext.string.match-all"
    ],
    	"core-js/stage/pre": [
    	"esnext.aggregate-error",
    	"esnext.array.is-template-object",
    	"esnext.array.last-index",
    	"esnext.array.last-item",
    	"esnext.async-iterator.constructor",
    	"esnext.async-iterator.as-indexed-pairs",
    	"esnext.async-iterator.drop",
    	"esnext.async-iterator.every",
    	"esnext.async-iterator.filter",
    	"esnext.async-iterator.find",
    	"esnext.async-iterator.flat-map",
    	"esnext.async-iterator.for-each",
    	"esnext.async-iterator.from",
    	"esnext.async-iterator.map",
    	"esnext.async-iterator.reduce",
    	"esnext.async-iterator.some",
    	"esnext.async-iterator.take",
    	"esnext.async-iterator.to-array",
    	"esnext.composite-key",
    	"esnext.composite-symbol",
    	"esnext.global-this",
    	"esnext.iterator.constructor",
    	"esnext.iterator.as-indexed-pairs",
    	"esnext.iterator.drop",
    	"esnext.iterator.every",
    	"esnext.iterator.filter",
    	"esnext.iterator.find",
    	"esnext.iterator.flat-map",
    	"esnext.iterator.for-each",
    	"esnext.iterator.from",
    	"esnext.iterator.map",
    	"esnext.iterator.reduce",
    	"esnext.iterator.some",
    	"esnext.iterator.take",
    	"esnext.iterator.to-array",
    	"esnext.map.delete-all",
    	"esnext.map.every",
    	"esnext.map.filter",
    	"esnext.map.find",
    	"esnext.map.find-key",
    	"esnext.map.from",
    	"esnext.map.group-by",
    	"esnext.map.includes",
    	"esnext.map.key-by",
    	"esnext.map.key-of",
    	"esnext.map.map-keys",
    	"esnext.map.map-values",
    	"esnext.map.merge",
    	"esnext.map.of",
    	"esnext.map.reduce",
    	"esnext.map.some",
    	"esnext.map.update",
    	"esnext.map.update-or-insert",
    	"esnext.map.upsert",
    	"esnext.math.clamp",
    	"esnext.math.deg-per-rad",
    	"esnext.math.degrees",
    	"esnext.math.fscale",
    	"esnext.math.iaddh",
    	"esnext.math.imulh",
    	"esnext.math.isubh",
    	"esnext.math.rad-per-deg",
    	"esnext.math.radians",
    	"esnext.math.scale",
    	"esnext.math.seeded-prng",
    	"esnext.math.signbit",
    	"esnext.math.umulh",
    	"esnext.number.from-string",
    	"esnext.object.iterate-entries",
    	"esnext.object.iterate-keys",
    	"esnext.object.iterate-values",
    	"esnext.observable",
    	"esnext.promise.all-settled",
    	"esnext.promise.any",
    	"esnext.promise.try",
    	"esnext.reflect.define-metadata",
    	"esnext.reflect.delete-metadata",
    	"esnext.reflect.get-metadata",
    	"esnext.reflect.get-metadata-keys",
    	"esnext.reflect.get-own-metadata",
    	"esnext.reflect.get-own-metadata-keys",
    	"esnext.reflect.has-metadata",
    	"esnext.reflect.has-own-metadata",
    	"esnext.reflect.metadata",
    	"esnext.set.add-all",
    	"esnext.set.delete-all",
    	"esnext.set.difference",
    	"esnext.set.every",
    	"esnext.set.filter",
    	"esnext.set.find",
    	"esnext.set.from",
    	"esnext.set.intersection",
    	"esnext.set.is-disjoint-from",
    	"esnext.set.is-subset-of",
    	"esnext.set.is-superset-of",
    	"esnext.set.join",
    	"esnext.set.map",
    	"esnext.set.of",
    	"esnext.set.reduce",
    	"esnext.set.some",
    	"esnext.set.symmetric-difference",
    	"esnext.set.union",
    	"esnext.string.at",
    	"esnext.string.code-points",
    	"esnext.string.match-all",
    	"esnext.string.replace-all",
    	"esnext.symbol.async-dispose",
    	"esnext.symbol.dispose",
    	"esnext.symbol.observable",
    	"esnext.symbol.pattern-match",
    	"esnext.symbol.replace-all",
    	"esnext.weak-map.delete-all",
    	"esnext.weak-map.from",
    	"esnext.weak-map.of",
    	"esnext.weak-map.upsert",
    	"esnext.weak-set.add-all",
    	"esnext.weak-set.delete-all",
    	"esnext.weak-set.from",
    	"esnext.weak-set.of",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/web": [
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator",
    	"web.immediate",
    	"web.queue-microtask",
    	"web.timers",
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/web/dom-collections": [
    	"web.dom-collections.for-each",
    	"web.dom-collections.iterator"
    ],
    	"core-js/web/immediate": [
    	"web.immediate"
    ],
    	"core-js/web/queue-microtask": [
    	"web.queue-microtask"
    ],
    	"core-js/web/timers": [
    	"web.timers"
    ],
    	"core-js/web/url": [
    	"web.url",
    	"web.url.to-json",
    	"web.url-search-params"
    ],
    	"core-js/web/url-search-params": [
    	"web.url-search-params"
    ]
    };

    function isBabelPolyfillSource(source) {
      return source === "@babel/polyfill" || source === "babel-polyfill";
    }

    function isCoreJSSource(source) {
      if (typeof source === "string") {
        source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
      }

      return has$6(corejsEntries, source) && corejsEntries[source];
    }

    var BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
    function replaceCoreJS3EntryPlugin (_, _ref) {
      var corejs = _ref.corejs,
          include = _ref.include,
          exclude = _ref.exclude,
          polyfillTargets = _ref.polyfillTargets,
          debug = _ref.debug;
      var polyfills = filterItems(corejs3Polyfills, include, exclude, polyfillTargets, null);
      var available = new Set(getModulesListForTargetVersion(corejs.version));

      function shouldReplace(source, modules) {
        if (!modules) return false;

        if (modules.length === 1 && polyfills.has(modules[0]) && available.has(modules[0]) && getModulePath(modules[0]) === source) {
          return false;
        }

        return true;
      }

      var isPolyfillImport = {
        ImportDeclaration: function ImportDeclaration(path) {
          var source = getImportSource(path);
          if (!source) return;

          if (isBabelPolyfillSource(source)) {
            console.warn(BABEL_POLYFILL_DEPRECATION);
          } else {
            var modules = isCoreJSSource(source);

            if (shouldReplace(source, modules)) {
              this.replaceBySeparateModulesImport(path, modules);
            }
          }
        },
        Program: {
          enter: function enter(path) {
            var _this = this;

            path.get("body").forEach(function (bodyPath) {
              var source = getRequireSource(bodyPath);
              if (!source) return;

              if (isBabelPolyfillSource(source)) {
                console.warn(BABEL_POLYFILL_DEPRECATION);
              } else {
                var modules = isCoreJSSource(source);

                if (shouldReplace(source, modules)) {
                  _this.replaceBySeparateModulesImport(bodyPath, modules);
                }
              }
            });
          },
          exit: function exit(path) {
            var _this2 = this;

            var filtered = intersection(polyfills, this.polyfillsSet, available);
            var reversed = Array.from(filtered).reverse();

            for (var _iterator = _createForOfIteratorHelperLoose(reversed), _step; !(_step = _iterator()).done;) {
              var module = _step.value;

              if (!this.injectedPolyfills.has(module)) {
                createImport(path, module);
              }
            }

            filtered.forEach(function (module) {
              return _this2.injectedPolyfills.add(module);
            });
          }
        }
      };
      return {
        name: "corejs3-entry",
        visitor: isPolyfillImport,
        pre: function pre() {
          this.injectedPolyfills = new Set();
          this.polyfillsSet = new Set();

          this.replaceBySeparateModulesImport = function (path, modules) {
            for (var _iterator2 = _createForOfIteratorHelperLoose(modules), _step2; !(_step2 = _iterator2()).done;) {
              var module = _step2.value;
              this.polyfillsSet.add(module);
            }

            path.remove();
          };
        },
        post: function post() {
          if (debug) {
            logEntryPolyfills("core-js", this.injectedPolyfills.size > 0, this.injectedPolyfills, this.file.opts.filename, polyfillTargets, corejs3Polyfills);
          }
        }
      };
    }

    function isRegeneratorSource(source) {
      return source === "regenerator-runtime/runtime";
    }

    function removeRegeneratorEntryPlugin () {
      var visitor = {
        ImportDeclaration: function ImportDeclaration(path) {
          if (isRegeneratorSource(getImportSource(path))) {
            this.regeneratorImportExcluded = true;
            path.remove();
          }
        },
        Program: function Program(path) {
          var _this = this;

          path.get("body").forEach(function (bodyPath) {
            if (isRegeneratorSource(getRequireSource(bodyPath))) {
              _this.regeneratorImportExcluded = true;
              bodyPath.remove();
            }
          });
        }
      };
      return {
        name: "regenerator-entry",
        visitor: visitor,
        pre: function pre() {
          this.regeneratorImportExcluded = false;
        },
        post: function post() {
          if (this.opts.debug && this.regeneratorImportExcluded) {
            var filename = this.file.opts.filename;

            if (process.env.BABEL_ENV === "test") {
              filename = filename.replace(/\\/g, "/");
            }

            console.log("\n[" + filename + "] Based on your targets, regenerator-runtime import excluded.");
          }
        }
      };
    }

    var pluginLists = {
      withProposals: {
        withoutBugfixes: pluginsFiltered,
        withBugfixes: Object.assign({}, pluginsFiltered, bugfixPluginsFiltered)
      },
      withoutProposals: {
        withoutBugfixes: filterStageFromList(pluginsFiltered, shippedProposals_2),
        withBugfixes: filterStageFromList(Object.assign({}, pluginsFiltered, bugfixPluginsFiltered), shippedProposals_2)
      }
    };

    function getPluginList(proposals, bugfixes) {
      if (proposals) {
        if (bugfixes) return pluginLists.withProposals.withBugfixes;else return pluginLists.withProposals.withoutBugfixes;
      } else {
        if (bugfixes) return pluginLists.withoutProposals.withBugfixes;else return pluginLists.withoutProposals.withoutBugfixes;
      }
    }

    var getPlugin = function getPlugin(pluginName) {
      var plugin = availablePlugins[pluginName];

      if (!plugin) {
        throw new Error("Could not find plugin \"" + pluginName + "\". Ensure there is an entry in ./available-plugins.js for it.");
      }

      return plugin;
    };

    var transformIncludesAndExcludes = function transformIncludesAndExcludes(opts) {
      return opts.reduce(function (result, opt) {
        var target = opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins";
        result[target].add(opt);
        return result;
      }, {
        all: opts,
        plugins: new Set(),
        builtIns: new Set()
      });
    };
    var getModulesPluginNames = function getModulesPluginNames(_ref) {
      var modules = _ref.modules,
          transformations = _ref.transformations,
          shouldTransformESM = _ref.shouldTransformESM,
          shouldTransformDynamicImport = _ref.shouldTransformDynamicImport,
          shouldParseTopLevelAwait = _ref.shouldParseTopLevelAwait;
      var modulesPluginNames = [];

      if (modules !== false && transformations[modules]) {
        if (shouldTransformESM) {
          modulesPluginNames.push(transformations[modules]);
        }

        if (shouldTransformDynamicImport && shouldTransformESM && modules !== "umd") {
          modulesPluginNames.push("proposal-dynamic-import");
        } else {
          if (shouldTransformDynamicImport) {
            console.warn("Dynamic import can only be supported when transforming ES modules" + " to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled.");
          }

          modulesPluginNames.push("syntax-dynamic-import");
        }
      } else {
        modulesPluginNames.push("syntax-dynamic-import");
      }

      if (shouldParseTopLevelAwait) {
        modulesPluginNames.push("syntax-top-level-await");
      }

      return modulesPluginNames;
    };
    var getPolyfillPlugins = function getPolyfillPlugins(_ref2) {
      var useBuiltIns = _ref2.useBuiltIns,
          corejs = _ref2.corejs,
          polyfillTargets = _ref2.polyfillTargets,
          include = _ref2.include,
          exclude = _ref2.exclude,
          proposals = _ref2.proposals,
          shippedProposals = _ref2.shippedProposals,
          regenerator = _ref2.regenerator,
          debug = _ref2.debug;
      var polyfillPlugins = [];

      if (useBuiltIns === "usage" || useBuiltIns === "entry") {
        var pluginOptions = {
          corejs: corejs,
          polyfillTargets: polyfillTargets,
          include: include,
          exclude: exclude,
          proposals: proposals,
          shippedProposals: shippedProposals,
          regenerator: regenerator,
          debug: debug
        };

        if (corejs) {
          if (useBuiltIns === "usage") {
            if (corejs.major === 2) {
              polyfillPlugins.push([addCoreJS2UsagePlugin, pluginOptions]);
            } else {
              polyfillPlugins.push([addCoreJS3UsagePlugin, pluginOptions]);
            }

            if (regenerator) {
              polyfillPlugins.push([addRegeneratorUsagePlugin, pluginOptions]);
            }
          } else {
            if (corejs.major === 2) {
              polyfillPlugins.push([replaceCoreJS2EntryPlugin, pluginOptions]);
            } else {
              polyfillPlugins.push([replaceCoreJS3EntryPlugin, pluginOptions]);

              if (!regenerator) {
                polyfillPlugins.push([removeRegeneratorEntryPlugin, pluginOptions]);
              }
            }
          }
        }
      }

      return polyfillPlugins;
    };

    function supportsStaticESM$1(caller) {
      return !!(caller && caller.supportsStaticESM);
    }

    function supportsDynamicImport(caller) {
      return !!(caller && caller.supportsDynamicImport);
    }

    function supportsTopLevelAwait(caller) {
      return !!(caller && caller.supportsTopLevelAwait);
    }

    var presetEnv = declare(function (api, opts) {
      api.assertVersion(7);

      var _normalizeOptions = normalizeOptions$3(opts),
          bugfixes = _normalizeOptions.bugfixes,
          configPath = _normalizeOptions.configPath,
          debug = _normalizeOptions.debug,
          optionsExclude = _normalizeOptions.exclude,
          forceAllTransforms = _normalizeOptions.forceAllTransforms,
          ignoreBrowserslistConfig = _normalizeOptions.ignoreBrowserslistConfig,
          optionsInclude = _normalizeOptions.include,
          loose = _normalizeOptions.loose,
          modules = _normalizeOptions.modules,
          shippedProposals = _normalizeOptions.shippedProposals,
          spec = _normalizeOptions.spec,
          optionsTargets = _normalizeOptions.targets,
          useBuiltIns = _normalizeOptions.useBuiltIns,
          _normalizeOptions$cor = _normalizeOptions.corejs,
          corejs = _normalizeOptions$cor.version,
          proposals = _normalizeOptions$cor.proposals;

      var hasUglifyTarget = false;

      if (optionsTargets && optionsTargets.uglify) {
        hasUglifyTarget = true;
        delete optionsTargets.uglify;
        console.log("");
        console.log("The uglify target has been deprecated. Set the top level");
        console.log("option `forceAllTransforms: true` instead.");
        console.log("");
      }

      if (optionsTargets && optionsTargets.esmodules && optionsTargets.browsers) {
        console.log("");
        console.log("@babel/preset-env: esmodules and browsers targets have been specified together.");
        console.log("`browsers` target, `" + optionsTargets.browsers + "` will be ignored.");
        console.log("");
      }

      var targets = getTargets(optionsTargets, {
        ignoreBrowserslistConfig: ignoreBrowserslistConfig,
        configPath: configPath
      });
      var include = transformIncludesAndExcludes(optionsInclude);
      var exclude = transformIncludesAndExcludes(optionsExclude);
      var transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
      var modulesPluginNames = getModulesPluginNames({
        modules: modules,
        transformations: moduleTransformations,
        shouldTransformESM: modules !== "auto" || !api.caller || !api.caller(supportsStaticESM$1),
        shouldTransformDynamicImport: modules !== "auto" || !api.caller || !api.caller(supportsDynamicImport),
        shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
      });
      var pluginNames = filterItems(getPluginList(shippedProposals, bugfixes), include.plugins, exclude.plugins, transformTargets, modulesPluginNames, getOptionSpecificExcludesFor({
        loose: loose
      }), shippedProposals_1);
      removeUnnecessaryItems(pluginNames, overlappingPlugins$2);
      var polyfillPlugins = getPolyfillPlugins({
        useBuiltIns: useBuiltIns,
        corejs: corejs,
        polyfillTargets: targets,
        include: include.builtIns,
        exclude: exclude.builtIns,
        proposals: proposals,
        shippedProposals: shippedProposals,
        regenerator: pluginNames.has("transform-regenerator"),
        debug: debug
      });
      var pluginUseBuiltIns = useBuiltIns !== false;
      var plugins = Array.from(pluginNames).map(function (pluginName) {
        return [getPlugin(pluginName), {
          spec: spec,
          loose: loose,
          useBuiltIns: pluginUseBuiltIns
        }];
      }).concat(polyfillPlugins);

      if (debug) {
        console.log("@babel/preset-env: `DEBUG` option");
        console.log("\nUsing targets:");
        console.log(JSON.stringify(prettifyTargets(targets), null, 2));
        console.log("\nUsing modules transform: " + modules.toString());
        console.log("\nUsing plugins:");
        pluginNames.forEach(function (pluginName) {
          logPluginOrPolyfill(pluginName, targets, pluginsFiltered);
        });

        if (!useBuiltIns) {
          console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
        } else {
          console.log("\nUsing polyfills with `" + useBuiltIns + "` option:");
        }
      }

      return {
        plugins: plugins
      };
    });

    var presetFlow = declare(function (api, _ref) {
      var all = _ref.all,
          allowDeclareFields = _ref.allowDeclareFields;
      api.assertVersion(7);
      return {
        plugins: [[transformFlowStripTypes, {
          all: all,
          allowDeclareFields: allowDeclareFields
        }]]
      };
    });

    var presetReact = declare(function (api, opts) {
      api.assertVersion(7);
      var pragma = opts.pragma,
          pragmaFrag = opts.pragmaFrag;
      var pure = opts.pure,
          _opts$throwIfNamespac = opts.throwIfNamespace,
          throwIfNamespace = _opts$throwIfNamespac === void 0 ? true : _opts$throwIfNamespac,
          useSpread = opts.useSpread,
          _opts$runtime = opts.runtime,
          runtime = _opts$runtime === void 0 ? "classic" : _opts$runtime,
          importSource = opts.importSource;

      if (runtime === "classic") {
        pragma = pragma || "React.createElement";
        pragmaFrag = pragmaFrag || "React.Fragment";
      }

      var development = !!opts.development;
      var useBuiltIns = !!opts.useBuiltIns;

      if (typeof development !== "boolean") {
        throw new Error("@babel/preset-react 'development' option must be a boolean.");
      }

      var transformReactJSXPlugin = runtime === "automatic" && development ? transformReactJSXDevelopment : transformReactJSX;
      return {
        plugins: [[transformReactJSXPlugin, {
          importSource: importSource,
          pragma: pragma,
          pragmaFrag: pragmaFrag,
          runtime: runtime,
          throwIfNamespace: throwIfNamespace,
          useBuiltIns: useBuiltIns,
          useSpread: useSpread,
          pure: pure
        }], transformReactDisplayName, development && runtime === "classic" && transformReactJSXSource, development && runtime === "classic" && transformReactJSXSelf].filter(Boolean)
      };
    });

    var presetTypescript = declare(function (api, _ref) {
      var _ref$allExtensions = _ref.allExtensions,
          allExtensions = _ref$allExtensions === void 0 ? false : _ref$allExtensions,
          allowDeclareFields = _ref.allowDeclareFields,
          allowNamespaces = _ref.allowNamespaces,
          jsxPragma = _ref.jsxPragma,
          _ref$isTSX = _ref.isTSX,
          isTSX = _ref$isTSX === void 0 ? false : _ref$isTSX,
          onlyRemoveTypeImports = _ref.onlyRemoveTypeImports;
      api.assertVersion(7);

      if (typeof allExtensions !== "boolean") {
        throw new Error(".allExtensions must be a boolean, or undefined");
      }

      if (typeof isTSX !== "boolean") {
        throw new Error(".isTSX must be a boolean, or undefined");
      }

      if (isTSX && !allExtensions) {
        throw new Error("isTSX:true requires allExtensions:true");
      }

      var pluginOptions = function pluginOptions(isTSX) {
        return {
          allowDeclareFields: allowDeclareFields,
          allowNamespaces: allowNamespaces,
          isTSX: isTSX,
          jsxPragma: jsxPragma,
          onlyRemoveTypeImports: onlyRemoveTypeImports
        };
      };

      return {
        overrides: allExtensions ? [{
          plugins: [[transformTypeScript, pluginOptions(isTSX)]]
        }] : [{
          test: /\.ts$/,
          plugins: [[transformTypeScript, pluginOptions(false)]]
        }, {
          test: /\.tsx$/,
          plugins: [[transformTypeScript, pluginOptions(true)]]
        }]
      };
    });

    var scriptTypes = ["text/jsx", "text/babel"];
    var headEl;
    var inlineScriptCount = 0;

    function transformCode(transformFn, script) {
      var source;

      if (script.url != null) {
        source = script.url;
      } else {
        source = "Inline Babel script";
        inlineScriptCount++;

        if (inlineScriptCount > 1) {
          source += " (" + inlineScriptCount + ")";
        }
      }

      return transformFn(script.content, buildBabelOptions(script, source)).code;
    }

    function buildBabelOptions(script, filename) {
      return {
        filename: filename,
        presets: script.presets || ["react", "es2015"],
        plugins: script.plugins || ["proposal-class-properties", "proposal-object-rest-spread", "transform-flow-strip-types"],
        sourceMaps: "inline",
        sourceFileName: filename
      };
    }

    function run$1(transformFn, script) {
      var scriptEl = document.createElement("script");
      scriptEl.text = transformCode(transformFn, script);
      headEl.appendChild(scriptEl);
    }

    function load(url, successCallback, errorCallback) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);

      if ("overrideMimeType" in xhr) {
        xhr.overrideMimeType("text/plain");
      }

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 0 || xhr.status === 200) {
            successCallback(xhr.responseText);
          } else {
            errorCallback();
            throw new Error("Could not load " + url);
          }
        }
      };

      return xhr.send(null);
    }

    function getPluginsOrPresetsFromScript(script, attributeName) {
      var rawValue = script.getAttribute(attributeName);

      if (rawValue === "") {
        return [];
      }

      if (!rawValue) {
        return null;
      }

      return rawValue.split(",").map(function (item) {
        return item.trim();
      });
    }

    function loadScripts(transformFn, scripts) {
      var result = [];
      var count = scripts.length;

      function check() {
        var script, i;

        for (i = 0; i < count; i++) {
          script = result[i];

          if (script.loaded && !script.executed) {
            script.executed = true;
            run$1(transformFn, script);
          } else if (!script.loaded && !script.error && !script.async) {
            break;
          }
        }
      }

      scripts.forEach(function (script, i) {
        var scriptData = {
          async: script.hasAttribute("async"),
          error: false,
          executed: false,
          plugins: getPluginsOrPresetsFromScript(script, "data-plugins"),
          presets: getPluginsOrPresetsFromScript(script, "data-presets")
        };

        if (script.src) {
          result[i] = Object.assign({}, scriptData, {
            content: null,
            loaded: false,
            url: script.src
          });
          load(script.src, function (content) {
            result[i].loaded = true;
            result[i].content = content;
            check();
          }, function () {
            result[i].error = true;
            check();
          });
        } else {
          result[i] = Object.assign({}, scriptData, {
            content: script.innerHTML,
            loaded: true,
            url: script.getAttribute("data-module") || null
          });
        }
      });
      check();
    }

    function runScripts(transformFn, scripts) {
      headEl = document.getElementsByTagName("head")[0];

      if (!scripts) {
        scripts = document.getElementsByTagName("script");
      }

      var jsxScripts = [];

      for (var i = 0; i < scripts.length; i++) {
        var script = scripts.item(i);
        var type = script.type.split(";")[0];

        if (scriptTypes.indexOf(type) !== -1) {
          jsxScripts.push(script);
        }
      }

      if (jsxScripts.length === 0) {
        return;
      }

      console.warn("You are using the in-browser Babel transformer. Be sure to precompile " + "your scripts for production - https://babeljs.io/docs/setup/");
      loadScripts(transformFn, jsxScripts);
    }

    var isArray$4 = Array.isArray || function (arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };

    function loadBuiltin(builtinTable, name) {
      if (isArray$4(name) && typeof name[0] === "string") {
        if (Object.prototype.hasOwnProperty.call(builtinTable, name[0])) {
          return [builtinTable[name[0]]].concat(name.slice(1));
        }

        return;
      } else if (typeof name === "string") {
        return builtinTable[name];
      }

      return name;
    }

    function processOptions(options) {
      var presets = (options.presets || []).map(function (presetName) {
        var preset = loadBuiltin(availablePresets, presetName);

        if (preset) {
          if (isArray$4(preset) && typeof preset[0] === "object" && Object.prototype.hasOwnProperty.call(preset[0], "buildPreset")) {
            preset[0] = Object.assign({}, preset[0], {
              buildPreset: preset[0].buildPreset
            });
          }
        } else {
          throw new Error("Invalid preset specified in Babel options: \"" + presetName + "\"");
        }

        return preset;
      });
      var plugins = (options.plugins || []).map(function (pluginName) {
        var plugin = loadBuiltin(availablePlugins$1, pluginName);

        if (!plugin) {
          throw new Error("Invalid plugin specified in Babel options: \"" + pluginName + "\"");
        }

        return plugin;
      });
      return Object.assign({
        babelrc: false
      }, options, {
        presets: presets,
        plugins: plugins
      });
    }

    function transform$1(code, options) {
      return transform(code, processOptions(options));
    }
    function transformFromAst$1(ast, code, options) {
      return transformFromAst(ast, code, processOptions(options));
    }
    var availablePlugins$1 = {};
    var availablePresets = {};
    var buildExternalHelpers = babelBuildExternalHelpers;
    function registerPlugin(name, plugin) {
      if (Object.prototype.hasOwnProperty.call(availablePlugins$1, name)) {
        console.warn("A plugin named \"" + name + "\" is already registered, it will be overridden");
      }

      availablePlugins$1[name] = plugin;
    }
    function registerPlugins(newPlugins) {
      Object.keys(newPlugins).forEach(function (name) {
        return registerPlugin(name, newPlugins[name]);
      });
    }
    function registerPreset(name, preset) {
      if (Object.prototype.hasOwnProperty.call(availablePresets, name)) {
        if (name === "env") {
          console.warn("@babel/preset-env is now included in @babel/standalone, please remove @babel/preset-env-standalone");
        } else {
          console.warn("A preset named \"" + name + "\" is already registered, it will be overridden");
        }
      }

      availablePresets[name] = preset;
    }
    function registerPresets(newPresets) {
      Object.keys(newPresets).forEach(function (name) {
        return registerPreset(name, newPresets[name]);
      });
    }
    registerPlugins(all);
    registerPresets({
      env: presetEnv,
      es2015: preset2015,
      es2016: function es2016() {
        return {
          plugins: [availablePlugins$1["transform-exponentiation-operator"]]
        };
      },
      es2017: function es2017() {
        return {
          plugins: [availablePlugins$1["transform-async-to-generator"]]
        };
      },
      react: presetReact,
      "stage-0": presetStage0,
      "stage-1": presetStage1,
      "stage-2": presetStage2,
      "stage-3": presetStage3,
      "es2015-loose": {
        presets: [[preset2015, {
          loose: true
        }]]
      },
      "es2015-no-commonjs": {
        presets: [[preset2015, {
          modules: false
        }]]
      },
      typescript: presetTypescript,
      flow: presetFlow
    });
    var version$7 = "7.9.0";

    function onDOMContentLoaded() {
      transformScriptTags();
    }

    if (typeof window !== "undefined" && window && window.addEventListener) {
      window.addEventListener("DOMContentLoaded", onDOMContentLoaded, false);
    }

    function transformScriptTags(scriptTags) {
      runScripts(transform$1, scriptTags);
    }
    function disableScriptTags() {
      window.removeEventListener("DOMContentLoaded", onDOMContentLoaded);
    }

    exports.availablePlugins = availablePlugins$1;
    exports.availablePresets = availablePresets;
    exports.buildExternalHelpers = buildExternalHelpers;
    exports.disableScriptTags = disableScriptTags;
    exports.registerPlugin = registerPlugin;
    exports.registerPlugins = registerPlugins;
    exports.registerPreset = registerPreset;
    exports.registerPresets = registerPresets;
    exports.transform = transform$1;
    exports.transformFromAst = transformFromAst$1;
    exports.transformScriptTags = transformScriptTags;
    exports.version = version$7;

    Object.defineProperty(exports, '__esModule', { value: true });

  })));
  });

  var babel$1 = /*@__PURE__*/unwrapExports(babel);

  const HIDDEN_PREFIX = '$h\u200d_';
  const HIDDEN_CONST_VAR_PREFIX = '$c\u200d_';
  const HIDDEN_A = `${HIDDEN_PREFIX}a`;
  const HIDDEN_IMPORT = `${HIDDEN_PREFIX}import`;
  const HIDDEN_IMPORT_SELF = `${HIDDEN_PREFIX}importSelf`;
  const HIDDEN_IMPORTS = `${HIDDEN_PREFIX}imports`;
  const HIDDEN_ONCE = `${HIDDEN_PREFIX}once`;
  const HIDDEN_LIVE = `${HIDDEN_PREFIX}live`;
  const HIDDEN_IDENTIFIERS = [
    HIDDEN_A,
    HIDDEN_IMPORT,
    HIDDEN_IMPORT_SELF,
    HIDDEN_IMPORTS,
    HIDDEN_ONCE,
    HIDDEN_LIVE,
  ];

  /* eslint max-lines: 0 */

  // export const pattern = ...;
  const collectPatternIdentifiers = (path, pattern) => {
    switch (pattern.type) {
      case 'Identifier':
        return [pattern];
      case 'RestElement':
        return collectPatternIdentifiers(path, pattern.argument);
      case 'ObjectProperty':
        return collectPatternIdentifiers(path, pattern.value);
      case 'ObjectPattern':
        return pattern.properties.reduce((prior, prop) => {
          prior.push(...collectPatternIdentifiers(path, prop));
          return prior;
        }, []);
      case 'ArrayPattern':
        return pattern.elements.reduce((prior, pat) => {
          if (pat !== null) {
            // Non-elided pattern.
            prior.push(...collectPatternIdentifiers(path, pat));
          }
          return prior;
        }, []);
      default:
        throw path.buildCodeFrameError(
          `Pattern type ${pattern.type} is not recognized`,
        );
    }
  };

  function makeModulePlugins(options) {
    const {
      exportAlls,
      fixedExportMap,
      imports,
      importDecls,
      importSources,
      liveExportMap,
    } = options;
    const updaterSources = Object.create(null);
    const topLevelIsOnce = Object.create(null);
    const topLevelExported = Object.create(null);

    const rewriteModules = pass => ({ types: t }) => {
      const allowedHiddens = new WeakSet();
      const rewrittenDecls = new WeakSet();
      const hiddenIdentifier = hi => {
        const ident = t.identifier(hi);
        allowedHiddens.add(ident);
        return ident;
      };
      const hOnceId = hiddenIdentifier(HIDDEN_ONCE);
      const hLiveId = hiddenIdentifier(HIDDEN_LIVE);
      const soften = id => {
        // Remap the name to $c_name.
        const { name } = id;
        id.name = `${HIDDEN_CONST_VAR_PREFIX}${name}`;
        allowedHiddens.add(id);
      };

      const rewriteVars = (vids, isConst, needsHoisting) =>
        vids.reduce((prior, id) => {
          const { name } = id;
          if (!isConst && !topLevelIsOnce[name]) {
            if (topLevelExported[name]) {
              // Just add $h_live.name($c_name);
              soften(id);
              prior.push(
                t.expressionStatement(
                  t.callExpression(
                    t.memberExpression(hLiveId, t.identifier(name)),
                    [id],
                  ),
                ),
              );
              for (const importTo of topLevelExported[name]) {
                liveExportMap[importTo] = [name, true];
              }
            } else {
              // Make this variable mutable with: let name = $c_name;
              soften(id);
              prior.push(
                t.variableDeclaration('let', [
                  t.variableDeclarator(t.identifier(name), id),
                ]),
              );
            }
          } else if (topLevelExported[name]) {
            if (needsHoisting) {
              // Hoist the declaration and soften.
              soften(id);
              if (needsHoisting === 'function') {
                options.hoistedDecls.push([name, id.name]);
              } else {
                // Rewrite to be just name = value.
                options.hoistedDecls.push([name]);
                prior.push(
                  t.expressionStatement(
                    t.assignmentExpression('=', t.identifier(name), id),
                  ),
                );
              }
              for (const importTo of topLevelExported[name]) {
                liveExportMap[importTo] = [name, true];
              }
            } else {
              // Just add $h_once.name(name);
              prior.push(
                t.expressionStatement(
                  t.callExpression(t.memberExpression(hOnceId, id), [id]),
                ),
              );
              for (const importTo of topLevelExported[name]) {
                fixedExportMap[importTo] = [name];
              }
            }
          }
          return prior;
        }, []);

      const rewriteDeclaration = path => {
        // Find all the declared identifiers.
        if (rewrittenDecls.has(path.node)) {
          return;
        }
        const decl = path.node;
        const declarations = decl.declarations || [decl];
        const vids = declarations.reduce((prior, { id: pat }) => {
          prior.push(...collectPatternIdentifiers(path, pat));
          return prior;
        }, []);

        // Create the export calls.
        const isConst = decl.kind === 'const';
        const replace = rewriteVars(
          vids,
          isConst,
          decl.type === 'FunctionDeclaration'
            ? 'function'
            : !isConst && decl.kind !== 'let',
        );

        if (replace.length > 0) {
          switch (decl.type) {
            case 'VariableDeclaration': {
              // We rewrote the declaration.
              rewrittenDecls.add(decl);
              replace.unshift(decl);
              break;
            }
            case 'FunctionDeclaration': {
              replace.unshift(decl);
              break;
            }
            default: {
              throw TypeError(`Unknown declaration type ${decl.type}`);
            }
          }
        }
        if (replace.length > 0) {
          path.replaceWithMultiple(replace);
        }
      };

      const visitor = {
        Identifier(path) {
          if (options.allowHidden || allowedHiddens.has(path.node)) {
            return;
          }
          // Ensure the parse doesn't already include our required hidden identifiers.
          // console.log(`have identifier`, path.node);
          const i = HIDDEN_IDENTIFIERS.indexOf(path.node.name);
          if (i >= 0) {
            throw path.buildCodeFrameError(
              `The ${HIDDEN_IDENTIFIERS[i]} identifier is reserved`,
            );
          }
          if (path.node.name.startsWith(HIDDEN_CONST_VAR_PREFIX)) {
            throw path.buildCodeFrameError(
              `The ${path.node.name} constant variable is reserved`,
            );
          }
        },
        CallExpression(path) {
          // import(FOO) -> $h_import(FOO)
          if (path.node.callee.type === 'Import') {
            path.node.callee = hiddenIdentifier(HIDDEN_IMPORT);
          }
        },
      };

      const moduleVisitor = (doAnalyze, doTransform) => ({
        // We handle all the import and export productions.
        ImportDeclaration(path) {
          if (doAnalyze) {
            const specs = path.node.specifiers;
            const specifier = path.node.source.value;
            let myImportSources = importSources[specifier];
            if (!myImportSources) {
              myImportSources = Object.create(null);
              importSources[specifier] = myImportSources;
            }
            let myImports = imports[specifier];
            if (!myImports) {
              myImports = [];
              imports[specifier] = myImports;
            }
            if (!specs) {
              return;
            }
            specs.forEach(spec => {
              const importTo = spec.local.name;
              importDecls.push(importTo);
              let importFrom;
              switch (spec.type) {
                // import importTo from 'module';
                case 'ImportDefaultSpecifier':
                  importFrom = 'default';
                  break;
                // import * as importTo from 'module';
                case 'ImportNamespaceSpecifier':
                  importFrom = '*';
                  break;
                // import { importFrom as importTo } from 'module';
                case 'ImportSpecifier':
                  importFrom = spec.imported.name;
                  break;
                default:
                  throw path.buildCodeFrameError(
                    `Unrecognized import specifier type ${spec.type}`,
                  );
              }
              if (myImports && myImports.indexOf(importFrom) < 0) {
                myImports.push(importFrom);
              }

              if (myImportSources) {
                let myUpdaterSources = myImportSources[importFrom];
                if (!myUpdaterSources) {
                  myUpdaterSources = [];
                  myImportSources[importFrom] = myUpdaterSources;
                }

                myUpdaterSources.push(
                  `${HIDDEN_A} => (${importTo} = ${HIDDEN_A})`,
                );
                updaterSources[importTo] = myUpdaterSources;
              }
            });
          }
          if (doTransform) {
            // Nullify the import declaration.
            path.replaceWithMultiple([]);
          }
        },
        ExportDefaultDeclaration(path) {
          // export default FOO -> $h_once.default(FOO)
          if (doAnalyze) {
            fixedExportMap.default = ['default'];
          }
          if (doTransform) {
            const id = t.identifier('default');
            const cid = t.identifier('default');
            soften(cid);
            const callee = t.memberExpression(
              hiddenIdentifier(HIDDEN_ONCE),
              id,
            );
            let expr = path.node.declaration;
            if (expr.type === 'ClassDeclaration') {
              expr = t.classExpression(expr.id, expr.superClass, expr.body);
            } else if (expr.type === 'FunctionDeclaration') {
              expr = t.functionExpression(
                expr.id,
                expr.params,
                expr.body,
                expr.generator,
                expr.async,
              );
            }
            // const {default: $c_default} = {default: (XXX)}; $h_once.default($c_default);
            path.replaceWithMultiple([
              t.variableDeclaration('const', [
                t.variableDeclarator(
                  t.objectPattern([t.objectProperty(id, cid)]),
                  t.objectExpression([t.objectProperty(id, expr)]),
                ),
              ]),
              t.expressionStatement(t.callExpression(callee, [cid])),
            ]);
          }
        },
        ClassDeclaration(path) {
          const ptype = path.parent.type;
          if (ptype !== 'Program' && ptype !== 'ExportNamedDeclaration') {
            return;
          }

          const { name } = path.node.id;
          if (doAnalyze) {
            topLevelIsOnce[name] = path.scope.getBinding(name).constant;
          }
          if (doTransform) {
            if (topLevelExported[name]) {
              const callee = t.memberExpression(
                hiddenIdentifier(HIDDEN_LIVE),
                path.node.id,
              );
              path.replaceWith(
                t.blockStatement([
                  path.node,
                  t.expressionStatement(t.callExpression(callee, [path.node.id])),
                ]),
              );
              for (const importTo of topLevelExported[name]) {
                liveExportMap[importTo] = [name, true];
              }
            }
          }
        },
        FunctionDeclaration(path) {
          const ptype = path.parent.type;
          if (ptype !== 'Program' && ptype !== 'ExportNamedDeclaration') {
            return;
          }

          const { name } = path.node.id;
          if (doAnalyze) {
            topLevelIsOnce[name] = path.scope.getBinding(name).constant;
          }
          if (doTransform) {
            if (topLevelExported[name]) {
              rewriteDeclaration(path);
              for (const importTo of topLevelExported[name]) {
                liveExportMap[importTo] = [name, true];
              }
            }
          }
        },
        VariableDeclaration(path) {
          const ptype = path.parent.type;
          if (ptype !== 'Program' && ptype !== 'ExportNamedDeclaration') {
            return;
          }

          // We may need to rewrite this topLevelDecl later.
          const vids = path.node.declarations.reduce((prior, { id: pat }) => {
            prior.push(...collectPatternIdentifiers(path, pat));
            return prior;
          }, []);
          if (doAnalyze) {
            vids.forEach(({ name }) => {
              topLevelIsOnce[name] = path.scope.getBinding(name).constant;
            });
          }
          if (doTransform) {
            for (const { name } of vids) {
              if (topLevelExported[name]) {
                rewriteDeclaration(path);
                break;
              }
            }
          }
        },
        ExportAllDeclaration(path) {
          const { source } = path.node;
          if (doAnalyze) {
            const specifier = source.value;
            let myImportSources = importSources[specifier];
            if (!myImportSources) {
              myImportSources = Object.create(null);
              importSources[specifier] = myImportSources;
            }
            let myImports = imports[specifier];
            if (!myImports) {
              // Ensure that the specifier is imported.
              myImports = [];
              imports[specifier] = myImports;
            }
            exportAlls.push(specifier);
          }
          if (doTransform) {
            path.replaceWithMultiple([]);
          }
        },
        ExportNamedDeclaration(path) {
          const { declaration: decl, specifiers: specs, source } = path.node;

          if (doAnalyze) {
            let myImportSources;
            let myImports;
            if (source) {
              const specifier = source.value;
              myImportSources = importSources[specifier];
              if (!myImportSources) {
                myImportSources = Object.create(null);
                importSources[specifier] = myImportSources;
              }
              myImports = imports[specifier];
              if (!myImports) {
                myImports = [];
                imports[specifier] = myImports;
              }
            }

            if (decl) {
              const declarations = decl.declarations || [decl];
              const vids = declarations.reduce((prior, { id: pat }) => {
                prior.push(...collectPatternIdentifiers(path, pat));
                return prior;
              }, []);
              vids.forEach(({ name }) => {
                let tle = topLevelExported[name];
                if (!tle) {
                  tle = [];
                  topLevelExported[name] = tle;
                }
                tle.push(name);
              });
            }

            specs.forEach(spec => {
              const { local, exported } = spec;
              const importFrom =
                spec.type === 'ExportNamespaceSpecifier' ? '*' : local.name;

              // If local.name is reexported we omit it.
              const importTo = exported.name;
              let myUpdaterSources = updaterSources[importFrom];
              if (myImportSources) {
                myUpdaterSources = myImportSources[importFrom];
                if (!myUpdaterSources) {
                  myUpdaterSources = [];
                  myImportSources[importFrom] = myUpdaterSources;
                }
                updaterSources[importTo] = myUpdaterSources;
                myImports.push(importFrom);
              }

              if (myUpdaterSources) {
                // If there are updaters, we must have a local
                // name, so update it with this export.
                const ident = topLevelIsOnce[importFrom]
                  ? HIDDEN_ONCE
                  : HIDDEN_LIVE;
                myUpdaterSources.push(`${ident}[${JSON.stringify(importFrom)}]`);
              }

              if (source || myUpdaterSources) {
                // Not declared, so make it a live export without proxy.
                liveExportMap[importTo] = [importFrom, false];
              } else {
                let tle = topLevelExported[importFrom];
                if (!tle) {
                  tle = [];
                  topLevelExported[importFrom] = tle;
                }
                tle.push(importTo);
              }
            });
          }
          if (doTransform) {
            path.replaceWithMultiple(decl ? [decl] : []);
          }
        },
      });

      if (options.sourceType === 'module') {
        // Add the module visitor.
        switch (pass) {
          case 0:
            return {
              visitor: {
                ...visitor,
                ...moduleVisitor(true, false),
              },
            };
          case 1:
            return { visitor: moduleVisitor(false, true) };
          default:
            throw TypeError(`Unrecognized module pass ${pass}`);
        }
      }
      return { visitor };
    };

    const rewriters = [rewriteModules(0)];
    if (options.sourceType === 'module') {
      rewriters.push(rewriteModules(1));
    }
    return rewriters;
  }

  const { freeze: freeze$2 } = Object;

  const makeTransformSource = babel =>
    function transformSource(source, sourceOptions = {}) {
      // Transform the script/expression source for import expressions.
      const parserPlugins = [];
      if (sourceOptions.sourceType === 'module') {
        parserPlugins.push(
          'exportDefaultFrom',
          'exportNamespaceFrom',
          'importMeta',
        );
      }

      // This list taken and amended from:
      // https://github.com/prettier/prettier/tree/master/src/language-js/parser-babylon.js#L21
      parserPlugins.push(
        'eventualSend',
        'doExpressions',
        'objectRestSpread',
        'classProperties',
        // 'exportDefaultFrom', // only for modules, above
        // 'exportNamespaceFrom', // only for modules, above
        'asyncGenerators',
        'functionBind',
        'functionSent',
        'dynamicImport', // needed for our rewrite
        'numericSeparator',
        // 'importMeta', // only for modules, above
        'optionalCatchBinding',
        'optionalChaining',
        'classPrivateProperties',
        ['pipelineOperator', { proposal: 'minimal' }],
        'nullishCoalescingOperator',
        'bigInt',
        'throwExpressions',
        'logicalAssignment',
        'classPrivateMethods',
        // 'v8intrinsic', // we really don't want people to rely on platform powers
        'partialApplication',
        ['decorators', { decoratorsBeforeExport: false }],
      );

      // console.log(`transforming`, sourceOptions, source);
      const modulePlugins = makeModulePlugins(sourceOptions);
      const output = babel.transform(source, {
        parserOpts: {
          // allowAwaitOutsideFunction: true,
          plugins: parserPlugins,
        },
        generatorOpts: {
          retainLines: true,
        },
        plugins: [modulePlugins[0]],
        ast: true,
        code: modulePlugins.length === 1,
      });
      let { ast, code } = output;
      for (let i = 1; i < modulePlugins.length - 1; i += 1) {
        const middleOut = babel.transformFromAst(ast, source, {
          plugins: [modulePlugins[i]],
          ast: true,
          code: false,
        });
        ast = middleOut.ast;
      }
      if (modulePlugins.length > 1) {
        const finalOut = babel.transformFromAst(ast, source, {
          generatorOpts: {
            retainLines: true,
          },
          plugins: [modulePlugins[modulePlugins.length - 1]],
        });
        code = finalOut.code;
      }

      // console.log(`transformed to`, output.code);
      return code;
    };

  const makeCreateStaticRecord = transformSource =>
    function createStaticRecord(moduleSource, url) {
      // Transform the Module source code.
      const sourceOptions = {
        sourceType: 'module',
        // exportNames of variables that are only initialized and used, but
        // never assigned to.
        fixedExportMap: {},
        // Record of imported module specifier names to list of importNames.
        // The importName '*' is that module's module namespace object.
        imports: {},
        // List of module specifiers that we export all from.
        exportAlls: [],
        // exportNames of variables that are assigned to, or reexported and
        // therefore assumed live. A reexported variable might not have any
        // localName.
        liveExportMap: {},
        hoistedDecls: [],
        importSources: {},
        importDecls: [],
      };
      if (moduleSource.startsWith('#!')) {
        // Comment out the shebang lines.
        moduleSource = `//${moduleSource}`;
      }
      const scriptSource = transformSource(moduleSource, sourceOptions);

      let preamble = sourceOptions.importDecls.join(',');
      if (preamble !== '') {
        preamble = `let ${preamble};`;
      }
      const js = JSON.stringify;
      const isrc = sourceOptions.importSources;
      preamble += `${HIDDEN_IMPORTS}(new Map([${Object.keys(isrc)
      .map(
        src =>
          `[${js(src)}, new Map([${Object.entries(isrc[src])
            .map(([exp, upds]) => `[${js(exp)}, [${upds.join(',')}]]`)
            .join(',')}])]`,
      )
      .join(',')}]), ${js(sourceOptions.exportAlls)});`;
      preamble += sourceOptions.hoistedDecls
        .map(([vname, cvname]) => {
          let src = '';
          if (cvname) {
            // It's a function, so set its name property.
            src = `Object.defineProperty(${cvname}, 'name', {value: ${js(
            vname,
          )}});`;
          }
          src += `${HIDDEN_LIVE}.${vname}(${cvname || ''});`;
          return src;
        })
        .join('');

      // The functor captures the SES `arguments`, which is definitely
      // less bad than the functor's arguments (which we are trying to
      // hide).
      //
      // It must also be strict to enforce strictness of modules.
      // We use destructuring parameters, so 'use strict' is not allowed
      // but the function actually is strict.
      const functorSource = `\
(({ \
  imports: ${HIDDEN_IMPORTS}, \
  liveVar: ${HIDDEN_LIVE}, \
  onceVar: ${HIDDEN_ONCE}, \
 }) => { \
  ${preamble} \
  ${scriptSource}
})
//# sourceURL=${url}`;

      const moduleAnalysis = freeze$2({
        exportAlls: freeze$2(sourceOptions.exportAlls),
        imports: freeze$2(sourceOptions.imports),
        liveExportMap: freeze$2(sourceOptions.liveExportMap),
        fixedExportMap: freeze$2(sourceOptions.fixedExportMap),
        functorSource,
      });
      return moduleAnalysis;
    };

  const makeModuleAnalyzer = babel => {
    const transformSource = makeTransformSource(babel);
    const createStaticRecord = makeCreateStaticRecord(transformSource);
    return ({ string, url }) => createStaticRecord(string, url);
  };

  // For brevity, in this file, as in module-link.js, the term "moduleRecord"

  const { details: d$4, quote: q$3 } = assert;

  // `makeAlias` constructs compartment specifier tuples for the `aliases`
  // private field of compartments.
  // These aliases allow a compartment to alias an internal module specifier to a
  // module specifier in an external compartment, and also to create internal
  // aliases.
  // Both are facilitated by the moduleMap Compartment constructor option.
  const makeAlias = (compartment, specifier) =>
    freeze({
      compartment,
      specifier,
    });

  // `resolveAll` pre-computes resolutions of all imports within the compartment
  // in which a module was loaded.
  const resolveAll = (imports, resolveHook, fullReferrerSpecifier) => {
    const resolvedImports = create(null);
    for (const importSpecifier of imports) {
      const fullSpecifier = resolveHook(importSpecifier, fullReferrerSpecifier);
      resolvedImports[importSpecifier] = fullSpecifier;
    }
    return freeze(resolvedImports);
  };

  const loadRecord = async (
    compartmentPrivateFields,
    moduleAliases,
    compartment,
    moduleSpecifier,
    staticModuleRecord,
  ) => {
    const { resolveHook, moduleRecords } = compartmentPrivateFields.get(
      compartment,
    );

    // resolve all imports relative to this referrer module.
    const resolvedImports = resolveAll(
      staticModuleRecord.imports,
      resolveHook,
      moduleSpecifier,
    );
    const moduleRecord = freeze({
      compartment,
      staticModuleRecord,
      moduleSpecifier,
      resolvedImports,
    });

    // Memoize.
    moduleRecords.set(moduleSpecifier, moduleRecord);

    // Await all dependencies to load, recursively.
    await Promise.all(
      values(resolvedImports).map(fullSpecifier =>
        // Behold: recursion.
        // eslint-disable-next-line no-use-before-define
        load(compartmentPrivateFields, moduleAliases, compartment, fullSpecifier),
      ),
    );

    return moduleRecord;
  };

  const loadWithoutErrorAnnotation = async (
    compartmentPrivateFields,
    moduleAliases,
    compartment,
    moduleSpecifier,
  ) => {
    const {
      importHook,
      moduleMap,
      moduleMapHook,
      moduleRecords,
    } = compartmentPrivateFields.get(compartment);

    // Follow moduleMap, or moduleMapHook if present.
    let aliasNamespace = moduleMap[moduleSpecifier];
    if (aliasNamespace === undefined && moduleMapHook !== undefined) {
      aliasNamespace = moduleMapHook(moduleSpecifier);
    }
    if (typeof aliasNamespace === 'string') {
      assert.fail(
        d$4`Cannot map module ${q$3(moduleSpecifier)} to ${q$3(
        aliasNamespace,
      )} in parent compartment, not yet implemented`,
        TypeError,
      );
    } else if (aliasNamespace !== undefined) {
      const alias = moduleAliases.get(aliasNamespace);
      if (alias === undefined) {
        assert.fail(
          d$4`Cannot map module ${q$3(
          moduleSpecifier,
        )} because the key is not a module exports namespace, or is from another realm`,
          ReferenceError,
        );
      }
      // Behold: recursion.
      // eslint-disable-next-line no-use-before-define
      const aliasRecord = await load(
        compartmentPrivateFields,
        moduleAliases,
        alias.compartment,
        alias.specifier,
      );
      // Memoize.
      moduleRecords.set(moduleSpecifier, aliasRecord);
      return aliasRecord;
    }

    // Memoize.
    if (moduleRecords.has(moduleSpecifier)) {
      return moduleRecords.get(moduleSpecifier);
    }

    const staticModuleRecord = await importHook(moduleSpecifier);

    if (staticModuleRecord.record !== undefined) {
      const {
        compartment: aliasCompartment = compartment,
        specifier: aliasSpecifier = moduleSpecifier,
        record: aliasModuleRecord,
      } = staticModuleRecord;

      const aliasRecord = await loadRecord(
        compartmentPrivateFields,
        moduleAliases,
        aliasCompartment,
        aliasSpecifier,
        aliasModuleRecord,
      );
      // Memoize by aliased specifier.
      moduleRecords.set(moduleSpecifier, aliasRecord);
      return aliasRecord;
    }

    return loadRecord(
      compartmentPrivateFields,
      moduleAliases,
      compartment,
      moduleSpecifier,
      staticModuleRecord,
    );
  };

  // `load` asynchronously loads `StaticModuleRecords` and creates a complete
  // graph of `ModuleCompartmentRecords`.
  // The module records refer to each other by a reference to the dependency's
  // compartment and the specifier of the module within its own compartment.
  // This graph is then ready to be synchronously linked and executed.
  const load = async (
    compartmentPrivateFields,
    moduleAliases,
    compartment,
    moduleSpecifier,
  ) => {
    return loadWithoutErrorAnnotation(
      compartmentPrivateFields,
      moduleAliases,
      compartment,
      moduleSpecifier,
    ).catch(error => {
      const { name } = compartmentPrivateFields.get(compartment);
      assert.note(
        error,
        d$4`${error.message}, loading ${q$3(moduleSpecifier)} in compartment ${q$3(
        name,
      )}`,
      );
      throw error;
    });
  };

  // Compartments need a mechanism to link a module from one compartment

  // q, as in quote, for error messages.
  const q$4 = JSON.stringify;

  // `deferExports` creates a module's exports proxy, proxied exports, and
  // activator.
  // A `Compartment` can create a module for any module specifier, regardless of
  // whether it is loadable or executable, and use that object as a token that
  // can be fed into another compartment's module map.
  // Only after the specified module has been analyzed is it possible for the
  // module namespace proxy to behave properly, so it throws exceptions until
  // after the compartment has begun executing the module.
  // The module instance must freeze the proxied exports and activate the exports
  // proxy before executing the module.
  //
  // The module exports proxy's behavior differs from the ECMAScript 262
  // specification for "module namespace exotic objects" only in that according
  // to the specification value property descriptors have a non-writable "value"
  // and this implementation models all properties with accessors.
  //
  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects
  //
  const deferExports = () => {
    let active = false;
    const proxiedExports = create(null);
    return freeze({
      activate() {
        active = true;
      },
      proxiedExports,
      exportsProxy: new Proxy(proxiedExports, {
        get(_target, name, receiver) {
          if (!active) {
            throw new TypeError(
              `Cannot get property ${q$4(
              name,
            )} of module exports namespace, the module has not yet begun to execute`,
            );
          }
          return Reflect.get(proxiedExports, name, receiver);
        },
        set(_target, name, _value) {
          throw new TypeError(
            `Cannot set property ${q$4(name)} of module exports namespace`,
          );
        },
        has(_target, name) {
          if (!active) {
            throw new TypeError(
              `Cannot check property ${q$4(
              name,
            )}, the module has not yet begun to execute`,
            );
          }
          return Reflect.has(proxiedExports, name);
        },
        deleteProperty(_target, name) {
          throw new TypeError(
            `Cannot delete property ${q$4(name)}s of module exports namespace`,
          );
        },
        ownKeys(_target) {
          if (!active) {
            throw new TypeError(
              'Cannot enumerate keys, the module has not yet begun to execute',
            );
          }
          // return Object.keys(proxiedExports);
          return Reflect.ownKeys(proxiedExports);
        },
        getOwnPropertyDescriptor(_target, name) {
          if (!active) {
            throw new TypeError(
              `Cannot get own property descriptor ${q$4(
              name,
            )}, the module has not yet begun to execute`,
            );
          }
          return Reflect.getOwnPropertyDescriptor(proxiedExports, name);
        },
        preventExtensions(_target) {
          if (!active) {
            throw new TypeError(
              'Cannot prevent extensions of module exports namespace, the module has not yet begun to execute',
            );
          }
          return Reflect.preventExtensions(proxiedExports);
        },
        isExtensible() {
          if (!active) {
            throw new TypeError(
              'Cannot check extensibility of module exports namespace, the module has not yet begun to execute',
            );
          }
          return Reflect.isExtensible(proxiedExports);
        },
        getPrototypeOf(_target) {
          return null;
        },
        setPrototypeOf(_target, _proto) {
          throw new TypeError('Cannot set prototype of module exports namespace');
        },
        defineProperty(_target, name, _descriptor) {
          throw new TypeError(
            `Cannot define property ${q$4(name)} of module exports namespace`,
          );
        },
        apply(_target, _thisArg, _args) {
          throw new TypeError(
            'Cannot call module exports namespace, it is not a function',
          );
        },
        construct(_target, _args) {
          throw new TypeError(
            'Cannot construct module exports namespace, it is not a constructor',
          );
        },
      }),
    });
  };

  // `getDeferredExports` memoizes the creation of a deferred module exports
  // namespace proxy for any abritrary full specifier in a compartment.
  // It also records the compartment and specifier affiliated with that module
  // exports namespace proxy so it can be used as an alias into another
  // compartment when threaded through a compartment's `moduleMap` argument.
  const getDeferredExports = (
    compartment,
    compartmentPrivateFields,
    moduleAliases,
    specifier,
  ) => {
    const { deferredExports } = compartmentPrivateFields;
    if (!deferredExports.has(specifier)) {
      const deferred = deferExports();
      moduleAliases.set(deferred.exportsProxy, makeAlias(compartment, specifier));
      deferredExports.set(specifier, deferred);
    }
    return deferredExports.get(specifier);
  };

  // q, for enquoting strings in error messages.
  const q$5 = JSON.stringify;

  // `makeModuleInstance` takes a module's compartment record, the live import
  // namespace, and a global object; and produces a module instance.
  // The module instance carries the proxied module exports namespace (the
  // "exports"), notifiers to update the module's internal import namespace, and
  // an idempotent execute function.
  // The module exports namespace is a proxy to the proxied exports namespace
  // that the execution of the module instance populates.
  const makeModuleInstance = (
    privateFields,
    moduleAnalysis,
    moduleAliases,
    moduleRecord,
    importedInstances,
    globalObject,
  ) => {
    const {
      functorSource,
      fixedExportMap,
      liveExportMap,
      exportAlls,
    } = moduleAnalysis;
    const { compartment, moduleSpecifier } = moduleRecord;

    const compartmentFields = privateFields.get(compartment);

    const { __shimTransforms__ } = compartmentFields;

    const { exportsProxy, proxiedExports, activate } = getDeferredExports(
      compartment,
      compartmentFields,
      moduleAliases,
      moduleSpecifier,
    );

    // {_exportName_: getter} module exports namespace
    // object (eventually proxied).
    const exportsProps = create(null);

    // {_localName_: accessor} proxy traps for globalLexicals and live bindings.
    // The globalLexicals object is frozen and the corresponding properties of
    // localLexicals must be immutable, so we copy the descriptors.
    const localLexicals = create(null);

    // {_localName_: init(initValue) -> initValue} used by the
    // rewritten code to initialize exported fixed bindings.
    const onceVar = create(null);

    // {_localName_: update(newValue)} used by the rewritten code to
    // both initialize and update live bindings.
    const liveVar = create(null);

    // {_localName_: [{get, set, notify}]} used to merge all the export updaters.
    const localGetNotify = create(null);

    // {_importName_: notify(update(newValue))} Used by code that imports
    // one of this module's exports, so that their update function will
    // be notified when this binding is initialized or updated.
    const notifiers = create(null);

    entries(fixedExportMap).forEach(([fixedExportName, [localName]]) => {
      let fixedGetNotify = localGetNotify[localName];
      if (!fixedGetNotify) {
        // fixed binding state
        let value;
        let tdz = true;
        let optUpdaters = [];

        // tdz sensitive getter
        const get = () => {
          if (tdz) {
            throw new ReferenceError(
              `binding ${q$5(localName)} not yet initialized`,
            );
          }
          return value;
        };

        // leave tdz once
        const init = freeze(initValue => {
          // init with initValue of a declared const binding, and return
          // it.
          if (!tdz) {
            throw new Error(
              `Internal: binding ${q$5(localName)} already initialized`,
            );
          }
          value = initValue;
          const updaters = optUpdaters;
          optUpdaters = null;
          tdz = false;
          for (const updater of updaters) {
            updater(initValue);
          }
          return initValue;
        });

        // If still tdz, register update for notification later.
        // Otherwise, update now.
        const notify = updater => {
          if (updater === init) {
            // Prevent recursion.
            return;
          }
          if (tdz) {
            optUpdaters.push(updater);
          } else {
            updater(value);
          }
        };

        // Need these for additional exports of the local variable.
        fixedGetNotify = {
          get,
          notify,
        };
        localGetNotify[localName] = fixedGetNotify;
        onceVar[localName] = init;
      }

      exportsProps[fixedExportName] = {
        get: fixedGetNotify.get,
        set: undefined,
        enumerable: true,
        configurable: false,
      };

      notifiers[fixedExportName] = fixedGetNotify.notify;
    });

    entries(liveExportMap).forEach(
      ([liveExportName, [localName, setProxyTrap]]) => {
        let liveGetNotify = localGetNotify[localName];
        if (!liveGetNotify) {
          // live binding state
          let value;
          let tdz = true;
          const updaters = [];

          // tdz sensitive getter
          const get = () => {
            if (tdz) {
              throw new ReferenceError(
                `binding ${q$5(liveExportName)} not yet initialized`,
              );
            }
            return value;
          };

          // This must be usable locally for the translation of initializing
          // a declared local live binding variable.
          //
          // For reexported variable, this is also an update function to
          // register for notification with the downstream import, which we
          // must assume to be live. Thus, it can be called independent of
          // tdz but always leaves tdz. Such reexporting creates a tree of
          // bindings. This lets the tree be hooked up even if the imported
          // module instance isn't initialized yet, as may happen in cycles.
          const update = freeze(newValue => {
            value = newValue;
            tdz = false;
            for (const updater of updaters) {
              updater(newValue);
            }
          });

          // tdz sensitive setter
          const set = newValue => {
            if (tdz) {
              throw new ReferenceError(
                `binding ${q$5(localName)} not yet initialized`,
              );
            }
            value = newValue;
            for (const updater of updaters) {
              updater(newValue);
            }
          };

          // Always register the updater function.
          // If not in tdz, also update now.
          const notify = updater => {
            if (updater === update) {
              // Prevent recursion.
              return;
            }
            updaters.push(updater);
            if (!tdz) {
              updater(value);
            }
          };

          liveGetNotify = {
            get,
            notify,
          };

          localGetNotify[localName] = liveGetNotify;
          if (setProxyTrap) {
            defineProperty(localLexicals, localName, {
              get,
              set,
              enumerable: true,
              configurable: false,
            });
          }
          liveVar[localName] = update;
        }

        exportsProps[liveExportName] = {
          get: liveGetNotify.get,
          set: undefined,
          enumerable: true,
          configurable: false,
        };

        notifiers[liveExportName] = liveGetNotify.notify;
      },
    );

    const notifyStar = update => {
      update(proxiedExports);
    };
    notifiers['*'] = notifyStar;

    // The updateRecord must conform to moduleAnalysis.imports
    // updateRecord = Map<specifier, importUpdaters>
    // importUpdaters = Map<importName, [update(newValue)*]>
    function imports(updateRecord) {
      // By the time imports is called, the importedInstances should already be
      // initialized with module instances that satisfy
      // imports.
      // importedInstances = Map[_specifier_, { notifiers, module, execute }]
      // notifiers = { _importName_: notify(update(newValue))}

      // export * cannot export default.
      const candidateAll = create(null);
      candidateAll.default = false;
      for (const [specifier, importUpdaters] of updateRecord.entries()) {
        const instance = importedInstances.get(specifier);
        instance.execute(); // bottom up cycle tolerant
        const { notifiers: modNotifiers } = instance;
        if (modNotifiers === undefined) {
          for (const [importName, updaters] of importUpdaters.entries()) {
            for (const update of updaters) {
              update(instance.exportsProxy[importName]);
            }
          }
          if (exportAlls.includes(specifier)) {
            for (const [importName, value] of entries(instance.exportsProxy)) {
              const notify = update => update(value);
              candidateAll[importName] = notify;
            }
          }
        } else {
          for (const [importName, updaters] of importUpdaters.entries()) {
            const notify = modNotifiers[importName];
            if (!notify) {
              throw SyntaxError(
                `The requested module '${specifier}' does not provide an export named '${importName}'`,
              );
            }
            for (const updater of updaters) {
              notify(updater);
            }
          }
          if (exportAlls.includes(specifier)) {
            // Make all these imports candidates.
            for (const [importName, notify] of entries(modNotifiers)) {
              if (candidateAll[importName] === undefined) {
                candidateAll[importName] = notify;
              } else {
                // Already a candidate: remove ambiguity.
                candidateAll[importName] = false;
              }
            }
          }
        }
      }

      for (const [importName, notify] of entries(candidateAll)) {
        if (!notifiers[importName] && notify !== false) {
          notifiers[importName] = notify;

          // exported live binding state
          let value;
          notify(v => (value = v));
          exportsProps[importName] = {
            get() {
              return value;
            },
            set: undefined,
            enumerable: true,
            configurable: false,
          };
        }
      }

      // Sort the module exports namespace as per spec.
      // The module exports namespace will be wrapped in a module namespace
      // exports proxy which will serve as a "module exports namespace exotic
      // object".
      // Sorting properties is not generally reliable because some properties may
      // be symbols, and symbols do not have an inherent relative order, but
      // since all properties of the exports namespace must be keyed by a string
      // and the string must correspond to a valid identifier, sorting these
      // properties works for this specific case.
      keys(exportsProps)
        .sort()
        .forEach(k => defineProperty(proxiedExports, k, exportsProps[k]));

      freeze(proxiedExports);
      activate();
    }

    let optFunctor = compartment.evaluate(functorSource, {
      globalObject,
      transforms: __shimTransforms__,
      __moduleShimLexicals__: localLexicals,
    });
    let didThrow = false;
    let thrownError;
    function execute() {
      if (optFunctor) {
        // uninitialized
        const functor = optFunctor;
        optFunctor = null;
        // initializing - call with `this` of `undefined`.
        try {
          functor(
            freeze({
              imports: freeze(imports),
              onceVar: freeze(onceVar),
              liveVar: freeze(liveVar),
            }),
          );
        } catch (e) {
          didThrow = true;
          thrownError = e;
        }
        // initialized
      }
      if (didThrow) {
        throw thrownError;
      }
    }

    return freeze({
      notifiers,
      exportsProxy,
      execute,
    });
  };

  // For brevity, in this file, as in module-load.js, the term "moduleRecord"

  // q, as in quote, for quoting strings in error messages.
  const q$6 = JSON.stringify;

  // `link` creates `ModuleInstances` and `ModuleNamespaces` for a module and its
  // transitive dependencies and connects their imports and exports.
  // After linking, the resulting working set is ready to be executed.
  // The linker only concerns itself with module namespaces that are objects with
  // property descriptors for their exports, which the Compartment proxies with
  // the actual `ModuleNamespace`.
  const link = (
    compartmentPrivateFields,
    moduleAnalyses,
    moduleAliases,
    compartment,
    moduleSpecifier,
  ) => {
    const { moduleRecords } = compartmentPrivateFields.get(compartment);

    const moduleRecord = moduleRecords.get(moduleSpecifier);
    if (moduleRecord === undefined) {
      throw new ReferenceError(`Missing link to module ${q$6(moduleSpecifier)}`);
    }

    // Mutual recursion so there's no confusion about which
    // compartment is in context: the module record may be in another
    // compartment, denoted by moduleRecord.compartment.
    // eslint-disable-next-line no-use-before-define
    return instantiate(
      compartmentPrivateFields,
      moduleAnalyses,
      moduleAliases,
      moduleRecord,
    );
  };

  const validateStaticModuleRecord = (staticModuleRecord, moduleAnalyses) => {
    const isObject = typeof staticModuleRecord === 'object';
    if (!isObject) {
      throw new TypeError(
        `importHook must return a StaticModuleRecord, got ${staticModuleRecord}`,
      );
    }

    const hasAnalysis = moduleAnalyses.has(staticModuleRecord);
    const hasImports = Array.isArray(staticModuleRecord.imports);
    const hasExports = typeof staticModuleRecord.execute === 'function';

    if (!hasAnalysis && !hasExports) {
      if (hasImports) {
        // In this case, the static module record has an `imports` property, but
        // no `execute` method.
        // This could either be a partially implemented custom static module
        // record or created by `StaticModuleRecord` in another realm.
        throw new TypeError(
          'importHook must return a StaticModuleRecord constructed within the same Realm, or a custom record with both imports and an execute method',
        );
      } else {
        // In this case, the static module record has no `imports` or `execute`
        // property, so it could not have been created by the
        // `StaticModuleRecord` from any realm.
        // From this we infer the intent was to produce a valid custom static
        // module record and clue accordingly.
        throw new TypeError(
          'importHook must return a StaticModuleRecord with both imports and an execute method',
        );
      }
    }
  };

  const instantiate = (
    compartmentPrivateFields,
    moduleAnalyses,
    moduleAliases,
    moduleRecord,
  ) => {
    const {
      compartment,
      moduleSpecifier,
      resolvedImports,
      staticModuleRecord,
    } = moduleRecord;
    const { globalObject, instances } = compartmentPrivateFields.get(compartment);

    // Memoize.
    if (instances.has(moduleSpecifier)) {
      return instances.get(moduleSpecifier);
    }

    validateStaticModuleRecord(staticModuleRecord, moduleAnalyses);

    const importedInstances = new Map();
    let moduleInstance;
    const moduleAnalysis = moduleAnalyses.get(staticModuleRecord);
    if (moduleAnalysis !== undefined) {
      moduleInstance = makeModuleInstance(
        compartmentPrivateFields,
        moduleAnalysis,
        moduleAliases,
        moduleRecord,
        importedInstances,
        globalObject,
      );
    } else {
      const { exportsProxy, proxiedExports, activate } = getDeferredExports(
        compartment,
        compartmentPrivateFields.get(compartment),
        moduleAliases,
        moduleSpecifier,
      );
      let activated = false;
      moduleInstance = freeze({
        exportsProxy,
        execute() {
          if (!activated) {
            activate();
            activated = true;
            staticModuleRecord.execute(
              proxiedExports,
              compartment,
              resolvedImports,
            );
          }
        },
      });
    }

    // Memoize.
    instances.set(moduleSpecifier, moduleInstance);

    // Link dependency modules.
    for (const [importSpecifier, resolvedSpecifier] of entries(resolvedImports)) {
      const importedInstance = link(
        compartmentPrivateFields,
        moduleAnalyses,
        moduleAliases,
        compartment,
        resolvedSpecifier,
      );
      importedInstances.set(importSpecifier, importedInstance);
    }

    return moduleInstance;
  };

  // This module exports both Compartment and StaticModuleRecord because they

  // privateFields captures the private state for each compartment.
  const privateFields = new WeakMap();

  const CompartmentPrototype = {
    constructor: InertCompartment,

    get globalThis() {
      return privateFields.get(this).globalObject;
    },

    get name() {
      return privateFields.get(this).name;
    },

    /**
     * @param {string} source is a JavaScript program grammar construction.
     * @param {Object} [options]
     * @param {Array<Transform>} [options.transforms]
     * @param {bool} [options.sloppyGlobalsMode]
     */
    evaluate(source, options = {}) {
      // Perform this check first to avoid unecessary sanitizing.
      // TODO Maybe relax string check and coerce instead:
      // https://github.com/tc39/proposal-dynamic-code-brand-checks
      if (typeof source !== 'string') {
        throw new TypeError('first argument of evaluate() must be a string');
      }

      // Extract options, and shallow-clone transforms.
      const {
        transforms = [],
        sloppyGlobalsMode = false,
        __moduleShimLexicals__ = undefined,
        __evadeHtmlCommentTest__ = false,
        __evadeImportExpressionTest__ = false,
        __rejectSomeDirectEvalExpressions__ = true, // Note default on
      } = options;
      const localTransforms = [...transforms];
      if (__evadeHtmlCommentTest__ === true) {
        localTransforms.push(evadeHtmlCommentTest);
      }
      if (__evadeImportExpressionTest__ === true) {
        localTransforms.push(evadeImportExpressionTest);
      }
      if (__rejectSomeDirectEvalExpressions__ === true) {
        localTransforms.push(rejectSomeDirectEvalExpressions);
      }

      const compartmentFields = privateFields.get(this);
      let { globalTransforms } = compartmentFields;
      const { globalObject, globalLexicals } = compartmentFields;

      let localObject = globalLexicals;
      if (__moduleShimLexicals__ !== undefined) {
        // When using `evaluate` for ESM modules, as should only occur from the
        // module-shim's module-instance.js, we do not reveal the SES-shim's
        // module-to-program translation, as this is not standardizable behavior.
        // However, the `localTransforms` will come from the `__shimTransforms__`
        // Compartment option in this case, which is a non-standardizable escape
        // hatch so programs designed specifically for the SES-shim
        // implementation may opt-in to use the same transforms for `evaluate`
        // and `import`, at the expense of being tightly coupled to SES-shim.
        globalTransforms = undefined;

        localObject = create(null, getOwnPropertyDescriptors(globalLexicals));
        defineProperties(
          localObject,
          getOwnPropertyDescriptors(__moduleShimLexicals__),
        );
      }

      return performEval(source, globalObject, localObject, {
        globalTransforms,
        localTransforms,
        sloppyGlobalsMode,
      });
    },

    toString() {
      return '[object Compartment]';
    },
  };

  defineProperties(InertCompartment, {
    prototype: { value: CompartmentPrototype },
  });

  const makeCompartmentConstructor = (
    targetMakeCompartmentConstructor,
    intrinsics,
    nativeBrander,
  ) => {
    /**
     * Compartment()
     * Each Compartment constructor is a global. A host that wants to execute
     * code in a context bound to a new global creates a new compartment.
     *
     * @param {Object} endowments
     * @param {Object} _moduleMap
     * @param {Object} [options]
     * @param {string} [options.name]
     * @param {Array<Transform>} [options.transforms]
     * @param {Array<Transform>} [options.__shimTransforms__]
     * @param {Object} [options.globalLexicals]
     */
    function Compartment(endowments = {}, _moduleMap = {}, options = {}) {
      if (new.target === undefined) {
        throw new TypeError(
          "Class constructor Compartment cannot be invoked without 'new'",
        );
      }

      // Extract options, and shallow-clone transforms.
      const {
        name = '<unknown>',
        transforms = [],
        __shimTransforms__ = [],
        globalLexicals = {},
      } = options;
      const globalTransforms = [...transforms, ...__shimTransforms__];

      const globalObject = {};
      initGlobalObject(
        globalObject,
        intrinsics,
        sharedGlobalPropertyNames,
        targetMakeCompartmentConstructor,
        this.constructor.prototype,
        {
          globalTransforms,
          nativeBrander,
        },
      );

      assign(globalObject, endowments);

      const invalidNames = getOwnPropertyNames(globalLexicals).filter(
        identifier => !isValidIdentifierName(identifier),
      );
      if (invalidNames.length) {
        throw new Error(
          `Cannot create compartment with invalid names for global lexicals: ${invalidNames.join(
          ', ',
        )}; these names would not be lexically mentionable`,
        );
      }

      privateFields.set(this, {
        name,
        globalTransforms,
        globalObject,
        // The caller continues to own the globalLexicals object they passed to
        // the compartment constructor, but the compartment only respects the
        // original values and they are constants in the scope of evaluated
        // programs and executed modules.
        // This shallow copy captures only the values of enumerable own
        // properties, erasing accessors.
        // The snapshot is frozen to ensure that the properties are immutable
        // when transferred-by-property-descriptor onto local scope objects.
        globalLexicals: freeze({ ...globalLexicals }),
      });
    }

    Compartment.prototype = CompartmentPrototype;

    return Compartment;
  };

  // This module exports both Compartment and StaticModuleRecord because they

  // q, for quoting strings.
  const q$7 = JSON.stringify;

  const analyzeModule = makeModuleAnalyzer(babel$1);

  // moduleAnalyses are the private data of a StaticModuleRecord.
  // We use moduleAnalyses in the loader/linker to look up
  // the analysis corresponding to any StaticModuleRecord constructed by an
  // importHook.
  const moduleAnalyses = new WeakMap();

  /*
   * StaticModuleRecord captures the effort of parsing and analyzing module text
   * so a cache of StaticModuleRecords may be shared by multiple Compartments.
   */
  function StaticModuleRecord(string, url) {
    if (new.target === undefined) {
      return new StaticModuleRecord(string, url);
    }

    const analysis = analyzeModule({ string, url });

    // `keys` below is Object.keys which shows only the names of string-named
    // enumerable own properties.
    // By contrast, Reflect.ownKeys also shows the names of symbol-named
    // enumerable own properties.
    // `sort` defaults to a comparator that stringifies the array elements in a
    // manner which fails on symbol-named properties.
    // Distinct symbols can have the same stringification.
    //
    // The other subtle reason this is correct is that analysis.imports should
    // only have identifier-named own properties.
    this.imports = keys(analysis.imports).sort();

    freeze(this);
    freeze(this.imports);

    moduleAnalyses.set(this, analysis);
  }

  const StaticModuleRecordPrototype = {
    constructor: InertStaticModuleRecord,
    toString() {
      return '[object StaticModuleRecord]';
    },
  };

  defineProperties(StaticModuleRecord, {
    prototype: { value: StaticModuleRecordPrototype },
  });

  defineProperties(InertStaticModuleRecord, {
    prototype: { value: StaticModuleRecordPrototype },
  });

  // moduleAliases associates every public module exports namespace with its
  // corresponding compartment and specifier so they can be used to link modules
  // across compartments.
  // The mechanism to thread an alias is to use the compartment.module function
  // to obtain the exports namespace of a foreign module and pass it into another
  // compartment's moduleMap constructor option.
  const moduleAliases = new WeakMap();

  // privateFields captures the private state for each compartment.
  const privateFields$1 = new WeakMap();

  // Compartments do not need an importHook or resolveHook to be useful
  // as a vessel for evaluating programs.
  // However, any method that operates the module system will throw an exception
  // if these hooks are not available.
  const assertModuleHooks = compartment => {
    const { importHook, resolveHook } = privateFields$1.get(compartment);
    if (typeof importHook !== 'function' || typeof resolveHook !== 'function') {
      throw new TypeError(
        'Compartment must be constructed with an importHook and a resolveHook for it to be able to load modules',
      );
    }
  };

  const ModularCompartmentPrototypeExtension = {
    constructor: InertCompartment,

    module(specifier) {
      if (typeof specifier !== 'string') {
        throw new TypeError('first argument of module() must be a string');
      }

      assertModuleHooks(this);

      const { exportsProxy } = getDeferredExports(
        this,
        privateFields$1.get(this),
        moduleAliases,
        specifier,
      );

      return exportsProxy;
    },

    async import(specifier) {
      if (typeof specifier !== 'string') {
        throw new TypeError('first argument of import() must be a string');
      }

      assertModuleHooks(this);

      return load(privateFields$1, moduleAliases, this, specifier).then(() => {
        const namespace = this.importNow(specifier);
        return { namespace };
      });
    },

    async load(specifier) {
      if (typeof specifier !== 'string') {
        throw new TypeError('first argument of load() must be a string');
      }

      assertModuleHooks(this);

      return load(privateFields$1, moduleAliases, this, specifier);
    },

    importNow(specifier) {
      if (typeof specifier !== 'string') {
        throw new TypeError('first argument of importNow() must be a string');
      }

      assertModuleHooks(this);

      const moduleInstance = link(
        privateFields$1,
        moduleAnalyses,
        moduleAliases,
        this,
        specifier,
      );
      moduleInstance.execute();
      return moduleInstance.exportsProxy;
    },
  };

  defineProperties(
    CompartmentPrototype,
    getOwnPropertyDescriptors(ModularCompartmentPrototypeExtension),
  );

  const makeModularCompartmentConstructor = (
    targetMakeCompartmentConstructor,
    intrinsics,
    nativeBrander,
  ) => {
    // `makeModularCompartmentConstructor` extends `makeCompartmentConstructor`.
    // The trick is that the underlying compartment constructor needs to use the
    // extended modular compartment constructor to create child compartments.
    const SuperCompartment = makeCompartmentConstructor(
      targetMakeCompartmentConstructor,
      intrinsics,
      nativeBrander,
    );

    const ModularCompartment = function Compartment(
      endowments = {},
      moduleMap = {},
      options = {},
    ) {
      if (new.target === undefined) {
        throw new TypeError(
          "Class constructor Compartment cannot be invoked without 'new'",
        );
      }

      const self = Reflect.construct(
        SuperCompartment,
        [endowments, moduleMap, options],
        new.target,
      );

      const {
        resolveHook,
        importHook,
        moduleMapHook,
        __shimTransforms__,
      } = options;

      // Map<FullSpecifier, ModuleCompartmentRecord>
      const moduleRecords = new Map();
      // Map<FullSpecifier, ModuleInstance>
      const instances = new Map();
      // Map<FullSpecifier, {ExportsProxy, ProxiedExports, activate()}>
      const deferredExports = new Map();

      // Validate given moduleMap.
      // The module map gets translated on-demand in module-load.js and the
      // moduleMap can be invalid in ways that cannot be detected in the
      // constructor, but these checks allow us to throw early for a better
      // developer experience.
      for (const [specifier, aliasNamespace] of entries(moduleMap)) {
        if (typeof aliasNamespace === 'string') {
          // TODO implement parent module record retrieval.
          throw new TypeError(
            `Cannot map module ${q$7(specifier)} to ${q$7(
            aliasNamespace,
          )} in parent compartment`,
          );
        } else if (moduleAliases.get(aliasNamespace) === undefined) {
          // TODO create and link a synthetic module instance from the given
          // namespace object.
          throw ReferenceError(
            `Cannot map module ${q$7(
            specifier,
          )} because it has no known compartment in this realm`,
          );
        }
      }

      privateFields$1.set(self, {
        resolveHook,
        importHook,
        moduleMap,
        moduleMapHook,
        moduleRecords,
        __shimTransforms__,
        deferredExports,
        instances,
      });

      return self;
    };

    ModularCompartment.prototype = CompartmentPrototype;

    return ModularCompartment;
  };

  // Copyright (C) 2018 Agoric

  assign(whitelist, modulesWhitelist);

  const nativeBrander$1 = tameFunctionToString();

  const ModularCompartment = makeModularCompartmentConstructor(
    makeModularCompartmentConstructor,
    getGlobalIntrinsics(globalThis),
    nativeBrander$1,
  );

  assign(globalThis, {
    harden,
    lockdown: makeLockdown(
      makeModularCompartmentConstructor,
      CompartmentPrototype,
      getModularAnonymousIntrinsics,
    ),
    Compartment: ModularCompartment,
    StaticModuleRecord,
    assert,
  });

})));
